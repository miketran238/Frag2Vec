Lesson: Algorithms The polymorphic algorithms described here are pieces of reusable functionality provided by the Java platform. All of them come from the Collections class, and all take the form of static methods whose first argument is the collection on which the operation is to be performed. The great majority of the algorithms provided by the Java platform operate on List instances, but a few of them operate on arbitrary Collection instances. This section briefly describes the following algorithms: Sorting Shuffling Routine Data Manipulation Searching Composition Finding Extreme Values
Sorting The Collections.sort algorithm reorders a List so that its elements are in ascending order according to an ordering relationship. Two forms of the operation are provided. The simple form takes a List and sorts it according to its elements' natural ordering. If you're unfamiliar with the concept of natural ordering, read the Object Ordering section. The Collections.sort operation uses a slightly optimized merge sort algorithm that is fast and stable: Fast: It is guaranteed to run in n log(n) time and runs substantially faster on nearly sorted lists. Empirical tests showed it to be as fast as a highly optimized quicksort. A quicksort is generally considered to be faster than a merge sort but isn't stable and doesn't guarantee n log(n) performance. Stable: It doesn't reorder equal elements. This is important if you sort the same list repeatedly on different attributes. If a user of a mail program sorts the inbox by mailing date and then sorts it by sender, the user naturally expects that the now-contiguous list of messages from a given sender will (still) be sorted by mailing date. This is guaranteed only if the second sort was stable.
Sorting - part 2 The following trivial program prints out its arguments in lexicographic (alphabetical) order. import java.util.*; public class Sort { public static void main(String[] args) { List<String> list = Arrays.asList(args); Collections.sort(list); System.out.println(list); } } Let's run the program. % java Sort i walk the line The following output is produced. [i, line, the, walk] The program was included only to show you that algorithms really are as easy to use as they appear to be. The second form of Collections.sort takes a Comparator in addition to a List and sorts the elements with the Comparator . Suppose you want to print out the anagram groups from our earlier example in reverse order of size ? largest anagram group first. The example that follows shows you how to achieve this with the help of the second form of the Collections.sort method.
Sorting - part 3 Recall that the anagram groups are stored as values in a Map , in the form of List instances. The revised printing code iterates through the Map 's values view, putting every List that passes the minimum-size test into a List of List s. Then the code sorts this List , using a Comparator that expects List instances, and implements reverse size-ordering. Finally, the code iterates through the sorted List , printing its elements (the anagram groups). The following code replaces the printing code at the end of the main method in the Anagrams example. // Make a List of all anagram groups above size threshold. List<List<String>> winners = new ArrayList<List<String>>(); for (List<String> l : m.values()) if (l.size() >= minGroupSize) winners.add(l); // Sort anagram groups according to size Collections.sort(winners, new Comparator<List<String>>() { public int compare(List<String> o1, List<String> o2) { return o2.size() - o1.size(); }}); // Print anagram groups. for (List<String> l : winners) System.out.println(l.size() + ": " + l); Running the program on the same dictionary as in The Map Interface section, with the same minimum anagram group size (eight), produces the following output. 12: [apers, apres, asper, pares, parse, pears, prase, presa, rapes, reaps, spare, spear] 11: [alerts, alters, artels, estral, laster, ratels, salter, slater, staler, stelar, talers] 10: [least, setal, slate, stale, steal, stela, taels, tales, teals, tesla] 9: [estrin, inerts, insert, inters, niters, nitres, sinter, triens, trines] 9: [capers, crapes, escarp, pacers, parsec, recaps, scrape, secpar, spacer] 9: [palest, palets, pastel, petals, plates, pleats, septal, staple, tepals] 9: [anestri, antsier, nastier, ratines, retains, retinas, retsina, stainer, stearin] 8: [lapse, leaps, pales, peals, pleas, salep, sepal, spale] 8: [aspers, parses, passer, prases, repass, spares, sparse, spears] 8: [enters, nester, renest, rentes, resent, tenser, ternes,treens] 8: [arles, earls, lares, laser, lears, rales, reals, seral] 8: [earings, erasing, gainers, reagins, regains, reginas, searing, seringa] 8: [peris, piers, pries, prise, ripes, speir, spier, spire] 8: [ates, east, eats, etas, sate, seat, seta, teas] 8: [carets, cartes, caster, caters, crates, reacts, recast,traces]
Shuffling The Collections.shuffle algorithm does the opposite of what Collections.sort does, destroying any trace of order that may have been present in a List . That is, this algorithm reorders the List based on input from a source of randomness such that all possible permutations occur with equal likelihood, assuming a fair source of randomness. This algorithm is useful in implementing games of chance. For example, it could be used to shuffle a List of Card objects representing a deck. Also, it's useful for generating test cases. This operation has two forms: one takes a List and uses a default source of randomness, and the other requires the caller to provide a Random object to use as a source of randomness. The code for this algorithm is used as an example in the List section.
Routine Data Manipulation The Collections class provides five algorithms for doing routine data manipulation on List objects, all of which are pretty straightforward: Collections.reverse ? reverses the order of the elements in a List . Collections.fill ? overwrites every element in a List with the specified value. This operation is useful for reinitializing a List . Collections.copy ? takes two arguments, a destination List and a source List , and copies the elements of the source into the destination, overwriting its contents. The destination List must be at least as long as the source. If it is longer, the remaining elements in the destination List are unaffected. Collections.swap ? swaps the elements at the specified positions in a List . Collections.addAll ? adds all the specified elements to a Collection . The elements to be added may be specified individually or as an array.
Searching The Collections.binarySearch algorithm searches for a specified element in a sorted List . This algorithm has two forms. The first takes a List and an element to search for (the "search key"). This form assumes that the List is sorted in ascending order according to the natural ordering of its elements. The second form takes a Comparator in addition to the List and the search key, and assumes that the List is sorted into ascending order according to the specified Comparator . The Collections.sort algorithm can be used to sort the List prior to calling Collections.binarySearch .
Searching - part 2 The return value is the same for both forms. If the List contains the search key, its index is returned. If not, the return value is (-(insertion point) - 1), where the insertion point is the point at which the value would be inserted into the List , or the index of the first element greater than the value or List.size() if all elements in the List are less than the specified value. This admittedly ugly formula guarantees that the return value will be >= 0 if and only if the search key is found. It's basically a hack to combine a boolean (found) and an integer (index) into a single int return value. The following idiom, usable with both forms of the Collections.binarySearch operation, looks for the specified search key and inserts it at the appropriate position if it's not already present. int pos = Collections.binarySearch(list, key); if (pos < 0) l.add(-pos-1);
Composition The frequency and disjoint algorithms test some aspect of the composition of one or more Collections : Collections.frequency ? counts the number of times the specified element occurs in the specified collection Collections.disjoint ? determines whether two Collections are disjoint; that is, whether they contain no elements in common
Finding Extreme Values The Collections.min and the Collections.max algorithms return, respectively, the minimum and maximum element contained in a specified Collection . Both of these operations come in two forms. The simple form takes only a Collection and returns the minimum (or maximum) element according to the elements' natural ordering. The second form takes a Comparator in addition to the Collection and returns the minimum (or maximum) element according to the specified Comparator .
Lesson: Custom Collection Implementations Many programmers will never need to implement their own Collection s classes. You can go pretty far using the implementations described in the preceding sections of this chapter. However, someday you might want to write your own implementation. It is fairly easy to do this with the aid of the abstract implementations provided by the Java platform. Before we discuss how to write an implementation, let's discuss why you might want to write one.
Reasons to Write an Implementation The following list illustrates the sort of custom Collection s you might want to implement. It is not intended to be exhaustive: Persistent: All of the built-in Collection implementations reside in main memory and vanish when the program exits. If you want a collection that will still be present the next time the program starts, you can implement it by building a veneer over an external database. Such a collection might be concurrently accessible by multiple programs. Application-specific: This is a very broad category. One example is an unmodifiable Map containing real-time telemetry data. The keys could represent locations, and the values could be read from sensors at these locations in response to the get operation. High-performance, special-purpose: Many data structures take advantage of restricted usage to offer better performance than is possible with general-purpose implementations. For instance, consider a List containing long runs of identical element values. Such lists, which occur frequently in text processing, can be run-length encoded ? runs can be represented as a single object containing the repeated element and the number of consecutive repetitions. This example is interesting because it trades off two aspects of performance: It requires less space but more time than an ArrayList . High-performance, general-purpose: The Java Collections Framework's designers tried to provide the best general-purpose implementations for each interface, but many, many data structures could have been used, and new ones are invented every day. Maybe you can come up with something faster! Enhanced functionality: Suppose you need an efficient bag implementation (also known as a multiset): a Collection that offers constant-time containment checks while allowing duplicate elements. It's reasonably straightforward to implement such a collection atop a HashMap . Convenience: You may want additional implementations that offer conveniences beyond those offered by the Java platform. For instance, you may frequently need List instances representing a contiguous range of Integer s. Adapter: Suppose you are using a legacy API that has its own ad hoc collections' API. You can write an adapter implementation that permits these collections to operate in the Java Collections Framework. An adapter implementation is a thin veneer that wraps objects of one type and makes them behave like objects of another type by translating operations on the latter type into operations on the former.
How to Write a Custom Implementation Writing a custom implementation is surprisingly easy. The Java Collections Framework provides abstract implementations designed expressly to facilitate custom implementations. We'll start with the following example of an implementation of Arrays.asList . public static <T> List<T> asList(T[] a) { return new MyArrayList<T>(a); } private static class MyArrayList<T> extends AbstractList<T> { private final T[] a; MyArrayList(T[] array) { a = array; } public T get(int index) { return a[index]; } public T set(int index, T element) { T oldValue = a[index]; a[index] = element; return oldValue; } public int size() { return a.length; } } Believe it or not, this is very close to the implementation that is contained in java.util.Arrays . It's that simple! You provide a constructor and the AbstractList.get , AbstractList.set , and AbstractCollection.size methods, and AbstractList does all the rest. You get the ListIterator , bulk operations, search operations, hash code computation, comparison, and string representation for free. Suppose you want to make the implementation a bit faster. The API documentation for abstract implementations describes precisely how each method is implemented, so you'll know which methods to override to get the performance you want. The preceding implementation's performance is fine, but it can be improved a bit. In particular, the AbstractCollection.toArray method iterates over the List, copying one element at a time. Given the internal representation, it's a lot faster and more sensible just to clone the array. public Object[] toArray() { return (Object[]) a.clone(); }
How to Write a Custom Implementation - part 2 With the addition of this override and a few more like it, this implementation is exactly the one found in java.util.Arrays . In the interest of full disclosure, it's a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it's still not that difficult. The following list summarizes the abstract implementations: AbstractCollection ? a Collection that is neither a Set nor a List. At a minimum, you must provide the AbstractList.iterator and the AbstractCollection.size methods. AbstractSet ? a Set ; use is identical to AbstractCollection . AbstractList ? a List backed up by a random-access data store, such as an array. At a minimum, you must provide the positional access methods ( AbstractList.get and, optionally, AbstractList.set , AbstractList.remove , and AbstractList.add ) and the AbstractCollection.size method. The abstract class takes care of AbstractList.listIterator (and AbstractList.iterator ). AbstractSequentialList ? a List backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the AbstractList.listIterator and AbstractCollection.size methods. The abstract class takes care of the positional access methods. (This is the opposite of AbstractList .) AbstractQueue ? at a minimum, you must provide the offer, peek, poll, and AbstractCollection.size methods and an AbstractList.iterator supporting AbstractList.remove . AbstractMap ? a Map . At a minimum you must provide the entrySet view. This is typically implemented with the AbstractSet class. If the Map is modifiable, you must also provide the put method.
List View of an Array The Arrays.asList method returns a List view of its array argument. Changes to the List write through to the array and vice versa. The size of the collection is that of the array and cannot be changed. If the add or the remove method is called on the List, an UnsupportedOperationException will result. The normal use of this implementation is as a bridge between array-based and collection-based APIs. It allows you to pass an array to a method expecting a Collection or a List. However, this implementation also has another use. If you need a fixed-size List, it's more efficient than any general-purpose List implementation. This is the idiom. List<String> list = Arrays.asList(new String[size]); Note that a reference to the backing array is not retained.
Immutable Multiple-Copy List Occasionally you'll need an immutable List consisting of multiple copies of the same element. The Collections.nCopies method returns such a list. This implementation has two main uses. The first is to initialize a newly created List; for example, suppose you want an ArrayList initially consisting of 1,000 null elements. The following incantation does the trick. List<Type> list = new ArrayList<Type>(Collections.nCopies(1000, (Type)null); Of course, the initial value of each element need not be null. The second main use is to grow an existing List. For example, suppose you want to add 69 copies of the string "fruit bat" to the end of a List<String>. It's not clear why you'd want to do such a thing, but let's just suppose you did. The following is how you'd do it. lovablePets.addAll(Collections.nCopies(69, "fruit bat")); By using the form of addAll that takes both an index and a Collection , you can add the new elements to the middle of a List instead of to the end of it.
Immutable Singleton Set Sometimes you'll need an immutable singleton Set , which consists of a single, specified element. The Collections.singleton method returns such a Set . One use of this implementation is to remove all occurrences of a specified element from a Collection . c.removeAll(Collections.singleton(e)); A related idiom removes all elements that map to a specified value from a Map . For example, suppose you have a Map ? job ? that maps people to their line of work and suppose you want to eliminate all the lawyers. The following one-liner will do the deed. job.values().removeAll(Collections.singleton(LAWYER)); One more use of this implementation is to provide a single input value to a method that is written to accept a collection of values.
Empty Set List and Map Constants The Collections class provides methods to return the empty Set , List, and Map ? Collections.emptySet , Collections.emptyList , and Collections.emptyMap . The main use of these constants is as input to methods that take a Collection of values when you don't want to provide any values at all, as in this example. tourist.declarePurchases(Collections.emptySet());
Deque Implementations The Deque interface, pronounced as "deck", represents a double-ended queue. The Deque interface can be implemented as various types of Collections . The Deque interface implementations are grouped into general-purpose and concurrent implementations.
General-Purpose Deque Implementations The general-purpose implementations include LinkedList and ArrayDeque classes. The Deque interface supports insertion, removal and retrieval of elements at both ends. The ArrayDeque class is the resizable array implementation of the Deque interface, whereas the LinkedList class is the list implementation. The basic insertion, removal and retieval operations in the Deque interface addFirst, addLast, removeFirst, removeLast, getFirst and getLast. The method addFirst adds an element at the head whereas addLast adds an element at the tail of the Deque instance. The LinkedList implementation is more flexible than the ArrayDeque implementation. LinkedList implements all optional list operations. null elements are allowed in the LinkedList implementation but not in the ArrayDeque implementation. In terms of efficiency, ArrayDeque is more efficient than the LinkedList for add and remove operation at both ends. The best operation in a LinkedList implementation is removing the current element during the iteration. LinkedList implementations are not ideal structures to iterate. The LinkedList implementation consumes more memory than the ArrayDeque implementation. For the ArrayDeque instance traversal use any of the following:
Concurrent Deque Implementations The LinkedBlockingDeque class is the concurrent implementation of the Deque interface. If the deque is empty then methods such as LinkedBlockingDeque.takeFirst and LinkedBlockingDeque.takeLast wait until the element becomes available, and then retrieves and removes the same element.
Lesson: Implementations - part 2 The general-purpose implementations are summarized in the following table. General-purpose Implementations Interfaces Hash table Implementations Resizable array Implementations Tree Implementations Linked list Implementations Hash table + Linked list Implementations Set HashSet TreeSet LinkedHashSet List ArrayList LinkedList Queue Deque ArrayDeque LinkedList Map HashMap TreeMap LinkedHashMap As you can see from the table, the Java Collections Framework provides several general-purpose implementations of the Set , List , and Map interfaces. In each case, one implementation ? HashSet , ArrayList , and HashMap ? is clearly the one to use for most applications, all other things being equal. Note that the SortedSet and the SortedMap interfaces do not have rows in the table. Each of those interfaces has one implementation ( TreeSet and TreeMap ) and is listed in the Set and the Map rows. There are two general-purpose Queue implementations ? LinkedList , which is also a List implementation, and PriorityQueue , which is omitted from the table. These two implementations provide very different semantics: LinkedList provides FIFO semantics, while PriorityQueue orders its elements according to their values.
Lesson: Implementations - part 3 Each of the general-purpose implementations provides all optional operations contained in its interface. All permit null elements, keys, and values. None are synchronized (thread-safe). All have fail-fast iterators, which detect illegal concurrent modification during iteration and fail quickly and cleanly rather than risking arbitrary, nondeterministic behavior at an undetermined time in the future. All are Serializable and all support a public clone method. The fact that these implementations are unsynchronized represents a break with the past: The legacy collections Vector and Hashtable are synchronized. The present approach was taken because collections are frequently used when the synchronization is of no benefit. Such uses include single-threaded use, read-only use, and use as part of a larger data object that does its own synchronization. In general, it is good API design practice not to make users pay for a feature they don't use. Furthermore, unnecessary synchronization can result in deadlock under certain circumstances.
Lesson: Implementations - part 4 If you need thread-safe collections, the synchronization wrappers, described in the Wrapper Implementations section, allow any collection to be transformed into a synchronized collection. Thus, synchronization is optional for general-purpose implementations, whereas it is mandatory for legacy implementations. Moreover, the java.util.concurrent package provides concurrent implementations of the BlockingQueue interface, which extends Queue, and of the ConcurrentMap interface, which extends Map . These implementations offer much higher concurrency than mere synchronized implementations. As a rule, you should be thinking about the interfaces, BigInteger.not the implementations. That is why there are no programming examples in this section. For the most part, the choice of implementation affects only performance. The preferred style, as mentioned in the Interfaces section, is to choose an implementation when a Collection is created and to immediately assign the new collection to a variable of the corresponding interface type (or to pass the collection to a method expecting an argument of the interface type). In this way, the program does not become dependent on any added methods in a given implementation, leaving the programmer free to change implementations anytime that it is warranted by performance concerns or behavioral details.
General-Purpose List Implementations There are two general-purpose List implementations ? ArrayList and LinkedList . Most of the time, you'll probably use ArrayList , which offers constant-time positional access and is just plain fast. It does not have to allocate a node object for each element in the List, and it can take advantage of System.arraycopy when it has to move multiple elements at the same time. Think of ArrayList as Vector without the synchronization overhead. If you frequently add elements to the beginning of the List or iterate over the List to delete elements from its interior, you should consider using LinkedList . These operations require constant-time in a LinkedList and linear-time in an ArrayList . But you pay a big price in performance. Positional access requires linear-time in a LinkedList and constant-time in an ArrayList . Furthermore, the constant factor for LinkedList is much worse. If you think you want to use a LinkedList , measure the performance of your application with both LinkedList and ArrayList before making your choice; ArrayList is usually faster.
General-Purpose List Implementations - part 2 ArrayList has one tuning parameter ? the initial capacity, which refers to the number of elements the ArrayList can hold before it has to grow. LinkedList has no tuning parameters and seven optional operations, one of which is clone. The other six are LinkedList.addFirst , LinkedList.getFirst , LinkedList.removeFirst , LinkedList.addLast , LinkedList.getLast , and LinkedList.removeLast . LinkedList also implements the Queue interface.
Special-Purpose List Implementations CopyOnWriteArrayList is a List implementation backed up by a copy-on-write array. This implementation is similar in nature to CopyOnWriteArraySet . No synchronization is necessary, even during iteration, and iterators are guaranteed never to throw ConcurrentModificationException . This implementation is well suited to maintaining event-handler lists, in which change is infrequent, and traversal is frequent and potentially time-consuming. If you need synchronization, a Vector will be slightly faster than an ArrayList synchronized with Collections.synchronizedList . But Vector has loads of legacy operations, so be careful to always manipulate the Vector with the List interface or else you won't be able to replace the implementation at a later time. If your List is fixed in size ? that is, you'll never use remove, add, or any of the bulk operations other than containsAll ? you have a third option that's definitely worth considering. See Arrays.asList in the Convenience Implementations section for more information.
Map Implementations Map implementations are grouped into general-purpose, special-purpose, and concurrent implementations.
General-Purpose Map Implementations The three general-purpose Map implementations are HashMap , TreeMap and LinkedHashMap . If you need SortedMap operations or key-ordered Collection -view iteration, use TreeMap ; if you want maximum speed and don't care about iteration order, use HashMap ; if you want near- HashMap performance and insertion-order iteration, use LinkedHashMap . In this respect, the situation for Map is analogous to Set . Likewise, everything else in the Set Implementations section also applies to Map implementations. LinkedHashMap provides two capabilities that are not available with LinkedHashSet . When you create a LinkedHashMap , you can order it based on key access rather than insertion. In other words, merely looking up the value associated with a key brings that key to the end of the map. Also, LinkedHashMap provides the LinkedHashMap.removeEldestEntry method, which may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map. This makes it very easy to implement a custom cache.
Special-Purpose Map Implementations There are three special-purpose Map implementations ? EnumMap , WeakHashMap and IdentityHashMap . EnumMap , which is internally implemented as an array, is a high-performance Map implementation for use with enum keys. This implementation combines the richness and safety of the Map interface with a speed approaching that of an array. If you want to map an enum to a value, you should always use an EnumMap in preference to an array. WeakHashMap is an implementation of the Map interface that stores only weak references to its keys. Storing only weak references allows a key-value pair to be garbage-collected when its key is no longer referenced outside of the WeakHashMap . This class provides the easiest way to harness the power of weak references. It is useful for implementing "registry-like" data structures, where the utility of an entry vanishes when its key is no longer reachable by any thread.
Special-Purpose Map Implementations - part 2 IdentityHashMap is an identity-based Map implementation based on a hash table. This class is useful for topology-preserving object graph transformations, such as serialization or deep-copying. To perform such transformations, you need to maintain an identity-based "node table" that keeps track of which objects have already been seen. Identity-based maps are also used to maintain object-to-meta-information mappings in dynamic debuggers and similar systems. Finally, identity-based maps are useful in thwarting "spoof attacks" that are a result of intentionally perverse equals methods because IdentityHashMap never invokes the equals method on its keys. An added benefit of this implementation is that it is fast.
Concurrent Map Implementations The java.util.concurrent package contains the ConcurrentMap interface, which extends Map with atomic putIfAbsent, remove, and replace methods, and the ConcurrentHashMap implementation of that interface. ConcurrentHashMap is a highly concurrent, high-performance implementation backed up by a hash table. This implementation never blocks when performing retrievals and allows the client to select the concurrency level for updates. It is intended as a drop-in replacement for Hashtable : in addition to implementing ConcurrentMap , it supports all the legacy methods peculiar to Hashtable . Again, if you don't need the legacy operations, be careful to manipulate it with the ConcurrentMap interface.
Questions Question: You plan to write a program that uses several basic collection interfaces: Set , List, Queue, and Map . You're not sure which implementations will work best, so you decide to use general-purpose implementations until you get a better idea how your program will work in the real world. Which implementations are these? Answer: Set : HashSet List: ArrayList Queue: LinkedList Map : HashMap Question: If you need a Set implementation that provides value-ordered iteration, which class should you use? Answer: TreeSet guarantees that the sorted set is in ascending element order, sorted according to the natural order of the elements or by the Comparator provided. Question: Which class do you use to access wrapper implementations? Answer: You use the Collections class, which provides static methods that operate on or return collections.
Exercises Exercise: Write a program that reads a text file, specified by the first command line argument, into a List. The program should then print random lines from the file, the number of lines printed to be specified by the second command line argument. Write the program so that a correctly-sized collection is allocated all at once, instead of being gradually expanded as the file is read in. Hint: To determine the number of lines in the file, use java.io.File.length to obtain the size of the file, then divide by an assumed size of an average line. Answer: Since we are accessing the List randomly, we will use ArrayList . We estimate the number of lines by taking the file size and dividing by 50. We then double that figure, since it is more efficient to overestimate than to underestmate. import java.util.*; import java.io.*; public class FileList { public static void main(String[] args) { final int assumedLineLength = 50; File file = new File(args[0]); List<String> fileList = new ArrayList<String>((int)(file.length() / assumedLineLength) * 2); BufferedReader reader = null; int lineCount = 0; try { reader = new BufferedReader(new FileReader(file)); for (String line = reader.readLine(); line != null; line = reader.readLine()) { fileList.add(line); lineCount++; } } catch (IOException e) { System.err.format("Could not read %s: %s%n", file, e); System.exit(1); } finally { if (reader != null) { try { reader.close(); } catch (IOException e) {} } } int repeats = Integer.parseInt(args[1]); Random random = new Random(); for (int i = 0; i < repeats; i++) { System.out.format("%d: %s%n", i, fileList.get(random.nextInt(lineCount - 1))); } } } This program actually spends most of its time reading in the file, so pre-allocating the ArrayList has little affect on its performance. Specifying an initial capacity in advance is more likely to be useful when your program repeatly creates large ArrayList objects without intervening I/O.
General-Purpose Queue Implementations As mentioned in the previous section, LinkedList implements the Queue interface, providing first in, first out (FIFO) queue operations for add, poll, and so on. The PriorityQueue class is a priority queue based on the heap data structure. This queue orders elements according to the order specified at construction time, which can be the elements' natural ordering or the ordering imposed by an explicit Comparator . The queue retrieval operations ? poll, remove, peek , and element ? access the element at the head of the queue. The Queue.head of the queue is the least element with respect to the specified ordering. If multiple elements are tied for least value, the head is one of those elements; ties are broken arbitrarily. PriorityQueue and its iterator implement all of the optional methods of the Collection and Iterator interfaces. The iterator provided in method iterator is not guaranteed to traverse the elements of the PriorityQueue in any particular order. For ordered traversal, consider using Arrays.sort(pq.toArray()) .
Concurrent Queue Implementations The java.util.concurrent package contains a set of synchronized Queue interfaces and classes. BlockingQueue extends Queue with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes: LinkedBlockingQueue ? an optionally bounded FIFO blocking queue backed by linked nodes ArrayBlockingQueue ? a bounded FIFO blocking queue backed by an array PriorityBlockingQueue ? an unbounded blocking priority queue backed by a heap DelayQueue ? a time-based scheduling queue backed by a heap SynchronousQueue ? a simple rendezvous mechanism that uses the BlockingQueue interface In JDK 7, TransferQueue is a specialized BlockingQueue in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. TransferQueue has a single implementation: LinkedTransferQueue ? an unbounded TransferQueue based on linked nodes
Set Implementations The Set implementations are grouped into general-purpose and special-purpose implementations.
General-Purpose Set Implementations There are three general-purpose Set implementations ? HashSet , TreeSet , and LinkedHashSet . Which of these three to use is generally straightforward. HashSet is much faster than TreeSet (constant-time versus log-time for most operations) but offers no ordering guarantees. If you need to use the operations in the SortedSet interface, or if value-ordered iteration is required, use TreeSet ; otherwise, use HashSet . It's a fair bet that you'll end up using HashSet most of the time. LinkedHashSet is in some sense intermediate between HashSet and TreeSet . Implemented as a hash table with a linked list running through it, it provides insertion-ordered iteration (least recently inserted to most recently) and runs nearly as fast as HashSet . The LinkedHashSet implementation spares its clients from the unspecified, generally chaotic ordering provided by HashSet without incurring the increased cost associated with TreeSet .
General-Purpose Set Implementations - part 2 One thing worth keeping in mind about HashSet is that iteration is linear in the sum of the number of entries and the number of buckets (the capacity). Thus, choosing an initial capacity that's too high can waste both space and time. On the other hand, choosing an initial capacity that's too low wastes time by copying the data structure each time it's forced to increase its capacity. If you don't specify an initial capacity, the default is 16. In the past, there was some advantage to choosing a prime number as the initial capacity. This is no longer true. Internally, the capacity is always rounded up to a power of two. The initial capacity is specified by using the int constructor. The following line of code allocates a HashSet whose initial capacity is 64. Set<String> s = new HashSet<String>(64);
General-Purpose Set Implementations - part 3 The HashSet class has one other tuning parameter called the load factor. If you care a lot about the space consumption of your HashSet , read the HashSet documentation for more information. Otherwise, just accept the default; it's almost always the right thing to do. If you accept the default load factor but want to specify an initial capacity, pick a number that's about twice the size to which you expect the set to grow. If your guess is way off, you may waste a bit of space, time, or both, but it's unlikely to be a big problem. LinkedHashSet has the same tuning parameters as HashSet , but iteration time is not affected by capacity. TreeSet has no tuning parameters.
Special-Purpose Set Implementations There are two special-purpose Set implementations ? EnumSet and CopyOnWriteArraySet . EnumSet is a high-performance Set implementation for enum types. All of the members of an enum set must be of the same enum type. Internally, it is represented by a bit-vector, typically a single long. Enum sets support iteration over ranges of enum types. For example, given the enum declaration for the days of the week, you can iterate over the weekdays. The EnumSet class provides a static factory that makes it easy. for (Day d : EnumSet.range(Day.MONDAY, Day.FRIDAY)) System.out.println(d); Enum sets also provide a rich, typesafe replacement for traditional bit flags. EnumSet.of(Style.BOLD, Style.ITALIC) CopyOnWriteArraySet is a Set implementation backed up by a copy-on-write array. All mutative operations, such as add, set, and remove, are implemented by making a new copy of the array; no locking is ever required. Even iteration may safely proceed concurrently with element insertion and deletion. Unlike most Set implementations, the add, remove, and contains methods require time proportional to the size of the set. This implementation is only appropriate for sets that are rarely modified but frequently iterated. It is well suited to maintaining event-handler lists that must prevent duplicates.
Summary of Implementations Implementations are the data objects used to store collections, which implement the interfaces described in the Interfaces lesson. The Java Collections Framework provides several general-purpose implementations of the core interfaces: For the Set interface, HashSet is the most commonly used implementation. For the List interface, ArrayList is the most commonly used implementation. For the Map interface, HashMap is the most commonly used implementation. For the Queue interface, LinkedList is the most commonly used implementation. For the Deque interface, ArrayDeque is the most commonly used implementation. Each of the general-purpose implementations provides all optional operations contained in its interface. The Java Collections Framework also provides several special-purpose implementations for situations that require nonstandard performance, usage restrictions, or other unusual behavior. The java.util.concurrent package contains several collections implementations, which are thread-safe but not governed by a single exclusion lock.
Summary of Implementations - part 2 The Collections class (as opposed to the Collection interface), provides static methods that operate on or return collections, which are known as Wrapper implementations. Finally, there are several Convenience implementations, which can be more efficient than general-purpose implementations when you don't need their full power. The Convenience implementations are made available through static factory methods.
Wrapper Implementations Wrapper implementations delegate all their real work to a specified collection but add extra functionality on top of what this collection offers. For design pattern fans, this is an example of the decorator pattern. Although it may seem a bit exotic, it's really pretty straightforward. These implementations are anonymous; rather than providing a public class, the library provides a static factory method. All these implementations are found in the Collections class, which consists solely of static methods.
Synchronization Wrappers The synchronization wrappers add automatic synchronization (thread-safety) to an arbitrary collection. Each of the six core collection interfaces ? Collection , Set , List, Map , SortedSet , and SortedMap ? has one static factory method. public static <T> Collection<T> synchronizedCollection(Collection<T> c); public static <T> Set<T> synchronizedSet(Set<T> s); public static <T> List<T> synchronizedList(List<T> list); public static <K,V> Map<K,V> synchronizedMap(Map<K,V> m); public static <T> SortedSet<T> synchronizedSortedSet(SortedSet<T> s); public static <K,V> SortedMap<K,V> synchronizedSortedMap(SortedMap<K,V> m); Each of these methods returns a synchronized (thread-safe) Collection backed up by the specified collection. To guarantee serial access, all access to the backing collection must be accomplished through the returned collection. The easy way to guarantee this is not to keep a reference to the backing collection. Create the synchronized collection with the following trick. List<Type> list = Collections.synchronizedList(new ArrayList<Type>()); A collection created in this fashion is every bit as thread-safe as a normally synchronized collection, such as a Vector . In the face of concurrent access, it is imperative that the user manually synchronize on the returned collection when iterating over it. The reason is that iteration is accomplished via multiple calls into the collection, which must be composed into a single atomic operation. The following is the idiom to iterate over a wrapper-synchronized collection. Collection<Type> c = Collections.synchronizedCollection(myCollection); synchronized(c) { for (Type e : c) foo(e); }
Synchronization Wrappers - part 2 If an explicit iterator is used, the iterator method must be called from within the synchronized block. Failure to follow this advice may result in nondeterministic behavior. The idiom for iterating over a Collection view of a synchronized Map is similar. It is imperative that the user synchronize on the synchronized Map when iterating over any of its Collection views rather than synchronizing on the Collection view itself, as shown in the following example. Map<KeyType, ValType> m = Collections.synchronizedMap(new HashMap<KeyType, ValType>()); ... Set<KeyType> s = m.keySet(); ... // Synchronizing on m, not s! synchronized(m) { while (KeyType k : s) foo(k); } One minor downside of using wrapper implementations is that you do not have the ability to execute any noninterface operations of a wrapped implementation. So, for instance, in the preceding List example, you cannot call ArrayList 's ensureCapacity operation on the wrapped ArrayList .
Unmodifiable Wrappers Unlike synchronization wrappers, which add functionality to the wrapped collection, the unmodifiable wrappers take functionality away. In particular, they take away the ability to modify the collection by intercepting all the operations that would modify the collection and throwing an UnsupportedOperationException . Unmodifiable wrappers have two main uses, as follows: To make a collection immutable once it has been built. In this case, it's good practice not to maintain a reference to the backing collection. This absolutely guarantees immutability. To allow certain clients read-only access to your data structures. You keep a reference to the backing collection but hand out a reference to the wrapper. In this way, clients can look but not modify, while you maintain full access. Like synchronization wrappers, each of the six core Collection interfaces has one static factory method. public static <T> Collection<T> unmodifiableCollection(Collection<? extends T> c); public static <T> Set<T> unmodifiableSet(Set<? extends T> s); public static <T> List<T> unmodifiableList(List<? extends T> list); public static <K,V> Map<K, V> unmodifiableMap(Map<? extends K, ? extends V> m); public static <T> SortedSet<T> unmodifiableSortedSet(SortedSet<? extends T> s); public static <K,V> SortedMap<K, V> unmodifiableSortedMap(SortedMap<K, ? extends V> m);
Checked Interface Wrappers The Collections.checked interface wrappers are provided for use with generic collections. These implementations return a dynamically type-safe view of the specified collection, which throws a ClassCastException if a client attempts to add an element of the wrong type. The generics mechanism in the language provides compile-time (static) type-checking, but it is possible to defeat this mechanism. Dynamically type-safe views eliminate this possibility entirely.
Parameters If your API contains a method that requires a collection on input, it is of paramount importance that you declare the relevant parameter type to be one of the collection interface types. Never use an implementation type because this defeats the purpose of an interface-based Collections Framework, which is to allow collections to be manipulated without regard to implementation details. Further, you should always use the least-specific type that makes sense. For example, don't require a List or a Set if a Collection would do. It's not that you should never require a List or a Set on input; it is correct to do so if a method depends on a property of one of these interfaces. For example, many of the algorithms provided by the Java platform require a List on input because they depend on the fact that lists are ordered. As a general rule, however, the best types to use on input are the most general: Collection and Map . Caution: Never define your own ad hoc collection class and require objects of this class on input. By doing this, you'd lose all the benefits provided by the Java Collections Framework.
Return Values You can afford to be much more flexible with return values than with input parameters. It's fine to return an object of any type that implements or extends one of the collection interfaces. This can be one of the interfaces or a special-purpose type that extends or implements one of these interfaces. For example, one could imagine an image-processing package, called ImageList, that returned objects of a new class that implements List. In addition to the List operations, ImageList could support any application-specific operations that seemed desirable. For example, it might provide an indexImage operation that returned an image containing thumbnail images of each graphic in the ImageList. It's critical to note that even if the API furnishes ImageList instances on output, it should accept arbitrary Collection (or perhaps List) instances on input.
Return Values - part 2 In one sense, return values should have the opposite behavior of input parameters: It's best to return the most specific applicable collection interface rather than the most general. For example, if you're sure that you'll always return a SortedMap , you should give the relevant method the return type of SortedMap rather than Map . SortedMap instances are more time-consuming to build than ordinary Map instances and are also more powerful. Given that your module has already invested the time to build a SortedMap , it makes good sense to give the user access to its increased power. Furthermore, the user will be able to pass the returned object to methods that demand a SortedMap , as well as those that accept any Map .
Compatibility The Java Collections Framework was designed to ensure complete interoperability between the core collection interfaces and the types that were used to represent collections in the early versions of the Java platform: Vector , Hashtable , array, and Enumeration . In this section, you'll learn how to transform old collections to the Java Collections Framework collections and vice versa.
Upward Compatibility Suppose that you're using an API that returns legacy collections in tandem with another API that requires objects implementing the collection interfaces. To make the two APIs interoperate smoothly, you'll have to transform the legacy collections into modern collections. Luckily, the Java Collections Framework makes this easy. Suppose the old API returns an array of objects and the new API requires a Collection . The Collections Framework has a convenience implementation that allows an array of objects to be viewed as a List. You use Arrays.asList to pass an array to any method requiring a Collection or a List. Foo[] result = oldMethod(arg); newMethod(Arrays.asList(result)); If the old API returns a Vector or a Hashtable , you have no work to do at all because Vector was retrofitted to implement the List interface, and Hashtable was retrofitted to implement Map . Therefore, a Vector may be passed directly to any method calling for a Collection or a List. Vector result = oldMethod(arg); newMethod(result); Similarly, a Hashtable may be passed directly to any method calling for a Map . Hashtable result = oldMethod(arg); newMethod(result); Less frequently, an API may return an Enumeration that represents a collection of objects. The Collections.list method translates an Enumeration into a Collection . Enumeration e = oldMethod(arg); newMethod(Collections.list(e));
Backward Compatibility Suppose you're using an API that returns modern collections in tandem with another API that requires you to pass in legacy collections. To make the two APIs interoperate smoothly, you have to transform modern collections into old collections. Again, the Java Collections Framework makes this easy. Suppose the new API returns a Collection , and the old API requires an array of Object . As you're probably aware, the Collection interface contains a Collection.toArray method designed expressly for this situation. Collection c = newMethod(); oldMethod(c.toArray()); What if the old API requires an array of String (or another type) instead of an array of Object ? You just use the other form of Collection.toArray ? the one that takes an array on input. Collection c = newMethod(); oldMethod((String[]) c.toArray(new String[0])); If the old API requires a Vector , the standard collection constructor comes in handy. Collection c = newMethod(); oldMethod(new Vector(c)); The case where the old API requires a Hashtable is handled analogously. Map m = newMethod(); oldMethod(new Hashtable(m));
Backward Compatibility - part 2 Finally, what do you do if the old API requires an Enumeration ? This case isn't common, but it does happen from time to time, and the Collections.enumeration method was provided to handle it. This is a static factory method that takes a Collection and returns an Enumeration over the elements of the Collection . Collection c = newMethod(); oldMethod(Collections.enumeration(c));
What Is a Collections Framework? A collections framework is a unified architecture for representing and manipulating collections. All collections frameworks contain the following: Interfaces: These are abstract data types that represent collections. Interfaces allow collections to be manipulated independently of the details of their representation. In object-oriented languages, interfaces generally form a hierarchy. Implementations: These are the concrete implementations of the collection interfaces. In essence, they are reusable data structures. Algorithms: These are the methods that perform useful computations, such as searching and sorting, on objects that implement collection interfaces. The algorithms are said to be polymorphic: that is, the same method can be used on many different implementations of the appropriate collection interface. In essence, algorithms are reusable functionality. Apart from the Java Collections Framework, the best-known examples of collections frameworks are the C++ Standard Template Library (STL) and Smalltalk's collection hierarchy. Historically, collections frameworks have been quite complex, which gave them a reputation for having a steep learning curve. We believe that the Java Collections Framework breaks with this tradition, as you will learn for yourself in this chapter.
Benefits of the Java Collections Framework The Java Collections Framework provides the following benefits: Reduces programming effort: By providing useful data structures and algorithms, the Collections Framework frees you to concentrate on the important parts of your program rather than on the low-level "plumbing" required to make it work. By facilitating interoperability among unrelated APIs, the Java Collections Framework frees you from writing adapter objects or conversion code to connect APIs. Increases program speed and quality: This Collections Framework provides high-performance, high-quality implementations of useful data structures and algorithms. The various implementations of each interface are interchangeable, so programs can be easily tuned by switching collection implementations. Because you're freed from the drudgery of writing your own data structures, you'll have more time to devote to improving programs' quality and performance. Allows interoperability among unrelated APIs: The collection interfaces are the vernacular by which APIs pass collections back and forth. If my network administration API furnishes a collection of node names and if your GUI toolkit expects a collection of column headings, our APIs will interoperate seamlessly, even though they were written independently. Reduces effort to learn and to use new APIs: Many APIs naturally take collections on input and furnish them as output. In the past, each such API had a small sub-API devoted to manipulating its collections. There was little consistency among these ad hoc collections sub-APIs, so you had to learn each one from scratch, and it was easy to make mistakes when using them. With the advent of standard collection interfaces, the problem went away. Reduces effort to design new APIs: This is the flip side of the previous advantage. Designers and implementers don't have to reinvent the wheel each time they create an API that relies on collections; instead, they can use standard collection interfaces. Fosters software reuse: New data structures that conform to the standard collection interfaces are by nature reusable. The same goes for new algorithms that operate on objects that implement these interfaces.
java.util.Collections: java.util.Collections:  This class consists exclusively of static methods that operate on or return collections. It contains polymorphic algorithms that operate on collections, "wrappers", which return a new collection backed by a specified collection, and a few other odds and ends. The methods of this class all throw a NullPointerException if the collections or class objects provided to them are null. The documentation for the polymorphic algorithms contained in this class generally includes a brief description of the implementation. Such descriptions should be regarded as implementation notes, rather than parts of the specification. Implementors should feel free to substitute other algorithms, so long as the specification itself is adhered to. (For example, the algorithm used by sort does not have to be a mergesort, but it does have to be stable.) The "destructive" algorithms contained in this class, that is, the algorithms that modify the collection on which they operate, are specified to throw UnsupportedOperationException if the collection does not support the appropriate mutation primitive(s), such as the set method. These algorithms may, but are not required to, throw this exception if an invocation would have no effect on the collection. For example, invoking the sort method on an unmodifiable list that is already sorted may or may not throw UnsupportedOperationException. This class is a member of the  Java Collections Framework.
java.util.Collections: java.util.Collections.CheckedList.replaceAll	(	UnaryOperator	):  Replaces each element of this list with the result of applying the operator to that element. Errors or runtime exceptions thrown by the operator are relayed to the caller.
java.util.Collections: java.util.Collections.CheckedMap.CheckedEntrySet:  We need this class in addition to CheckedSet as Map.Entry permits modification of the backing Map via the setValue operation. This class is subtle: there are many possible attacks that must be thwarted.
java.util.Collections: java.util.Collections.CheckedMap.CheckedEntrySet.CheckedEntry:  This "wrapper class" serves two purposes: it prevents the client from modifying the backing Map, by short-circuiting the setValue method, and it protects the backing Map against an ill-behaved Map.Entry that attempts to modify another Map.Entry when asked to perform an equality check.
java.util.Collections: java.util.Collections.CheckedMap.CheckedEntrySet.contains	(	Object	):  This method is overridden to protect the backing set against an object with a nefarious equals function that senses that the equality-candidate is Map.Entry and calls its setValue method.
java.util.Collections: java.util.Collections.CheckedMap.CheckedEntrySet.containsAll	(	Collection	):  The bulk collection methods are overridden to protect against an unscrupulous collection whose contains(Object o) method senses when o is a Map.Entry, and calls o.setValue.
java.util.Collections: java.util.Collections.SynchronizedList.readResolve	(	):  SynchronizedRandomAccessList instances are serialized as SynchronizedList instances to allow them to be deserialized in pre-1.4 JREs (which do not have SynchronizedRandomAccessList). This method inverts the transformation. As a beneficial side-effect, it also grafts the RandomAccess marker onto SynchronizedList instances that were serialized in pre-1.4 JREs. Note: Unfortunately, SynchronizedRandomAccessList instances serialized in 1.4.1 and deserialized in 1.4 will become SynchronizedList instances, as this method was missing in 1.4.
java.util.Collections: java.util.Collections.SynchronizedNavigableMap:  A synchronized NavigableMap.
java.util.Collections: java.util.Collections.SynchronizedRandomAccessList.writeReplace	(	):  Allows instances to be deserialized in pre-1.4 JREs (which do not have SynchronizedRandomAccessList). SynchronizedList has a readResolve method that inverts this transformation upon deserialization.
java.util.Collections: java.util.Collections.UnmodifiableList.readResolve	(	):  UnmodifiableRandomAccessList instances are serialized as UnmodifiableList instances to allow them to be deserialized in pre-1.4 JREs (which do not have UnmodifiableRandomAccessList). This method inverts the transformation. As a beneficial side-effect, it also grafts the RandomAccess marker onto UnmodifiableList instances that were serialized in pre-1.4 JREs. Note: Unfortunately, UnmodifiableRandomAccessList instances serialized in 1.4.1 and deserialized in 1.4 will become UnmodifiableList instances, as this method was missing in 1.4.
java.util.Collections: java.util.Collections.UnmodifiableMap.UnmodifiableEntrySet:  We need this class in addition to UnmodifiableSet as Map.Entries themselves permit modification of the backing Map via their setValue operation. This class is subtle: there are many possible attacks that must be thwarted.
java.util.Collections: java.util.Collections.UnmodifiableMap.UnmodifiableEntrySet.UnmodifiableEntry:  This "wrapper class" serves two purposes: it prevents the client from modifying the backing Map, by short-circuiting the setValue method, and it protects the backing Map against an ill-behaved Map.Entry that attempts to modify another Map Entry when asked to perform an equality check.
java.util.Collections: java.util.Collections.UnmodifiableMap.UnmodifiableEntrySet.contains	(	Object	):  This method is overridden to protect the backing set against an object with a nefarious equals function that senses that the equality-candidate is Map.Entry and calls its setValue method.
java.util.Collections: java.util.Collections.UnmodifiableMap.UnmodifiableEntrySet.containsAll	(	Collection	):  The next two methods are overridden to protect against an unscrupulous List whose contains(Object o) method senses when o is a Map.Entry, and calls o.setValue.
java.util.Collections: java.util.Collections.UnmodifiableNavigableMap.EmptyNavigableMap:  A class for the EMPTY_NAVIGABLE_MAP which needs readResolve to preserve singleton property.
java.util.Collections: java.util.Collections.UnmodifiableNavigableSet:  Wraps a navigable set and disables all of the mutative operations.
java.util.Collections: java.util.Collections.UnmodifiableNavigableSet.EmptyNavigableSet:  A singleton empty unmodifiable navigable set used for emptyNavigableSet().
java.util.Collections: java.util.Collections.UnmodifiableRandomAccessList.writeReplace	(	):  Allows instances to be deserialized in pre-1.4 JREs (which do not have UnmodifiableRandomAccessList). UnmodifiableList has a readResolve method that inverts this transformation upon deserialization.
java.util.Collections: java.util.Collections.addAll	(	Collection	T	):  Adds all of the specified elements to the specified collection. Elements to be added may be specified individually or as an array. The behavior of this convenience method is identical to that of c.addAll(Arrays.asList(elements)), but this method is likely to run significantly faster under most implementations. When elements are specified individually, this method provides a convenient way to add a few elements to an existing collection:  Collections.addAll(flavors, "Peaches 'n Plutonium", "Rocky Racoon"); 
java.util.Collections: java.util.Collections.asLifoQueue	(	Deque	):  Returns a view of a Deque as a Last-in-first-out (Lifo) Queue. Method add is mapped to push, remove is mapped to pop and so on. This view can be useful when you would like to use a method requiring a Queue but you need Lifo ordering. Each method invocation on the queue returned by this method results in exactly one method invocation on the backing deque, with one exception. The addAll method is implemented as a sequence of addFirst invocations on the backing deque.
java.util.Collections: java.util.Collections.binarySearch	(	List	T	):  Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the Comparable natural ordering of its elements (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the list contains multiple elements equal to the specified object, there is no guarantee which one will be found. This method runs in log(n) time for a "random access" list (which provides near-constant-time positional access). If the specified list does not implement the RandomAccess interface and is large, this method will do an iterator-based binary search that performs O(n) link traversals and O(log n) element comparisons.
java.util.Collections: java.util.Collections.binarySearch	(	List	T	Comparator	):  Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort() sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If the list contains multiple elements equal to the specified object, there is no guarantee which one will be found. This method runs in log(n) time for a "random access" list (which provides near-constant-time positional access). If the specified list does not implement the RandomAccess interface and is large, this method will do an iterator-based binary search that performs O(n) link traversals and O(log n) element comparisons.
java.util.Collections: java.util.Collections.checkedCollection	(	Collection	Class	):  Returns a dynamically typesafe view of the specified collection. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a collection contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the collection takes place through the view, it is guaranteed that the collection cannot contain an incorrectly typed element. The generics mechanism in the language provides compile-time (static) type checking, but it is possible to defeat this mechanism with unchecked casts. Usually this is not a problem, as the compiler issues warnings on all such unchecked operations. There are, however, times when static type checking alone is not sufficient. For example, suppose a collection is passed to a third-party library and it is imperative that the library code not corrupt the collection by inserting an element of the wrong type. Another use of dynamically typesafe views is debugging. Suppose a program fails with a ClassCastException, indicating that an incorrectly typed element was put into a parameterized collection. Unfortunately, the exception can occur at any time after the erroneous element is inserted, so it typically provides little or no information as to the real source of the problem. If the problem is reproducible, one can quickly determine its source by temporarily modifying the program to wrap the collection with a dynamically typesafe view. For example, this declaration:  Collection c = new HashSet<>(); may be replaced temporarily by this one:  Collection c = Collections.checkedCollection( new HashSet<>(), String.class); Running the program again will cause it to fail at the point where an incorrectly typed element is inserted into the collection, clearly identifying the source of the problem. Once the problem is fixed, the modified declaration may be reverted back to the original. The returned collection does not pass the hashCode and equals operations through to the backing collection, but relies on Object's equals and hashCode methods. This is necessary to preserve the contracts of these operations in the case that the backing collection is a set or a list. The returned collection will be serializable if the specified collection is serializable. Since null is considered to be a value of any reference type, the returned collection permits insertion of null elements whenever the backing collection does.
java.util.Collections: java.util.Collections.checkedList	(	List	Class	):  Returns a dynamically typesafe view of the specified list. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a list contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the list takes place through the view, it is guaranteed that the list cannot contain an incorrectly typed element. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned list will be serializable if the specified list is serializable. Since null is considered to be a value of any reference type, the returned list permits insertion of null elements whenever the backing list does.
java.util.Collections: java.util.Collections.checkedMap	(	Map	Class	Class	):  Returns a dynamically typesafe view of the specified map. Any attempt to insert a mapping whose key or value have the wrong type will result in an immediate ClassCastException. Similarly, any attempt to modify the value currently associated with a key will result in an immediate ClassCastException, whether the modification is attempted directly through the map itself, or through a Map.Entry instance obtained from the map's entrySet() entry set view. Assuming a map contains no incorrectly typed keys or values prior to the time a dynamically typesafe view is generated, and that all subsequent access to the map takes place through the view (or one of its collection views), it is guaranteed that the map cannot contain an incorrectly typed key or value. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned map will be serializable if the specified map is serializable. Since null is considered to be a value of any reference type, the returned map permits insertion of null keys or values whenever the backing map does.
java.util.Collections: java.util.Collections.checkedNavigableMap	(	NavigableMap	Class	Class	):  Returns a dynamically typesafe view of the specified navigable map. Any attempt to insert a mapping whose key or value have the wrong type will result in an immediate ClassCastException. Similarly, any attempt to modify the value currently associated with a key will result in an immediate ClassCastException, whether the modification is attempted directly through the map itself, or through a Map.Entry instance obtained from the map's entrySet() entry set view. Assuming a map contains no incorrectly typed keys or values prior to the time a dynamically typesafe view is generated, and that all subsequent access to the map takes place through the view (or one of its collection views), it is guaranteed that the map cannot contain an incorrectly typed key or value. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned map will be serializable if the specified map is serializable. Since null is considered to be a value of any reference type, the returned map permits insertion of null keys or values whenever the backing map does.
java.util.Collections: java.util.Collections.checkedNavigableSet	(	NavigableSet	Class	):  Returns a dynamically typesafe view of the specified navigable set. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a navigable set contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the navigable set takes place through the view, it is guaranteed that the navigable set cannot contain an incorrectly typed element. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned navigable set will be serializable if the specified navigable set is serializable. Since null is considered to be a value of any reference type, the returned navigable set permits insertion of null elements whenever the backing sorted set does.
java.util.Collections: java.util.Collections.checkedQueue	(	Queue	Class	):  Returns a dynamically typesafe view of the specified queue. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a queue contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the queue takes place through the view, it is guaranteed that the queue cannot contain an incorrectly typed element. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned queue will be serializable if the specified queue is serializable. Since null is considered to be a value of any reference type, the returned queue permits insertion of null elements whenever the backing queue does.
java.util.Collections: java.util.Collections.checkedSet	(	Set	Class	):  Returns a dynamically typesafe view of the specified set. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a set contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the set takes place through the view, it is guaranteed that the set cannot contain an incorrectly typed element. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned set will be serializable if the specified set is serializable. Since null is considered to be a value of any reference type, the returned set permits insertion of null elements whenever the backing set does.
java.util.Collections: java.util.Collections.checkedSortedMap	(	SortedMap	Class	Class	):  Returns a dynamically typesafe view of the specified sorted map. Any attempt to insert a mapping whose key or value have the wrong type will result in an immediate ClassCastException. Similarly, any attempt to modify the value currently associated with a key will result in an immediate ClassCastException, whether the modification is attempted directly through the map itself, or through a Map.Entry instance obtained from the map's entrySet() entry set view. Assuming a map contains no incorrectly typed keys or values prior to the time a dynamically typesafe view is generated, and that all subsequent access to the map takes place through the view (or one of its collection views), it is guaranteed that the map cannot contain an incorrectly typed key or value. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned map will be serializable if the specified map is serializable. Since null is considered to be a value of any reference type, the returned map permits insertion of null keys or values whenever the backing map does.
java.util.Collections: java.util.Collections.checkedSortedSet	(	SortedSet	Class	):  Returns a dynamically typesafe view of the specified sorted set. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a sorted set contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the sorted set takes place through the view, it is guaranteed that the sorted set cannot contain an incorrectly typed element. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned sorted set will be serializable if the specified sorted set is serializable. Since null is considered to be a value of any reference type, the returned sorted set permits insertion of null elements whenever the backing sorted set does.
java.util.Collections: java.util.Collections.copy	(	List	List	):  Copies all of the elements from one list into another. After the operation, the index of each copied element in the destination list will be identical to its index in the source list. The destination list must be at least as long as the source list. If it is longer, the remaining elements in the destination list are unaffected.  This method runs in linear time.
java.util.Collections: java.util.Collections.disjoint	(	Collection	Collection	):  Returns true if the two specified collections have no elements in common. Care must be exercised if this method is used on collections that do not comply with the general contract for Collection. Implementations may elect to iterate over either collection and test for containment in the other collection (or to perform any equivalent computation). If either collection uses a nonstandard equality test (as does a SortedSet whose ordering is not compatible with equals, or the key set of an IdentityHashMap), both collections must use the same nonstandard equality test, or the result of this method is undefined. Care must also be exercised when using collections that have restrictions on the elements that they may contain. Collection implementations are allowed to throw exceptions for any operation involving elements they deem ineligible. For absolute safety the specified collections should contain only elements which are eligible elements for both collections. Note that it is permissible to pass the same collection in both parameters, in which case the method will return true if and only if the collection is empty.
java.util.Collections: java.util.Collections.emptyEnumeration	(	):  Returns an enumeration that has no elements. More precisely,  hasMoreElements always returns false.  nextElement always throws NoSuchElementException.  Implementations of this method are permitted, but not required, to return the same object from multiple invocations.
java.util.Collections: java.util.Collections.emptyIterator	(	):  Returns an iterator that has no elements. More precisely,  hasNext always returns false. next always throws NoSuchElementException. remove always throws IllegalStateException.  Implementations of this method are permitted, but not required, to return the same object from multiple invocations.
java.util.Collections: java.util.Collections.emptyList	(	):  Returns an empty list (immutable). This list is serializable. This example illustrates the type-safe way to obtain an empty list:  List<String> s = Collections.emptyList(); 
java.util.Collections: java.util.Collections.emptyListIterator	(	):  Returns a list iterator that has no elements. More precisely,  hasNext and hasPrevious always return false. next and previous always throw NoSuchElementException. remove and set always throw IllegalStateException. add always throws UnsupportedOperationException. nextIndex always returns 0. previousIndex always returns -1.  Implementations of this method are permitted, but not required, to return the same object from multiple invocations.
java.util.Collections: java.util.Collections.emptyMap	(	):  Returns an empty map (immutable). This map is serializable. This example illustrates the type-safe way to obtain an empty map:  Map<String, Date> s = Collections.emptyMap(); 
java.util.Collections: java.util.Collections.emptyNavigableMap	(	):  Returns an empty navigable map (immutable). This map is serializable. This example illustrates the type-safe way to obtain an empty map:  NavigableMap s = Collections.emptyNavigableMap();
java.util.Collections: java.util.Collections.emptyNavigableSet	(	):  Returns an empty navigable set (immutable). This set is serializable. This example illustrates the type-safe way to obtain an empty navigable set:  NavigableSet s = Collections.emptyNavigableSet();
java.util.Collections: java.util.Collections.emptySet	(	):  Returns an empty set (immutable). This set is serializable. Unlike the like-named field, this method is parameterized. This example illustrates the type-safe way to obtain an empty set:  Set<String> s = Collections.emptySet(); 
java.util.Collections: java.util.Collections.emptySortedMap	(	):  Returns an empty sorted map (immutable). This map is serializable. This example illustrates the type-safe way to obtain an empty map:  SortedMap s = Collections.emptySortedMap();
java.util.Collections: java.util.Collections.emptySortedSet	(	):  Returns an empty sorted set (immutable). This set is serializable. This example illustrates the type-safe way to obtain an empty sorted set:  SortedSet s = Collections.emptySortedSet();
java.util.Collections: java.util.Collections.enumeration	(	Collection	):  Returns an enumeration over the specified collection. This provides interoperability with legacy APIs that require an enumeration as input.
java.util.Collections: java.util.Collections.eq	(	Object	Object	):  Returns true if the specified arguments are equal, or both null. NB: Do not replace with Object.equals until JDK-8015417 is resolved.
java.util.Collections: java.util.Collections.fill	(	List	T	):  Replaces all of the elements of the specified list with the specified element.  This method runs in linear time.
java.util.Collections: java.util.Collections.frequency	(	Collection	Object	):  Returns the number of elements in the specified collection equal to the specified object. More formally, returns the number of elements e in the collection such that (o == null ? e == null : o.equals(e)).
java.util.Collections: java.util.Collections.get	(	ListIterator	int	):  Gets the ith element from the given list by repositioning the specified list listIterator.
java.util.Collections: java.util.Collections.indexOfSubList	(	List	List	):  Returns the starting position of the first occurrence of the specified target list within the specified source list, or -1 if there is no such occurrence. More formally, returns the lowest index i such that source.subList(i, i+target.size()).equals(target), or -1 if there is no such index. (Returns -1 if target.size() > source.size()) This implementation uses the "brute force" technique of scanning over the source list, looking for a match with the target at each location in turn.
java.util.Collections: java.util.Collections.lastIndexOfSubList	(	List	List	):  Returns the starting position of the last occurrence of the specified target list within the specified source list, or -1 if there is no such occurrence. More formally, returns the highest index i such that source.subList(i, i+target.size()).equals(target), or -1 if there is no such index. (Returns -1 if target.size() > source.size()) This implementation uses the "brute force" technique of iterating over the source list, looking for a match with the target at each location in turn.
java.util.Collections: java.util.Collections.list	(	Enumeration	):  Returns an array list containing the elements returned by the specified enumeration in the order they are returned by the enumeration. This method provides interoperability between legacy APIs that return enumerations and new APIs that require collections.
java.util.Collections: java.util.Collections.max	(	Collection	):  Returns the maximum element of the given collection, according to the natural ordering of its elements. All elements in the collection must implement the Comparable interface. Furthermore, all elements in the collection must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the collection). This method iterates over the entire collection, hence it requires time proportional to the size of the collection.
java.util.Collections: java.util.Collections.max	(	Collection	Comparator	):  Returns the maximum element of the given collection, according to the order induced by the specified comparator. All elements in the collection must be mutually comparable by the specified comparator (that is, comp.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the collection). This method iterates over the entire collection, hence it requires time proportional to the size of the collection.
java.util.Collections: java.util.Collections.min	(	Collection	):  Returns the minimum element of the given collection, according to the natural ordering of its elements. All elements in the collection must implement the Comparable interface. Furthermore, all elements in the collection must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the collection). This method iterates over the entire collection, hence it requires time proportional to the size of the collection.
java.util.Collections: java.util.Collections.min	(	Collection	Comparator	):  Returns the minimum element of the given collection, according to the order induced by the specified comparator. All elements in the collection must be mutually comparable by the specified comparator (that is, comp.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the collection). This method iterates over the entire collection, hence it requires time proportional to the size of the collection.
java.util.Collections: java.util.Collections.nCopies	(	int	T	):  Returns an immutable list consisting of n copies of the specified object. The newly allocated data object is tiny (it contains a single reference to the data object). This method is useful in combination with the List.addAll method to grow lists. The returned list is serializable.
java.util.Collections: java.util.Collections.newSetFromMap	(	Map	):  Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>()); 
java.util.Collections: java.util.Collections.replaceAll	(	List	T	T	):  Replaces all occurrences of one specified value in a list with another. More formally, replaces with newVal each element e in list such that (oldVal==null ? e==null : oldVal.equals(e)). (This method has no effect on the size of the list.)
java.util.Collections: java.util.Collections.reverse	(	List	):  Reverses the order of the elements in the specified list. This method runs in linear time.
java.util.Collections: java.util.Collections.reverseOrder	(	):  Returns a comparator that imposes the reverse of the natural ordering on a collection of objects that implement the Comparable interface. (The natural ordering is the ordering imposed by the objects' own compareTo method.) This enables a simple idiom for sorting (or maintaining) collections (or arrays) of objects that implement the Comparable interface in reverse-natural-order. For example, suppose a is an array of strings. Then:  Arrays.sort(a, Collections.reverseOrder());  sorts the array in reverse-lexicographic (alphabetical) order. The returned comparator is serializable.
java.util.Collections: java.util.Collections.reverseOrder	(	Comparator	):  Returns a comparator that imposes the reverse ordering of the specified comparator. If the specified comparator is null, this method is equivalent to reverseOrder() (in other words, it returns a comparator that imposes the reverse of the natural ordering on a collection of objects that implement the Comparable interface). The returned comparator is serializable (assuming the specified comparator is also serializable or null).
java.util.Collections: java.util.Collections.rotate	(	List	int	):  Rotates the elements in the specified list by the specified distance. After calling this method, the element at index i will be the element previously at index (i - distance) mod list.size(), for all values of i between 0 and list.size()-1, inclusive. (This method has no effect on the size of the list.) For example, suppose list comprises [t, a, n, k, s]. After invoking Collections.rotate(list, 1) (or Collections.rotate(list, -4)), list will comprise [s, t, a, n, k]. Note that this method can usefully be applied to sublists to move one or more elements within a list while preserving the order of the remaining elements. For example, the following idiom moves the element at index j forward to position k (which must be greater than or equal to j):  Collections.rotate(list.subList(j, k+1), -1);  To make this concrete, suppose list comprises [a, b, c, d, e]. To move the element at index 1 (b) forward two positions, perform the following invocation:  Collections.rotate(l.subList(1, 4), -1);  The resulting list is [a, c, d, b, e]. To move more than one element forward, increase the absolute value of the rotation distance. To move elements backward, use a positive shift distance. If the specified list is small or implements the RandomAccess interface, this implementation exchanges the first element into the location it should go, and then repeatedly exchanges the displaced element into the location it should go until a displaced element is swapped into the first element. If necessary, the process is repeated on the second and successive elements, until the rotation is complete. If the specified list is large and doesn't implement the RandomAccess interface, this implementation breaks the list into two sublist views around index -distance mod size. Then the reverse() method is invoked on each sublist view, and finally it is invoked on the entire list. For a more complete description of both algorithms, see Section 2.3 of Jon Bentley's Programming Pearls (Addison-Wesley, 1986).
java.util.Collections: java.util.Collections.shuffle	(	List	):  Randomly permutes the specified list using a default source of randomness. All permutations occur with approximately equal likelihood. The hedge "approximately" is used in the foregoing description because default source of randomness is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm would choose permutations with perfect uniformity. This implementation traverses the list backwards, from the last element up to the second, repeatedly swapping a randomly selected element into the "current position". Elements are randomly selected from the portion of the list that runs from the first element to the current position, inclusive. This method runs in linear time. If the specified list does not implement the RandomAccess interface and is large, this implementation dumps the specified list into an array before shuffling it, and dumps the shuffled array back into the list. This avoids the quadratic behavior that would result from shuffling a "sequential access" list in place.
java.util.Collections: java.util.Collections.shuffle	(	List	Random	):  Randomly permute the specified list using the specified source of randomness. All permutations occur with equal likelihood assuming that the source of randomness is fair. This implementation traverses the list backwards, from the last element up to the second, repeatedly swapping a randomly selected element into the "current position". Elements are randomly selected from the portion of the list that runs from the first element to the current position, inclusive. This method runs in linear time. If the specified list does not implement the RandomAccess interface and is large, this implementation dumps the specified list into an array before shuffling it, and dumps the shuffled array back into the list. This avoids the quadratic behavior that would result from shuffling a "sequential access" list in place.
java.util.Collections: java.util.Collections.singleton	(	T	):  Returns an immutable set containing only the specified object. The returned set is serializable.
java.util.Collections: java.util.Collections.singletonList	(	T	):  Returns an immutable list containing only the specified object. The returned list is serializable.
java.util.Collections: java.util.Collections.singletonMap	(	K	V	):  Returns an immutable map, mapping only the specified key to the specified value. The returned map is serializable.
java.util.Collections: java.util.Collections.singletonSpliterator	(	T	):  Creates a Spliterator with only the specified element
java.util.Collections: java.util.Collections.sort	(	List	):  Sorts the specified list into ascending order, according to the Comparable natural ordering of its elements. All elements in the list must implement the Comparable interface. Furthermore, all elements in the list must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the list). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The specified list must be modifiable, but need not be resizable.
java.util.Collections: java.util.Collections.sort	(	List	Comparator	):  Sorts the specified list according to the order induced by the specified comparator. All elements in the list must be mutually comparable using the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the list). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The specified list must be modifiable, but need not be resizable.
java.util.Collections: java.util.Collections.swap	(	List	int	int	):  Swaps the elements at the specified positions in the specified list. (If the specified positions are equal, invoking this method leaves the list unchanged.)
java.util.Collections: java.util.Collections.swap	(	Object[]	int	int	):  Swaps the two specified elements in the specified array.
java.util.Collections: java.util.Collections.synchronizedCollection	(	Collection	):  Returns a synchronized (thread-safe) collection backed by the specified collection. In order to guarantee serial access, it is critical that all access to the backing collection is accomplished through the returned collection. It is imperative that the user manually synchronize on the returned collection when traversing it via Iterator, Spliterator or Stream:  Collection c = Collections.synchronizedCollection(myCollection); ... synchronized (c) { Iterator i = c.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned collection does not pass the hashCode and equals operations through to the backing collection, but relies on Object's equals and hashCode methods. This is necessary to preserve the contracts of these operations in the case that the backing collection is a set or a list. The returned collection will be serializable if the specified collection is serializable.
java.util.Collections: java.util.Collections.synchronizedList	(	List	):  Returns a synchronized (thread-safe) list backed by the specified list. In order to guarantee serial access, it is critical that all access to the backing list is accomplished through the returned list. It is imperative that the user manually synchronize on the returned list when iterating over it:  List list = Collections.synchronizedList(new ArrayList()); ... synchronized (list) { Iterator i = list.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned list will be serializable if the specified list is serializable.
java.util.Collections: java.util.Collections.synchronizedMap	(	Map	):  Returns a synchronized (thread-safe) map backed by the specified map. In order to guarantee serial access, it is critical that all access to the backing map is accomplished through the returned map. It is imperative that the user manually synchronize on the returned map when iterating over any of its collection views:  Map m = Collections.synchronizedMap(new HashMap()); ... Set s = m.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not s! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned map will be serializable if the specified map is serializable.
java.util.Collections: java.util.Collections.synchronizedNavigableMap	(	NavigableMap	):  Returns a synchronized (thread-safe) navigable map backed by the specified navigable map. In order to guarantee serial access, it is critical that all access to the backing navigable map is accomplished through the returned navigable map (or its views). It is imperative that the user manually synchronize on the returned navigable map when iterating over any of its collection views, or the collections views of any of its subMap, headMap or tailMap views.  NavigableMap m = Collections.synchronizedNavigableMap(new TreeMap()); ... Set s = m.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not s! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  or:  NavigableMap m = Collections.synchronizedNavigableMap(new TreeMap()); NavigableMap m2 = m.subMap(foo, true, bar, false); ... Set s2 = m2.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not m2 or s2! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned navigable map will be serializable if the specified navigable map is serializable.
java.util.Collections: java.util.Collections.synchronizedNavigableSet	(	NavigableSet	):  Returns a synchronized (thread-safe) navigable set backed by the specified navigable set. In order to guarantee serial access, it is critical that all access to the backing navigable set is accomplished through the returned navigable set (or its views). It is imperative that the user manually synchronize on the returned navigable set when iterating over it or any of its subSet, headSet, or tailSet views.  NavigableSet s = Collections.synchronizedNavigableSet(new TreeSet()); ... synchronized (s) { Iterator i = s.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  or:  NavigableSet s = Collections.synchronizedNavigableSet(new TreeSet()); NavigableSet s2 = s.headSet(foo, true); ... synchronized (s) { // Note: s, not s2!!! Iterator i = s2.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned navigable set will be serializable if the specified navigable set is serializable.
java.util.Collections: java.util.Collections.synchronizedSet	(	Set	):  Returns a synchronized (thread-safe) set backed by the specified set. In order to guarantee serial access, it is critical that all access to the backing set is accomplished through the returned set. It is imperative that the user manually synchronize on the returned set when iterating over it:  Set s = Collections.synchronizedSet(new HashSet()); ... synchronized (s) { Iterator i = s.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned set will be serializable if the specified set is serializable.
java.util.Collections: java.util.Collections.synchronizedSortedMap	(	SortedMap	):  Returns a synchronized (thread-safe) sorted map backed by the specified sorted map. In order to guarantee serial access, it is critical that all access to the backing sorted map is accomplished through the returned sorted map (or its views). It is imperative that the user manually synchronize on the returned sorted map when iterating over any of its collection views, or the collections views of any of its subMap, headMap or tailMap views.  SortedMap m = Collections.synchronizedSortedMap(new TreeMap()); ... Set s = m.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not s! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  or:  SortedMap m = Collections.synchronizedSortedMap(new TreeMap()); SortedMap m2 = m.subMap(foo, bar); ... Set s2 = m2.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not m2 or s2! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned sorted map will be serializable if the specified sorted map is serializable.
java.util.Collections: java.util.Collections.synchronizedSortedSet	(	SortedSet	):  Returns a synchronized (thread-safe) sorted set backed by the specified sorted set. In order to guarantee serial access, it is critical that all access to the backing sorted set is accomplished through the returned sorted set (or its views). It is imperative that the user manually synchronize on the returned sorted set when iterating over it or any of its subSet, headSet, or tailSet views.  SortedSet s = Collections.synchronizedSortedSet(new TreeSet()); ... synchronized (s) { Iterator i = s.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  or:  SortedSet s = Collections.synchronizedSortedSet(new TreeSet()); SortedSet s2 = s.headSet(foo); ... synchronized (s) { // Note: s, not s2!!! Iterator i = s2.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned sorted set will be serializable if the specified sorted set is serializable.
java.util.Collections: java.util.Collections.unmodifiableCollection	(	Collection	):  Returns an unmodifiable view of the specified collection. This method allows modules to provide users with "read-only" access to internal collections. Query operations on the returned collection "read through" to the specified collection, and attempts to modify the returned collection, whether direct or via its iterator, result in an UnsupportedOperationException. The returned collection does not pass the hashCode and equals operations through to the backing collection, but relies on Object's equals and hashCode methods. This is necessary to preserve the contracts of these operations in the case that the backing collection is a set or a list. The returned collection will be serializable if the specified collection is serializable.
java.util.Collections: java.util.Collections.unmodifiableList	(	List	):  Returns an unmodifiable view of the specified list. This method allows modules to provide users with "read-only" access to internal lists. Query operations on the returned list "read through" to the specified list, and attempts to modify the returned list, whether direct or via its iterator, result in an UnsupportedOperationException. The returned list will be serializable if the specified list is serializable. Similarly, the returned list will implement RandomAccess if the specified list does.
java.util.Collections: java.util.Collections.unmodifiableMap	(	Map	):  Returns an unmodifiable view of the specified map. This method allows modules to provide users with "read-only" access to internal maps. Query operations on the returned map "read through" to the specified map, and attempts to modify the returned map, whether direct or via its collection views, result in an UnsupportedOperationException. The returned map will be serializable if the specified map is serializable.
java.util.Collections: java.util.Collections.unmodifiableNavigableMap	(	NavigableMap	):  Returns an unmodifiable view of the specified navigable map. This method allows modules to provide users with "read-only" access to internal navigable maps. Query operations on the returned navigable map "read through" to the specified navigable map. Attempts to modify the returned navigable map, whether direct, via its collection views, or via its subMap, headMap, or tailMap views, result in an UnsupportedOperationException. The returned navigable map will be serializable if the specified navigable map is serializable.
java.util.Collections: java.util.Collections.unmodifiableNavigableSet	(	NavigableSet	):  Returns an unmodifiable view of the specified navigable set. This method allows modules to provide users with "read-only" access to internal navigable sets. Query operations on the returned navigable set "read through" to the specified navigable set. Attempts to modify the returned navigable set, whether direct, via its iterator, or via its subSet, headSet, or tailSet views, result in an UnsupportedOperationException. The returned navigable set will be serializable if the specified navigable set is serializable.
java.util.Collections: java.util.Collections.unmodifiableSet	(	Set	):  Returns an unmodifiable view of the specified set. This method allows modules to provide users with "read-only" access to internal sets. Query operations on the returned set "read through" to the specified set, and attempts to modify the returned set, whether direct or via its iterator, result in an UnsupportedOperationException. The returned set will be serializable if the specified set is serializable.
java.util.Collections: java.util.Collections.unmodifiableSortedMap	(	SortedMap	):  Returns an unmodifiable view of the specified sorted map. This method allows modules to provide users with "read-only" access to internal sorted maps. Query operations on the returned sorted map "read through" to the specified sorted map. Attempts to modify the returned sorted map, whether direct, via its collection views, or via its subMap, headMap, or tailMap views, result in an UnsupportedOperationException. The returned sorted map will be serializable if the specified sorted map is serializable.
java.util.Collections: java.util.Collections.unmodifiableSortedSet	(	SortedSet	):  Returns an unmodifiable view of the specified sorted set. This method allows modules to provide users with "read-only" access to internal sorted sets. Query operations on the returned sorted set "read through" to the specified sorted set. Attempts to modify the returned sorted set, whether direct, via its iterator, or via its subSet, headSet, or tailSet views, result in an UnsupportedOperationException. The returned sorted set will be serializable if the specified sorted set is serializable.
java.util.List: java.util.List:  An ordered collection (also known as a sequence). The user of this interface has precise control over where in the list each element is inserted. The user can access elements by their integer index (position in the list), and search for elements in the list. Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare. The List interface places additional stipulations, beyond those specified in the Collection interface, on the contracts of the iterator, add, remove, equals, and hashCode methods. Declarations for other inherited methods are also included here for convenience. The List interface provides four methods for positional (indexed) access to list elements. Lists (like Java arrays) are zero based. Note that these operations may execute in time proportional to the index value for some implementations (the LinkedList class, for example). Thus, iterating over the elements in a list is typically preferable to indexing through it if the caller does not know the implementation. The List interface provides a special iterator, called a ListIterator, that allows element insertion and replacement, and bidirectional access in addition to the normal operations that the Iterator interface provides. A method is provided to obtain a list iterator that starts at a specified position in the list. The List interface provides two methods to search for a specified object. From a performance standpoint, these methods should be used with caution. In many implementations they will perform costly linear searches. The List interface provides two methods to efficiently insert and remove multiple elements at an arbitrary point in the list. Note: While it is permissible for lists to contain themselves as elements, extreme caution is advised: the equals and hashCode methods are no longer well defined on such a list. Some list implementations have restrictions on the elements that they may contain. For example, some implementations prohibit null elements, and some have restrictions on the types of their elements. Attempting to add an ineligible element throws an unchecked exception, typically NullPointerException or ClassCastException. Attempting to query the presence of an ineligible element may throw an exception, or it may simply return false; some implementations will exhibit the former behavior and some will exhibit the latter. More generally, attempting an operation on an ineligible element whose completion would not result in the insertion of an ineligible element into the list may throw an exception or it may succeed, at the option of the implementation. Such exceptions are marked as "optional" in the specification for this interface. This interface is a member of the  Java Collections Framework.
java.util.List: java.util.List.add	(	E	):  Appends the specified element to the end of this list (optional operation). Lists that support this operation may place limitations on what elements may be added to this list. In particular, some lists will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. List classes should clearly specify in their documentation any restrictions on what elements may be added.
java.util.List: java.util.List.add	(	int	E	):  Inserts the specified element at the specified position in this list (optional operation). Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices).
java.util.List: java.util.List.addAll	(	Collection	):  Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's iterator (optional operation). The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (Note that this will occur if the specified collection is this list, and it's nonempty.)
java.util.List: java.util.List.addAll	(	int	Collection	):  Inserts all of the elements in the specified collection into this list at the specified position (optional operation). Shifts the element currently at that position (if any) and any subsequent elements to the right (increases their indices). The new elements will appear in this list in the order that they are returned by the specified collection's iterator. The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (Note that this will occur if the specified collection is this list, and it's nonempty.)
java.util.List: java.util.List.clear	(	):  Removes all of the elements from this list (optional operation). The list will be empty after this call returns.
java.util.List: java.util.List.contains	(	Object	):  Returns true if this list contains the specified element. More formally, returns true if and only if this list contains at least one element e such that (o==null ? e==null : o.equals(e)).
java.util.List: java.util.List.containsAll	(	Collection	):  Returns true if this list contains all of the elements of the specified collection.
java.util.List: java.util.List.equals	(	Object	):  Compares the specified object with this list for equality. Returns true if and only if the specified object is also a list, both lists have the same size, and all corresponding pairs of elements in the two lists are equal. (Two elements e1 and e2 are equal if (e1==null ? e2==null : e1.equals(e2)).) In other words, two lists are defined to be equal if they contain the same elements in the same order. This definition ensures that the equals method works properly across different implementations of the List interface.
java.util.List: java.util.List.get	(	int	):  Returns the element at the specified position in this list.
java.util.List: java.util.List.hashCode	(	):  Returns the hash code value for this list. The hash code of a list is defined to be the result of the following calculation: int hashCode = 1; for (E e : list) hashCode = 31*hashCode + (e==null ? 0 : e.hashCode()); This ensures that list1.equals(list2) implies that list1.hashCode()==list2.hashCode() for any two lists, list1 and list2, as required by the general contract of hashCode.
java.util.List: java.util.List.indexOf	(	Object	):  Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.
java.util.List: java.util.List.isEmpty	(	):  Returns true if this list contains no elements.
java.util.List: java.util.List.iterator	(	):  Returns an iterator over the elements in this list in proper sequence.
java.util.List: java.util.List.lastIndexOf	(	Object	):  Returns the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the highest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.
java.util.List: java.util.List.listIterator	(	):  Returns a list iterator over the elements in this list (in proper sequence).
java.util.List: java.util.List.listIterator	(	int	):  Returns a list iterator over the elements in this list (in proper sequence), starting at the specified position in the list. The specified index indicates the first element that would be returned by an initial call to next. An initial call to previous would return the element with the specified index minus one.
java.util.List: java.util.List.remove	(	Object	):  Removes the first occurrence of the specified element from this list, if it is present (optional operation). If this list does not contain the element, it is unchanged. More formally, removes the element with the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))) (if such an element exists). Returns true if this list contained the specified element (or equivalently, if this list changed as a result of the call).
java.util.List: java.util.List.remove	(	int	):  Removes the element at the specified position in this list (optional operation). Shifts any subsequent elements to the left (subtracts one from their indices). Returns the element that was removed from the list.
java.util.List: java.util.List.removeAll	(	Collection	):  Removes from this list all of its elements that are contained in the specified collection (optional operation).
java.util.List: java.util.List.replaceAll	(	UnaryOperator	):  Replaces each element of this list with the result of applying the operator to that element. Errors or runtime exceptions thrown by the operator are relayed to the caller.
java.util.List: java.util.List.retainAll	(	Collection	):  Retains only the elements in this list that are contained in the specified collection (optional operation). In other words, removes from this list all of its elements that are not contained in the specified collection.
java.util.List: java.util.List.set	(	int	E	):  Replaces the element at the specified position in this list with the specified element (optional operation).
java.util.List: java.util.List.size	(	):  Returns the number of elements in this list. If this list contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
java.util.List: java.util.List.sort	(	Comparator	):  Sorts this list according to the order induced by the specified Comparator. All elements in this list must be mutually comparable using the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the list). If the specified comparator is null then all elements in this list must implement the Comparable interface and the elements' Comparable natural ordering should be used. This list must be modifiable, but need not be resizable.
java.util.List: java.util.List.spliterator	(	):  Creates a Spliterator over the elements in this list. The Spliterator reports SIZED and ORDERED. Implementations should document the reporting of additional characteristic values.
java.util.List: java.util.List.subList	(	int	int	):  Returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive. (If fromIndex and toIndex are equal, the returned list is empty.) The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa. The returned list supports all of the optional list operations supported by this list. This method eliminates the need for explicit range operations (of the sort that commonly exist for arrays). Any operation that expects a list can be used as a range operation by passing a subList view instead of a whole list. For example, the following idiom removes a range of elements from a list: list.subList(from, to).clear(); Similar idioms may be constructed for indexOf and lastIndexOf, and all of the algorithms in the Collections class can be applied to a subList. The semantics of the list returned by this method become undefined if the backing list (i.e., this list) is structurally modified in any way other than via the returned list. (Structural modifications are those that change the size of this list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.)
java.util.List: java.util.List.toArray	(	):  Returns an array containing all of the elements in this list in proper sequence (from first to last element). The returned array will be "safe" in that no references to it are maintained by this list. (In other words, this method must allocate a new array even if this list is backed by an array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.List: java.util.List.toArray	(	T[]	):  Returns an array containing all of the elements in this list in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array. If the list fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this list. If the list fits in the specified array with room to spare (i.e., the array has more elements than the list), the element in the array immediately following the end of the list is set to null. (This is useful in determining the length of the list only if the caller knows that the list does not contain any null elements.) Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a list known to contain only strings. The following code can be used to dump the list into a newly allocated array of String: String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.Collection: java.util.Collection:  The root interface in the collection hierarchy. A collection represents a group of objects, known as its elements. Some collections allow duplicate elements and others do not. Some are ordered and others unordered. The JDK does not provide any direct implementations of this interface: it provides implementations of more specific subinterfaces like Set and List. This interface is typically used to pass collections around and manipulate them where maximum generality is desired. Bags or multisets (unordered collections that may contain duplicate elements) should implement this interface directly. All general-purpose Collection implementation classes (which typically implement Collection indirectly through one of its subinterfaces) should provide two "standard" constructors: a void (no arguments) constructor, which creates an empty collection, and a constructor with a single argument of type Collection, which creates a new collection with the same elements as its argument. In effect, the latter constructor allows the user to copy any collection, producing an equivalent collection of the desired implementation type. There is no way to enforce this convention (as interfaces cannot contain constructors) but all of the general-purpose Collection implementations in the Java platform libraries comply. The "destructive" methods contained in this interface, that is, the methods that modify the collection on which they operate, are specified to throw UnsupportedOperationException if this collection does not support the operation. If this is the case, these methods may, but are not required to, throw an UnsupportedOperationException if the invocation would have no effect on the collection. For example, invoking the addAll() method on an unmodifiable collection may, but is not required to, throw the exception if the collection to be added is empty.  Some collection implementations have restrictions on the elements that they may contain. For example, some implementations prohibit null elements, and some have restrictions on the types of their elements. Attempting to add an ineligible element throws an unchecked exception, typically NullPointerException or ClassCastException. Attempting to query the presence of an ineligible element may throw an exception, or it may simply return false; some implementations will exhibit the former behavior and some will exhibit the latter. More generally, attempting an operation on an ineligible element whose completion would not result in the insertion of an ineligible element into the collection may throw an exception or it may succeed, at the option of the implementation. Such exceptions are marked as "optional" in the specification for this interface. It is up to each collection to determine its own synchronization policy. In the absence of a stronger guarantee by the implementation, undefined behavior may result from the invocation of any method on a collection that is being mutated by another thread; this includes direct invocations, passing the collection to a method that might perform invocations, and using an existing iterator to examine the collection. Many methods in Collections Framework interfaces are defined in terms of the equals() method. For example, the specification for the contains() contains(Object o) method says: "returns true if and only if this collection contains at least one element e such that (o==null ? e==null : o.equals(e))." This specification should not be construed to imply that invoking Collection.contains with a non-null argument o will cause o.equals(e) to be invoked for any element e. Implementations are free to implement optimizations whereby the equals invocation is avoided, for example, by first comparing the hash codes of the two elements. (The hashCode() specification guarantees that two objects with unequal hash codes cannot be equal.) More generally, implementations of the various Collections Framework interfaces are free to take advantage of the specified behavior of underlying Object methods wherever the implementor deems it appropriate. Some collection operations which perform recursive traversal of the collection may fail with an exception for self-referential instances where the collection directly or indirectly contains itself. This includes the clone(), equals(), hashCode() and toString() methods. Implementations may optionally handle the self-referential scenario, however most current implementations do not do so. This interface is a member of the  Java Collections Framework.
java.util.Collection: java.util.Collection.add	(	E	):  Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.
java.util.Collection: java.util.Collection.addAll	(	Collection	):  Adds all of the elements in the specified collection to this collection (optional operation). The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (This implies that the behavior of this call is undefined if the specified collection is this collection, and this collection is nonempty.)
java.util.Collection: java.util.Collection.clear	(	):  Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.
java.util.Collection: java.util.Collection.contains	(	Object	):  Returns true if this collection contains the specified element. More formally, returns true if and only if this collection contains at least one element e such that (o==null ? e==null : o.equals(e)).
java.util.Collection: java.util.Collection.containsAll	(	Collection	):  Returns true if this collection contains all of the elements in the specified collection.
java.util.Collection: java.util.Collection.equals	(	Object	):  Compares the specified object with this collection for equality.  While the Collection interface adds no stipulations to the general contract for the Object.equals, programmers who implement the Collection interface "directly" (in other words, create a class that is a Collection but is not a Set or a List) must exercise care if they choose to override the Object.equals. It is not necessary to do so, and the simplest course of action is to rely on Object's implementation, but the implementor may wish to implement a "value comparison" in place of the default "reference comparison." (The List and Set interfaces mandate such value comparisons.) The general contract for the Object.equals method states that equals must be symmetric (in other words, a.equals(b) if and only if b.equals(a)). The contracts for List.equals and Set.equals state that lists are only equal to other lists, and sets to other sets. Thus, a custom equals method for a collection class that implements neither the List nor Set interface must return false when this collection is compared to any list or set. (By the same logic, it is not possible to write a class that correctly implements both the Set and List interfaces.)
java.util.Collection: java.util.Collection.hashCode	(	):  Returns the hash code value for this collection. While the Collection interface adds no stipulations to the general contract for the Object.hashCode method, programmers should take note that any class that overrides the Object.equals method must also override the Object.hashCode method in order to satisfy the general contract for the Object.hashCode method. In particular, c1.equals(c2) implies that c1.hashCode()==c2.hashCode().
java.util.Collection: java.util.Collection.isEmpty	(	):  Returns true if this collection contains no elements.
java.util.Collection: java.util.Collection.iterator	(	):  Returns an iterator over the elements in this collection. There are no guarantees concerning the order in which the elements are returned (unless this collection is an instance of some class that provides a guarantee).
java.util.Collection: java.util.Collection.parallelStream	(	):  Returns a possibly parallel Stream with this collection as its source. It is allowable for this method to return a sequential stream. This method should be overridden when the spliterator() method cannot return a spliterator that is IMMUTABLE, CONCURRENT, or late-binding. (See spliterator() for details.)
java.util.Collection: java.util.Collection.remove	(	Object	):  Removes a single instance of the specified element from this collection, if it is present (optional operation). More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this collection contains one or more such elements. Returns true if this collection contained the specified element (or equivalently, if this collection changed as a result of the call).
java.util.Collection: java.util.Collection.removeAll	(	Collection	):  Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.
java.util.Collection: java.util.Collection.removeIf	(	Predicate	):  Removes all of the elements of this collection that satisfy the given predicate. Errors or runtime exceptions thrown during iteration or by the predicate are relayed to the caller.
java.util.Collection: java.util.Collection.retainAll	(	Collection	):  Retains only the elements in this collection that are contained in the specified collection (optional operation). In other words, removes from this collection all of its elements that are not contained in the specified collection.
java.util.Collection: java.util.Collection.size	(	):  Returns the number of elements in this collection. If this collection contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
java.util.Collection: java.util.Collection.spliterator	(	):  Creates a Spliterator over the elements in this collection. Implementations should document characteristic values reported by the spliterator. Such characteristic values are not required to be reported if the spliterator reports SIZED and this collection contains no elements. The default implementation should be overridden by subclasses that can return a more efficient spliterator. In order to preserve expected laziness behavior for the stream() and parallelStream()} methods, spliterators should either have the characteristic of IMMUTABLE or CONCURRENT, or be late-binding. If none of these is practical, the overriding class should describe the spliterator's documented policy of binding and structural interference, and should override the stream() and parallelStream() methods to create streams using a Supplier of the spliterator, as in: Stream s = StreamSupport.stream(() -> spliterator(), spliteratorCharacteristics) These requirements ensure that streams produced by the stream() and parallelStream() methods will reflect the contents of the collection as of initiation of the terminal stream operation.
java.util.Collection: java.util.Collection.stream	(	):  Returns a sequential Stream with this collection as its source. This method should be overridden when the spliterator() method cannot return a spliterator that is IMMUTABLE, CONCURRENT, or late-binding. (See spliterator() for details.)
java.util.Collection: java.util.Collection.toArray	(	):  Returns an array containing all of the elements in this collection. If this collection makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. The returned array will be "safe" in that no references to it are maintained by this collection. (In other words, this method must allocate a new array even if this collection is backed by an array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.Collection: java.util.Collection.toArray	(	T[]	):  Returns an array containing all of the elements in this collection; the runtime type of the returned array is that of the specified array. If the collection fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this collection. If this collection fits in the specified array with room to spare (i.e., the array has more elements than this collection), the element in the array immediately following the end of the collection is set to null. (This is useful in determining the length of this collection only if the caller knows that this collection does not contain any null elements.) If this collection makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a collection known to contain only strings. The following code can be used to dump the collection into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.Comparator: java.util.Comparator:  A comparison function, which imposes a total ordering on some collection of objects. Comparators can be passed to a sort method (such as sort() Collections.sort or sort() Arrays.sort) to allow precise control over the sort order. Comparators can also be used to control the order of certain data structures (such as SortedSet sorted sets or SortedMap sorted maps), or to provide an ordering for collections of objects that don't have a Comparable natural ordering. The ordering imposed by a comparator c on a set of elements S is said to be consistent with equals if and only if c.compare(e1, e2)==0 has the same boolean value as e1.equals(e2) for every e1 and e2 in S. Caution should be exercised when using a comparator capable of imposing an ordering inconsistent with equals to order a sorted set (or sorted map). Suppose a sorted set (or sorted map) with an explicit comparator c is used with elements (or keys) drawn from a set S. If the ordering imposed by c on S is inconsistent with equals, the sorted set (or sorted map) will behave "strangely." In particular the sorted set (or sorted map) will violate the general contract for set (or map), which is defined in terms of equals. For example, suppose one adds two elements a and b such that (a.equals(b) && c.compare(a, b) != 0) to an empty TreeSet with comparator c. The second add operation will return true (and the size of the tree set will increase) because a and b are not equivalent from the tree set's perspective, even though this is contrary to the specification of the add Set.add method. Note: It is generally a good idea for comparators to also implement java.io.Serializable, as they may be used as ordering methods in serializable data structures (like TreeSet, TreeMap). In order for the data structure to serialize successfully, the comparator (if provided) must implement Serializable. For the mathematically inclined, the relation that defines the imposed ordering that a given comparator c imposes on a given set of objects S is: {(x, y) such that c.compare(x, y) <= 0}.  The quotient for this total order is: {(x, y) such that c.compare(x, y) == 0}.  It follows immediately from the contract for compare that the quotient is an equivalence relation on S, and that the imposed ordering is a total order on S. When we say that the ordering imposed by c on S is consistent with equals, we mean that the quotient for the ordering is the equivalence relation defined by the objects' equals() equals(Object) method(s): {(x, y) such that x.equals(y)}.  Unlike Comparable, a comparator may optionally permit comparison of null arguments, while maintaining the requirements for an equivalence relation. This interface is a member of the  Java Collections Framework.
java.util.Comparator: java.util.Comparator.compare	(	T	T	):  Compares its two arguments for order. Returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. In the foregoing description, the notation sgn(expression) designates the mathematical signum function, which is defined to return one of -1, 0, or 1 according to whether the value of expression is negative, zero or positive. The implementor must ensure that sgn(compare(x, y)) == -sgn(compare(y, x)) for all x and y. (This implies that compare(x, y) must throw an exception if and only if compare(y, x) throws an exception.) The implementor must also ensure that the relation is transitive: ((compare(x, y)>0) && (compare(y, z)>0)) implies compare(x, z)>0. Finally, the implementor must ensure that compare(x, y)==0 implies that sgn(compare(x, z))==sgn(compare(y, z)) for all z. It is generally the case, but not strictly required that (compare(x, y)==0) == (x.equals(y)). Generally speaking, any comparator that violates this condition should clearly indicate this fact. The recommended language is "Note: this comparator imposes orderings that are inconsistent with equals."
java.util.Comparator: java.util.Comparator.comparing	(	Function	):  Accepts a function that extracts a java.lang.Comparable Comparable sort key from a type T, and returns a Comparator that compares by that sort key. The returned comparator is serializable if the specified function is also serializable.
java.util.Comparator: java.util.Comparator.comparing	(	Function	Comparator	):  Accepts a function that extracts a sort key from a type T, and returns a Comparator that compares by that sort key using the specified Comparator. The returned comparator is serializable if the specified function and comparator are both serializable.
java.util.Comparator: java.util.Comparator.comparingDouble	(	ToDoubleFunction	):  Accepts a function that extracts a double sort key from a type T, and returns a Comparator that compares by that sort key. The returned comparator is serializable if the specified function is also serializable.
java.util.Comparator: java.util.Comparator.comparingInt	(	ToIntFunction	):  Accepts a function that extracts an int sort key from a type T, and returns a Comparator that compares by that sort key. The returned comparator is serializable if the specified function is also serializable.
java.util.Comparator: java.util.Comparator.comparingLong	(	ToLongFunction	):  Accepts a function that extracts a long sort key from a type T, and returns a Comparator that compares by that sort key. The returned comparator is serializable if the specified function is also serializable.
java.util.Comparator: java.util.Comparator.equals	(	Object	):  Indicates whether some other object is "equal to" this comparator. This method must obey the general contract of equals(). Additionally, this method can return true only if the specified object is also a comparator and it imposes the same ordering as this comparator. Thus, comp1.equals(comp2) implies that sgn(comp1.compare(o1, o2))==sgn(comp2.compare(o1, o2)) for every object reference o1 and o2. Note that it is always safe not to override Object.equals(Object). However, overriding this method may, in some cases, improve performance by allowing programs to determine that two distinct comparators impose the same order.
java.util.Comparator: java.util.Comparator.naturalOrder	(	):  Returns a comparator that compares Comparable objects in natural order. The returned comparator is serializable and throws NullPointerException when comparing null.
java.util.Comparator: java.util.Comparator.nullsFirst	(	Comparator	):  Returns a null-friendly comparator that considers null to be less than non-null. When both are null, they are considered equal. If both are non-null, the specified Comparator is used to determine the order. If the specified comparator is null, then the returned comparator considers all non-null values to be equal. The returned comparator is serializable if the specified comparator is serializable.
java.util.Comparator: java.util.Comparator.nullsLast	(	Comparator	):  Returns a null-friendly comparator that considers null to be greater than non-null. When both are null, they are considered equal. If both are non-null, the specified Comparator is used to determine the order. If the specified comparator is null, then the returned comparator considers all non-null values to be equal. The returned comparator is serializable if the specified comparator is serializable.
java.util.Comparator: java.util.Comparator.reverseOrder	(	):  Returns a comparator that imposes the reverse of the natural ordering. The returned comparator is serializable and throws NullPointerException when comparing null.
java.util.Comparator: java.util.Comparator.reversed	(	):  Returns a comparator that imposes the reverse ordering of this comparator.
java.util.Comparator: java.util.Comparator.thenComparing	(	Comparator	):  Returns a lexicographic-order comparator with another comparator. If this Comparator considers two elements equal, i.e. compare(a, b) == 0, other is used to determine the order. The returned comparator is serializable if the specified comparator is also serializable.
java.util.Comparator: java.util.Comparator.thenComparing	(	Function	):  Returns a lexicographic-order comparator with a function that extracts a Comparable sort key.
java.util.Comparator: java.util.Comparator.thenComparing	(	Function	Comparator	):  Returns a lexicographic-order comparator with a function that extracts a key to be compared with the given Comparator.
java.util.Comparator: java.util.Comparator.thenComparingDouble	(	ToDoubleFunction	):  Returns a lexicographic-order comparator with a function that extracts a double sort key.
java.util.Comparator: java.util.Comparator.thenComparingInt	(	ToIntFunction	):  Returns a lexicographic-order comparator with a function that extracts a int sort key.
java.util.Comparator: java.util.Comparator.thenComparingLong	(	ToLongFunction	):  Returns a lexicographic-order comparator with a function that extracts a long sort key.
java.util.Map: java.util.Map:  An object that maps keys to values. A map cannot contain duplicate keys; each key can map to at most one value. This interface takes the place of the Dictionary class, which was a totally abstract class rather than an interface. The Map interface provides three collection views, which allow a map's contents to be viewed as a set of keys, collection of values, or set of key-value mappings. The order of a map is defined as the order in which the iterators on the map's collection views return their elements. Some map implementations, like the TreeMap class, make specific guarantees as to their order; others, like the HashMap class, do not. Note: great care must be exercised if mutable objects are used as map keys. The behavior of a map is not specified if the value of an object is changed in a manner that affects equals comparisons while the object is a key in the map. A special case of this prohibition is that it is not permissible for a map to contain itself as a key. While it is permissible for a map to contain itself as a value, extreme caution is advised: the equals and hashCode methods are no longer well defined on such a map. All general-purpose map implementation classes should provide two "standard" constructors: a void (no arguments) constructor which creates an empty map, and a constructor with a single argument of type Map, which creates a new map with the same key-value mappings as its argument. In effect, the latter constructor allows the user to copy any map, producing an equivalent map of the desired class. There is no way to enforce this recommendation (as interfaces cannot contain constructors) but all of the general-purpose map implementations in the JDK comply. The "destructive" methods contained in this interface, that is, the methods that modify the map on which they operate, are specified to throw UnsupportedOperationException if this map does not support the operation. If this is the case, these methods may, but are not required to, throw an UnsupportedOperationException if the invocation would have no effect on the map. For example, invoking the putAll() method on an unmodifiable map may, but is not required to, throw the exception if the map whose mappings are to be "superimposed" is empty. Some map implementations have restrictions on the keys and values they may contain. For example, some implementations prohibit null keys and values, and some have restrictions on the types of their keys. Attempting to insert an ineligible key or value throws an unchecked exception, typically NullPointerException or ClassCastException. Attempting to query the presence of an ineligible key or value may throw an exception, or it may simply return false; some implementations will exhibit the former behavior and some will exhibit the latter. More generally, attempting an operation on an ineligible key or value whose completion would not result in the insertion of an ineligible element into the map may throw an exception or it may succeed, at the option of the implementation. Such exceptions are marked as "optional" in the specification for this interface. Many methods in Collections Framework interfaces are defined in terms of the equals() method. For example, the specification for the containsKey() containsKey(Object key) method says: "returns true if and only if this map contains a mapping for a key k such that (key==null ? k==null : key.equals(k))." This specification should not be construed to imply that invoking Map.containsKey with a non-null argument key will cause key.equals(k) to be invoked for any key k. Implementations are free to implement optimizations whereby the equals invocation is avoided, for example, by first comparing the hash codes of the two keys. (The hashCode() specification guarantees that two objects with unequal hash codes cannot be equal.) More generally, implementations of the various Collections Framework interfaces are free to take advantage of the specified behavior of underlying Object methods wherever the implementor deems it appropriate. Some map operations which perform recursive traversal of the map may fail with an exception for self-referential instances where the map directly or indirectly contains itself. This includes the clone(), equals(), hashCode() and toString() methods. Implementations may optionally handle the self-referential scenario, however most current implementations do not do so. This interface is a member of the  Java Collections Framework.
java.util.Map: java.util.Map.Entry:  A map entry (key-value pair). The Map.entrySet method returns a collection-view of the map, whose elements are of this class. The only way to obtain a reference to a map entry is from the iterator of this collection-view. These Map.Entry objects are valid only for the duration of the iteration; more formally, the behavior of a map entry is undefined if the backing map has been modified after the entry was returned by the iterator, except through the setValue operation on the map entry.
java.util.Map: java.util.Map.Entry.comparingByKey	(	):  Returns a comparator that compares Map.Entry in natural order on key. The returned comparator is serializable and throws NullPointerException when comparing an entry with a null key.
java.util.Map: java.util.Map.Entry.comparingByKey	(	Comparator	):  Returns a comparator that compares Map.Entry by key using the given Comparator. The returned comparator is serializable if the specified comparator is also serializable.
java.util.Map: java.util.Map.Entry.comparingByValue	(	):  Returns a comparator that compares Map.Entry in natural order on value. The returned comparator is serializable and throws NullPointerException when comparing an entry with null values.
java.util.Map: java.util.Map.Entry.comparingByValue	(	Comparator	):  Returns a comparator that compares Map.Entry by value using the given Comparator. The returned comparator is serializable if the specified comparator is also serializable.
java.util.Map: java.util.Map.Entry.equals	(	Object	):  Compares the specified object with this entry for equality. Returns true if the given object is also a map entry and the two entries represent the same mapping. More formally, two entries e1 and e2 represent the same mapping if (e1.getKey()==null ? e2.getKey()==null : e1.getKey().equals(e2.getKey())) && (e1.getValue()==null ? e2.getValue()==null : e1.getValue().equals(e2.getValue()))  This ensures that the equals method works properly across different implementations of the Map.Entry interface.
java.util.Map: java.util.Map.Entry.getKey	(	):  Returns the key corresponding to this entry.
java.util.Map: java.util.Map.Entry.getValue	(	):  Returns the value corresponding to this entry. If the mapping has been removed from the backing map (by the iterator's remove operation), the results of this call are undefined.
java.util.Map: java.util.Map.Entry.hashCode	(	):  Returns the hash code value for this map entry. The hash code of a map entry e is defined to be:  (e.getKey()==null ? 0 : e.getKey().hashCode()) ^ (e.getValue()==null ? 0 : e.getValue().hashCode())  This ensures that e1.equals(e2) implies that e1.hashCode()==e2.hashCode() for any two Entries e1 and e2, as required by the general contract of Object.hashCode.
java.util.Map: java.util.Map.Entry.setValue	(	V	):  Replaces the value corresponding to this entry with the specified value (optional operation). (Writes through to the map.) The behavior of this call is undefined if the mapping has already been removed from the map (by the iterator's remove operation).
java.util.Map: java.util.Map.clear	(	):  Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.
java.util.Map: java.util.Map.compute	(	K	BiFunction	):  Attempts to compute a mapping for the specified key and its current mapped value (or null if there is no current mapping). For example, to either create or append a String msg to a value mapping:  map.compute(key, (k, v) -> (v == null) ? msg : v.concat(msg)) (Method merge merge() is often simpler to use for such purposes.) If the function returns null, the mapping is removed (or remains absent if initially absent). If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.
java.util.Map: java.util.Map.computeIfAbsent	(	K	Function	):  If the specified key is not already associated with a value (or is mapped to null), attempts to compute its value using the given mapping function and enters it into this map unless null. If the function returns null no mapping is recorded. If the function itself throws an (unchecked) exception, the exception is rethrown, and no mapping is recorded. The most common usage is to construct a new object serving as an initial mapped value or memoized result, as in:  map.computeIfAbsent(key, k -> new Value(f(k))); Or to implement a multi-value map, Map>, supporting multiple values per key:  map.computeIfAbsent(key, k -> new HashSet()).add(v);
java.util.Map: java.util.Map.computeIfPresent	(	K	BiFunction	):  If the value for the specified key is present and non-null, attempts to compute a new mapping given the key and its current mapped value. If the function returns null, the mapping is removed. If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.
java.util.Map: java.util.Map.containsKey	(	Object	):  Returns true if this map contains a mapping for the specified key. More formally, returns true if and only if this map contains a mapping for a key k such that (key==null ? k==null : key.equals(k)). (There can be at most one such mapping.)
java.util.Map: java.util.Map.containsValue	(	Object	):  Returns true if this map maps one or more keys to the specified value. More formally, returns true if and only if this map contains at least one mapping to a value v such that (value==null ? v==null : value.equals(v)). This operation will probably require time linear in the map size for most implementations of the Map interface.
java.util.Map: java.util.Map.entrySet	(	):  Returns a Set view of the mappings contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation, or through the setValue operation on a map entry returned by the iterator) the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.Map: java.util.Map.equals	(	Object	):  Compares the specified object with this map for equality. Returns true if the given object is also a map and the two maps represent the same mappings. More formally, two maps m1 and m2 represent the same mappings if m1.entrySet().equals(m2.entrySet()). This ensures that the equals method works properly across different implementations of the Map interface.
java.util.Map: java.util.Map.forEach	(	BiConsumer	):  Performs the given action for each entry in this map until all entries have been processed or the action throws an exception. Unless otherwise specified by the implementing class, actions are performed in the order of entry set iteration (if an iteration order is specified.) Exceptions thrown by the action are relayed to the caller.
java.util.Map: java.util.Map.get	(	Object	):  Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that (key==null ? k==null : key.equals(k)), then this method returns v; otherwise it returns null. (There can be at most one such mapping.) If this map permits null values, then a return value of null does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to null. The containsKey operation may be used to distinguish these two cases.
java.util.Map: java.util.Map.getOrDefault	(	Object	V	):  Returns the value to which the specified key is mapped, or defaultValue if this map contains no mapping for the key.
java.util.Map: java.util.Map.hashCode	(	):  Returns the hash code value for this map. The hash code of a map is defined to be the sum of the hash codes of each entry in the map's entrySet() view. This ensures that m1.equals(m2) implies that m1.hashCode()==m2.hashCode() for any two maps m1 and m2, as required by the general contract of hashCode.
java.util.Map: java.util.Map.isEmpty	(	):  Returns true if this map contains no key-value mappings.
java.util.Map: java.util.Map.keySet	(	):  Returns a Set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.Map: java.util.Map.merge	(	K	V	BiFunction	):  If the specified key is not already associated with a value or is associated with null, associates it with the given non-null value. Otherwise, replaces the associated value with the results of the given remapping function, or removes if the result is null. This method may be of use when combining multiple mapped values for a key. For example, to either create or append a String msg to a value mapping:  map.merge(key, msg, String::concat) If the function returns null the mapping is removed. If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.
java.util.Map: java.util.Map.put	(	K	V	):  Associates the specified value with the specified key in this map (optional operation). If the map previously contained a mapping for the key, the old value is replaced by the specified value. (A map m is said to contain a mapping for a key k if and only if containsKey() m.containsKey(k) would return true.)
java.util.Map: java.util.Map.putAll	(	Map	):  Copies all of the mappings from the specified map to this map (optional operation). The effect of this call is equivalent to that of calling put() put(k, v) on this map once for each mapping from key k to value v in the specified map. The behavior of this operation is undefined if the specified map is modified while the operation is in progress.
java.util.Map: java.util.Map.putIfAbsent	(	K	V	):  If the specified key is not already associated with a value (or is mapped to null) associates it with the given value and returns null, else returns the current value.
java.util.Map: java.util.Map.remove	(	Object	):  Removes the mapping for a key from this map if it is present (optional operation). More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. If this map permits null values, then a return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.
java.util.Map: java.util.Map.remove	(	Object	Object	):  Removes the entry for the specified key only if it is currently mapped to the specified value.
java.util.Map: java.util.Map.replace	(	K	V	):  Replaces the entry for the specified key only if it is currently mapped to some value.
java.util.Map: java.util.Map.replace	(	K	V	V	):  Replaces the entry for the specified key only if currently mapped to the specified value.
java.util.Map: java.util.Map.replaceAll	(	BiFunction	):  Replaces each entry's value with the result of invoking the given function on that entry until all entries have been processed or the function throws an exception. Exceptions thrown by the function are relayed to the caller.
java.util.Map: java.util.Map.size	(	):  Returns the number of key-value mappings in this map. If the map contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
java.util.Map: java.util.Map.values	(	):  Returns a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.Random: java.util.Random:  An instance of this class is used to generate a stream of pseudorandom numbers. The class uses a 48-bit seed, which is modified using a linear congruential formula. (See Donald Knuth, The Art of Computer Programming, Volume 2, Section 3.2.1.)  If two instances of Random are created with the same seed, and the same sequence of method calls is made for each, they will generate and return identical sequences of numbers. In order to guarantee this property, particular algorithms are specified for the class Random. Java implementations must use all the algorithms shown here for the class Random, for the sake of absolute portability of Java code. However, subclasses of class Random are permitted to use other algorithms, so long as they adhere to the general contracts for all the methods.  The algorithms implemented by class Random use a protected utility method that on each invocation can supply up to 32 pseudorandomly generated bits.  Many applications will find the method random simpler to use. Instances of java.util.Random are threadsafe. However, the concurrent use of the same java.util.Random instance across threads may encounter contention and consequent poor performance. Consider instead using java.util.concurrent.ThreadLocalRandom in multithreaded designs. Instances of java.util.Random are not cryptographically secure. Consider instead using java.security.SecureRandom to get a cryptographically secure pseudo-random number generator for use by security-sensitive applications.
java.util.Random: java.util.Random.Random	(	):  Creates a new random number generator. This constructor sets the seed of the random number generator to a value very likely to be distinct from any other invocation of this constructor.
java.util.Random: java.util.Random.Random	(	long	):  Creates a new random number generator using a single long seed. The seed is the initial value of the internal state of the pseudorandom number generator which is maintained by method next. The invocation new Random(seed) is equivalent to:  Random rnd = new Random(); rnd.setSeed(seed);
java.util.Random: java.util.Random.RandomDoublesSpliterator:  Spliterator for double streams.
java.util.Random: java.util.Random.RandomIntsSpliterator:  Spliterator for int streams. We multiplex the four int versions into one class by treating a bound less than origin as unbounded, and also by treating "infinite" as equivalent to Long.MAX_VALUE. For splits, it uses the standard divide-by-two approach. The long and double versions of this class are identical except for types.
java.util.Random: java.util.Random.RandomLongsSpliterator:  Spliterator for long streams.
java.util.Random: java.util.Random.doubles	(	):  Returns an effectively unlimited stream of pseudorandom double values, each between zero (inclusive) and one (exclusive). A pseudorandom double value is generated as if it's the result of calling the method nextDouble().
java.util.Random: java.util.Random.doubles	(	double	double	):  Returns an effectively unlimited stream of pseudorandom double values, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom double value is generated as if it's the result of calling the following method with the origin and bound:  double nextDouble(double origin, double bound) double r = nextDouble(); r = r * (bound - origin) + origin; if (r >= bound) // correct for rounding r = Math.nextDown(bound); return r; }}
java.util.Random: java.util.Random.doubles	(	long	):  Returns a stream producing the given streamSize number of pseudorandom double values, each between zero (inclusive) and one (exclusive). A pseudorandom double value is generated as if it's the result of calling the method nextDouble().
java.util.Random: java.util.Random.doubles	(	long	double	double	):  Returns a stream producing the given streamSize number of pseudorandom double values, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom double value is generated as if it's the result of calling the following method with the origin and bound:  double nextDouble(double origin, double bound) double r = nextDouble(); r = r * (bound - origin) + origin; if (r >= bound) // correct for rounding r = Math.nextDown(bound); return r; }}
java.util.Random: java.util.Random.internalNextDouble	(	double	double	):  The form of nextDouble used by DoubleStream Spliterators.
java.util.Random: java.util.Random.internalNextInt	(	int	int	):  The form of nextInt used by IntStream Spliterators. For the unbounded case: uses nextInt(). For the bounded case with representable range: uses nextInt(int bound) For the bounded case with unrepresentable range: uses nextInt()
java.util.Random: java.util.Random.internalNextLong	(	long	long	):  The form of nextLong used by LongStream Spliterators. If origin is greater than bound, acts as unbounded form of nextLong, else as bounded form.
java.util.Random: java.util.Random.ints	(	):  Returns an effectively unlimited stream of pseudorandom int values. A pseudorandom int value is generated as if it's the result of calling the method nextInt().
java.util.Random: java.util.Random.ints	(	int	int	):  Returns an effectively unlimited stream of pseudorandom int values, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom int value is generated as if it's the result of calling the following method with the origin and bound:  int nextInt(int origin, int bound) int n = bound - origin; if (n > 0) { return nextInt(n) + origin; } else { // range not representable as int int r; do { r = nextInt(); } while (r < origin || r >= bound); return r; } }}
java.util.Random: java.util.Random.ints	(	long	):  Returns a stream producing the given streamSize number of pseudorandom int values. A pseudorandom int value is generated as if it's the result of calling the method nextInt().
java.util.Random: java.util.Random.ints	(	long	int	int	):  Returns a stream producing the given streamSize number of pseudorandom int values, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom int value is generated as if it's the result of calling the following method with the origin and bound:  int nextInt(int origin, int bound) int n = bound - origin; if (n > 0) { return nextInt(n) + origin; } else { // range not representable as int int r; do { r = nextInt(); } while (r < origin || r >= bound); return r; } }}
java.util.Random: java.util.Random.longs	(	):  Returns an effectively unlimited stream of pseudorandom long values. A pseudorandom long value is generated as if it's the result of calling the method nextLong().
java.util.Random: java.util.Random.longs	(	long	):  Returns a stream producing the given streamSize number of pseudorandom long values. A pseudorandom long value is generated as if it's the result of calling the method nextLong().
java.util.Random: java.util.Random.longs	(	long	long	):  Returns an effectively unlimited stream of pseudorandom long values, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom long value is generated as if it's the result of calling the following method with the origin and bound:  long nextLong(long origin, long bound) long r = nextLong(); long n = bound - origin, m = n - 1; if ((n & m) == 0L) // power of two r = (r & m) + origin; else if (n > 0L) { // reject over-represented candidates for (long u = r >>> 1; // ensure nonnegative u + m - (r = u % n) < 0L; // rejection check u = nextLong() >>> 1) // retry ; r += origin; } else { // range not representable as long while (r < origin || r >= bound) r = nextLong(); } return r; }}
java.util.Random: java.util.Random.longs	(	long	long	long	):  Returns a stream producing the given streamSize number of pseudorandom long, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom long value is generated as if it's the result of calling the following method with the origin and bound:  long nextLong(long origin, long bound) long r = nextLong(); long n = bound - origin, m = n - 1; if ((n & m) == 0L) // power of two r = (r & m) + origin; else if (n > 0L) { // reject over-represented candidates for (long u = r >>> 1; // ensure nonnegative u + m - (r = u % n) < 0L; // rejection check u = nextLong() >>> 1) // retry ; r += origin; } else { // range not representable as long while (r < origin || r >= bound) r = nextLong(); } return r; }}
java.util.Random: java.util.Random.next	(	int	):  Generates the next pseudorandom number. Subclasses should override this, as this is used by all other methods. The general contract of next is that it returns an int value and if the argument bits is between 1 and 32 (inclusive), then that many low-order bits of the returned value will be (approximately) independently chosen bit values, each of which is (approximately) equally likely to be 0 or 1. The method next is implemented by class Random by atomically updating the seed to (seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1) and returning (int)(seed >>> (48 - bits)). This is a linear congruential pseudorandom number generator, as defined by D. H. Lehmer and described by Donald E. Knuth in The Art of Computer Programming, Volume 3: Seminumerical Algorithms, section 3.2.1.
java.util.Random: java.util.Random.nextBoolean	(	):  Returns the next pseudorandom, uniformly distributed boolean value from this random number generator's sequence. The general contract of nextBoolean is that one boolean value is pseudorandomly generated and returned. The values true and false are produced with (approximately) equal probability. The method nextBoolean is implemented by class Random as if by:  public boolean nextBoolean() return next(1) != 0; }}
java.util.Random: java.util.Random.nextBytes	(	byte[]	):  Generates random bytes and places them into a user-supplied byte array. The number of random bytes produced is equal to the length of the byte array. The method nextBytes is implemented by class Random as if by:  public void nextBytes(byte[] bytes) for (int i = 0; i < bytes.length; ) for (int rnd = nextInt(), n = Math.min(bytes.length - i, 4); n-- > 0; rnd >>= 8) bytes[i++] = (byte)rnd; }}
java.util.Random: java.util.Random.nextDouble	(	):  Returns the next pseudorandom, uniformly distributed double value between 0.0 and 1.0 from this random number generator's sequence. The general contract of nextDouble is that one double value, chosen (approximately) uniformly from the range 0.0d (inclusive) to 1.0d (exclusive), is pseudorandomly generated and returned. The method nextDouble is implemented by class Random as if by:  public double nextDouble() return (((long)next(26) << 27) + next(27)) / (double)(1L << 53); }} The hedge "approximately" is used in the foregoing description only because the next method is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm shown would choose double values from the stated range with perfect uniformity. [In early versions of Java, the result was incorrectly calculated as:  return (((long)next(27) << 27) + next(27)) / (double)(1L << 54); This might seem to be equivalent, if not better, but in fact it introduced a large nonuniformity because of the bias in the rounding of floating-point numbers: it was three times as likely that the low-order bit of the significand would be 0 than that it would be 1! This nonuniformity probably doesn't matter much in practice, but we strive for perfection.]
java.util.Random: java.util.Random.nextFloat	(	):  Returns the next pseudorandom, uniformly distributed float value between 0.0 and 1.0 from this random number generator's sequence. The general contract of nextFloat is that one float value, chosen (approximately) uniformly from the range 0.0f (inclusive) to 1.0f (exclusive), is pseudorandomly generated and returned. All 224 possible float values of the form m x 2-24, where m is a positive integer less than 224, are produced with (approximately) equal probability. The method nextFloat is implemented by class Random as if by:  public float nextFloat() return next(24) / ((float)(1 << 24)); }} The hedge "approximately" is used in the foregoing description only because the next method is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm shown would choose float values from the stated range with perfect uniformity. [In early versions of Java, the result was incorrectly calculated as:  return next(30) / ((float)(1 << 30)); This might seem to be equivalent, if not better, but in fact it introduced a slight nonuniformity because of the bias in the rounding of floating-point numbers: it was slightly more likely that the low-order bit of the significand would be 0 than that it would be 1.]
java.util.Random: java.util.Random.nextGaussian	(	):  Returns the next pseudorandom, Gaussian ("normally") distributed double value with mean 0.0 and standard deviation 1.0 from this random number generator's sequence.  The general contract of nextGaussian is that one double value, chosen from (approximately) the usual normal distribution with mean 0.0 and standard deviation 1.0, is pseudorandomly generated and returned. The method nextGaussian is implemented by class Random as if by a threadsafe version of the following:  private double nextNextGaussian; private boolean haveNextNextGaussian = false; public double nextGaussian() if (haveNextNextGaussian) { haveNextNextGaussian = false; return nextNextGaussian; } else { double v1, v2, s; do { v1 = 2 * nextDouble() - 1; // between -1.0 and 1.0 v2 = 2 * nextDouble() - 1; // between -1.0 and 1.0 s = v1 * v1 + v2 * v2; } while (s >= 1 || s == 0); double multiplier = StrictMath.sqrt(-2 * StrictMath.log(s)/s); nextNextGaussian = v2 * multiplier; haveNextNextGaussian = true; return v1 * multiplier; } }} This uses the polar method of G. E. P. Box, M. E. Muller, and G. Marsaglia, as described by Donald E. Knuth in The Art of Computer Programming, Volume 3: Seminumerical Algorithms, section 3.4.1, subsection C, algorithm P. Note that it generates two independent values at the cost of only one call to StrictMath.log and one call to StrictMath.sqrt.
java.util.Random: java.util.Random.nextInt	(	):  Returns the next pseudorandom, uniformly distributed int value from this random number generator's sequence. The general contract of nextInt is that one int value is pseudorandomly generated and returned. All 232 possible int values are produced with (approximately) equal probability. The method nextInt is implemented by class Random as if by:  public int nextInt() return next(32); }}
java.util.Random: java.util.Random.nextInt	(	int	):  Returns a pseudorandom, uniformly distributed int value between 0 (inclusive) and the specified value (exclusive), drawn from this random number generator's sequence. The general contract of nextInt is that one int value in the specified range is pseudorandomly generated and returned. All bound possible int values are produced with (approximately) equal probability. The method nextInt(int bound) is implemented by class Random as if by:  public int nextInt(int bound) if (bound <= 0) throw new IllegalArgumentException("bound must be positive"); if ((bound & -bound) == bound) // i.e., bound is a power of 2 return (int)((bound * (long)next(31)) >> 31); int bits, val; do { bits = next(31); val = bits % bound; } while (bits - val + (bound-1) < 0); return val; }} The hedge "approximately" is used in the foregoing description only because the next method is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm shown would choose int values from the stated range with perfect uniformity.  The algorithm is slightly tricky. It rejects values that would result in an uneven distribution (due to the fact that 2^31 is not divisible by n). The probability of a value being rejected depends on n. The worst case is n=2^30+1, for which the probability of a reject is 1/2, and the expected number of iterations before the loop terminates is 2.  The algorithm treats the case where n is a power of two specially: it returns the correct number of high-order bits from the underlying pseudo-random number generator. In the absence of special treatment, the correct number of low-order bits would be returned. Linear congruential pseudo-random number generators such as the one implemented by this class are known to have short periods in the sequence of values of their low-order bits. Thus, this special case greatly increases the length of the sequence of values returned by successive calls to this method if n is a small power of two.
java.util.Random: java.util.Random.nextLong	(	):  Returns the next pseudorandom, uniformly distributed long value from this random number generator's sequence. The general contract of nextLong is that one long value is pseudorandomly generated and returned. The method nextLong is implemented by class Random as if by:  public long nextLong() return ((long)next(32) << 32) + next(32); }} Because class Random uses a seed with only 48 bits, this algorithm will not return all possible long values.
java.util.Random: java.util.Random.readObject	(	java.io.ObjectInputStream	):  Reconstitute the Random instance from a stream (that is, deserialize it).
java.util.Random: java.util.Random.setSeed	(	long	):  Sets the seed of this random number generator using a single long seed. The general contract of setSeed is that it alters the state of this random number generator object so as to be in exactly the same state as if it had just been created with the argument seed as a seed. The method setSeed is implemented by class Random by atomically updating the seed to (seed ^ 0x5DEECE66DL) & ((1L << 48) - 1) and clearing the haveNextNextGaussian flag used by nextGaussian. The implementation of setSeed by class Random happens to use only 48 bits of the given seed. In general, however, an overriding method may use all 64 bits of the long argument as a seed value.
java.util.Random: java.util.Random.writeObject	(	ObjectOutputStream	):  Save the Random instance to a stream.
java.util.ArrayList: java.util.ArrayList:  Resizable-array implementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to Vector, except that it is unsynchronized.) The size, isEmpty, get, set, iterator, and listIterator operations run in constant time. The add operation runs in amortized constant time, that is, adding n elements requires O(n) time. All of the other operations run in linear time (roughly speaking). The constant factor is low compared to that for the LinkedList implementation. Each ArrayList instance has a capacity. The capacity is the size of the array used to store the elements in the list. It is always at least as large as the list size. As elements are added to an ArrayList, its capacity grows automatically. The details of the growth policy are not specified beyond the fact that adding an element has constant amortized time cost. An application can increase the capacity of an ArrayList instance before adding a large number of elements using the ensureCapacity operation. This may reduce the amount of incremental reallocation. Note that this implementation is not synchronized. If multiple threads access an ArrayList instance concurrently, and at least one of the threads modifies the list structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more elements, or explicitly resizes the backing array; merely setting the value of an element is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the list. If no such object exists, the list should be "wrapped" using the synchronizedList Collections.synchronizedList method. This is best done at creation time, to prevent accidental unsynchronized access to the list: List list = Collections.synchronizedList(new ArrayList(...));  The iterators returned by this class's iterator() and listIterator() methods are fail-fast: if the list is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove() or add() methods, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. This class is a member of the  Java Collections Framework.
java.util.ArrayList: java.util.ArrayList.ArrayList	(	):  Constructs an empty list with an initial capacity of ten.
java.util.ArrayList: java.util.ArrayList.ArrayList	(	Collection	):  Constructs a list containing the elements of the specified collection, in the order they are returned by the collection's iterator.
java.util.ArrayList: java.util.ArrayList.ArrayList	(	int	):  Constructs an empty list with the specified initial capacity.
java.util.ArrayList: java.util.ArrayList.ArrayListSpliterator:  Index-based split-by-two, lazily initialized Spliterator 
java.util.ArrayList: java.util.ArrayList.ArrayListSpliterator.ArrayListSpliterator	(	ArrayList	int	int	int	):  Create new spliterator covering the given range 
java.util.ArrayList: java.util.ArrayList.Itr:  An optimized version of AbstractList.Itr
java.util.ArrayList: java.util.ArrayList.ListItr:  An optimized version of AbstractList.ListItr
java.util.ArrayList: java.util.ArrayList.add	(	E	):  Appends the specified element to the end of this list.
java.util.ArrayList: java.util.ArrayList.add	(	int	E	):  Inserts the specified element at the specified position in this list. Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices).
java.util.ArrayList: java.util.ArrayList.addAll	(	Collection	):  Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's Iterator. The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (This implies that the behavior of this call is undefined if the specified collection is this list, and this list is nonempty.)
java.util.ArrayList: java.util.ArrayList.addAll	(	int	Collection	):  Inserts all of the elements in the specified collection into this list, starting at the specified position. Shifts the element currently at that position (if any) and any subsequent elements to the right (increases their indices). The new elements will appear in the list in the order that they are returned by the specified collection's iterator.
java.util.ArrayList: java.util.ArrayList.clear	(	):  Removes all of the elements from this list. The list will be empty after this call returns.
java.util.ArrayList: java.util.ArrayList.clone	(	):  Returns a shallow copy of this ArrayList instance. (The elements themselves are not copied.)
java.util.ArrayList: java.util.ArrayList.contains	(	Object	):  Returns true if this list contains the specified element. More formally, returns true if and only if this list contains at least one element e such that (o==null ? e==null : o.equals(e)).
java.util.ArrayList: java.util.ArrayList.ensureCapacity	(	int	):  Increases the capacity of this ArrayList instance, if necessary, to ensure that it can hold at least the number of elements specified by the minimum capacity argument.
java.util.ArrayList: java.util.ArrayList.get	(	int	):  Returns the element at the specified position in this list.
java.util.ArrayList: java.util.ArrayList.grow	(	int	):  Increases the capacity to ensure that it can hold at least the number of elements specified by the minimum capacity argument.
java.util.ArrayList: java.util.ArrayList.indexOf	(	Object	):  Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.
java.util.ArrayList: java.util.ArrayList.isEmpty	(	):  Returns true if this list contains no elements.
java.util.ArrayList: java.util.ArrayList.iterator	(	):  Returns an iterator over the elements in this list in proper sequence. The returned iterator is fail-fast.
java.util.ArrayList: java.util.ArrayList.lastIndexOf	(	Object	):  Returns the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the highest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.
java.util.ArrayList: java.util.ArrayList.listIterator	(	):  Returns a list iterator over the elements in this list (in proper sequence). The returned list iterator is fail-fast.
java.util.ArrayList: java.util.ArrayList.listIterator	(	int	):  Returns a list iterator over the elements in this list (in proper sequence), starting at the specified position in the list. The specified index indicates the first element that would be returned by an initial call to next. An initial call to previous would return the element with the specified index minus one. The returned list iterator is fail-fast.
java.util.ArrayList: java.util.ArrayList.outOfBoundsMsg	(	int	):  Constructs an IndexOutOfBoundsException detail message. Of the many possible refactorings of the error handling code, this "outlining" performs best with both server and client VMs.
java.util.ArrayList: java.util.ArrayList.rangeCheck	(	int	):  Checks if the given index is in range. If not, throws an appropriate runtime exception. This method does *not* check if the index is negative: It is always used immediately prior to an array access, which throws an ArrayIndexOutOfBoundsException if index is negative.
java.util.ArrayList: java.util.ArrayList.rangeCheckForAdd	(	int	):  A version of rangeCheck used by add and addAll.
java.util.ArrayList: java.util.ArrayList.readObject	(	java.io.ObjectInputStream	):  Reconstitute the ArrayList instance from a stream (that is, deserialize it).
java.util.ArrayList: java.util.ArrayList.remove	(	Object	):  Removes the first occurrence of the specified element from this list, if it is present. If the list does not contain the element, it is unchanged. More formally, removes the element with the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))) (if such an element exists). Returns true if this list contained the specified element (or equivalently, if this list changed as a result of the call).
java.util.ArrayList: java.util.ArrayList.remove	(	int	):  Removes the element at the specified position in this list. Shifts any subsequent elements to the left (subtracts one from their indices).
java.util.ArrayList: java.util.ArrayList.removeAll	(	Collection	):  Removes from this list all of its elements that are contained in the specified collection.
java.util.ArrayList: java.util.ArrayList.removeRange	(	int	int	):  Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive. Shifts any succeeding elements to the left (reduces their index). This call shortens the list by (toIndex - fromIndex) elements. (If toIndex==fromIndex, this operation has no effect.)
java.util.ArrayList: java.util.ArrayList.retainAll	(	Collection	):  Retains only the elements in this list that are contained in the specified collection. In other words, removes from this list all of its elements that are not contained in the specified collection.
java.util.ArrayList: java.util.ArrayList.set	(	int	E	):  Replaces the element at the specified position in this list with the specified element.
java.util.ArrayList: java.util.ArrayList.size	(	):  Returns the number of elements in this list.
java.util.ArrayList: java.util.ArrayList.spliterator	(	):  Creates a late-binding and fail-fast Spliterator over the elements in this list. The Spliterator reports SIZED, SUBSIZED, and ORDERED. Overriding implementations should document the reporting of additional characteristic values.
java.util.ArrayList: java.util.ArrayList.subList	(	int	int	):  Returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive. (If fromIndex and toIndex are equal, the returned list is empty.) The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa. The returned list supports all of the optional list operations. This method eliminates the need for explicit range operations (of the sort that commonly exist for arrays). Any operation that expects a list can be used as a range operation by passing a subList view instead of a whole list. For example, the following idiom removes a range of elements from a list:  list.subList(from, to).clear();  Similar idioms may be constructed for indexOf() and lastIndexOf(), and all of the algorithms in the Collections class can be applied to a subList. The semantics of the list returned by this method become undefined if the backing list (i.e., this list) is structurally modified in any way other than via the returned list. (Structural modifications are those that change the size of this list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.)
java.util.ArrayList: java.util.ArrayList.toArray	(	):  Returns an array containing all of the elements in this list in proper sequence (from first to last element). The returned array will be "safe" in that no references to it are maintained by this list. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.ArrayList: java.util.ArrayList.toArray	(	T[]	):  Returns an array containing all of the elements in this list in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array. If the list fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this list. If the list fits in the specified array with room to spare (i.e., the array has more elements than the list), the element in the array immediately following the end of the collection is set to null. (This is useful in determining the length of the list only if the caller knows that the list does not contain any null elements.)
java.util.ArrayList: java.util.ArrayList.trimToSize	(	):  Trims the capacity of this ArrayList instance to be the list's current size. An application can use this operation to minimize the storage of an ArrayList instance.
java.util.ArrayList: java.util.ArrayList.writeObject	(	java.io.ObjectOutputStream	):  Save the state of the ArrayList instance to a stream (that is, serialize it).
java.util.HashMap: java.util.HashMap:  Hash table based implementation of the Map interface. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time. This implementation provides constant-time performance for the basic operations (get and put), assuming the hash function disperses the elements properly among the buckets. Iteration over collection views requires time proportional to the "capacity" of the HashMap instance (the number of buckets) plus its size (the number of key-value mappings). Thus, it's very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important. An instance of HashMap has two parameters that affect its performance: initial capacity and load factor. The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased. When the number of entries in the hash table exceeds the product of the load factor and the current capacity, the hash table is rehashed (that is, internal data structures are rebuilt) so that the hash table has approximately twice the number of buckets. As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the HashMap class, including get and put). The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations. If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur. If many mappings are to be stored in a HashMap instance, creating it with a sufficiently large capacity will allow the mappings to be stored more efficiently than letting it perform automatic rehashing as needed to grow the table. Note that using many keys with the same hashCode() is a sure way to slow down performance of any hash table. To ameliorate impact, when keys are Comparable, this class may use comparison order among keys to help break ties. Note that this implementation is not synchronized. If multiple threads access a hash map concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more mappings; merely changing the value associated with a key that an instance already contains is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the map. If no such object exists, the map should be "wrapped" using the synchronizedMap Collections.synchronizedMap method. This is best done at creation time, to prevent accidental unsynchronized access to the map: Map m = Collections.synchronizedMap(new HashMap(...)); The iterators returned by all of this class's "collection view methods" are fail-fast: if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. This class is a member of the  Java Collections Framework.
java.util.HashMap: java.util.HashMap.HashMap	(	):  Constructs an empty HashMap with the default initial capacity (16) and the default load factor (0.75).
java.util.HashMap: java.util.HashMap.HashMap	(	Map	):  Constructs a new HashMap with the same mappings as the specified Map. The HashMap is created with default load factor (0.75) and an initial capacity sufficient to hold the mappings in the specified Map.
java.util.HashMap: java.util.HashMap.HashMap	(	int	):  Constructs an empty HashMap with the specified initial capacity and the default load factor (0.75).
java.util.HashMap: java.util.HashMap.HashMap	(	int	float	):  Constructs an empty HashMap with the specified initial capacity and load factor.
java.util.HashMap: java.util.HashMap.Node:  Basic hash bin node, used for most entries. (See below for TreeNode subclass, and in LinkedHashMap for its Entry subclass.)
java.util.HashMap: java.util.HashMap.TreeNode:  Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn extends Node) so can be used as extension of either regular or linked node.
java.util.HashMap: java.util.HashMap.TreeNode.checkInvariants	(	TreeNode	):  Recursive invariant check
java.util.HashMap: java.util.HashMap.TreeNode.find	(	int	Object	Class	):  Finds the node starting at root p with the given hash and key. The kc argument caches comparableClassFor(key) upon first use comparing keys.
java.util.HashMap: java.util.HashMap.TreeNode.getTreeNode	(	int	Object	):  Calls find for root node.
java.util.HashMap: java.util.HashMap.TreeNode.moveRootToFront	(	Node[]	TreeNode	):  Ensures that the given root is the first node of its bin.
java.util.HashMap: java.util.HashMap.TreeNode.putTreeVal	(	HashMap	Node[]	int	K	V	):  Tree version of putVal.
java.util.HashMap: java.util.HashMap.TreeNode.removeTreeNode	(	HashMap	Node[]	boolean	):  Removes the given node, that must be present before this call. This is messier than typical red-black deletion code because we cannot swap the contents of an interior node with a leaf successor that is pinned by "next" pointers that are accessible independently during traversal. So instead we swap the tree linkages. If the current tree appears to have too few nodes, the bin is converted back to a plain bin. (The test triggers somewhere between 2 and 6 nodes, depending on tree structure).
java.util.HashMap: java.util.HashMap.TreeNode.root	(	):  Returns root of tree containing this node.
java.util.HashMap: java.util.HashMap.TreeNode.split	(	HashMap	Node[]	int	int	):  Splits nodes in a tree bin into lower and upper tree bins, or untreeifies if now too small. Called only from resize; see above discussion about split bits and indices.
java.util.HashMap: java.util.HashMap.TreeNode.tieBreakOrder	(	Object	Object	):  Tie-breaking utility for ordering insertions when equal hashCodes and non-comparable. We don't require a total order, just a consistent insertion rule to maintain equivalence across rebalancings. Tie-breaking further than necessary simplifies testing a bit.
java.util.HashMap: java.util.HashMap.TreeNode.treeify	(	Node[]	):  Forms tree of the nodes linked from this node.
java.util.HashMap: java.util.HashMap.TreeNode.untreeify	(	HashMap	):  Returns a list of non-TreeNodes replacing those linked from this node.
java.util.HashMap: java.util.HashMap.clear	(	):  Removes all of the mappings from this map. The map will be empty after this call returns.
java.util.HashMap: java.util.HashMap.clone	(	):  Returns a shallow copy of this HashMap instance: the keys and values themselves are not cloned.
java.util.HashMap: java.util.HashMap.comparableClassFor	(	Object	):  Returns x's Class if it is of the form "class C implements Comparable", else null.
java.util.HashMap: java.util.HashMap.compareComparables	(	Class	Object	Object	):  Returns k.compareTo(x) if x matches kc (k's screened comparable class), else 0.
java.util.HashMap: java.util.HashMap.containsKey	(	Object	):  Returns true if this map contains a mapping for the specified key.
java.util.HashMap: java.util.HashMap.containsValue	(	Object	):  Returns true if this map maps one or more keys to the specified value.
java.util.HashMap: java.util.HashMap.entrySet	(	):  Returns a Set view of the mappings contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation, or through the setValue operation on a map entry returned by the iterator) the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.HashMap: java.util.HashMap.get	(	Object	):  Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that (key==null ? k==null : key.equals(k)), then this method returns v; otherwise it returns null. (There can be at most one such mapping.) A return value of null does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to null. The containsKey operation may be used to distinguish these two cases.
java.util.HashMap: java.util.HashMap.getNode	(	int	Object	):  Implements Map.get and related methods
java.util.HashMap: java.util.HashMap.hash	(	Object	):  Computes key.hashCode() and spreads (XORs) higher bits of hash to lower. Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.) So we apply a transform that spreads the impact of higher bits downward. There is a tradeoff between speed, utility, and quality of bit-spreading. Because many common sets of hashes are already reasonably distributed (so don't benefit from spreading), and because we use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds.
java.util.HashMap: java.util.HashMap.isEmpty	(	):  Returns true if this map contains no key-value mappings.
java.util.HashMap: java.util.HashMap.keySet	(	):  Returns a Set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.HashMap: java.util.HashMap.put	(	K	V	):  Associates the specified value with the specified key in this map. If the map previously contained a mapping for the key, the old value is replaced.
java.util.HashMap: java.util.HashMap.putAll	(	Map	):  Copies all of the mappings from the specified map to this map. These mappings will replace any mappings that this map had for any of the keys currently in the specified map.
java.util.HashMap: java.util.HashMap.putMapEntries	(	Map	boolean	):  Implements Map.putAll and Map constructor
java.util.HashMap: java.util.HashMap.putVal	(	int	K	V	boolean	boolean	):  Implements Map.put and related methods
java.util.HashMap: java.util.HashMap.readObject	(	java.io.ObjectInputStream	):  Reconstitute the HashMap instance from a stream (i.e., deserialize it).
java.util.HashMap: java.util.HashMap.reinitialize	(	):  Reset to initial default state. Called by clone and readObject.
java.util.HashMap: java.util.HashMap.remove	(	Object	):  Removes the mapping for the specified key from this map if present.
java.util.HashMap: java.util.HashMap.removeNode	(	int	Object	Object	boolean	boolean	):  Implements Map.remove and related methods
java.util.HashMap: java.util.HashMap.resize	(	):  Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table.
java.util.HashMap: java.util.HashMap.size	(	):  Returns the number of key-value mappings in this map.
java.util.HashMap: java.util.HashMap.tableSizeFor	(	int	):  Returns a power of two size for the given target capacity.
java.util.HashMap: java.util.HashMap.treeifyBin	(	Node[]	int	):  Replaces all linked nodes in bin at index for given hash unless table is too small, in which case resizes instead.
java.util.HashMap: java.util.HashMap.values	(	):  Returns a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.HashMap: java.util.HashMap.writeObject	(	java.io.ObjectOutputStream	):  Save the state of the HashMap instance to a stream (i.e., serialize it).
java.util.Arrays: java.util.Arrays:  This class contains various methods for manipulating arrays (such as sorting and searching). This class also contains a static factory that allows arrays to be viewed as lists. The methods in this class all throw a NullPointerException, if the specified array reference is null, except where noted. The documentation for the methods contained in this class includes briefs description of the implementations. Such descriptions should be regarded as implementation notes, rather than parts of the specification. Implementors should feel free to substitute other algorithms, so long as the specification itself is adhered to. (For example, the algorithm used by sort(Object[]) does not have to be a MergeSort, but it does have to be stable.) This class is a member of the  Java Collections Framework.
java.util.Arrays: java.util.Arrays.LegacyMergeSort:  Old merge sort implementation can be selected (for compatibility with broken comparators) using a system property. Cannot be a static boolean in the enclosing class due to circular dependencies. To be removed in a future release.
java.util.Arrays: java.util.Arrays.NaturalOrder:  A comparator that implements the natural ordering of a group of mutually comparable elements. May be used when a supplied comparator is null. To simplify code-sharing within underlying implementations, the compare method only declares type Object for its second argument. Arrays class implementor's note: It is an empirical matter whether ComparableTimSort offers any performance benefit over TimSort used with this comparator. If not, you are better off deleting or bypassing ComparableTimSort. There is currently no empirical case for separating them for parallel sorting, so all public Object parallelSort methods use the same comparator based implementation.
java.util.Arrays: java.util.Arrays.asList	(	T	):  Returns a fixed-size list backed by the specified array. (Changes to the returned list "write through" to the array.) This method acts as bridge between array-based and collection-based APIs, in combination with toArray. The returned list is serializable and implements RandomAccess. This method also provides a convenient way to create a fixed-size list initialized to contain several elements:  List<String> stooges = Arrays.asList("Larry", "Moe", "Curly"); 
java.util.Arrays: java.util.Arrays.binarySearch	(	Object[]	Object	):  Searches the specified array for the specified object using the binary search algorithm. The array must be sorted into ascending order according to the Comparable natural ordering of its elements (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. (If the array contains elements that are not mutually comparable (for example, strings and integers), it cannot be sorted according to the natural ordering of its elements, hence results are undefined.) If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found.
java.util.Arrays: java.util.Arrays.binarySearch	(	Object[]	int	int	Object	):  Searches a range of the specified array for the specified object using the binary search algorithm. The range must be sorted into ascending order according to the Comparable natural ordering of its elements (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. (If the range contains elements that are not mutually comparable (for example, strings and integers), it cannot be sorted according to the natural ordering of its elements, hence results are undefined.) If the range contains multiple elements equal to the specified object, there is no guarantee which one will be found.
java.util.Arrays: java.util.Arrays.binarySearch	(	T[]	T	Comparator	):  Searches the specified array for the specified object using the binary search algorithm. The array must be sorted into ascending order according to the specified comparator (as by the sort() sort(T[], Comparator) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found.
java.util.Arrays: java.util.Arrays.binarySearch	(	T[]	int	int	T	Comparator	):  Searches a range of the specified array for the specified object using the binary search algorithm. The range must be sorted into ascending order according to the specified comparator (as by the sort() sort(T[], int, int, Comparator) method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements equal to the specified object, there is no guarantee which one will be found.
java.util.Arrays: java.util.Arrays.binarySearch	(	byte[]	byte	):  Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.
java.util.Arrays: java.util.Arrays.binarySearch	(	byte[]	int	int	byte	):  Searches a range of the specified array of bytes for the specified value using the binary search algorithm. The range must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.
java.util.Arrays: java.util.Arrays.binarySearch	(	char[]	char	):  Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.
java.util.Arrays: java.util.Arrays.binarySearch	(	char[]	int	int	char	):  Searches a range of the specified array of chars for the specified value using the binary search algorithm. The range must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.
java.util.Arrays: java.util.Arrays.binarySearch	(	double[]	double	):  Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.
java.util.Arrays: java.util.Arrays.binarySearch	(	double[]	int	int	double	):  Searches a range of the specified array of doubles for the specified value using the binary search algorithm. The range must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.
java.util.Arrays: java.util.Arrays.binarySearch	(	float[]	float	):  Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.
java.util.Arrays: java.util.Arrays.binarySearch	(	float[]	int	int	float	):  Searches a range of the specified array of floats for the specified value using the binary search algorithm. The range must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.
java.util.Arrays: java.util.Arrays.binarySearch	(	int[]	int	):  Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.
java.util.Arrays: java.util.Arrays.binarySearch	(	int[]	int	int	int	):  Searches a range of the specified array of ints for the specified value using the binary search algorithm. The range must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.
java.util.Arrays: java.util.Arrays.binarySearch	(	long[]	int	int	long	):  Searches a range of the specified array of longs for the specified value using the binary search algorithm. The range must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.
java.util.Arrays: java.util.Arrays.binarySearch	(	long[]	long	):  Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.
java.util.Arrays: java.util.Arrays.binarySearch	(	short[]	int	int	short	):  Searches a range of the specified array of shorts for the specified value using the binary search algorithm. The range must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.
java.util.Arrays: java.util.Arrays.binarySearch	(	short[]	short	):  Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.
java.util.Arrays: java.util.Arrays.copyOf	(	T[]	int	):  Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain null. Such indices will exist if and only if the specified length is greater than that of the original array. The resulting array is of exactly the same class as the original array.
java.util.Arrays: java.util.Arrays.copyOf	(	U[]	int	Class	):  Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain null. Such indices will exist if and only if the specified length is greater than that of the original array. The resulting array is of the class newType.
java.util.Arrays: java.util.Arrays.copyOf	(	boolean[]	int	):  Copies the specified array, truncating or padding with false (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain false. Such indices will exist if and only if the specified length is greater than that of the original array.
java.util.Arrays: java.util.Arrays.copyOf	(	byte[]	int	):  Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain (byte)0. Such indices will exist if and only if the specified length is greater than that of the original array.
java.util.Arrays: java.util.Arrays.copyOf	(	char[]	int	):  Copies the specified array, truncating or padding with null characters (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain '\\u000'. Such indices will exist if and only if the specified length is greater than that of the original array.
java.util.Arrays: java.util.Arrays.copyOf	(	double[]	int	):  Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain 0d. Such indices will exist if and only if the specified length is greater than that of the original array.
java.util.Arrays: java.util.Arrays.copyOf	(	float[]	int	):  Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain 0f. Such indices will exist if and only if the specified length is greater than that of the original array.
java.util.Arrays: java.util.Arrays.copyOf	(	int[]	int	):  Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain 0. Such indices will exist if and only if the specified length is greater than that of the original array.
java.util.Arrays: java.util.Arrays.copyOf	(	long[]	int	):  Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain 0L. Such indices will exist if and only if the specified length is greater than that of the original array.
java.util.Arrays: java.util.Arrays.copyOf	(	short[]	int	):  Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain (short)0. Such indices will exist if and only if the specified length is greater than that of the original array.
java.util.Arrays: java.util.Arrays.copyOfRange	(	T[]	int	int	):  Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case null is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.  The resulting array is of exactly the same class as the original array.
java.util.Arrays: java.util.Arrays.copyOfRange	(	U[]	int	int	Class	):  Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case null is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from. The resulting array is of the class newType.
java.util.Arrays: java.util.Arrays.copyOfRange	(	boolean[]	int	int	):  Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case false is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.
java.util.Arrays: java.util.Arrays.copyOfRange	(	byte[]	int	int	):  Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case (byte)0 is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.
java.util.Arrays: java.util.Arrays.copyOfRange	(	char[]	int	int	):  Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case '\\u000' is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.
java.util.Arrays: java.util.Arrays.copyOfRange	(	double[]	int	int	):  Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case 0d is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.
java.util.Arrays: java.util.Arrays.copyOfRange	(	float[]	int	int	):  Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case 0f is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.
java.util.Arrays: java.util.Arrays.copyOfRange	(	int[]	int	int	):  Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case 0 is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.
java.util.Arrays: java.util.Arrays.copyOfRange	(	long[]	int	int	):  Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case 0L is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.
java.util.Arrays: java.util.Arrays.copyOfRange	(	short[]	int	int	):  Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case (short)0 is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.
java.util.Arrays: java.util.Arrays.deepEquals	(	Object[]	Object[]	):  Returns true if the two specified arrays are deeply equal to one another. Unlike the equals() method, this method is appropriate for use with nested arrays of arbitrary depth. Two array references are considered deeply equal if both are null, or if they refer to arrays that contain the same number of elements and all corresponding pairs of elements in the two arrays are deeply equal. Two possibly null elements e1 and e2 are deeply equal if any of the following conditions hold:   e1 and e2 are both arrays of object reference types, and Arrays.deepEquals(e1, e2) would return true  e1 and e2 are arrays of the same primitive type, and the appropriate overloading of Arrays.equals(e1, e2) would return true.  e1 == e2  e1.equals(e2) would return true.  Note that this definition permits null elements at any depth. If either of the specified arrays contain themselves as elements either directly or indirectly through one or more levels of arrays, the behavior of this method is undefined.
java.util.Arrays: java.util.Arrays.deepHashCode	(	Object	):  Returns a hash code based on the "deep contents" of the specified array. If the array contains other arrays as elements, the hash code is based on their contents and so on, ad infinitum. It is therefore unacceptable to invoke this method on an array that contains itself as an element, either directly or indirectly through one or more levels of arrays. The behavior of such an invocation is undefined. For any two arrays a and b such that Arrays.deepEquals(a, b), it is also the case that Arrays.deepHashCode(a) == Arrays.deepHashCode(b). The computation of the value returned by this method is similar to that of the value returned by hashCode() on a list containing the same elements as a in the same order, with one difference: If an element e of a is itself an array, its hash code is computed not by calling e.hashCode(), but as by calling the appropriate overloading of Arrays.hashCode(e) if e is an array of a primitive type, or as by calling Arrays.deepHashCode(e) recursively if e is an array of a reference type. If a is null, this method returns 0.
java.util.Arrays: java.util.Arrays.deepToString	(	Object[]	):  Returns a string representation of the "deep contents" of the specified array. If the array contains other arrays as elements, the string representation contains their contents and so on. This method is designed for converting multidimensional arrays to strings. The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Elements are converted to strings as by String.valueOf(Object), unless they are themselves arrays. If an element e is an array of a primitive type, it is converted to a string as by invoking the appropriate overloading of Arrays.toString(e). If an element e is an array of a reference type, it is converted to a string as by invoking this method recursively. To avoid infinite recursion, if the specified array contains itself as an element, or contains an indirect reference to itself through one or more levels of arrays, the self-reference is converted to the string "[...]". For example, an array containing only a reference to itself would be rendered as "[[...]]". This method returns "null" if the specified array is null.
java.util.Arrays: java.util.Arrays.equals	(	Object[]	Object[]	):  Returns true if the two specified arrays of Objects are equal to one another. The two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. Two objects e1 and e2 are considered equal if (e1==null ? e2==null : e1.equals(e2)). In other words, the two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.
java.util.Arrays: java.util.Arrays.equals	(	boolean[]	boolean[]	):  Returns true if the two specified arrays of booleans are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.
java.util.Arrays: java.util.Arrays.equals	(	byte[]	byte[]	):  Returns true if the two specified arrays of bytes are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.
java.util.Arrays: java.util.Arrays.equals	(	char[]	char[]	):  Returns true if the two specified arrays of chars are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.
java.util.Arrays: java.util.Arrays.equals	(	double[]	double[]	):  Returns true if the two specified arrays of doubles are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null. Two doubles d1 and d2 are considered equal if:  new Double(d1).equals(new Double(d2)) (Unlike the == operator, this method considers NaN equals to itself, and 0.0d unequal to -0.0d.)
java.util.Arrays: java.util.Arrays.equals	(	float[]	float[]	):  Returns true if the two specified arrays of floats are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null. Two floats f1 and f2 are considered equal if:  new Float(f1).equals(new Float(f2)) (Unlike the == operator, this method considers NaN equals to itself, and 0.0f unequal to -0.0f.)
java.util.Arrays: java.util.Arrays.equals	(	int[]	int[]	):  Returns true if the two specified arrays of ints are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.
java.util.Arrays: java.util.Arrays.equals	(	long[]	long[]	):  Returns true if the two specified arrays of longs are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.
java.util.Arrays: java.util.Arrays.equals	(	short[]	short	):  Returns true if the two specified arrays of shorts are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.
java.util.Arrays: java.util.Arrays.fill	(	Object[]	Object	):  Assigns the specified Object reference to each element of the specified array of Objects.
java.util.Arrays: java.util.Arrays.fill	(	Object[]	int	int	Object	):  Assigns the specified Object reference to each element of the specified range of the specified array of Objects. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)
java.util.Arrays: java.util.Arrays.fill	(	boolean[]	boolean	):  Assigns the specified boolean value to each element of the specified array of booleans.
java.util.Arrays: java.util.Arrays.fill	(	boolean[]	int	int	boolean	):  Assigns the specified boolean value to each element of the specified range of the specified array of booleans. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)
java.util.Arrays: java.util.Arrays.fill	(	byte[]	byte	):  Assigns the specified byte value to each element of the specified array of bytes.
java.util.Arrays: java.util.Arrays.fill	(	byte[]	int	int	byte	):  Assigns the specified byte value to each element of the specified range of the specified array of bytes. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)
java.util.Arrays: java.util.Arrays.fill	(	char[]	char	):  Assigns the specified char value to each element of the specified array of chars.
java.util.Arrays: java.util.Arrays.fill	(	char[]	int	int	char	):  Assigns the specified char value to each element of the specified range of the specified array of chars. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)
java.util.Arrays: java.util.Arrays.fill	(	double[]	double	):  Assigns the specified double value to each element of the specified array of doubles.
java.util.Arrays: java.util.Arrays.fill	(	double[]	int	int	double	):  Assigns the specified double value to each element of the specified range of the specified array of doubles. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)
java.util.Arrays: java.util.Arrays.fill	(	float[]	float	):  Assigns the specified float value to each element of the specified array of floats.
java.util.Arrays: java.util.Arrays.fill	(	float[]	int	int	float	):  Assigns the specified float value to each element of the specified range of the specified array of floats. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)
java.util.Arrays: java.util.Arrays.fill	(	int[]	int	):  Assigns the specified int value to each element of the specified array of ints.
java.util.Arrays: java.util.Arrays.fill	(	int[]	int	int	int	):  Assigns the specified int value to each element of the specified range of the specified array of ints. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)
java.util.Arrays: java.util.Arrays.fill	(	long[]	int	int	long	):  Assigns the specified long value to each element of the specified range of the specified array of longs. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)
java.util.Arrays: java.util.Arrays.fill	(	long[]	long	):  Assigns the specified long value to each element of the specified array of longs.
java.util.Arrays: java.util.Arrays.fill	(	short[]	int	int	short	):  Assigns the specified short value to each element of the specified range of the specified array of shorts. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)
java.util.Arrays: java.util.Arrays.fill	(	short[]	short	):  Assigns the specified short value to each element of the specified array of shorts.
java.util.Arrays: java.util.Arrays.hashCode	(	Object	):  Returns a hash code based on the contents of the specified array. If the array contains other arrays as elements, the hash code is based on their identities rather than their contents. It is therefore acceptable to invoke this method on an array that contains itself as an element, either directly or indirectly through one or more levels of arrays. For any two arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b). The value returned by this method is equal to the value that would be returned by Arrays.asList(a).hashCode(), unless a is null, in which case 0 is returned.
java.util.Arrays: java.util.Arrays.hashCode	(	boolean	):  Returns a hash code based on the contents of the specified array. For any two boolean arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode() hashCode method on a List containing a sequence of Boolean instances representing the elements of a in the same order. If a is null, this method returns 0.
java.util.Arrays: java.util.Arrays.hashCode	(	byte	):  Returns a hash code based on the contents of the specified array. For any two byte arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode() hashCode method on a List containing a sequence of Byte instances representing the elements of a in the same order. If a is null, this method returns 0.
java.util.Arrays: java.util.Arrays.hashCode	(	char	):  Returns a hash code based on the contents of the specified array. For any two char arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode() hashCode method on a List containing a sequence of Character instances representing the elements of a in the same order. If a is null, this method returns 0.
java.util.Arrays: java.util.Arrays.hashCode	(	double	):  Returns a hash code based on the contents of the specified array. For any two double arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode() hashCode method on a List containing a sequence of Double instances representing the elements of a in the same order. If a is null, this method returns 0.
java.util.Arrays: java.util.Arrays.hashCode	(	float	):  Returns a hash code based on the contents of the specified array. For any two float arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode() hashCode method on a List containing a sequence of Float instances representing the elements of a in the same order. If a is null, this method returns 0.
java.util.Arrays: java.util.Arrays.hashCode	(	int	):  Returns a hash code based on the contents of the specified array. For any two non-null int arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode() hashCode method on a List containing a sequence of Integer instances representing the elements of a in the same order. If a is null, this method returns 0.
java.util.Arrays: java.util.Arrays.hashCode	(	long	):  Returns a hash code based on the contents of the specified array. For any two long arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode() hashCode method on a List containing a sequence of Long instances representing the elements of a in the same order. If a is null, this method returns 0.
java.util.Arrays: java.util.Arrays.hashCode	(	short	):  Returns a hash code based on the contents of the specified array. For any two short arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode() hashCode method on a List containing a sequence of Short instances representing the elements of a in the same order. If a is null, this method returns 0.
java.util.Arrays: java.util.Arrays.legacyMergeSort	(	Object[]	):  To be removed in a future release. 
java.util.Arrays: java.util.Arrays.legacyMergeSort	(	Object[]	int	int	):  To be removed in a future release. 
java.util.Arrays: java.util.Arrays.legacyMergeSort	(	T[]	Comparator	):  To be removed in a future release. 
java.util.Arrays: java.util.Arrays.legacyMergeSort	(	T[]	int	int	Comparator	):  To be removed in a future release. 
java.util.Arrays: java.util.Arrays.mergeSort	(	Object[]	Object[]	int	int	int	):  Src is the source array that starts at index 0 Dest is the (possibly larger) array destination with a possible offset low is the index in dest to start sorting high is the end index in dest to end sorting off is the offset to generate corresponding low, high in src To be removed in a future release.
java.util.Arrays: java.util.Arrays.mergeSort	(	Object[]	Object[]	int	int	int	Comparator	):  Src is the source array that starts at index 0 Dest is the (possibly larger) array destination with a possible offset low is the index in dest to start sorting high is the end index in dest to end sorting off is the offset into src corresponding to low in dest To be removed in a future release.
java.util.Arrays: java.util.Arrays.parallelPrefix	(	T[]	BinaryOperator	):  Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds [2, 1, 0, 3] and the operation performs addition, then upon return the array holds [2, 3, 3, 6]. Parallel prefix computation is usually more efficient than sequential loops for large arrays.
java.util.Arrays: java.util.Arrays.parallelPrefix	(	T[]	int	int	BinaryOperator	):  Performs parallelPrefix() for the given subrange of the array.
java.util.Arrays: java.util.Arrays.parallelPrefix	(	double[]	DoubleBinaryOperator	):  Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds [2.0, 1.0, 0.0, 3.0] and the operation performs addition, then upon return the array holds [2.0, 3.0, 3.0, 6.0]. Parallel prefix computation is usually more efficient than sequential loops for large arrays.  Because floating-point operations may not be strictly associative, the returned result may not be identical to the value that would be obtained if the operation was performed sequentially.
java.util.Arrays: java.util.Arrays.parallelPrefix	(	double[]	int	int	DoubleBinaryOperator	):  Performs parallelPrefix() for the given subrange of the array.
java.util.Arrays: java.util.Arrays.parallelPrefix	(	int[]	IntBinaryOperator	):  Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds [2, 1, 0, 3] and the operation performs addition, then upon return the array holds [2, 3, 3, 6]. Parallel prefix computation is usually more efficient than sequential loops for large arrays.
java.util.Arrays: java.util.Arrays.parallelPrefix	(	int[]	int	int	IntBinaryOperator	):  Performs parallelPrefix() for the given subrange of the array.
java.util.Arrays: java.util.Arrays.parallelPrefix	(	long[]	LongBinaryOperator	):  Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds [2, 1, 0, 3] and the operation performs addition, then upon return the array holds [2, 3, 3, 6]. Parallel prefix computation is usually more efficient than sequential loops for large arrays.
java.util.Arrays: java.util.Arrays.parallelPrefix	(	long[]	int	int	LongBinaryOperator	):  Performs parallelPrefix() for the given subrange of the array.
java.util.Arrays: java.util.Arrays.parallelSetAll	(	T[]	IntFunction	):  Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from parallelSetAll and the array is left in an indeterminate state.
java.util.Arrays: java.util.Arrays.parallelSetAll	(	double[]	IntToDoubleFunction	):  Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from parallelSetAll and the array is left in an indeterminate state.
java.util.Arrays: java.util.Arrays.parallelSetAll	(	int[]	IntUnaryOperator	):  Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from parallelSetAll and the array is left in an indeterminate state.
java.util.Arrays: java.util.Arrays.parallelSetAll	(	long[]	IntToLongFunction	):  Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from parallelSetAll and the array is left in an indeterminate state.
java.util.Arrays: java.util.Arrays.parallelSort	(	T[]	):  Sorts the specified array of objects into ascending order, according to the Comparable natural ordering of its elements. All elements in the array must implement the Comparable interface. Furthermore, all elements in the array must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort.
java.util.Arrays: java.util.Arrays.parallelSort	(	T[]	Comparator	):  Sorts the specified array of objects according to the order induced by the specified comparator. All elements in the array must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort.
java.util.Arrays: java.util.Arrays.parallelSort	(	T[]	int	int	):  Sorts the specified range of the specified array of objects into ascending order, according to the Comparable natural ordering of its elements. The range to be sorted extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be sorted is empty.) All elements in this range must implement the Comparable interface. Furthermore, all elements in this range must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort.
java.util.Arrays: java.util.Arrays.parallelSort	(	T[]	int	int	Comparator	):  Sorts the specified range of the specified array of objects according to the order induced by the specified comparator. The range to be sorted extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be sorted is empty.) All elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the range). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort.
java.util.Arrays: java.util.Arrays.parallelSort	(	byte[]	):  Sorts the specified array into ascending numerical order.
java.util.Arrays: java.util.Arrays.parallelSort	(	byte[]	int	int	):  Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty.
java.util.Arrays: java.util.Arrays.parallelSort	(	char[]	):  Sorts the specified array into ascending numerical order.
java.util.Arrays: java.util.Arrays.parallelSort	(	char[]	int	int	):  Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty.
java.util.Arrays: java.util.Arrays.parallelSort	(	double[]	):  Sorts the specified array into ascending numerical order. The < relation does not provide a total order on all double values: -0.0d == 0.0d is true and a Double.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method compareTo: -0.0d is treated as less than value 0.0d and Double.NaN is considered greater than any other value and all Double.NaN values are considered equal.
java.util.Arrays: java.util.Arrays.parallelSort	(	double[]	int	int	):  Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. The < relation does not provide a total order on all double values: -0.0d == 0.0d is true and a Double.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method compareTo: -0.0d is treated as less than value 0.0d and Double.NaN is considered greater than any other value and all Double.NaN values are considered equal.
java.util.Arrays: java.util.Arrays.parallelSort	(	float[]	):  Sorts the specified array into ascending numerical order. The < relation does not provide a total order on all float values: -0.0f == 0.0f is true and a Float.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method compareTo: -0.0f is treated as less than value 0.0f and Float.NaN is considered greater than any other value and all Float.NaN values are considered equal.
java.util.Arrays: java.util.Arrays.parallelSort	(	float[]	int	int	):  Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. The < relation does not provide a total order on all float values: -0.0f == 0.0f is true and a Float.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method compareTo: -0.0f is treated as less than value 0.0f and Float.NaN is considered greater than any other value and all Float.NaN values are considered equal.
java.util.Arrays: java.util.Arrays.parallelSort	(	int[]	):  Sorts the specified array into ascending numerical order.
java.util.Arrays: java.util.Arrays.parallelSort	(	int[]	int	int	):  Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty.
java.util.Arrays: java.util.Arrays.parallelSort	(	long[]	):  Sorts the specified array into ascending numerical order.
java.util.Arrays: java.util.Arrays.parallelSort	(	long[]	int	int	):  Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty.
java.util.Arrays: java.util.Arrays.parallelSort	(	short[]	):  Sorts the specified array into ascending numerical order.
java.util.Arrays: java.util.Arrays.parallelSort	(	short[]	int	int	):  Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty.
java.util.Arrays: java.util.Arrays.rangeCheck	(	int	int	int	):  Checks that fromIndex and toIndex are in the range and throws an exception if they aren't.
java.util.Arrays: java.util.Arrays.setAll	(	T[]	IntFunction	):  Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state.
java.util.Arrays: java.util.Arrays.setAll	(	double[]	IntToDoubleFunction	):  Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state.
java.util.Arrays: java.util.Arrays.setAll	(	int[]	IntUnaryOperator	):  Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state.
java.util.Arrays: java.util.Arrays.setAll	(	long[]	IntToLongFunction	):  Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state.
java.util.Arrays: java.util.Arrays.sort	(	Object[]	):  Sorts the specified array of objects into ascending order, according to the Comparable natural ordering of its elements. All elements in the array must implement the Comparable interface. Furthermore, all elements in the array must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's "Optimistic Sorting and Information Theoretic Complexity", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993.
java.util.Arrays: java.util.Arrays.sort	(	Object[]	int	int	):  Sorts the specified range of the specified array of objects into ascending order, according to the Comparable natural ordering of its elements. The range to be sorted extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be sorted is empty.) All elements in this range must implement the Comparable interface. Furthermore, all elements in this range must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's "Optimistic Sorting and Information Theoretic Complexity", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993.
java.util.Arrays: java.util.Arrays.sort	(	T[]	Comparator	):  Sorts the specified array of objects according to the order induced by the specified comparator. All elements in the array must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's "Optimistic Sorting and Information Theoretic Complexity", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993.
java.util.Arrays: java.util.Arrays.sort	(	T[]	int	int	Comparator	):  Sorts the specified range of the specified array of objects according to the order induced by the specified comparator. The range to be sorted extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be sorted is empty.) All elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the range). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's "Optimistic Sorting and Information Theoretic Complexity", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993.
java.util.Arrays: java.util.Arrays.sort	(	byte[]	):  Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays: java.util.Arrays.sort	(	byte[]	int	int	):  Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays: java.util.Arrays.sort	(	char[]	):  Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays: java.util.Arrays.sort	(	char[]	int	int	):  Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays: java.util.Arrays.sort	(	double[]	):  Sorts the specified array into ascending numerical order. The < relation does not provide a total order on all double values: -0.0d == 0.0d is true and a Double.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method compareTo: -0.0d is treated as less than value 0.0d and Double.NaN is considered greater than any other value and all Double.NaN values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays: java.util.Arrays.sort	(	double[]	int	int	):  Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. The < relation does not provide a total order on all double values: -0.0d == 0.0d is true and a Double.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method compareTo: -0.0d is treated as less than value 0.0d and Double.NaN is considered greater than any other value and all Double.NaN values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays: java.util.Arrays.sort	(	float[]	):  Sorts the specified array into ascending numerical order. The < relation does not provide a total order on all float values: -0.0f == 0.0f is true and a Float.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method compareTo: -0.0f is treated as less than value 0.0f and Float.NaN is considered greater than any other value and all Float.NaN values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays: java.util.Arrays.sort	(	float[]	int	int	):  Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. The < relation does not provide a total order on all float values: -0.0f == 0.0f is true and a Float.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method compareTo: -0.0f is treated as less than value 0.0f and Float.NaN is considered greater than any other value and all Float.NaN values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays: java.util.Arrays.sort	(	int[]	):  Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays: java.util.Arrays.sort	(	int[]	int	int	):  Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays: java.util.Arrays.sort	(	long[]	):  Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays: java.util.Arrays.sort	(	long[]	int	int	):  Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays: java.util.Arrays.sort	(	short[]	):  Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays: java.util.Arrays.sort	(	short[]	int	int	):  Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays: java.util.Arrays.spliterator	(	T[]	):  Returns a Spliterator covering all of the specified array. The spliterator reports SIZED, SUBSIZED, ORDERED, and IMMUTABLE.
java.util.Arrays: java.util.Arrays.spliterator	(	T[]	int	int	):  Returns a Spliterator covering the specified range of the specified array. The spliterator reports SIZED, SUBSIZED, ORDERED, and IMMUTABLE.
java.util.Arrays: java.util.Arrays.spliterator	(	double[]	):  Returns a Spliterator.OfDouble covering all of the specified array. The spliterator reports SIZED, SUBSIZED, ORDERED, and IMMUTABLE.
java.util.Arrays: java.util.Arrays.spliterator	(	double[]	int	int	):  Returns a Spliterator.OfDouble covering the specified range of the specified array. The spliterator reports SIZED, SUBSIZED, ORDERED, and IMMUTABLE.
java.util.Arrays: java.util.Arrays.spliterator	(	int[]	):  Returns a Spliterator.OfInt covering all of the specified array. The spliterator reports SIZED, SUBSIZED, ORDERED, and IMMUTABLE.
java.util.Arrays: java.util.Arrays.spliterator	(	int[]	int	int	):  Returns a Spliterator.OfInt covering the specified range of the specified array. The spliterator reports SIZED, SUBSIZED, ORDERED, and IMMUTABLE.
java.util.Arrays: java.util.Arrays.spliterator	(	long[]	):  Returns a Spliterator.OfLong covering all of the specified array. The spliterator reports SIZED, SUBSIZED, ORDERED, and IMMUTABLE.
java.util.Arrays: java.util.Arrays.spliterator	(	long[]	int	int	):  Returns a Spliterator.OfLong covering the specified range of the specified array. The spliterator reports SIZED, SUBSIZED, ORDERED, and IMMUTABLE.
java.util.Arrays: java.util.Arrays.stream	(	T[]	):  Returns a sequential Stream with the specified array as its source.
java.util.Arrays: java.util.Arrays.stream	(	T[]	int	int	):  Returns a sequential Stream with the specified range of the specified array as its source.
java.util.Arrays: java.util.Arrays.stream	(	double[]	):  Returns a sequential DoubleStream with the specified array as its source.
java.util.Arrays: java.util.Arrays.stream	(	double[]	int	int	):  Returns a sequential DoubleStream with the specified range of the specified array as its source.
java.util.Arrays: java.util.Arrays.stream	(	int[]	):  Returns a sequential IntStream with the specified array as its source.
java.util.Arrays: java.util.Arrays.stream	(	int[]	int	int	):  Returns a sequential IntStream with the specified range of the specified array as its source.
java.util.Arrays: java.util.Arrays.stream	(	long[]	):  Returns a sequential LongStream with the specified array as its source.
java.util.Arrays: java.util.Arrays.stream	(	long[]	int	int	):  Returns a sequential LongStream with the specified range of the specified array as its source.
java.util.Arrays: java.util.Arrays.swap	(	Object[]	int	int	):  Swaps x[a] with x[b].
java.util.Arrays: java.util.Arrays.toString	(	Object[]	):  Returns a string representation of the contents of the specified array. If the array contains other arrays as elements, they are converted to strings by the toString method inherited from Object, which describes their identities rather than their contents. The value returned by this method is equal to the value that would be returned by Arrays.asList(a).toString(), unless a is null, in which case "null" is returned.
java.util.Arrays: java.util.Arrays.toString	(	boolean[]	):  Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Elements are converted to strings as by String.valueOf(boolean). Returns "null" if a is null.
java.util.Arrays: java.util.Arrays.toString	(	byte[]	):  Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Elements are converted to strings as by String.valueOf(byte). Returns "null" if a is null.
java.util.Arrays: java.util.Arrays.toString	(	char[]	):  Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Elements are converted to strings as by String.valueOf(char). Returns "null" if a is null.
java.util.Arrays: java.util.Arrays.toString	(	double[]	):  Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Elements are converted to strings as by String.valueOf(double). Returns "null" if a is null.
java.util.Arrays: java.util.Arrays.toString	(	float[]	):  Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Elements are converted to strings as by String.valueOf(float). Returns "null" if a is null.
java.util.Arrays: java.util.Arrays.toString	(	int[]	):  Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Elements are converted to strings as by String.valueOf(int). Returns "null" if a is null.
java.util.Arrays: java.util.Arrays.toString	(	long[]	):  Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Elements are converted to strings as by String.valueOf(long). Returns "null" if a is null.
java.util.Arrays: java.util.Arrays.toString	(	short[]	):  Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Elements are converted to strings as by String.valueOf(short). Returns "null" if a is null.
java.util.AbstractList: java.util.AbstractList:  This class provides a skeletal implementation of the List interface to minimize the effort required to implement this interface backed by a "random access" data store (such as an array). For sequential access data (such as a linked list), AbstractSequentialList should be used in preference to this class. To implement an unmodifiable list, the programmer needs only to extend this class and provide implementations for the get() and size() size() methods. To implement a modifiable list, the programmer must additionally override the set() set(int, E) method (which otherwise throws an UnsupportedOperationException). If the list is variable-size the programmer must additionally override the add() add(int, E) and remove() methods. The programmer should generally provide a void (no argument) and collection constructor, as per the recommendation in the Collection interface specification. Unlike the other abstract collection implementations, the programmer does not have to provide an iterator implementation; the iterator and list iterator are implemented by this class, on top of the "random access" methods: get(), set() set(int, E), add() add(int, E) and remove(). The documentation for each non-abstract method in this class describes its implementation in detail. Each of these methods may be overridden if the collection being implemented admits a more efficient implementation. This class is a member of the  Java Collections Framework.
java.util.AbstractList: java.util.AbstractList.AbstractList	(	):  Sole constructor. (For invocation by subclass constructors, typically implicit.)
java.util.AbstractList: java.util.AbstractList.add	(	E	):  Appends the specified element to the end of this list (optional operation). Lists that support this operation may place limitations on what elements may be added to this list. In particular, some lists will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. List classes should clearly specify in their documentation any restrictions on what elements may be added. This implementation calls add(size(), e). Note that this implementation throws an UnsupportedOperationException unless add() add(int, E) is overridden.
java.util.AbstractList: java.util.AbstractList.add	(	int	E	):  Inserts the specified element at the specified position in this list (optional operation). Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices). This implementation always throws an UnsupportedOperationException.
java.util.AbstractList: java.util.AbstractList.addAll	(	int	Collection	):  Inserts all of the elements in the specified collection into this list at the specified position (optional operation). Shifts the element currently at that position (if any) and any subsequent elements to the right (increases their indices). The new elements will appear in this list in the order that they are returned by the specified collection's iterator. The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (Note that this will occur if the specified collection is this list, and it's nonempty.) This implementation gets an iterator over the specified collection and iterates over it, inserting the elements obtained from the iterator into this list at the appropriate position, one at a time, using add(int, E). Many implementations will override this method for efficiency. Note that this implementation throws an UnsupportedOperationException unless add() add(int, E) is overridden.
java.util.AbstractList: java.util.AbstractList.clear	(	):  Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.
java.util.AbstractList: java.util.AbstractList.equals	(	Object	):  Compares the specified object with this list for equality. Returns true if and only if the specified object is also a list, both lists have the same size, and all corresponding pairs of elements in the two lists are equal. (Two elements e1 and e2 are equal if (e1==null ? e2==null : e1.equals(e2)).) In other words, two lists are defined to be equal if they contain the same elements in the same order. This implementation first checks if the specified object is this list. If so, it returns true; if not, it checks if the specified object is a list. If not, it returns false; if so, it iterates over both lists, comparing corresponding pairs of elements. If any comparison returns false, this method returns false. If either iterator runs out of elements before the other it returns false (as the lists are of unequal length); otherwise it returns true when the iterations complete.
java.util.AbstractList: java.util.AbstractList.get	(	int	):  Returns the element at the specified position in this list.
java.util.AbstractList: java.util.AbstractList.hashCode	(	):  Returns the hash code value for this list. This implementation uses exactly the code that is used to define the list hash function in the documentation for the hashCode method.
java.util.AbstractList: java.util.AbstractList.indexOf	(	Object	):  Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index. This implementation first gets a list iterator (with listIterator()). Then, it iterates over the list until the specified element is found or the end of the list is reached.
java.util.AbstractList: java.util.AbstractList.iterator	(	):  Returns an iterator over the elements in this list in proper sequence. This implementation returns a straightforward implementation of the iterator interface, relying on the backing list's size(), get(int), and remove(int) methods. Note that the iterator returned by this method will throw an UnsupportedOperationException in response to its remove method unless the list's remove(int) method is overridden. This implementation can be made to throw runtime exceptions in the face of concurrent modification, as described in the specification for the (protected) modCount field.
java.util.AbstractList: java.util.AbstractList.lastIndexOf	(	Object	):  Returns the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the highest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index. This implementation first gets a list iterator that points to the end of the list (with listIterator(size())). Then, it iterates backwards over the list until the specified element is found, or the beginning of the list is reached.
java.util.AbstractList: java.util.AbstractList.listIterator	(	):  Returns a list iterator over the elements in this list (in proper sequence). This implementation returns listIterator(0).
java.util.AbstractList: java.util.AbstractList.listIterator	(	int	):  Returns a list iterator over the elements in this list (in proper sequence), starting at the specified position in the list. The specified index indicates the first element that would be returned by an initial call to next. An initial call to previous would return the element with the specified index minus one. This implementation returns a straightforward implementation of the ListIterator interface that extends the implementation of the Iterator interface returned by the iterator() method. The ListIterator implementation relies on the backing list's get(int), set(int, E), add(int, E) and remove(int) methods. Note that the list iterator returned by this implementation will throw an UnsupportedOperationException in response to its remove, set and add methods unless the list's remove(int), set(int, E), and add(int, E) methods are overridden. This implementation can be made to throw runtime exceptions in the face of concurrent modification, as described in the specification for the (protected) modCount field.
java.util.AbstractList: java.util.AbstractList.remove	(	int	):  Removes the element at the specified position in this list (optional operation). Shifts any subsequent elements to the left (subtracts one from their indices). Returns the element that was removed from the list. This implementation always throws an UnsupportedOperationException.
java.util.AbstractList: java.util.AbstractList.removeRange	(	int	int	):  Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive. Shifts any succeeding elements to the left (reduces their index). This call shortens the list by (toIndex - fromIndex) elements. (If toIndex==fromIndex, this operation has no effect.) This method is called by the clear operation on this list and its subLists. Overriding this method to take advantage of the internals of the list implementation can substantially improve the performance of the clear operation on this list and its subLists. This implementation gets a list iterator positioned before fromIndex, and repeatedly calls ListIterator.next followed by ListIterator.remove until the entire range has been removed. Note: if ListIterator.remove requires linear time, this implementation requires quadratic time.
java.util.AbstractList: java.util.AbstractList.set	(	int	E	):  Replaces the element at the specified position in this list with the specified element (optional operation). This implementation always throws an UnsupportedOperationException.
java.util.AbstractList: java.util.AbstractList.subList	(	int	int	):  Returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive. (If fromIndex and toIndex are equal, the returned list is empty.) The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa. The returned list supports all of the optional list operations supported by this list. This method eliminates the need for explicit range operations (of the sort that commonly exist for arrays). Any operation that expects a list can be used as a range operation by passing a subList view instead of a whole list. For example, the following idiom removes a range of elements from a list: list.subList(from, to).clear(); Similar idioms may be constructed for indexOf and lastIndexOf, and all of the algorithms in the Collections class can be applied to a subList. The semantics of the list returned by this method become undefined if the backing list (i.e., this list) is structurally modified in any way other than via the returned list. (Structural modifications are those that change the size of this list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.) This implementation returns a list that subclasses AbstractList. The subclass stores, in private fields, the offset of the subList within the backing list, the size of the subList (which can change over its lifetime), and the expected modCount value of the backing list. There are two variants of the subclass, one of which implements RandomAccess. If this list implements RandomAccess the returned list will be an instance of the subclass that implements RandomAccess. The subclass's set(int, E), get(int), add(int, E), remove(int), addAll(int, Collection) and removeRange(int, int) methods all delegate to the corresponding methods on the backing abstract list, after bounds-checking the index and adjusting for the offset. The addAll(Collection c) method merely returns addAll(size, c). The listIterator(int) method returns a "wrapper object" over a list iterator on the backing list, which is created with the corresponding method on the backing list. The iterator method merely returns listIterator(), and the size method merely returns the subclass's size field. All methods first check to see if the actual modCount of the backing list is equal to its expected value, and throw a ConcurrentModificationException if it is not.
java.util.AbstractCollection: java.util.AbstractCollection:  This class provides a skeletal implementation of the Collection interface, to minimize the effort required to implement this interface.  To implement an unmodifiable collection, the programmer needs only to extend this class and provide implementations for the iterator and size methods. (The iterator returned by the iterator method must implement hasNext and next.) To implement a modifiable collection, the programmer must additionally override this class's add method (which otherwise throws an UnsupportedOperationException), and the iterator returned by the iterator method must additionally implement its remove method. The programmer should generally provide a void (no argument) and Collection constructor, as per the recommendation in the Collection interface specification. The documentation for each non-abstract method in this class describes its implementation in detail. Each of these methods may be overridden if the collection being implemented admits a more efficient implementation. This class is a member of the  Java Collections Framework.
java.util.AbstractCollection: java.util.AbstractCollection.AbstractCollection	(	):  Sole constructor. (For invocation by subclass constructors, typically implicit.)
java.util.AbstractCollection: java.util.AbstractCollection.add	(	E	):  Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns. This implementation always throws an UnsupportedOperationException.
java.util.AbstractCollection: java.util.AbstractCollection.addAll	(	Collection	):  Adds all of the elements in the specified collection to this collection (optional operation). The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (This implies that the behavior of this call is undefined if the specified collection is this collection, and this collection is nonempty.) This implementation iterates over the specified collection, and adds each object returned by the iterator to this collection, in turn. Note that this implementation will throw an UnsupportedOperationException unless add is overridden (assuming the specified collection is non-empty).
java.util.AbstractCollection: java.util.AbstractCollection.clear	(	):  Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns. This implementation iterates over this collection, removing each element using the Iterator.remove operation. Most implementations will probably choose to override this method for efficiency. Note that this implementation will throw an UnsupportedOperationException if the iterator returned by this collection's iterator method does not implement the remove method and this collection is non-empty.
java.util.AbstractCollection: java.util.AbstractCollection.contains	(	Object	):  Returns true if this collection contains the specified element. More formally, returns true if and only if this collection contains at least one element e such that (o==null ? e==null : o.equals(e)). This implementation iterates over the elements in the collection, checking each element in turn for equality with the specified element.
java.util.AbstractCollection: java.util.AbstractCollection.containsAll	(	Collection	):  Returns true if this collection contains all of the elements in the specified collection. This implementation iterates over the specified collection, checking each element returned by the iterator in turn to see if it's contained in this collection. If all elements are so contained true is returned, otherwise false.
java.util.AbstractCollection: java.util.AbstractCollection.finishToArray	(	T[]	Iterator	):  Reallocates the array being used within toArray when the iterator returned more elements than expected, and finishes filling it from the iterator.
java.util.AbstractCollection: java.util.AbstractCollection.isEmpty	(	):  Returns true if this collection contains no elements. This implementation returns size() == 0.
java.util.AbstractCollection: java.util.AbstractCollection.iterator	(	):  Returns an iterator over the elements contained in this collection.
java.util.AbstractCollection: java.util.AbstractCollection.remove	(	Object	):  Removes a single instance of the specified element from this collection, if it is present (optional operation). More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this collection contains one or more such elements. Returns true if this collection contained the specified element (or equivalently, if this collection changed as a result of the call). This implementation iterates over the collection looking for the specified element. If it finds the element, it removes the element from the collection using the iterator's remove method. Note that this implementation throws an UnsupportedOperationException if the iterator returned by this collection's iterator method does not implement the remove method and this collection contains the specified object.
java.util.AbstractCollection: java.util.AbstractCollection.removeAll	(	Collection	):  Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection. This implementation iterates over this collection, checking each element returned by the iterator in turn to see if it's contained in the specified collection. If it's so contained, it's removed from this collection with the iterator's remove method. Note that this implementation will throw an UnsupportedOperationException if the iterator returned by the iterator method does not implement the remove method and this collection contains one or more elements in common with the specified collection.
java.util.AbstractCollection: java.util.AbstractCollection.retainAll	(	Collection	):  Retains only the elements in this collection that are contained in the specified collection (optional operation). In other words, removes from this collection all of its elements that are not contained in the specified collection. This implementation iterates over this collection, checking each element returned by the iterator in turn to see if it's contained in the specified collection. If it's not so contained, it's removed from this collection with the iterator's remove method. Note that this implementation will throw an UnsupportedOperationException if the iterator returned by the iterator method does not implement the remove method and this collection contains one or more elements not present in the specified collection.
java.util.AbstractCollection: java.util.AbstractCollection.toArray	(	):  Returns an array containing all of the elements in this collection. If this collection makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. The returned array will be "safe" in that no references to it are maintained by this collection. (In other words, this method must allocate a new array even if this collection is backed by an array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs. This implementation returns an array containing all the elements returned by this collection's iterator, in the same order, stored in consecutive elements of the array, starting with index 0. The length of the returned array is equal to the number of elements returned by the iterator, even if the size of this collection changes during iteration, as might happen if the collection permits concurrent modification during iteration. The size method is called only as an optimization hint; the correct result is returned even if the iterator returns a different number of elements. This method is equivalent to:  List list = new ArrayList(size()); for (E e : this) list.add(e); return list.toArray();
java.util.AbstractCollection: java.util.AbstractCollection.toArray	(	T[]	):  Returns an array containing all of the elements in this collection; the runtime type of the returned array is that of the specified array. If the collection fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this collection. If this collection fits in the specified array with room to spare (i.e., the array has more elements than this collection), the element in the array immediately following the end of the collection is set to null. (This is useful in determining the length of this collection only if the caller knows that this collection does not contain any null elements.) If this collection makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a collection known to contain only strings. The following code can be used to dump the collection into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray(). This implementation returns an array containing all the elements returned by this collection's iterator in the same order, stored in consecutive elements of the array, starting with index 0. If the number of elements returned by the iterator is too large to fit into the specified array, then the elements are returned in a newly allocated array with length equal to the number of elements returned by the iterator, even if the size of this collection changes during iteration, as might happen if the collection permits concurrent modification during iteration. The size method is called only as an optimization hint; the correct result is returned even if the iterator returns a different number of elements. This method is equivalent to:  List list = new ArrayList(size()); for (E e : this) list.add(e); return list.toArray(a);
java.util.AbstractCollection: java.util.AbstractCollection.toString	(	):  Returns a string representation of this collection. The string representation consists of a list of the collection's elements in the order they are returned by its iterator, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (comma and space). Elements are converted to strings as by valueOf().
java.util.ListIterator: java.util.ListIterator:  An iterator for lists that allows the programmer to traverse the list in either direction, modify the list during iteration, and obtain the iterator's current position in the list. A ListIterator has no current element; its cursor position always lies between the element that would be returned by a call to previous() and the element that would be returned by a call to next(). An iterator for a list of length n has n+1 possible cursor positions, as illustrated by the carets (^) below:  Element(0) Element(1) Element(2) ... Element(n-1) cursor positions: ^ ^ ^ ^ ^  Note that the remove and set() methods are not defined in terms of the cursor position; they are defined to operate on the last element returned by a call to next or previous(). This interface is a member of the  Java Collections Framework.
java.util.ListIterator: java.util.ListIterator.add	(	E	):  Inserts the specified element into the list (optional operation). The element is inserted immediately before the element that would be returned by next, if any, and after the element that would be returned by previous, if any. (If the list contains no elements, the new element becomes the sole element on the list.) The new element is inserted before the implicit cursor: a subsequent call to next would be unaffected, and a subsequent call to previous would return the new element. (This call increases by one the value that would be returned by a call to nextIndex or previousIndex.)
java.util.ListIterator: java.util.ListIterator.hasNext	(	):  Returns true if this list iterator has more elements when traversing the list in the forward direction. (In other words, returns true if next would return an element rather than throwing an exception.)
java.util.ListIterator: java.util.ListIterator.hasPrevious	(	):  Returns true if this list iterator has more elements when traversing the list in the reverse direction. (In other words, returns true if previous would return an element rather than throwing an exception.)
java.util.ListIterator: java.util.ListIterator.next	(	):  Returns the next element in the list and advances the cursor position. This method may be called repeatedly to iterate through the list, or intermixed with calls to previous to go back and forth. (Note that alternating calls to next and previous will return the same element repeatedly.)
java.util.ListIterator: java.util.ListIterator.nextIndex	(	):  Returns the index of the element that would be returned by a subsequent call to next. (Returns list size if the list iterator is at the end of the list.)
java.util.ListIterator: java.util.ListIterator.previous	(	):  Returns the previous element in the list and moves the cursor position backwards. This method may be called repeatedly to iterate through the list backwards, or intermixed with calls to next to go back and forth. (Note that alternating calls to next and previous will return the same element repeatedly.)
java.util.ListIterator: java.util.ListIterator.previousIndex	(	):  Returns the index of the element that would be returned by a subsequent call to previous. (Returns -1 if the list iterator is at the beginning of the list.)
java.util.ListIterator: java.util.ListIterator.remove	(	):  Removes from the list the last element that was returned by next or previous (optional operation). This call can only be made once per call to next or previous. It can be made only if add has not been called after the last call to next or previous.
java.util.ListIterator: java.util.ListIterator.set	(	E	):  Replaces the last element returned by next or previous with the specified element (optional operation). This call can be made only if neither remove nor add have been called after the last call to next or previous.
java.util.Set: java.util.Set:  A collection that contains no duplicate elements. More formally, sets contain no pair of elements e1 and e2 such that e1.equals(e2), and at most one null element. As implied by its name, this interface models the mathematical set abstraction. The Set interface places additional stipulations, beyond those inherited from the Collection interface, on the contracts of all constructors and on the contracts of the add, equals and hashCode methods. Declarations for other inherited methods are also included here for convenience. (The specifications accompanying these declarations have been tailored to the Set interface, but they do not contain any additional stipulations.) The additional stipulation on constructors is, not surprisingly, that all constructors must create a set that contains no duplicate elements (as defined above). Note: Great care must be exercised if mutable objects are used as set elements. The behavior of a set is not specified if the value of an object is changed in a manner that affects equals comparisons while the object is an element in the set. A special case of this prohibition is that it is not permissible for a set to contain itself as an element. Some set implementations have restrictions on the elements that they may contain. For example, some implementations prohibit null elements, and some have restrictions on the types of their elements. Attempting to add an ineligible element throws an unchecked exception, typically NullPointerException or ClassCastException. Attempting to query the presence of an ineligible element may throw an exception, or it may simply return false; some implementations will exhibit the former behavior and some will exhibit the latter. More generally, attempting an operation on an ineligible element whose completion would not result in the insertion of an ineligible element into the set may throw an exception or it may succeed, at the option of the implementation. Such exceptions are marked as "optional" in the specification for this interface. This interface is a member of the  Java Collections Framework.
java.util.Set: java.util.Set.add	(	E	):  Adds the specified element to this set if it is not already present (optional operation). More formally, adds the specified element e to this set if the set contains no element e2 such that (e==null ? e2==null : e.equals(e2)). If this set already contains the element, the call leaves the set unchanged and returns false. In combination with the restriction on constructors, this ensures that sets never contain duplicate elements. The stipulation above does not imply that sets must accept all elements; sets may refuse to add any particular element, including null, and throw an exception, as described in the specification for add Collection.add. Individual set implementations should clearly document any restrictions on the elements that they may contain.
java.util.Set: java.util.Set.addAll	(	Collection	):  Adds all of the elements in the specified collection to this set if they're not already present (optional operation). If the specified collection is also a set, the addAll operation effectively modifies this set so that its value is the union of the two sets. The behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.Set: java.util.Set.clear	(	):  Removes all of the elements from this set (optional operation). The set will be empty after this call returns.
java.util.Set: java.util.Set.contains	(	Object	):  Returns true if this set contains the specified element. More formally, returns true if and only if this set contains an element e such that (o==null ? e==null : o.equals(e)).
java.util.Set: java.util.Set.containsAll	(	Collection	):  Returns true if this set contains all of the elements of the specified collection. If the specified collection is also a set, this method returns true if it is a subset of this set.
java.util.Set: java.util.Set.equals	(	Object	):  Compares the specified object with this set for equality. Returns true if the specified object is also a set, the two sets have the same size, and every member of the specified set is contained in this set (or equivalently, every member of this set is contained in the specified set). This definition ensures that the equals method works properly across different implementations of the set interface.
java.util.Set: java.util.Set.hashCode	(	):  Returns the hash code value for this set. The hash code of a set is defined to be the sum of the hash codes of the elements in the set, where the hash code of a null element is defined to be zero. This ensures that s1.equals(s2) implies that s1.hashCode()==s2.hashCode() for any two sets s1 and s2, as required by the general contract of hashCode.
java.util.Set: java.util.Set.isEmpty	(	):  Returns true if this set contains no elements.
java.util.Set: java.util.Set.iterator	(	):  Returns an iterator over the elements in this set. The elements are returned in no particular order (unless this set is an instance of some class that provides a guarantee).
java.util.Set: java.util.Set.remove	(	Object	):  Removes the specified element from this set if it is present (optional operation). More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)
java.util.Set: java.util.Set.removeAll	(	Collection	):  Removes from this set all of its elements that are contained in the specified collection (optional operation). If the specified collection is also a set, this operation effectively modifies this set so that its value is the asymmetric set difference of the two sets.
java.util.Set: java.util.Set.retainAll	(	Collection	):  Retains only the elements in this set that are contained in the specified collection (optional operation). In other words, removes from this set all of its elements that are not contained in the specified collection. If the specified collection is also a set, this operation effectively modifies this set so that its value is the intersection of the two sets.
java.util.Set: java.util.Set.size	(	):  Returns the number of elements in this set (its cardinality). If this set contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
java.util.Set: java.util.Set.spliterator	(	):  Creates a Spliterator over the elements in this set. The Spliterator reports DISTINCT. Implementations should document the reporting of additional characteristic values.
java.util.Set: java.util.Set.toArray	(	):  Returns an array containing all of the elements in this set. If this set makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. The returned array will be "safe" in that no references to it are maintained by this set. (In other words, this method must allocate a new array even if this set is backed by an array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.Set: java.util.Set.toArray	(	T[]	):  Returns an array containing all of the elements in this set; the runtime type of the returned array is that of the specified array. If the set fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this set. If this set fits in the specified array with room to spare (i.e., the array has more elements than this set), the element in the array immediately following the end of the set is set to null. (This is useful in determining the length of this set only if the caller knows that this set does not contain any null elements.) If this set makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a set known to contain only strings. The following code can be used to dump the set into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.AbstractSet: java.util.AbstractSet:  This class provides a skeletal implementation of the Set interface to minimize the effort required to implement this interface.  The process of implementing a set by extending this class is identical to that of implementing a Collection by extending AbstractCollection, except that all of the methods and constructors in subclasses of this class must obey the additional constraints imposed by the Set interface (for instance, the add method must not permit addition of multiple instances of an object to a set). Note that this class does not override any of the implementations from the AbstractCollection class. It merely adds implementations for equals and hashCode. This class is a member of the  Java Collections Framework.
java.util.AbstractSet: java.util.AbstractSet.AbstractSet	(	):  Sole constructor. (For invocation by subclass constructors, typically implicit.)
java.util.AbstractSet: java.util.AbstractSet.equals	(	Object	):  Compares the specified object with this set for equality. Returns true if the given object is also a set, the two sets have the same size, and every member of the given set is contained in this set. This ensures that the equals method works properly across different implementations of the Set interface. This implementation first checks if the specified object is this set; if so it returns true. Then, it checks if the specified object is a set whose size is identical to the size of this set; if not, it returns false. If so, it returns containsAll((Collection) o).
java.util.AbstractSet: java.util.AbstractSet.hashCode	(	):  Returns the hash code value for this set. The hash code of a set is defined to be the sum of the hash codes of the elements in the set, where the hash code of a null element is defined to be zero. This ensures that s1.equals(s2) implies that s1.hashCode()==s2.hashCode() for any two sets s1 and s2, as required by the general contract of hashCode. This implementation iterates over the set, calling the hashCode method on each element in the set, and adding up the results.
java.util.AbstractSet: java.util.AbstractSet.removeAll	(	Collection	):  Removes from this set all of its elements that are contained in the specified collection (optional operation). If the specified collection is also a set, this operation effectively modifies this set so that its value is the asymmetric set difference of the two sets. This implementation determines which is the smaller of this set and the specified collection, by invoking the size method on each. If this set has fewer elements, then the implementation iterates over this set, checking each element returned by the iterator in turn to see if it is contained in the specified collection. If it is so contained, it is removed from this set with the iterator's remove method. If the specified collection has fewer elements, then the implementation iterates over the specified collection, removing from this set each element returned by the iterator, using this set's remove method. Note that this implementation will throw an UnsupportedOperationException if the iterator returned by the iterator method does not implement the remove method.
java.util.AbstractSequentialList: java.util.AbstractSequentialList:  This class provides a skeletal implementation of the List interface to minimize the effort required to implement this interface backed by a "sequential access" data store (such as a linked list). For random access data (such as an array), AbstractList should be used in preference to this class. This class is the opposite of the AbstractList class in the sense that it implements the "random access" methods (get(int index), set(int index, E element), add(int index, E element) and remove(int index)) on top of the list's list iterator, instead of the other way around. To implement a list the programmer needs only to extend this class and provide implementations for the listIterator and size methods. For an unmodifiable list, the programmer need only implement the list iterator's hasNext, next, hasPrevious, previous and index methods. For a modifiable list the programmer should additionally implement the list iterator's set method. For a variable-size list the programmer should additionally implement the list iterator's remove and add methods. The programmer should generally provide a void (no argument) and collection constructor, as per the recommendation in the Collection interface specification. This class is a member of the  Java Collections Framework.
java.util.AbstractSequentialList: java.util.AbstractSequentialList.AbstractSequentialList	(	):  Sole constructor. (For invocation by subclass constructors, typically implicit.)
java.util.AbstractSequentialList: java.util.AbstractSequentialList.add	(	int	E	):  Inserts the specified element at the specified position in this list (optional operation). Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices). This implementation first gets a list iterator pointing to the indexed element (with listIterator(index)). Then, it inserts the specified element with ListIterator.add. Note that this implementation will throw an UnsupportedOperationException if the list iterator does not implement the add operation.
java.util.AbstractSequentialList: java.util.AbstractSequentialList.addAll	(	int	Collection	):  Inserts all of the elements in the specified collection into this list at the specified position (optional operation). Shifts the element currently at that position (if any) and any subsequent elements to the right (increases their indices). The new elements will appear in this list in the order that they are returned by the specified collection's iterator. The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (Note that this will occur if the specified collection is this list, and it's nonempty.) This implementation gets an iterator over the specified collection and a list iterator over this list pointing to the indexed element (with listIterator(index)). Then, it iterates over the specified collection, inserting the elements obtained from the iterator into this list, one at a time, using ListIterator.add followed by ListIterator.next (to skip over the added element). Note that this implementation will throw an UnsupportedOperationException if the list iterator returned by the listIterator method does not implement the add operation.
java.util.AbstractSequentialList: java.util.AbstractSequentialList.get	(	int	):  Returns the element at the specified position in this list. This implementation first gets a list iterator pointing to the indexed element (with listIterator(index)). Then, it gets the element using ListIterator.next and returns it.
java.util.AbstractSequentialList: java.util.AbstractSequentialList.iterator	(	):  Returns an iterator over the elements in this list (in proper sequence). This implementation merely returns a list iterator over the list.
java.util.AbstractSequentialList: java.util.AbstractSequentialList.listIterator	(	int	):  Returns a list iterator over the elements in this list (in proper sequence).
java.util.AbstractSequentialList: java.util.AbstractSequentialList.remove	(	int	):  Removes the element at the specified position in this list (optional operation). Shifts any subsequent elements to the left (subtracts one from their indices). Returns the element that was removed from the list. This implementation first gets a list iterator pointing to the indexed element (with listIterator(index)). Then, it removes the element with ListIterator.remove. Note that this implementation will throw an UnsupportedOperationException if the list iterator does not implement the remove operation.
java.util.AbstractSequentialList: java.util.AbstractSequentialList.set	(	int	E	):  Replaces the element at the specified position in this list with the specified element (optional operation). This implementation first gets a list iterator pointing to the indexed element (with listIterator(index)). Then, it gets the current element using ListIterator.next and replaces it with ListIterator.set. Note that this implementation will throw an UnsupportedOperationException if the list iterator does not implement the set operation.
java.util.AbstractQueue: java.util.AbstractQueue:  This class provides skeletal implementations of some Queue operations. The implementations in this class are appropriate when the base implementation does not allow null elements. Methods add, remove, and element are based on offer, poll, and peek, respectively, but throw exceptions instead of indicating failure via false or null returns. A Queue implementation that extends this class must minimally define a method offer which does not permit insertion of null elements, along with methods peek, poll, size, and iterator. Typically, additional methods will be overridden as well. If these requirements cannot be met, consider instead subclassing AbstractCollection. This class is a member of the  Java Collections Framework.
java.util.AbstractQueue: java.util.AbstractQueue.AbstractQueue	(	):  Constructor for use by subclasses.
java.util.AbstractQueue: java.util.AbstractQueue.add	(	E	):  Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an IllegalStateException if no space is currently available. This implementation returns true if offer succeeds, else throws an IllegalStateException.
java.util.AbstractQueue: java.util.AbstractQueue.addAll	(	Collection	):  Adds all of the elements in the specified collection to this queue. Attempts to addAll of a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress. This implementation iterates over the specified collection, and adds each element returned by the iterator to this queue, in turn. A runtime exception encountered while trying to add an element (including, in particular, a null element) may result in only some of the elements having been successfully added when the associated exception is thrown.
java.util.AbstractQueue: java.util.AbstractQueue.clear	(	):  Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.
java.util.AbstractQueue: java.util.AbstractQueue.element	(	):  Retrieves, but does not remove, the head of this queue. This method differs from peek only in that it throws an exception if this queue is empty. This implementation returns the result of peek unless the queue is empty.
java.util.AbstractQueue: java.util.AbstractQueue.remove	(	):  Retrieves and removes the head of this queue. This method differs from poll only in that it throws an exception if this queue is empty. This implementation returns the result of poll unless the queue is empty.
java.util.AbstractMap: java.util.AbstractMap:  This class provides a skeletal implementation of the Map interface, to minimize the effort required to implement this interface. To implement an unmodifiable map, the programmer needs only to extend this class and provide an implementation for the entrySet method, which returns a set-view of the map's mappings. Typically, the returned set will, in turn, be implemented atop AbstractSet. This set should not support the add or remove methods, and its iterator should not support the remove method. To implement a modifiable map, the programmer must additionally override this class's put method (which otherwise throws an UnsupportedOperationException), and the iterator returned by entrySet().iterator() must additionally implement its remove method. The programmer should generally provide a void (no argument) and map constructor, as per the recommendation in the Map interface specification. The documentation for each non-abstract method in this class describes its implementation in detail. Each of these methods may be overridden if the map being implemented admits a more efficient implementation. This class is a member of the  Java Collections Framework.
java.util.AbstractMap: java.util.AbstractMap.AbstractMap	(	):  Sole constructor. (For invocation by subclass constructors, typically implicit.)
java.util.AbstractMap: java.util.AbstractMap.SimpleEntry:  An Entry maintaining a key and a value. The value may be changed using the setValue method. This class facilitates the process of building custom map implementations. For example, it may be convenient to return arrays of SimpleEntry instances in method Map.entrySet().toArray.
java.util.AbstractMap: java.util.AbstractMap.SimpleEntry.SimpleEntry	(	Entry	):  Creates an entry representing the same mapping as the specified entry.
java.util.AbstractMap: java.util.AbstractMap.SimpleEntry.SimpleEntry	(	K	V	):  Creates an entry representing a mapping from the specified key to the specified value.
java.util.AbstractMap: java.util.AbstractMap.SimpleEntry.equals	(	Object	):  Compares the specified object with this entry for equality. Returns true if the given object is also a map entry and the two entries represent the same mapping. More formally, two entries e1 and e2 represent the same mapping if (e1.getKey()==null ? e2.getKey()==null : e1.getKey().equals(e2.getKey())) && (e1.getValue()==null ? e2.getValue()==null : e1.getValue().equals(e2.getValue())) This ensures that the equals method works properly across different implementations of the Map.Entry interface.
java.util.AbstractMap: java.util.AbstractMap.SimpleEntry.getKey	(	):  Returns the key corresponding to this entry.
java.util.AbstractMap: java.util.AbstractMap.SimpleEntry.getValue	(	):  Returns the value corresponding to this entry.
java.util.AbstractMap: java.util.AbstractMap.SimpleEntry.hashCode	(	):  Returns the hash code value for this map entry. The hash code of a map entry e is defined to be:  (e.getKey()==null ? 0 : e.getKey().hashCode()) ^ (e.getValue()==null ? 0 : e.getValue().hashCode()) This ensures that e1.equals(e2) implies that e1.hashCode()==e2.hashCode() for any two Entries e1 and e2, as required by the general contract of hashCode.
java.util.AbstractMap: java.util.AbstractMap.SimpleEntry.setValue	(	V	):  Replaces the value corresponding to this entry with the specified value.
java.util.AbstractMap: java.util.AbstractMap.SimpleEntry.toString	(	):  Returns a String representation of this map entry. This implementation returns the string representation of this entry's key followed by the equals character ("=") followed by the string representation of this entry's value.
java.util.AbstractMap: java.util.AbstractMap.SimpleImmutableEntry:  An Entry maintaining an immutable key and value. This class does not support method setValue. This class may be convenient in methods that return thread-safe snapshots of key-value mappings.
java.util.AbstractMap: java.util.AbstractMap.SimpleImmutableEntry.SimpleImmutableEntry	(	Entry	):  Creates an entry representing the same mapping as the specified entry.
java.util.AbstractMap: java.util.AbstractMap.SimpleImmutableEntry.SimpleImmutableEntry	(	K	V	):  Creates an entry representing a mapping from the specified key to the specified value.
java.util.AbstractMap: java.util.AbstractMap.SimpleImmutableEntry.equals	(	Object	):  Compares the specified object with this entry for equality. Returns true if the given object is also a map entry and the two entries represent the same mapping. More formally, two entries e1 and e2 represent the same mapping if (e1.getKey()==null ? e2.getKey()==null : e1.getKey().equals(e2.getKey())) && (e1.getValue()==null ? e2.getValue()==null : e1.getValue().equals(e2.getValue())) This ensures that the equals method works properly across different implementations of the Map.Entry interface.
java.util.AbstractMap: java.util.AbstractMap.SimpleImmutableEntry.getKey	(	):  Returns the key corresponding to this entry.
java.util.AbstractMap: java.util.AbstractMap.SimpleImmutableEntry.getValue	(	):  Returns the value corresponding to this entry.
java.util.AbstractMap: java.util.AbstractMap.SimpleImmutableEntry.hashCode	(	):  Returns the hash code value for this map entry. The hash code of a map entry e is defined to be:  (e.getKey()==null ? 0 : e.getKey().hashCode()) ^ (e.getValue()==null ? 0 : e.getValue().hashCode()) This ensures that e1.equals(e2) implies that e1.hashCode()==e2.hashCode() for any two Entries e1 and e2, as required by the general contract of hashCode.
java.util.AbstractMap: java.util.AbstractMap.SimpleImmutableEntry.setValue	(	V	):  Replaces the value corresponding to this entry with the specified value (optional operation). This implementation simply throws UnsupportedOperationException, as this class implements an immutable map entry.
java.util.AbstractMap: java.util.AbstractMap.SimpleImmutableEntry.toString	(	):  Returns a String representation of this map entry. This implementation returns the string representation of this entry's key followed by the equals character ("=") followed by the string representation of this entry's value.
java.util.AbstractMap: java.util.AbstractMap.clear	(	):  Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.
java.util.AbstractMap: java.util.AbstractMap.clone	(	):  Returns a shallow copy of this AbstractMap instance: the keys and values themselves are not cloned.
java.util.AbstractMap: java.util.AbstractMap.containsKey	(	Object	):  Returns true if this map contains a mapping for the specified key. More formally, returns true if and only if this map contains a mapping for a key k such that (key==null ? k==null : key.equals(k)). (There can be at most one such mapping.)
java.util.AbstractMap: java.util.AbstractMap.containsValue	(	Object	):  Returns true if this map maps one or more keys to the specified value. More formally, returns true if and only if this map contains at least one mapping to a value v such that (value==null ? v==null : value.equals(v)). This operation will probably require time linear in the map size for most implementations of the Map interface.
java.util.AbstractMap: java.util.AbstractMap.eq	(	Object	Object	):  Utility method for SimpleEntry and SimpleImmutableEntry. Test for equality, checking for nulls. NB: Do not replace with Object.equals until JDK-8015417 is resolved.
java.util.AbstractMap: java.util.AbstractMap.equals	(	Object	):  Compares the specified object with this map for equality. Returns true if the given object is also a map and the two maps represent the same mappings. More formally, two maps m1 and m2 represent the same mappings if m1.entrySet().equals(m2.entrySet()). This ensures that the equals method works properly across different implementations of the Map interface.
java.util.AbstractMap: java.util.AbstractMap.get	(	Object	):  Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that (key==null ? k==null : key.equals(k)), then this method returns v; otherwise it returns null. (There can be at most one such mapping.) If this map permits null values, then a return value of null does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to null. The containsKey operation may be used to distinguish these two cases.
java.util.AbstractMap: java.util.AbstractMap.hashCode	(	):  Returns the hash code value for this map. The hash code of a map is defined to be the sum of the hash codes of each entry in the map's entrySet() view. This ensures that m1.equals(m2) implies that m1.hashCode()==m2.hashCode() for any two maps m1 and m2, as required by the general contract of hashCode.
java.util.AbstractMap: java.util.AbstractMap.isEmpty	(	):  Returns true if this map contains no key-value mappings.
java.util.AbstractMap: java.util.AbstractMap.keySet	(	):  Returns a Set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.AbstractMap: java.util.AbstractMap.put	(	K	V	):  Associates the specified value with the specified key in this map (optional operation). If the map previously contained a mapping for the key, the old value is replaced by the specified value. (A map m is said to contain a mapping for a key k if and only if containsKey() m.containsKey(k) would return true.)
java.util.AbstractMap: java.util.AbstractMap.putAll	(	Map	):  Copies all of the mappings from the specified map to this map (optional operation). The effect of this call is equivalent to that of calling put() put(k, v) on this map once for each mapping from key k to value v in the specified map. The behavior of this operation is undefined if the specified map is modified while the operation is in progress.
java.util.AbstractMap: java.util.AbstractMap.remove	(	Object	):  Removes the mapping for a key from this map if it is present (optional operation). More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. If this map permits null values, then a return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.
java.util.AbstractMap: java.util.AbstractMap.size	(	):  Returns the number of key-value mappings in this map. If the map contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
java.util.AbstractMap: java.util.AbstractMap.toString	(	):  Returns a string representation of this map. The string representation consists of a list of key-value mappings in the order returned by the map's entrySet view's iterator, enclosed in braces ("{}"). Adjacent mappings are separated by the characters ", " (comma and space). Each key-value mapping is rendered as the key followed by an equals sign ("=") followed by the associated value. Keys and values are converted to strings as by valueOf().
java.util.AbstractMap: java.util.AbstractMap.values	(	):  Returns a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.Deque: java.util.Deque:  A linear collection that supports element insertion and removal at both ends. The name deque is short for "double ended queue" and is usually pronounced "deck". Most Deque implementations place no fixed limits on the number of elements they may contain, but this interface supports capacity-restricted deques as well as those with no fixed size limit. This interface defines methods to access the elements at both ends of the deque. Methods are provided to insert, remove, and examine the element. Each of these methods exists in two forms: one throws an exception if the operation fails, the other returns a special value (either null or false, depending on the operation). The latter form of the insert operation is designed specifically for use with capacity-restricted Deque implementations; in most implementations, insert operations cannot fail. The twelve methods described above are summarized in the following table:  Summary of Deque methods    First Element (Head)  Last Element (Tail)    Throws exception Special value Throws exception Special value   Insert addFirst addFirst(e) offerFirst offerFirst(e) addLast addLast(e) offerLast offerLast(e)   Remove removeFirst removeFirst() pollFirst pollFirst() removeLast removeLast() pollLast pollLast()   Examine getFirst getFirst() peekFirst peekFirst() getLast getLast() peekLast peekLast()   This interface extends the Queue interface. When a deque is used as a queue, FIFO (First-In-First-Out) behavior results. Elements are added at the end of the deque and removed from the beginning. The methods inherited from the Queue interface are precisely equivalent to Deque methods as indicated in the following table:  Comparison of Queue and Deque methods   Queue Method  Equivalent Deque Method   add add(e) addLast addLast(e)   offer offer(e) offerLast offerLast(e)   remove remove() removeFirst removeFirst()   poll poll() pollFirst pollFirst()   element element() getFirst getFirst()   peek peek() peek peekFirst()   Deques can also be used as LIFO (Last-In-First-Out) stacks. This interface should be used in preference to the legacy Stack class. When a deque is used as a stack, elements are pushed and popped from the beginning of the deque. Stack methods are precisely equivalent to Deque methods as indicated in the table below:  Comparison of Stack and Deque methods   Stack Method  Equivalent Deque Method   push push(e) addFirst addFirst(e)   pop pop() removeFirst removeFirst()   peek peek() peekFirst peekFirst()   Note that the peek method works equally well when a deque is used as a queue or a stack; in either case, elements are drawn from the beginning of the deque. This interface provides two methods to remove interior elements, removeFirstOccurrence and removeLastOccurrence. Unlike the List interface, this interface does not provide support for indexed access to elements. While Deque implementations are not strictly required to prohibit the insertion of null elements, they are strongly encouraged to do so. Users of any Deque implementations that do allow null elements are strongly encouraged not to take advantage of the ability to insert nulls. This is so because null is used as a special return value by various methods to indicated that the deque is empty. Deque implementations generally do not define element-based versions of the equals and hashCode methods, but instead inherit the identity-based versions from class Object. This interface is a member of the  Java Collections Framework.
java.util.Deque: java.util.Deque.add	(	E	):  Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque) if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an IllegalStateException if no space is currently available. When using a capacity-restricted deque, it is generally preferable to use offer(). This method is equivalent to addLast.
java.util.Deque: java.util.Deque.addFirst	(	E	):  Inserts the specified element at the front of this deque if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available. When using a capacity-restricted deque, it is generally preferable to use method offerFirst.
java.util.Deque: java.util.Deque.addLast	(	E	):  Inserts the specified element at the end of this deque if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available. When using a capacity-restricted deque, it is generally preferable to use method offerLast. This method is equivalent to add.
java.util.Deque: java.util.Deque.contains	(	Object	):  Returns true if this deque contains the specified element. More formally, returns true if and only if this deque contains at least one element e such that (o==null ? e==null : o.equals(e)).
java.util.Deque: java.util.Deque.descendingIterator	(	):  Returns an iterator over the elements in this deque in reverse sequential order. The elements will be returned in order from last (tail) to first (head).
java.util.Deque: java.util.Deque.element	(	):  Retrieves, but does not remove, the head of the queue represented by this deque (in other words, the first element of this deque). This method differs from peek only in that it throws an exception if this deque is empty. This method is equivalent to getFirst().
java.util.Deque: java.util.Deque.getFirst	(	):  Retrieves, but does not remove, the first element of this deque. This method differs from peekFirst only in that it throws an exception if this deque is empty.
java.util.Deque: java.util.Deque.getLast	(	):  Retrieves, but does not remove, the last element of this deque. This method differs from peekLast only in that it throws an exception if this deque is empty.
java.util.Deque: java.util.Deque.iterator	(	):  Returns an iterator over the elements in this deque in proper sequence. The elements will be returned in order from first (head) to last (tail).
java.util.Deque: java.util.Deque.offer	(	E	):  Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque) if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available. When using a capacity-restricted deque, this method is generally preferable to the add method, which can fail to insert an element only by throwing an exception. This method is equivalent to offerLast.
java.util.Deque: java.util.Deque.offerFirst	(	E	):  Inserts the specified element at the front of this deque unless it would violate capacity restrictions. When using a capacity-restricted deque, this method is generally preferable to the addFirst method, which can fail to insert an element only by throwing an exception.
java.util.Deque: java.util.Deque.offerLast	(	E	):  Inserts the specified element at the end of this deque unless it would violate capacity restrictions. When using a capacity-restricted deque, this method is generally preferable to the addLast method, which can fail to insert an element only by throwing an exception.
java.util.Deque: java.util.Deque.peek	(	):  Retrieves, but does not remove, the head of the queue represented by this deque (in other words, the first element of this deque), or returns null if this deque is empty. This method is equivalent to peekFirst().
java.util.Deque: java.util.Deque.peekFirst	(	):  Retrieves, but does not remove, the first element of this deque, or returns null if this deque is empty.
java.util.Deque: java.util.Deque.peekLast	(	):  Retrieves, but does not remove, the last element of this deque, or returns null if this deque is empty.
java.util.Deque: java.util.Deque.poll	(	):  Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque), or returns null if this deque is empty. This method is equivalent to pollFirst().
java.util.Deque: java.util.Deque.pollFirst	(	):  Retrieves and removes the first element of this deque, or returns null if this deque is empty.
java.util.Deque: java.util.Deque.pollLast	(	):  Retrieves and removes the last element of this deque, or returns null if this deque is empty.
java.util.Deque: java.util.Deque.pop	(	):  Pops an element from the stack represented by this deque. In other words, removes and returns the first element of this deque. This method is equivalent to removeFirst().
java.util.Deque: java.util.Deque.push	(	E	):  Pushes an element onto the stack represented by this deque (in other words, at the head of this deque) if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available. This method is equivalent to addFirst.
java.util.Deque: java.util.Deque.remove	(	):  Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque). This method differs from poll only in that it throws an exception if this deque is empty. This method is equivalent to removeFirst().
java.util.Deque: java.util.Deque.remove	(	Object	):  Removes the first occurrence of the specified element from this deque. If the deque does not contain the element, it is unchanged. More formally, removes the first element e such that (o==null ? e==null : o.equals(e)) (if such an element exists). Returns true if this deque contained the specified element (or equivalently, if this deque changed as a result of the call). This method is equivalent to removeFirstOccurrence().
java.util.Deque: java.util.Deque.removeFirst	(	):  Retrieves and removes the first element of this deque. This method differs from pollFirst only in that it throws an exception if this deque is empty.
java.util.Deque: java.util.Deque.removeFirstOccurrence	(	Object	):  Removes the first occurrence of the specified element from this deque. If the deque does not contain the element, it is unchanged. More formally, removes the first element e such that (o==null ? e==null : o.equals(e)) (if such an element exists). Returns true if this deque contained the specified element (or equivalently, if this deque changed as a result of the call).
java.util.Deque: java.util.Deque.removeLast	(	):  Retrieves and removes the last element of this deque. This method differs from pollLast only in that it throws an exception if this deque is empty.
java.util.Deque: java.util.Deque.removeLastOccurrence	(	Object	):  Removes the last occurrence of the specified element from this deque. If the deque does not contain the element, it is unchanged. More formally, removes the last element e such that (o==null ? e==null : o.equals(e)) (if such an element exists). Returns true if this deque contained the specified element (or equivalently, if this deque changed as a result of the call).
java.util.Deque: java.util.Deque.size	(	):  Returns the number of elements in this deque.
java.util.LinkedList: java.util.LinkedList:  Doubly-linked list implementation of the List and Deque interfaces. Implements all optional list operations, and permits all elements (including null). All of the operations perform as could be expected for a doubly-linked list. Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index. Note that this implementation is not synchronized. If multiple threads access a linked list concurrently, and at least one of the threads modifies the list structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more elements; merely setting the value of an element is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the list. If no such object exists, the list should be "wrapped" using the synchronizedList Collections.synchronizedList method. This is best done at creation time, to prevent accidental unsynchronized access to the list: List list = Collections.synchronizedList(new LinkedList(...)); The iterators returned by this class's iterator and listIterator methods are fail-fast: if the list is structurally modified at any time after the iterator is created, in any way except through the Iterator's own remove or add methods, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. This class is a member of the  Java Collections Framework.
java.util.LinkedList: java.util.LinkedList.DescendingIterator:  Adapter to provide descending iterators via ListItr.previous
java.util.LinkedList: java.util.LinkedList.LLSpliterator:  A customized variant of Spliterators.IteratorSpliterator 
java.util.LinkedList: java.util.LinkedList.LinkedList	(	):  Constructs an empty list.
java.util.LinkedList: java.util.LinkedList.LinkedList	(	Collection	):  Constructs a list containing the elements of the specified collection, in the order they are returned by the collection's iterator.
java.util.LinkedList: java.util.LinkedList.add	(	E	):  Appends the specified element to the end of this list. This method is equivalent to addLast.
java.util.LinkedList: java.util.LinkedList.add	(	int	E	):  Inserts the specified element at the specified position in this list. Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices).
java.util.LinkedList: java.util.LinkedList.addAll	(	Collection	):  Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's iterator. The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (Note that this will occur if the specified collection is this list, and it's nonempty.)
java.util.LinkedList: java.util.LinkedList.addAll	(	int	Collection	):  Inserts all of the elements in the specified collection into this list, starting at the specified position. Shifts the element currently at that position (if any) and any subsequent elements to the right (increases their indices). The new elements will appear in the list in the order that they are returned by the specified collection's iterator.
java.util.LinkedList: java.util.LinkedList.addFirst	(	E	):  Inserts the specified element at the beginning of this list.
java.util.LinkedList: java.util.LinkedList.addLast	(	E	):  Appends the specified element to the end of this list. This method is equivalent to add.
java.util.LinkedList: java.util.LinkedList.clear	(	):  Removes all of the elements from this list. The list will be empty after this call returns.
java.util.LinkedList: java.util.LinkedList.clone	(	):  Returns a shallow copy of this LinkedList. (The elements themselves are not cloned.)
java.util.LinkedList: java.util.LinkedList.contains	(	Object	):  Returns true if this list contains the specified element. More formally, returns true if and only if this list contains at least one element e such that (o==null ? e==null : o.equals(e)).
java.util.LinkedList: java.util.LinkedList.descendingIterator	(	):  Returns an iterator over the elements in this deque in reverse sequential order. The elements will be returned in order from last (tail) to first (head).
java.util.LinkedList: java.util.LinkedList.element	(	):  Retrieves, but does not remove, the head (first element) of this list.
java.util.LinkedList: java.util.LinkedList.get	(	int	):  Returns the element at the specified position in this list.
java.util.LinkedList: java.util.LinkedList.getFirst	(	):  Returns the first element in this list.
java.util.LinkedList: java.util.LinkedList.getLast	(	):  Returns the last element in this list.
java.util.LinkedList: java.util.LinkedList.indexOf	(	Object	):  Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.
java.util.LinkedList: java.util.LinkedList.isElementIndex	(	int	):  Tells if the argument is the index of an existing element.
java.util.LinkedList: java.util.LinkedList.isPositionIndex	(	int	):  Tells if the argument is the index of a valid position for an iterator or an add operation.
java.util.LinkedList: java.util.LinkedList.lastIndexOf	(	Object	):  Returns the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the highest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.
java.util.LinkedList: java.util.LinkedList.linkBefore	(	E	Node	):  Inserts element e before non-null Node succ.
java.util.LinkedList: java.util.LinkedList.linkFirst	(	E	):  Links e as first element.
java.util.LinkedList: java.util.LinkedList.linkLast	(	E	):  Links e as last element.
java.util.LinkedList: java.util.LinkedList.listIterator	(	int	):  Returns a list-iterator of the elements in this list (in proper sequence), starting at the specified position in the list. Obeys the general contract of List.listIterator(int). The list-iterator is fail-fast: if the list is structurally modified at any time after the Iterator is created, in any way except through the list-iterator's own remove or add methods, the list-iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.
java.util.LinkedList: java.util.LinkedList.node	(	int	):  Returns the (non-null) Node at the specified element index.
java.util.LinkedList: java.util.LinkedList.offer	(	E	):  Adds the specified element as the tail (last element) of this list.
java.util.LinkedList: java.util.LinkedList.offerFirst	(	E	):  Inserts the specified element at the front of this list.
java.util.LinkedList: java.util.LinkedList.offerLast	(	E	):  Inserts the specified element at the end of this list.
java.util.LinkedList: java.util.LinkedList.outOfBoundsMsg	(	int	):  Constructs an IndexOutOfBoundsException detail message. Of the many possible refactorings of the error handling code, this "outlining" performs best with both server and client VMs.
java.util.LinkedList: java.util.LinkedList.peek	(	):  Retrieves, but does not remove, the head (first element) of this list.
java.util.LinkedList: java.util.LinkedList.peekFirst	(	):  Retrieves, but does not remove, the first element of this list, or returns null if this list is empty.
java.util.LinkedList: java.util.LinkedList.peekLast	(	):  Retrieves, but does not remove, the last element of this list, or returns null if this list is empty.
java.util.LinkedList: java.util.LinkedList.poll	(	):  Retrieves and removes the head (first element) of this list.
java.util.LinkedList: java.util.LinkedList.pollFirst	(	):  Retrieves and removes the first element of this list, or returns null if this list is empty.
java.util.LinkedList: java.util.LinkedList.pollLast	(	):  Retrieves and removes the last element of this list, or returns null if this list is empty.
java.util.LinkedList: java.util.LinkedList.pop	(	):  Pops an element from the stack represented by this list. In other words, removes and returns the first element of this list. This method is equivalent to removeFirst().
java.util.LinkedList: java.util.LinkedList.push	(	E	):  Pushes an element onto the stack represented by this list. In other words, inserts the element at the front of this list. This method is equivalent to addFirst.
java.util.LinkedList: java.util.LinkedList.readObject	(	java.io.ObjectInputStream	):  Reconstitutes this LinkedList instance from a stream (that is, deserializes it).
java.util.LinkedList: java.util.LinkedList.remove	(	):  Retrieves and removes the head (first element) of this list.
java.util.LinkedList: java.util.LinkedList.remove	(	Object	):  Removes the first occurrence of the specified element from this list, if it is present. If this list does not contain the element, it is unchanged. More formally, removes the element with the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))) (if such an element exists). Returns true if this list contained the specified element (or equivalently, if this list changed as a result of the call).
java.util.LinkedList: java.util.LinkedList.remove	(	int	):  Removes the element at the specified position in this list. Shifts any subsequent elements to the left (subtracts one from their indices). Returns the element that was removed from the list.
java.util.LinkedList: java.util.LinkedList.removeFirst	(	):  Removes and returns the first element from this list.
java.util.LinkedList: java.util.LinkedList.removeFirstOccurrence	(	Object	):  Removes the first occurrence of the specified element in this list (when traversing the list from head to tail). If the list does not contain the element, it is unchanged.
java.util.LinkedList: java.util.LinkedList.removeLast	(	):  Removes and returns the last element from this list.
java.util.LinkedList: java.util.LinkedList.removeLastOccurrence	(	Object	):  Removes the last occurrence of the specified element in this list (when traversing the list from head to tail). If the list does not contain the element, it is unchanged.
java.util.LinkedList: java.util.LinkedList.set	(	int	E	):  Replaces the element at the specified position in this list with the specified element.
java.util.LinkedList: java.util.LinkedList.size	(	):  Returns the number of elements in this list.
java.util.LinkedList: java.util.LinkedList.spliterator	(	):  Creates a late-binding and fail-fast Spliterator over the elements in this list. The Spliterator reports SIZED and ORDERED. Overriding implementations should document the reporting of additional characteristic values.
java.util.LinkedList: java.util.LinkedList.toArray	(	):  Returns an array containing all of the elements in this list in proper sequence (from first to last element). The returned array will be "safe" in that no references to it are maintained by this list. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.LinkedList: java.util.LinkedList.toArray	(	T[]	):  Returns an array containing all of the elements in this list in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array. If the list fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this list. If the list fits in the specified array with room to spare (i.e., the array has more elements than the list), the element in the array immediately following the end of the list is set to null. (This is useful in determining the length of the list only if the caller knows that the list does not contain any null elements.) Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a list known to contain only strings. The following code can be used to dump the list into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.LinkedList: java.util.LinkedList.unlink	(	Node	):  Unlinks non-null node x.
java.util.LinkedList: java.util.LinkedList.unlinkFirst	(	Node	):  Unlinks non-null first node f.
java.util.LinkedList: java.util.LinkedList.unlinkLast	(	Node	):  Unlinks non-null last node l.
java.util.LinkedList: java.util.LinkedList.writeObject	(	java.io.ObjectOutputStream	):  Saves the state of this LinkedList instance to a stream (that is, serializes it).
java.util.ArrayDeque: java.util.ArrayDeque:  Resizable-array implementation of the Deque interface. Array deques have no capacity restrictions; they grow as necessary to support usage. They are not thread-safe; in the absence of external synchronization, they do not support concurrent access by multiple threads. Null elements are prohibited. This class is likely to be faster than Stack when used as a stack, and faster than LinkedList when used as a queue. Most ArrayDeque operations run in amortized constant time. Exceptions include remove(), removeFirstOccurrence, removeLastOccurrence , contains, iterator iterator.remove(), and the bulk operations, all of which run in linear time. The iterators returned by this class's iterator method are fail-fast: If the deque is modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will generally throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces. This class is a member of the  Java Collections Framework.
java.util.ArrayDeque: java.util.ArrayDeque.ArrayDeque	(	):  Constructs an empty array deque with an initial capacity sufficient to hold 16 elements.
java.util.ArrayDeque: java.util.ArrayDeque.ArrayDeque	(	Collection	):  Constructs a deque containing the elements of the specified collection, in the order they are returned by the collection's iterator. (The first element returned by the collection's iterator becomes the first element, or front of the deque.)
java.util.ArrayDeque: java.util.ArrayDeque.ArrayDeque	(	int	):  Constructs an empty array deque with an initial capacity sufficient to hold the specified number of elements.
java.util.ArrayDeque: java.util.ArrayDeque.DeqSpliterator.DeqSpliterator	(	ArrayDeque	int	int	):  Creates new spliterator covering the given array and range 
java.util.ArrayDeque: java.util.ArrayDeque.add	(	E	):  Inserts the specified element at the end of this deque. This method is equivalent to addLast.
java.util.ArrayDeque: java.util.ArrayDeque.addFirst	(	E	):  Inserts the specified element at the front of this deque.
java.util.ArrayDeque: java.util.ArrayDeque.addLast	(	E	):  Inserts the specified element at the end of this deque. This method is equivalent to add.
java.util.ArrayDeque: java.util.ArrayDeque.allocateElements	(	int	):  Allocates empty array to hold the given number of elements.
java.util.ArrayDeque: java.util.ArrayDeque.clear	(	):  Removes all of the elements from this deque. The deque will be empty after this call returns.
java.util.ArrayDeque: java.util.ArrayDeque.clone	(	):  Returns a copy of this deque.
java.util.ArrayDeque: java.util.ArrayDeque.contains	(	Object	):  Returns true if this deque contains the specified element. More formally, returns true if and only if this deque contains at least one element e such that o.equals(e).
java.util.ArrayDeque: java.util.ArrayDeque.copyElements	(	T[]	):  Copies the elements from our element array into the specified array, in order (from first to last element in the deque). It is assumed that the array is large enough to hold all elements in the deque.
java.util.ArrayDeque: java.util.ArrayDeque.delete	(	int	):  Removes the element at the specified position in the elements array, adjusting head and tail as necessary. This can result in motion of elements backwards or forwards in the array. This method is called delete rather than remove to emphasize that its semantics differ from those of remove().
java.util.ArrayDeque: java.util.ArrayDeque.doubleCapacity	(	):  Doubles the capacity of this deque. Call only when full, i.e., when head and tail have wrapped around to become equal.
java.util.ArrayDeque: java.util.ArrayDeque.element	(	):  Retrieves, but does not remove, the head of the queue represented by this deque. This method differs from peek only in that it throws an exception if this deque is empty. This method is equivalent to getFirst.
java.util.ArrayDeque: java.util.ArrayDeque.getFirst	(	):  Retrieves, but does not remove, the first element of this deque. This method differs from peekFirst only in that it throws an exception if this deque is empty.
java.util.ArrayDeque: java.util.ArrayDeque.getLast	(	):  Retrieves, but does not remove, the last element of this deque. This method differs from peekLast only in that it throws an exception if this deque is empty.
java.util.ArrayDeque: java.util.ArrayDeque.isEmpty	(	):  Returns true if this deque contains no elements.
java.util.ArrayDeque: java.util.ArrayDeque.iterator	(	):  Returns an iterator over the elements in this deque. The elements will be ordered from first (head) to last (tail). This is the same order that elements would be dequeued (via successive calls to remove or popped (via successive calls to pop).
java.util.ArrayDeque: java.util.ArrayDeque.offer	(	E	):  Inserts the specified element at the end of this deque. This method is equivalent to offerLast.
java.util.ArrayDeque: java.util.ArrayDeque.offerFirst	(	E	):  Inserts the specified element at the front of this deque.
java.util.ArrayDeque: java.util.ArrayDeque.offerLast	(	E	):  Inserts the specified element at the end of this deque.
java.util.ArrayDeque: java.util.ArrayDeque.peek	(	):  Retrieves, but does not remove, the head of the queue represented by this deque, or returns null if this deque is empty. This method is equivalent to peekFirst.
java.util.ArrayDeque: java.util.ArrayDeque.poll	(	):  Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque), or returns null if this deque is empty. This method is equivalent to pollFirst.
java.util.ArrayDeque: java.util.ArrayDeque.pop	(	):  Pops an element from the stack represented by this deque. In other words, removes and returns the first element of this deque. This method is equivalent to removeFirst().
java.util.ArrayDeque: java.util.ArrayDeque.push	(	E	):  Pushes an element onto the stack represented by this deque. In other words, inserts the element at the front of this deque. This method is equivalent to addFirst.
java.util.ArrayDeque: java.util.ArrayDeque.readObject	(	java.io.ObjectInputStream	):  Reconstitutes this deque from a stream (that is, deserializes it).
java.util.ArrayDeque: java.util.ArrayDeque.remove	(	):  Retrieves and removes the head of the queue represented by this deque. This method differs from poll only in that it throws an exception if this deque is empty. This method is equivalent to removeFirst.
java.util.ArrayDeque: java.util.ArrayDeque.remove	(	Object	):  Removes a single instance of the specified element from this deque. If the deque does not contain the element, it is unchanged. More formally, removes the first element e such that o.equals(e) (if such an element exists). Returns true if this deque contained the specified element (or equivalently, if this deque changed as a result of the call). This method is equivalent to removeFirstOccurrence().
java.util.ArrayDeque: java.util.ArrayDeque.removeFirst	(	):  Retrieves and removes the first element of this deque. This method differs from pollFirst only in that it throws an exception if this deque is empty.
java.util.ArrayDeque: java.util.ArrayDeque.removeFirstOccurrence	(	Object	):  Removes the first occurrence of the specified element in this deque (when traversing the deque from head to tail). If the deque does not contain the element, it is unchanged. More formally, removes the first element e such that o.equals(e) (if such an element exists). Returns true if this deque contained the specified element (or equivalently, if this deque changed as a result of the call).
java.util.ArrayDeque: java.util.ArrayDeque.removeLast	(	):  Retrieves and removes the last element of this deque. This method differs from pollLast only in that it throws an exception if this deque is empty.
java.util.ArrayDeque: java.util.ArrayDeque.removeLastOccurrence	(	Object	):  Removes the last occurrence of the specified element in this deque (when traversing the deque from head to tail). If the deque does not contain the element, it is unchanged. More formally, removes the last element e such that o.equals(e) (if such an element exists). Returns true if this deque contained the specified element (or equivalently, if this deque changed as a result of the call).
java.util.ArrayDeque: java.util.ArrayDeque.size	(	):  Returns the number of elements in this deque.
java.util.ArrayDeque: java.util.ArrayDeque.spliterator	(	):  Creates a late-binding and fail-fast Spliterator over the elements in this deque. The Spliterator reports SIZED, SUBSIZED, ORDERED, and NONNULL. Overriding implementations should document the reporting of additional characteristic values.
java.util.ArrayDeque: java.util.ArrayDeque.toArray	(	):  Returns an array containing all of the elements in this deque in proper sequence (from first to last element). The returned array will be "safe" in that no references to it are maintained by this deque. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.ArrayDeque: java.util.ArrayDeque.toArray	(	T[]	):  Returns an array containing all of the elements in this deque in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array. If the deque fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this deque. If this deque fits in the specified array with room to spare (i.e., the array has more elements than this deque), the element in the array immediately following the end of the deque is set to null. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a deque known to contain only strings. The following code can be used to dump the deque into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.ArrayDeque: java.util.ArrayDeque.writeObject	(	java.io.ObjectOutputStream	):  Saves this deque to a stream (that is, serializes it).
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque:  An optionally-bounded BlockingDeque blocking deque based on linked nodes. The optional capacity bound constructor argument serves as a way to prevent excessive expansion. The capacity, if unspecified, is equal to MAX_VALUE. Linked nodes are dynamically created upon each insertion unless this would bring the deque above capacity. Most operations run in constant time (ignoring time spent blocking). Exceptions include remove(), removeFirstOccurrence, removeLastOccurrence, contains , iterator iterator.remove(), and the bulk operations, all of which run in linear time. This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces. This class is a member of the  Java Collections Framework.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.AbstractItr:  Base class for Iterators for LinkedBlockingDeque
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.AbstractItr.advance	(	):  Advances next.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.AbstractItr.succ	(	Node	):  Returns the successor node of the given non-null, but possibly previously deleted, node.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.DescendingItr:  Descending iterator 
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.Itr:  Forward iterator 
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.LBDSpliterator:  A customized variant of Spliterators.IteratorSpliterator 
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.LinkedBlockingDeque	(	):  Creates a LinkedBlockingDeque with a capacity of MAX_VALUE.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.LinkedBlockingDeque	(	Collection	):  Creates a LinkedBlockingDeque with a capacity of MAX_VALUE, initially containing the elements of the given collection, added in traversal order of the collection's iterator.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.LinkedBlockingDeque	(	int	):  Creates a LinkedBlockingDeque with the given (fixed) capacity.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.Node:  Doubly-linked list node class 
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.add	(	E	):  Inserts the specified element at the end of this deque unless it would violate capacity restrictions. When using a capacity-restricted deque, it is generally preferable to use method offer(). This method is equivalent to addLast.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.addFirst	(	E	):  Inserts the specified element at the front of this deque if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available. When using a capacity-restricted deque, it is generally preferable to use offerFirst().
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.addLast	(	E	):  Inserts the specified element at the end of this deque if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available. When using a capacity-restricted deque, it is generally preferable to use offerLast().
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.clear	(	):  Atomically removes all of the elements from this deque. The deque will be empty after this call returns.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.contains	(	Object	):  Returns true if this deque contains the specified element. More formally, returns true if and only if this deque contains at least one element e such that o.equals(e).
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.descendingIterator	(	):  Returns an iterator over the elements in this deque in reverse sequential order. The elements will be returned in order from last (tail) to first (head). The returned iterator is weakly consistent.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.drainTo	(	Collection	):  Removes all available elements from this queue and adds them to the given collection. This operation may be more efficient than repeatedly polling this queue. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.drainTo	(	Collection	int	):  Removes at most the given number of available elements from this queue and adds them to the given collection. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.element	(	):  Retrieves, but does not remove, the head of the queue represented by this deque. This method differs from peek only in that it throws an exception if this deque is empty. This method is equivalent to getFirst().
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.getFirst	(	):  Retrieves, but does not remove, the first element of this deque. This method differs from peekFirst only in that it throws an exception if this deque is empty.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.getLast	(	):  Retrieves, but does not remove, the last element of this deque. This method differs from peekLast only in that it throws an exception if this deque is empty.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.iterator	(	):  Returns an iterator over the elements in this deque in proper sequence. The elements will be returned in order from first (head) to last (tail). The returned iterator is weakly consistent.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.linkFirst	(	Node	):  Links node as first element, or returns false if full.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.linkLast	(	Node	):  Links node as last element, or returns false if full.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.offer	(	E	):  Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions. When using a capacity-restricted queue, this method is generally preferable to add, which can fail to insert an element only by throwing an exception.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.offer	(	E	long	TimeUnit	):  Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque), waiting up to the specified wait time if necessary for space to become available. This method is equivalent to offerLast().
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.offerFirst	(	E	):  Inserts the specified element at the front of this deque if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available. When using a capacity-restricted deque, this method is generally preferable to the addFirst() method, which can fail to insert an element only by throwing an exception.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.offerFirst	(	E	long	TimeUnit	):  Inserts the specified element at the front of this deque, waiting up to the specified wait time if necessary for space to become available.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.offerLast	(	E	):  Inserts the specified element at the end of this deque if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available. When using a capacity-restricted deque, this method is generally preferable to the addLast() method, which can fail to insert an element only by throwing an exception.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.offerLast	(	E	long	TimeUnit	):  Inserts the specified element at the end of this deque, waiting up to the specified wait time if necessary for space to become available.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.pop	(	):  Pops an element from the stack represented by this deque. In other words, removes and returns the first element of this deque. This method is equivalent to removeFirst().
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.push	(	E	):  Pushes an element onto the stack represented by this deque (in other words, at the head of this deque) if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available. This method is equivalent to addFirst().
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.put	(	E	):  Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque), waiting if necessary for space to become available. This method is equivalent to putLast().
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.putFirst	(	E	):  Inserts the specified element at the front of this deque, waiting if necessary for space to become available.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.putLast	(	E	):  Inserts the specified element at the end of this deque, waiting if necessary for space to become available.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.readObject	(	java.io.ObjectInputStream	):  Reconstitutes this deque from a stream (that is, deserializes it).
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.remainingCapacity	(	):  Returns the number of additional elements that this deque can ideally (in the absence of memory or resource constraints) accept without blocking. This is always equal to the initial capacity of this deque less the current size of this deque. Note that you cannot always tell if an attempt to insert an element will succeed by inspecting remainingCapacity because it may be the case that another thread is about to insert or remove an element.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.remove	(	):  Retrieves and removes the head of the queue represented by this deque. This method differs from poll only in that it throws an exception if this deque is empty. This method is equivalent to removeFirst().
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.remove	(	Object	):  Removes the first occurrence of the specified element from this deque. If the deque does not contain the element, it is unchanged. More formally, removes the first element e such that o.equals(e) (if such an element exists). Returns true if this deque contained the specified element (or equivalently, if this deque changed as a result of the call). This method is equivalent to removeFirstOccurrence().
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.removeFirst	(	):  Retrieves and removes the first element of this deque. This method differs from pollFirst only in that it throws an exception if this deque is empty.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.removeLast	(	):  Retrieves and removes the last element of this deque. This method differs from pollLast only in that it throws an exception if this deque is empty.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.size	(	):  Returns the number of elements in this deque.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.spliterator	(	):  Returns a Spliterator over the elements in this deque. The returned spliterator is weakly consistent. The Spliterator reports CONCURRENT, ORDERED, and NONNULL.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.toArray	(	):  Returns an array containing all of the elements in this deque, in proper sequence (from first to last element). The returned array will be "safe" in that no references to it are maintained by this deque. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.toArray	(	T[]	):  Returns an array containing all of the elements in this deque, in proper sequence; the runtime type of the returned array is that of the specified array. If the deque fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this deque. If this deque fits in the specified array with room to spare (i.e., the array has more elements than this deque), the element in the array immediately following the end of the deque is set to null. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a deque known to contain only strings. The following code can be used to dump the deque into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.unlink	(	Node	):  Unlinks x.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.unlinkFirst	(	):  Removes and returns first element, or null if empty.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.unlinkLast	(	):  Removes and returns last element, or null if empty.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.writeObject	(	java.io.ObjectOutputStream	):  Saves this deque to a stream (that is, serializes it).
java.util.HashSet: java.util.HashSet:  This class implements the Set interface, backed by a hash table (actually a HashMap instance). It makes no guarantees as to the iteration order of the set; in particular, it does not guarantee that the order will remain constant over time. This class permits the null element. This class offers constant time performance for the basic operations (add, remove, contains and size), assuming the hash function disperses the elements properly among the buckets. Iterating over this set requires time proportional to the sum of the HashSet instance's size (the number of elements) plus the "capacity" of the backing HashMap instance (the number of buckets). Thus, it's very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important. Note that this implementation is not synchronized. If multiple threads access a hash set concurrently, and at least one of the threads modifies the set, it must be synchronized externally. This is typically accomplished by synchronizing on some object that naturally encapsulates the set. If no such object exists, the set should be "wrapped" using the synchronizedSet Collections.synchronizedSet method. This is best done at creation time, to prevent accidental unsynchronized access to the set: Set s = Collections.synchronizedSet(new HashSet(...)); The iterators returned by this class's iterator method are fail-fast: if the set is modified at any time after the iterator is created, in any way except through the iterator's own remove method, the Iterator throws a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. This class is a member of the  Java Collections Framework.
java.util.HashSet: java.util.HashSet.HashSet	(	):  Constructs a new, empty set; the backing HashMap instance has default initial capacity (16) and load factor (0.75).
java.util.HashSet: java.util.HashSet.HashSet	(	Collection	):  Constructs a new set containing the elements in the specified collection. The HashMap is created with default load factor (0.75) and an initial capacity sufficient to contain the elements in the specified collection.
java.util.HashSet: java.util.HashSet.HashSet	(	int	):  Constructs a new, empty set; the backing HashMap instance has the specified initial capacity and default load factor (0.75).
java.util.HashSet: java.util.HashSet.HashSet	(	int	float	):  Constructs a new, empty set; the backing HashMap instance has the specified initial capacity and the specified load factor.
java.util.HashSet: java.util.HashSet.HashSet	(	int	float	boolean	):  Constructs a new, empty linked hash set. (This package private constructor is only used by LinkedHashSet.) The backing HashMap instance is a LinkedHashMap with the specified initial capacity and the specified load factor.
java.util.HashSet: java.util.HashSet.add	(	E	):  Adds the specified element to this set if it is not already present. More formally, adds the specified element e to this set if this set contains no element e2 such that (e==null ? e2==null : e.equals(e2)). If this set already contains the element, the call leaves the set unchanged and returns false.
java.util.HashSet: java.util.HashSet.clear	(	):  Removes all of the elements from this set. The set will be empty after this call returns.
java.util.HashSet: java.util.HashSet.clone	(	):  Returns a shallow copy of this HashSet instance: the elements themselves are not cloned.
java.util.HashSet: java.util.HashSet.contains	(	Object	):  Returns true if this set contains the specified element. More formally, returns true if and only if this set contains an element e such that (o==null ? e==null : o.equals(e)).
java.util.HashSet: java.util.HashSet.isEmpty	(	):  Returns true if this set contains no elements.
java.util.HashSet: java.util.HashSet.iterator	(	):  Returns an iterator over the elements in this set. The elements are returned in no particular order.
java.util.HashSet: java.util.HashSet.readObject	(	java.io.ObjectInputStream	):  Reconstitute the HashSet instance from a stream (that is, deserialize it).
java.util.HashSet: java.util.HashSet.remove	(	Object	):  Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)
java.util.HashSet: java.util.HashSet.size	(	):  Returns the number of elements in this set (its cardinality).
java.util.HashSet: java.util.HashSet.spliterator	(	):  Creates a late-binding and fail-fast Spliterator over the elements in this set. The Spliterator reports SIZED and DISTINCT. Overriding implementations should document the reporting of additional characteristic values.
java.util.HashSet: java.util.HashSet.writeObject	(	java.io.ObjectOutputStream	):  Save the state of this HashSet instance to a stream (that is, serialize it).
java.util.TreeSet: java.util.TreeSet:  A NavigableSet implementation based on a TreeMap. The elements are ordered using their Comparable natural ordering, or by a Comparator provided at set creation time, depending on which constructor is used. This implementation provides guaranteed log(n) time cost for the basic operations (add, remove and contains). Note that the ordering maintained by a set (whether or not an explicit comparator is provided) must be consistent with equals if it is to correctly implement the Set interface. (See Comparable or Comparator for a precise definition of consistent with equals.) This is so because the Set interface is defined in terms of the equals operation, but a TreeSet instance performs all element comparisons using its compareTo (or compare) method, so two elements that are deemed equal by this method are, from the standpoint of the set, equal. The behavior of a set is well-defined even if its ordering is inconsistent with equals; it just fails to obey the general contract of the Set interface. Note that this implementation is not synchronized. If multiple threads access a tree set concurrently, and at least one of the threads modifies the set, it must be synchronized externally. This is typically accomplished by synchronizing on some object that naturally encapsulates the set. If no such object exists, the set should be "wrapped" using the synchronizedSortedSet Collections.synchronizedSortedSet method. This is best done at creation time, to prevent accidental unsynchronized access to the set:  SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...)); The iterators returned by this class's iterator method are fail-fast: if the set is modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. This class is a member of the  Java Collections Framework.
java.util.TreeSet: java.util.TreeSet.TreeSet	(	):  Constructs a new, empty tree set, sorted according to the natural ordering of its elements. All elements inserted into the set must implement the Comparable interface. Furthermore, all such elements must be mutually comparable: e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the set. If the user attempts to add an element to the set that violates this constraint (for example, the user attempts to add a string element to a set whose elements are integers), the add call will throw a ClassCastException.
java.util.TreeSet: java.util.TreeSet.TreeSet	(	Collection	):  Constructs a new tree set containing the elements in the specified collection, sorted according to the natural ordering of its elements. All elements inserted into the set must implement the Comparable interface. Furthermore, all such elements must be mutually comparable: e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the set.
java.util.TreeSet: java.util.TreeSet.TreeSet	(	Comparator	):  Constructs a new, empty tree set, sorted according to the specified comparator. All elements inserted into the set must be mutually comparable by the specified comparator: comparator.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the set. If the user attempts to add an element to the set that violates this constraint, the add call will throw a ClassCastException.
java.util.TreeSet: java.util.TreeSet.TreeSet	(	NavigableMap	):  Constructs a set backed by the specified navigable map.
java.util.TreeSet: java.util.TreeSet.TreeSet	(	SortedSet	):  Constructs a new tree set containing the same elements and using the same ordering as the specified sorted set.
java.util.TreeSet: java.util.TreeSet.add	(	E	):  Adds the specified element to this set if it is not already present. More formally, adds the specified element e to this set if the set contains no element e2 such that (e==null ? e2==null : e.equals(e2)). If this set already contains the element, the call leaves the set unchanged and returns false.
java.util.TreeSet: java.util.TreeSet.addAll	(	Collection	):  Adds all of the elements in the specified collection to this set.
java.util.TreeSet: java.util.TreeSet.ceiling	(	E	):  Returns the least element in this set greater than or equal to the given element, or null if there is no such element.
java.util.TreeSet: java.util.TreeSet.clear	(	):  Removes all of the elements from this set. The set will be empty after this call returns.
java.util.TreeSet: java.util.TreeSet.clone	(	):  Returns a shallow copy of this TreeSet instance. (The elements themselves are not cloned.)
java.util.TreeSet: java.util.TreeSet.contains	(	Object	):  Returns true if this set contains the specified element. More formally, returns true if and only if this set contains an element e such that (o==null ? e==null : o.equals(e)).
java.util.TreeSet: java.util.TreeSet.descendingIterator	(	):  Returns an iterator over the elements in this set in descending order.
java.util.TreeSet: java.util.TreeSet.descendingSet	(	):  Returns a reverse order view of the elements contained in this set. The descending set is backed by this set, so changes to the set are reflected in the descending set, and vice-versa. If either set is modified while an iteration over either set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The returned set has an ordering equivalent to reverseOrder() Collections.reverseOrder(comparator()). The expression s.descendingSet().descendingSet() returns a view of s essentially equivalent to s.
java.util.TreeSet: java.util.TreeSet.first	(	):  Returns the first (lowest) element currently in this set.
java.util.TreeSet: java.util.TreeSet.floor	(	E	):  Returns the greatest element in this set less than or equal to the given element, or null if there is no such element.
java.util.TreeSet: java.util.TreeSet.headSet	(	E	):  Returns a view of the portion of this set whose elements are strictly less than toElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range. Equivalent to headSet(toElement, false).
java.util.TreeSet: java.util.TreeSet.headSet	(	E	boolean	):  Returns a view of the portion of this set whose elements are less than (or equal to, if inclusive is true) toElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range.
java.util.TreeSet: java.util.TreeSet.higher	(	E	):  Returns the least element in this set strictly greater than the given element, or null if there is no such element.
java.util.TreeSet: java.util.TreeSet.isEmpty	(	):  Returns true if this set contains no elements.
java.util.TreeSet: java.util.TreeSet.iterator	(	):  Returns an iterator over the elements in this set in ascending order.
java.util.TreeSet: java.util.TreeSet.last	(	):  Returns the last (highest) element currently in this set.
java.util.TreeSet: java.util.TreeSet.lower	(	E	):  Returns the greatest element in this set strictly less than the given element, or null if there is no such element.
java.util.TreeSet: java.util.TreeSet.pollFirst	(	):  Retrieves and removes the first (lowest) element, or returns null if this set is empty.
java.util.TreeSet: java.util.TreeSet.pollLast	(	):  Retrieves and removes the last (highest) element, or returns null if this set is empty.
java.util.TreeSet: java.util.TreeSet.readObject	(	java.io.ObjectInputStream	):  Reconstitute the TreeSet instance from a stream (that is, deserialize it).
java.util.TreeSet: java.util.TreeSet.remove	(	Object	):  Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)
java.util.TreeSet: java.util.TreeSet.size	(	):  Returns the number of elements in this set (its cardinality).
java.util.TreeSet: java.util.TreeSet.spliterator	(	):  Creates a late-binding and fail-fast Spliterator over the elements in this set. The Spliterator reports SIZED, DISTINCT, SORTED, and ORDERED. Overriding implementations should document the reporting of additional characteristic values. The spliterator's comparator (see getComparator()) is null if the tree set's comparator (see comparator()) is null. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the tree set's comparator.
java.util.TreeSet: java.util.TreeSet.subSet	(	E	E	):  Returns a view of the portion of this set whose elements range from fromElement, inclusive, to toElement, exclusive. (If fromElement and toElement are equal, the returned set is empty.) The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range. Equivalent to subSet(fromElement, true, toElement, false).
java.util.TreeSet: java.util.TreeSet.subSet	(	E	boolean	E	boolean	):  Returns a view of the portion of this set whose elements range from fromElement to toElement. If fromElement and toElement are equal, the returned set is empty unless fromInclusive and toInclusive are both true. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range.
java.util.TreeSet: java.util.TreeSet.tailSet	(	E	):  Returns a view of the portion of this set whose elements are greater than or equal to fromElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range. Equivalent to tailSet(fromElement, true).
java.util.TreeSet: java.util.TreeSet.tailSet	(	E	boolean	):  Returns a view of the portion of this set whose elements are greater than (or equal to, if inclusive is true) fromElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range.
java.util.TreeSet: java.util.TreeSet.writeObject	(	java.io.ObjectOutputStream	):  Save the state of the TreeSet instance to a stream (that is, serialize it).
java.util.LinkedHashSet: java.util.LinkedHashSet:  Hash table and linked list implementation of the Set interface, with predictable iteration order. This implementation differs from HashSet in that it maintains a doubly-linked list running through all of its entries. This linked list defines the iteration ordering, which is the order in which elements were inserted into the set (insertion-order). Note that insertion order is not affected if an element is re-inserted into the set. (An element e is reinserted into a set s if s.add(e) is invoked when s.contains(e) would return true immediately prior to the invocation.) This implementation spares its clients from the unspecified, generally chaotic ordering provided by HashSet, without incurring the increased cost associated with TreeSet. It can be used to produce a copy of a set that has the same order as the original, regardless of the original set's implementation:  void foo(Set s) { Set copy = new LinkedHashSet(s); ... }  This technique is particularly useful if a module takes a set on input, copies it, and later returns results whose order is determined by that of the copy. (Clients generally appreciate having things returned in the same order they were presented.) This class provides all of the optional Set operations, and permits null elements. Like HashSet, it provides constant-time performance for the basic operations (add, contains and remove), assuming the hash function disperses elements properly among the buckets. Performance is likely to be just slightly below that of HashSet, due to the added expense of maintaining the linked list, with one exception: Iteration over a LinkedHashSet requires time proportional to the size of the set, regardless of its capacity. Iteration over a HashSet is likely to be more expensive, requiring time proportional to its capacity. A linked hash set has two parameters that affect its performance: initial capacity and load factor. They are defined precisely as for HashSet. Note, however, that the penalty for choosing an excessively high value for initial capacity is less severe for this class than for HashSet, as iteration times for this class are unaffected by capacity. Note that this implementation is not synchronized. If multiple threads access a linked hash set concurrently, and at least one of the threads modifies the set, it must be synchronized externally. This is typically accomplished by synchronizing on some object that naturally encapsulates the set. If no such object exists, the set should be "wrapped" using the synchronizedSet Collections.synchronizedSet method. This is best done at creation time, to prevent accidental unsynchronized access to the set:  Set s = Collections.synchronizedSet(new LinkedHashSet(...)); The iterators returned by this class's iterator method are fail-fast: if the set is modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. This class is a member of the  Java Collections Framework.
java.util.LinkedHashSet: java.util.LinkedHashSet.LinkedHashSet	(	):  Constructs a new, empty linked hash set with the default initial capacity (16) and load factor (0.75).
java.util.LinkedHashSet: java.util.LinkedHashSet.LinkedHashSet	(	Collection	):  Constructs a new linked hash set with the same elements as the specified collection. The linked hash set is created with an initial capacity sufficient to hold the elements in the specified collection and the default load factor (0.75).
java.util.LinkedHashSet: java.util.LinkedHashSet.LinkedHashSet	(	int	):  Constructs a new, empty linked hash set with the specified initial capacity and the default load factor (0.75).
java.util.LinkedHashSet: java.util.LinkedHashSet.LinkedHashSet	(	int	float	):  Constructs a new, empty linked hash set with the specified initial capacity and load factor.
java.util.LinkedHashSet: java.util.LinkedHashSet.spliterator	(	):  Creates a late-binding and fail-fast Spliterator over the elements in this set. The Spliterator reports SIZED, DISTINCT, and ORDERED. Implementations should document the reporting of additional characteristic values.
java.util.Queue: java.util.Queue:  A collection designed for holding elements prior to processing. Besides basic java.util.Collection Collection operations, queues provide additional insertion, extraction, and inspection operations. Each of these methods exists in two forms: one throws an exception if the operation fails, the other returns a special value (either null or false, depending on the operation). The latter form of the insert operation is designed specifically for use with capacity-restricted Queue implementations; in most implementations, insert operations cannot fail.  Summary of Queue methods   Throws exception Returns special value   Insert add add(e) offer offer(e)   Remove remove remove() poll poll()   Examine element element() peek peek()   Queues typically, but do not necessarily, order elements in a FIFO (first-in-first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator, or the elements' natural ordering, and LIFO queues (or stacks) which order the elements LIFO (last-in-first-out). Whatever the ordering used, the head of the queue is that element which would be removed by a call to remove() or poll(). In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. The offer method inserts an element if possible, otherwise returning false. This differs from the add Collection.add method, which can fail to add an element only by throwing an unchecked exception. The offer method is designed for use when failure is a normal, rather than exceptional occurrence, for example, in fixed-capacity (or "bounded") queues. The remove() and poll() methods remove and return the head of the queue. Exactly which element is removed from the queue is a function of the queue's ordering policy, which differs from implementation to implementation. The remove() and poll() methods differ only in their behavior when the queue is empty: the remove() method throws an exception, while the poll() method returns null. The element() and peek() methods return, but do not remove, the head of the queue. The Queue interface does not define the blocking queue methods, which are common in concurrent programming. These methods, which wait for elements to appear or for space to become available, are defined in the java.util.concurrent.BlockingQueue interface, which extends this interface. Queue implementations generally do not allow insertion of null elements, although some implementations, such as LinkedList, do not prohibit insertion of null. Even in the implementations that permit it, null should not be inserted into a Queue, as null is also used as a special return value by the poll method to indicate that the queue contains no elements. Queue implementations generally do not define element-based versions of methods equals and hashCode but instead inherit the identity based versions from class Object, because element-based equality is not always well-defined for queues with the same elements but different ordering properties. This interface is a member of the  Java Collections Framework.
java.util.Queue: java.util.Queue.add	(	E	):  Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an IllegalStateException if no space is currently available.
java.util.Queue: java.util.Queue.element	(	):  Retrieves, but does not remove, the head of this queue. This method differs from peek only in that it throws an exception if this queue is empty.
java.util.Queue: java.util.Queue.offer	(	E	):  Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions. When using a capacity-restricted queue, this method is generally preferable to add, which can fail to insert an element only by throwing an exception.
java.util.Queue: java.util.Queue.peek	(	):  Retrieves, but does not remove, the head of this queue, or returns null if this queue is empty.
java.util.Queue: java.util.Queue.poll	(	):  Retrieves and removes the head of this queue, or returns null if this queue is empty.
java.util.Queue: java.util.Queue.remove	(	):  Retrieves and removes the head of this queue. This method differs from poll only in that it throws an exception if this queue is empty.
java.util.TreeMap: java.util.TreeMap:  A Red-Black tree based NavigableMap implementation. The map is sorted according to the Comparable natural ordering of its keys, or by a Comparator provided at map creation time, depending on which constructor is used. This implementation provides guaranteed log(n) time cost for the containsKey, get, put and remove operations. Algorithms are adaptations of those in Cormen, Leiserson, and Rivest's Introduction to Algorithms. Note that the ordering maintained by a tree map, like any sorted map, and whether or not an explicit comparator is provided, must be consistent with equals if this sorted map is to correctly implement the Map interface. (See Comparable or Comparator for a precise definition of consistent with equals.) This is so because the Map interface is defined in terms of the equals operation, but a sorted map performs all key comparisons using its compareTo (or compare) method, so two keys that are deemed equal by this method are, from the standpoint of the sorted map, equal. The behavior of a sorted map is well-defined even if its ordering is inconsistent with equals; it just fails to obey the general contract of the Map interface. Note that this implementation is not synchronized. If multiple threads access a map concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more mappings; merely changing the value associated with an existing key is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the map. If no such object exists, the map should be "wrapped" using the synchronizedSortedMap Collections.synchronizedSortedMap method. This is best done at creation time, to prevent accidental unsynchronized access to the map:  SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...)); The iterators returned by the iterator method of the collections returned by all of this class's "collection view methods" are fail-fast: if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. All Map.Entry pairs returned by methods in this class and its views represent snapshots of mappings at the time they were produced. They do not support the Entry.setValue method. (Note however that it is possible to change mappings in the associated map using put.) This class is a member of the  Java Collections Framework.
java.util.TreeMap: java.util.TreeMap.Entry:  Node in the Tree. Doubles as a means to pass key-value pairs back to user (see Map.Entry).
java.util.TreeMap: java.util.TreeMap.Entry.Entry	(	K	V	Entry	):  Make a new cell with given key, value, and parent, and with null child links, and BLACK color.
java.util.TreeMap: java.util.TreeMap.Entry.getKey	(	):  Returns the key.
java.util.TreeMap: java.util.TreeMap.Entry.getValue	(	):  Returns the value associated with the key.
java.util.TreeMap: java.util.TreeMap.Entry.setValue	(	V	):  Replaces the value currently associated with the key with the given value.
java.util.TreeMap: java.util.TreeMap.NavigableSubMap.SubMapIterator:  Iterators for SubMaps
java.util.TreeMap: java.util.TreeMap.NavigableSubMap.absHighFence	(	):  Returns the absolute high fence for ascending traversal 
java.util.TreeMap: java.util.TreeMap.NavigableSubMap.absLowFence	(	):  Return the absolute low fence for descending traversal 
java.util.TreeMap: java.util.TreeMap.NavigableSubMap.descendingKeyIterator	(	):  Returns descending iterator from the perspective of this submap 
java.util.TreeMap: java.util.TreeMap.NavigableSubMap.keyIterator	(	):  Returns ascending iterator from the perspective of this submap 
java.util.TreeMap: java.util.TreeMap.PrivateEntryIterator:  Base class for TreeMap Iterators
java.util.TreeMap: java.util.TreeMap.SubMap:  This class exists solely for the sake of serialization compatibility with previous releases of TreeMap that did not support NavigableMap. It translates an old-version SubMap into a new-version AscendingSubMap. This class is never otherwise used.
java.util.TreeMap: java.util.TreeMap.TreeMap	(	):  Constructs a new, empty tree map, using the natural ordering of its keys. All keys inserted into the map must implement the Comparable interface. Furthermore, all such keys must be mutually comparable: k1.compareTo(k2) must not throw a ClassCastException for any keys k1 and k2 in the map. If the user attempts to put a key into the map that violates this constraint (for example, the user attempts to put a string key into a map whose keys are integers), the put(Object key, Object value) call will throw a ClassCastException.
java.util.TreeMap: java.util.TreeMap.TreeMap	(	Comparator	):  Constructs a new, empty tree map, ordered according to the given comparator. All keys inserted into the map must be mutually comparable by the given comparator: comparator.compare(k1, k2) must not throw a ClassCastException for any keys k1 and k2 in the map. If the user attempts to put a key into the map that violates this constraint, the put(Object key, Object value) call will throw a ClassCastException.
java.util.TreeMap: java.util.TreeMap.TreeMap	(	Map	):  Constructs a new tree map containing the same mappings as the given map, ordered according to the natural ordering of its keys. All keys inserted into the new map must implement the Comparable interface. Furthermore, all such keys must be mutually comparable: k1.compareTo(k2) must not throw a ClassCastException for any keys k1 and k2 in the map. This method runs in n*log(n) time.
java.util.TreeMap: java.util.TreeMap.TreeMap	(	SortedMap	):  Constructs a new tree map containing the same mappings and using the same ordering as the specified sorted map. This method runs in linear time.
java.util.TreeMap: java.util.TreeMap.TreeMapSpliterator:  Base class for spliterators. Iteration starts at a given origin and continues up to but not including a given fence (or null for end). At top-level, for ascending cases, the first split uses the root as left-fence/right-origin. From there, right-hand splits replace the current fence with its left child, also serving as origin for the split-off spliterator. Left-hands are symmetric. Descending versions place the origin at the end and invert ascending split rules. This base class is non-commital about directionality, or whether the top-level spliterator covers the whole tree. This means that the actual split mechanics are located in subclasses. Some of the subclass trySplit methods are identical (except for return types), but not nicely factorable. Currently, subclass versions exist only for the full map (including descending keys via its descendingMap). Others are possible but currently not worthwhile because submaps require O(n) computations to determine size, which substantially limits potential speed-ups of using custom Spliterators versus default mechanics. To boostrap initialization, external constructors use negative size estimates: -1 for ascend, -2 for descend.
java.util.TreeMap: java.util.TreeMap.addAllForTreeSet	(	SortedSet	V	):  Intended to be called only from TreeSet.addAll 
java.util.TreeMap: java.util.TreeMap.buildFromSorted	(	int	Iterator	java.io.ObjectInputStream	V	):  Linear time tree building algorithm from sorted data. Can accept keys and/or values from iterator or stream. This leads to too many parameters, but seems better than alternatives. The four formats that this method accepts are: 1) An iterator of Map.Entries. (it != null, defaultVal == null). 2) An iterator of keys. (it != null, defaultVal != null). 3) A stream of alternating serialized keys and values. (it == null, defaultVal == null). 4) A stream of serialized keys. (it == null, defaultVal != null). It is assumed that the comparator of the TreeMap is already set prior to calling this method.
java.util.TreeMap: java.util.TreeMap.buildFromSorted	(	int	int	int	int	Iterator	java.io.ObjectInputStream	V	):  Recursive "helper method" that does the real work of the previous method. Identically named parameters have identical definitions. Additional parameters are documented below. It is assumed that the comparator and size fields of the TreeMap are already set prior to calling this method. (It ignores both fields.)
java.util.TreeMap: java.util.TreeMap.ceilingEntry	(	K	):  Returns a key-value mapping associated with the least key greater than or equal to the given key, or null if there is no such key.
java.util.TreeMap: java.util.TreeMap.ceilingKey	(	K	):  Returns the least key greater than or equal to the given key, or null if there is no such key.
java.util.TreeMap: java.util.TreeMap.clear	(	):  Removes all of the mappings from this map. The map will be empty after this call returns.
java.util.TreeMap: java.util.TreeMap.clone	(	):  Returns a shallow copy of this TreeMap instance. (The keys and values themselves are not cloned.)
java.util.TreeMap: java.util.TreeMap.colorOf	(	Entry	):  Balancing operations. Implementations of rebalancings during insertion and deletion are slightly different than the CLR version. Rather than using dummy nilnodes, we use a set of accessors that deal properly with null. They are used to avoid messiness surrounding nullness checks in the main algorithms.
java.util.TreeMap: java.util.TreeMap.compare	(	Object	Object	):  Compares two keys using the correct comparison method for this TreeMap.
java.util.TreeMap: java.util.TreeMap.computeRedLevel	(	int	):  Find the level down to which to assign all nodes BLACK. This is the last `full' level of the complete binary tree produced by buildTree. The remaining nodes are colored RED. (This makes a `nice' set of color assignments wrt future insertions.) This level number is computed by finding the number of splits needed to reach the zeroeth node. (The answer is ~lg(N), but in any case must be computed by same quick O(lg(N)) loop.)
java.util.TreeMap: java.util.TreeMap.containsKey	(	Object	):  Returns true if this map contains a mapping for the specified key.
java.util.TreeMap: java.util.TreeMap.containsValue	(	Object	):  Returns true if this map maps one or more keys to the specified value. More formally, returns true if and only if this map contains at least one mapping to a value v such that (value==null ? v==null : value.equals(v)). This operation will probably require time linear in the map size for most implementations.
java.util.TreeMap: java.util.TreeMap.deleteEntry	(	Entry	):  Delete node p, and then rebalance the tree.
java.util.TreeMap: java.util.TreeMap.descendingKeySet	(	):  Returns a reverse order NavigableSet view of the keys contained in this map. The set's iterator returns the keys in descending order. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.TreeMap: java.util.TreeMap.descendingMap	(	):  Returns a reverse order view of the mappings contained in this map. The descending map is backed by this map, so changes to the map are reflected in the descending map, and vice-versa. If either map is modified while an iteration over a collection view of either map is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The returned map has an ordering equivalent to reverseOrder() Collections.reverseOrder(comparator()). The expression m.descendingMap().descendingMap() returns a view of m essentially equivalent to m.
java.util.TreeMap: java.util.TreeMap.entrySet	(	):  Returns a Set view of the mappings contained in this map. The set's iterator returns the entries in ascending key order. The sets's spliterator is late-binding, fail-fast, and additionally reports SORTED and ORDERED with an encounter order that is ascending key order. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation, or through the setValue operation on a map entry returned by the iterator) the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.TreeMap: java.util.TreeMap.exportEntry	(	TreeMap.Entry	):  Return SimpleImmutableEntry for entry, or null if null
java.util.TreeMap: java.util.TreeMap.firstEntry	(	):  Returns a key-value mapping associated with the least key in this map, or null if the map is empty.
java.util.TreeMap: java.util.TreeMap.firstKey	(	):  Returns the first (lowest) key currently in this map.
java.util.TreeMap: java.util.TreeMap.fixAfterDeletion	(	Entry	):  From CLR 
java.util.TreeMap: java.util.TreeMap.fixAfterInsertion	(	Entry	):  From CLR 
java.util.TreeMap: java.util.TreeMap.floorEntry	(	K	):  Returns a key-value mapping associated with the greatest key less than or equal to the given key, or null if there is no such key.
java.util.TreeMap: java.util.TreeMap.floorKey	(	K	):  Returns the greatest key less than or equal to the given key, or null if there is no such key.
java.util.TreeMap: java.util.TreeMap.get	(	Object	):  Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that key compares equal to k according to the map's ordering, then this method returns v; otherwise it returns null. (There can be at most one such mapping.) A return value of null does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to null. The containsKey operation may be used to distinguish these two cases.
java.util.TreeMap: java.util.TreeMap.getCeilingEntry	(	K	):  Gets the entry corresponding to the specified key; if no such entry exists, returns the entry for the least key greater than the specified key; if no such entry exists (i.e., the greatest key in the Tree is less than the specified key), returns null.
java.util.TreeMap: java.util.TreeMap.getEntry	(	Object	):  Returns this map's entry for the given key, or null if the map does not contain an entry for the key.
java.util.TreeMap: java.util.TreeMap.getEntryUsingComparator	(	Object	):  Version of getEntry using comparator. Split off from getEntry for performance. (This is not worth doing for most methods, that are less dependent on comparator performance, but is worthwhile here.)
java.util.TreeMap: java.util.TreeMap.getFirstEntry	(	):  Returns the first Entry in the TreeMap (according to the TreeMap's key-sort function). Returns null if the TreeMap is empty.
java.util.TreeMap: java.util.TreeMap.getFloorEntry	(	K	):  Gets the entry corresponding to the specified key; if no such entry exists, returns the entry for the greatest key less than the specified key; if no such entry exists, returns null.
java.util.TreeMap: java.util.TreeMap.getHigherEntry	(	K	):  Gets the entry for the least key greater than the specified key; if no such entry exists, returns the entry for the least key greater than the specified key; if no such entry exists returns null.
java.util.TreeMap: java.util.TreeMap.getLastEntry	(	):  Returns the last Entry in the TreeMap (according to the TreeMap's key-sort function). Returns null if the TreeMap is empty.
java.util.TreeMap: java.util.TreeMap.getLowerEntry	(	K	):  Returns the entry for the greatest key less than the specified key; if no such entry exists (i.e., the least key in the Tree is greater than the specified key), returns null.
java.util.TreeMap: java.util.TreeMap.headMap	(	K	):  Returns a view of the portion of this map whose keys are strictly less than toKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range. Equivalent to headMap(toKey, false).
java.util.TreeMap: java.util.TreeMap.headMap	(	K	boolean	):  Returns a view of the portion of this map whose keys are less than (or equal to, if inclusive is true) toKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range.
java.util.TreeMap: java.util.TreeMap.higherEntry	(	K	):  Returns a key-value mapping associated with the least key strictly greater than the given key, or null if there is no such key.
java.util.TreeMap: java.util.TreeMap.higherKey	(	K	):  Returns the least key strictly greater than the given key, or null if there is no such key.
java.util.TreeMap: java.util.TreeMap.key	(	Entry	):  Returns the key corresponding to the specified Entry.
java.util.TreeMap: java.util.TreeMap.keyOrNull	(	TreeMap.Entry	):  Return key for entry, or null if null
java.util.TreeMap: java.util.TreeMap.keySet	(	):  Returns a Set view of the keys contained in this map. The set's iterator returns the keys in ascending order. The set's spliterator is late-binding, fail-fast, and additionally reports SORTED and ORDERED with an encounter order that is ascending key order. The spliterator's comparator (see getComparator()) is null if the tree map's comparator (see comparator()) is null. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the tree map's comparator. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.TreeMap: java.util.TreeMap.keySpliteratorFor	(	NavigableMap	):  Currently, we support Spliterator-based versions only for the full map, in either plain of descending form, otherwise relying on defaults because size estimation for submaps would dominate costs. The type tests needed to check these for key views are not very nice but avoid disrupting existing class structures. Callers must use plain default spliterators if this returns null.
java.util.TreeMap: java.util.TreeMap.lastEntry	(	):  Returns a key-value mapping associated with the greatest key in this map, or null if the map is empty.
java.util.TreeMap: java.util.TreeMap.lastKey	(	):  Returns the last (highest) key currently in this map.
java.util.TreeMap: java.util.TreeMap.lowerEntry	(	K	):  Returns a key-value mapping associated with the greatest key strictly less than the given key, or null if there is no such key.
java.util.TreeMap: java.util.TreeMap.lowerKey	(	K	):  Returns the greatest key strictly less than the given key, or null if there is no such key.
java.util.TreeMap: java.util.TreeMap.navigableKeySet	(	):  Returns a NavigableSet view of the keys contained in this map. The set's iterator returns the keys in ascending order. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.TreeMap: java.util.TreeMap.pollFirstEntry	(	):  Removes and returns a key-value mapping associated with the least key in this map, or null if the map is empty.
java.util.TreeMap: java.util.TreeMap.pollLastEntry	(	):  Removes and returns a key-value mapping associated with the greatest key in this map, or null if the map is empty.
java.util.TreeMap: java.util.TreeMap.predecessor	(	Entry	):  Returns the predecessor of the specified Entry, or null if no such.
java.util.TreeMap: java.util.TreeMap.put	(	K	V	):  Associates the specified value with the specified key in this map. If the map previously contained a mapping for the key, the old value is replaced.
java.util.TreeMap: java.util.TreeMap.putAll	(	Map	):  Copies all of the mappings from the specified map to this map. These mappings replace any mappings that this map had for any of the keys currently in the specified map.
java.util.TreeMap: java.util.TreeMap.readObject	(	java.io.ObjectInputStream	):  Reconstitute the TreeMap instance from a stream (i.e., deserialize it).
java.util.TreeMap: java.util.TreeMap.readTreeSet	(	int	java.io.ObjectInputStream	V	):  Intended to be called only from TreeSet.readObject 
java.util.TreeMap: java.util.TreeMap.remove	(	Object	):  Removes the mapping for this key from this TreeMap if present.
java.util.TreeMap: java.util.TreeMap.rotateLeft	(	Entry	):  From CLR 
java.util.TreeMap: java.util.TreeMap.rotateRight	(	Entry	):  From CLR 
java.util.TreeMap: java.util.TreeMap.size	(	):  Returns the number of key-value mappings in this map.
java.util.TreeMap: java.util.TreeMap.subMap	(	K	K	):  Returns a view of the portion of this map whose keys range from fromKey, inclusive, to toKey, exclusive. (If fromKey and toKey are equal, the returned map is empty.) The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range. Equivalent to subMap(fromKey, true, toKey, false).
java.util.TreeMap: java.util.TreeMap.subMap	(	K	boolean	K	boolean	):  Returns a view of the portion of this map whose keys range from fromKey to toKey. If fromKey and toKey are equal, the returned map is empty unless fromInclusive and toInclusive are both true. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside of its range, or to construct a submap either of whose endpoints lie outside its range.
java.util.TreeMap: java.util.TreeMap.successor	(	Entry	):  Returns the successor of the specified Entry, or null if no such.
java.util.TreeMap: java.util.TreeMap.tailMap	(	K	):  Returns a view of the portion of this map whose keys are greater than or equal to fromKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range. Equivalent to tailMap(fromKey, true).
java.util.TreeMap: java.util.TreeMap.tailMap	(	K	boolean	):  Returns a view of the portion of this map whose keys are greater than (or equal to, if inclusive is true) fromKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range.
java.util.TreeMap: java.util.TreeMap.valEquals	(	Object	Object	):  Test two values for equality. Differs from o1.equals(o2) only in that it copes with null o1 properly.
java.util.TreeMap: java.util.TreeMap.values	(	):  Returns a Collection view of the values contained in this map. The collection's iterator returns the values in ascending order of the corresponding keys. The collection's spliterator is late-binding, fail-fast, and additionally reports ORDERED with an encounter order that is ascending order of the corresponding keys. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.TreeMap: java.util.TreeMap.writeObject	(	java.io.ObjectOutputStream	):  Save the state of the TreeMap instance to a stream (i.e., serialize it).
java.util.LinkedHashMap: java.util.LinkedHashMap:  Hash table and linked list implementation of the Map interface, with predictable iteration order. This implementation differs from HashMap in that it maintains a doubly-linked list running through all of its entries. This linked list defines the iteration ordering, which is normally the order in which keys were inserted into the map (insertion-order). Note that insertion order is not affected if a key is re-inserted into the map. (A key k is reinserted into a map m if m.put(k, v) is invoked when m.containsKey(k) would return true immediately prior to the invocation.) This implementation spares its clients from the unspecified, generally chaotic ordering provided by HashMap (and Hashtable), without incurring the increased cost associated with TreeMap. It can be used to produce a copy of a map that has the same order as the original, regardless of the original map's implementation:  void foo(Map m) { Map copy = new LinkedHashMap(m); ... }  This technique is particularly useful if a module takes a map on input, copies it, and later returns results whose order is determined by that of the copy. (Clients generally appreciate having things returned in the same order they were presented.) A special LinkedHashMap() constructor is provided to create a linked hash map whose order of iteration is the order in which its entries were last accessed, from least-recently accessed to most-recently (access-order). This kind of map is well-suited to building LRU caches. Invoking the put, putIfAbsent, get, getOrDefault, compute, computeIfAbsent, computeIfPresent, or merge methods results in an access to the corresponding entry (assuming it exists after the invocation completes). The replace methods only result in an access of the entry if the value is replaced. The putAll method generates one entry access for each mapping in the specified map, in the order that key-value mappings are provided by the specified map's entry set iterator. No other methods generate entry accesses. In particular, operations on collection-views do not affect the order of iteration of the backing map. The removeEldestEntry() method may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map. This class provides all of the optional Map operations, and permits null elements. Like HashMap, it provides constant-time performance for the basic operations (add, contains and remove), assuming the hash function disperses elements properly among the buckets. Performance is likely to be just slightly below that of HashMap, due to the added expense of maintaining the linked list, with one exception: Iteration over the collection-views of a LinkedHashMap requires time proportional to the size of the map, regardless of its capacity. Iteration over a HashMap is likely to be more expensive, requiring time proportional to its capacity. A linked hash map has two parameters that affect its performance: initial capacity and load factor. They are defined precisely as for HashMap. Note, however, that the penalty for choosing an excessively high value for initial capacity is less severe for this class than for HashMap, as iteration times for this class are unaffected by capacity. Note that this implementation is not synchronized. If multiple threads access a linked hash map concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally. This is typically accomplished by synchronizing on some object that naturally encapsulates the map. If no such object exists, the map should be "wrapped" using the synchronizedMap Collections.synchronizedMap method. This is best done at creation time, to prevent accidental unsynchronized access to the map: Map m = Collections.synchronizedMap(new LinkedHashMap(...)); A structural modification is any operation that adds or deletes one or more mappings or, in the case of access-ordered linked hash maps, affects iteration order. In insertion-ordered linked hash maps, merely changing the value associated with a key that is already contained in the map is not a structural modification. In access-ordered linked hash maps, merely querying the map with get is a structural modification. ) The iterators returned by the iterator method of the collections returned by all of this class's collection view methods are fail-fast: if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. The spliterators returned by the spliterator method of the collections returned by all of this class's collection view methods are late-binding, fail-fast, and additionally report ORDERED. This class is a member of the  Java Collections Framework.
java.util.LinkedHashMap: java.util.LinkedHashMap.Entry:  HashMap.Node subclass for normal LinkedHashMap entries.
java.util.LinkedHashMap: java.util.LinkedHashMap.LinkedHashMap	(	):  Constructs an empty insertion-ordered LinkedHashMap instance with the default initial capacity (16) and load factor (0.75).
java.util.LinkedHashMap: java.util.LinkedHashMap.LinkedHashMap	(	Map	):  Constructs an insertion-ordered LinkedHashMap instance with the same mappings as the specified map. The LinkedHashMap instance is created with a default load factor (0.75) and an initial capacity sufficient to hold the mappings in the specified map.
java.util.LinkedHashMap: java.util.LinkedHashMap.LinkedHashMap	(	int	):  Constructs an empty insertion-ordered LinkedHashMap instance with the specified initial capacity and a default load factor (0.75).
java.util.LinkedHashMap: java.util.LinkedHashMap.LinkedHashMap	(	int	float	):  Constructs an empty insertion-ordered LinkedHashMap instance with the specified initial capacity and load factor.
java.util.LinkedHashMap: java.util.LinkedHashMap.LinkedHashMap	(	int	float	boolean	):  Constructs an empty LinkedHashMap instance with the specified initial capacity, load factor and ordering mode.
java.util.LinkedHashMap: java.util.LinkedHashMap.clear	(	):  Removes all of the mappings from this map. The map will be empty after this call returns.
java.util.LinkedHashMap: java.util.LinkedHashMap.containsValue	(	Object	):  Returns true if this map maps one or more keys to the specified value.
java.util.LinkedHashMap: java.util.LinkedHashMap.entrySet	(	):  Returns a Set view of the mappings contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation, or through the setValue operation on a map entry returned by the iterator) the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations. Its Spliterator typically provides faster sequential performance but much poorer parallel performance than that of HashMap.
java.util.LinkedHashMap: java.util.LinkedHashMap.get	(	Object	):  Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that (key==null ? k==null : key.equals(k)), then this method returns v; otherwise it returns null. (There can be at most one such mapping.) A return value of null does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to null. The containsKey operation may be used to distinguish these two cases.
java.util.LinkedHashMap: java.util.LinkedHashMap.getOrDefault	(	Object	V	):  
java.util.LinkedHashMap: java.util.LinkedHashMap.keySet	(	):  Returns a Set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations. Its Spliterator typically provides faster sequential performance but much poorer parallel performance than that of HashMap.
java.util.LinkedHashMap: java.util.LinkedHashMap.removeEldestEntry	(	Map.Entry	):  Returns true if this map should remove its eldest entry. This method is invoked by put and putAll after inserting a new entry into the map. It provides the implementor with the opportunity to remove the eldest entry each time a new one is added. This is useful if the map represents a cache: it allows the map to reduce memory consumption by deleting stale entries. Sample use: this override will allow the map to grow up to 100 entries and then delete the eldest entry each time a new entry is added, maintaining a steady state of 100 entries.  private static final int MAX_ENTRIES = 100; protected boolean removeEldestEntry(Map.Entry eldest) { return size() > MAX_ENTRIES; }  This method typically does not modify the map in any way, instead allowing the map to modify itself as directed by its return value. It is permitted for this method to modify the map directly, but if it does so, it must return false (indicating that the map should not attempt any further modification). The effects of returning true after modifying the map from within this method are unspecified. This implementation merely returns false (so that this map acts like a normal map - the eldest element is never removed).
java.util.LinkedHashMap: java.util.LinkedHashMap.values	(	):  Returns a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations. Its Spliterator typically provides faster sequential performance but much poorer parallel performance than that of HashMap.
java.util.SortedSet: java.util.SortedSet:  A Set that further provides a total ordering on its elements. The elements are ordered using their Comparable natural ordering, or by a Comparator typically provided at sorted set creation time. The set's iterator will traverse the set in ascending element order. Several additional operations are provided to take advantage of the ordering. (This interface is the set analogue of SortedMap.) All elements inserted into a sorted set must implement the Comparable interface (or be accepted by the specified comparator). Furthermore, all such elements must be mutually comparable: e1.compareTo(e2) (or comparator.compare(e1, e2)) must not throw a ClassCastException for any elements e1 and e2 in the sorted set. Attempts to violate this restriction will cause the offending method or constructor invocation to throw a ClassCastException. Note that the ordering maintained by a sorted set (whether or not an explicit comparator is provided) must be consistent with equals if the sorted set is to correctly implement the Set interface. (See the Comparable interface or Comparator interface for a precise definition of consistent with equals.) This is so because the Set interface is defined in terms of the equals operation, but a sorted set performs all element comparisons using its compareTo (or compare) method, so two elements that are deemed equal by this method are, from the standpoint of the sorted set, equal. The behavior of a sorted set is well-defined even if its ordering is inconsistent with equals; it just fails to obey the general contract of the Set interface. All general-purpose sorted set implementation classes should provide four "standard" constructors: 1) A void (no arguments) constructor, which creates an empty sorted set sorted according to the natural ordering of its elements. 2) A constructor with a single argument of type Comparator, which creates an empty sorted set sorted according to the specified comparator. 3) A constructor with a single argument of type Collection, which creates a new sorted set with the same elements as its argument, sorted according to the natural ordering of the elements. 4) A constructor with a single argument of type SortedSet, which creates a new sorted set with the same elements and the same ordering as the input sorted set. There is no way to enforce this recommendation, as interfaces cannot contain constructors. Note: several methods return subsets with restricted ranges. Such ranges are half-open, that is, they include their low endpoint but not their high endpoint (where applicable). If you need a closed range (which includes both endpoints), and the element type allows for calculation of the successor of a given value, merely request the subrange from lowEndpoint to successor(highEndpoint). For example, suppose that s is a sorted set of strings. The following idiom obtains a view containing all of the strings in s from low to high, inclusive: SortedSet<String> sub = s.subSet(low, high+"\0"); A similar technique can be used to generate an open range (which contains neither endpoint). The following idiom obtains a view containing all of the Strings in s from low to high, exclusive: SortedSet<String> sub = s.subSet(low+"\0", high); This interface is a member of the  Java Collections Framework.
java.util.SortedSet: java.util.SortedSet.comparator	(	):  Returns the comparator used to order the elements in this set, or null if this set uses the Comparable natural ordering of its elements.
java.util.SortedSet: java.util.SortedSet.first	(	):  Returns the first (lowest) element currently in this set.
java.util.SortedSet: java.util.SortedSet.headSet	(	E	):  Returns a view of the portion of this set whose elements are strictly less than toElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range.
java.util.SortedSet: java.util.SortedSet.last	(	):  Returns the last (highest) element currently in this set.
java.util.SortedSet: java.util.SortedSet.spliterator	(	):  Creates a Spliterator over the elements in this sorted set. The Spliterator reports DISTINCT, SORTED and ORDERED. Implementations should document the reporting of additional characteristic values. The spliterator's comparator (see getComparator()) must be null if the sorted set's comparator (see comparator()) is null. Otherwise, the spliterator's comparator must be the same as or impose the same total ordering as the sorted set's comparator.
java.util.SortedSet: java.util.SortedSet.subSet	(	E	E	):  Returns a view of the portion of this set whose elements range from fromElement, inclusive, to toElement, exclusive. (If fromElement and toElement are equal, the returned set is empty.) The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range.
java.util.SortedSet: java.util.SortedSet.tailSet	(	E	):  Returns a view of the portion of this set whose elements are greater than or equal to fromElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range.
java.util.SortedMap: java.util.SortedMap:  A Map that further provides a total ordering on its keys. The map is ordered according to the Comparable natural ordering of its keys, or by a Comparator typically provided at sorted map creation time. This order is reflected when iterating over the sorted map's collection views (returned by the entrySet, keySet and values methods). Several additional operations are provided to take advantage of the ordering. (This interface is the map analogue of SortedSet.) All keys inserted into a sorted map must implement the Comparable interface (or be accepted by the specified comparator). Furthermore, all such keys must be mutually comparable: k1.compareTo(k2) (or comparator.compare(k1, k2)) must not throw a ClassCastException for any keys k1 and k2 in the sorted map. Attempts to violate this restriction will cause the offending method or constructor invocation to throw a ClassCastException. Note that the ordering maintained by a sorted map (whether or not an explicit comparator is provided) must be consistent with equals if the sorted map is to correctly implement the Map interface. (See the Comparable interface or Comparator interface for a precise definition of consistent with equals.) This is so because the Map interface is defined in terms of the equals operation, but a sorted map performs all key comparisons using its compareTo (or compare) method, so two keys that are deemed equal by this method are, from the standpoint of the sorted map, equal. The behavior of a tree map is well-defined even if its ordering is inconsistent with equals; it just fails to obey the general contract of the Map interface. All general-purpose sorted map implementation classes should provide four "standard" constructors. It is not possible to enforce this recommendation though as required constructors cannot be specified by interfaces. The expected "standard" constructors for all sorted map implementations are:  A void (no arguments) constructor, which creates an empty sorted map sorted according to the natural ordering of its keys. A constructor with a single argument of type Comparator, which creates an empty sorted map sorted according to the specified comparator. A constructor with a single argument of type Map, which creates a new map with the same key-value mappings as its argument, sorted according to the keys' natural ordering. A constructor with a single argument of type SortedMap, which creates a new sorted map with the same key-value mappings and the same ordering as the input sorted map.  Note: several methods return submaps with restricted key ranges. Such ranges are half-open, that is, they include their low endpoint but not their high endpoint (where applicable). If you need a closed range (which includes both endpoints), and the key type allows for calculation of the successor of a given key, merely request the subrange from lowEndpoint to successor(highEndpoint). For example, suppose that m is a map whose keys are strings. The following idiom obtains a view containing all of the key-value mappings in m whose keys are between low and high, inclusive: SortedMap<String, V> sub = m.subMap(low, high+"\0"); A similar technique can be used to generate an open range (which contains neither endpoint). The following idiom obtains a view containing all of the key-value mappings in m whose keys are between low and high, exclusive: SortedMap<String, V> sub = m.subMap(low+"\0", high); This interface is a member of the  Java Collections Framework.
java.util.SortedMap: java.util.SortedMap.comparator	(	):  Returns the comparator used to order the keys in this map, or null if this map uses the Comparable natural ordering of its keys.
java.util.SortedMap: java.util.SortedMap.entrySet	(	):  Returns a Set view of the mappings contained in this map. The set's iterator returns the entries in ascending key order. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation, or through the setValue operation on a map entry returned by the iterator) the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.SortedMap: java.util.SortedMap.firstKey	(	):  Returns the first (lowest) key currently in this map.
java.util.SortedMap: java.util.SortedMap.headMap	(	K	):  Returns a view of the portion of this map whose keys are strictly less than toKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range.
java.util.SortedMap: java.util.SortedMap.keySet	(	):  Returns a Set view of the keys contained in this map. The set's iterator returns the keys in ascending order. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.SortedMap: java.util.SortedMap.lastKey	(	):  Returns the last (highest) key currently in this map.
java.util.SortedMap: java.util.SortedMap.subMap	(	K	K	):  Returns a view of the portion of this map whose keys range from fromKey, inclusive, to toKey, exclusive. (If fromKey and toKey are equal, the returned map is empty.) The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range.
java.util.SortedMap: java.util.SortedMap.tailMap	(	K	):  Returns a view of the portion of this map whose keys are greater than or equal to fromKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range.
java.util.SortedMap: java.util.SortedMap.values	(	):  Returns a Collection view of the values contained in this map. The collection's iterator returns the values in ascending order of the corresponding keys. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.PriorityQueue: java.util.PriorityQueue:  An unbounded priority Queue queue based on a priority heap. The elements of the priority queue are ordered according to their Comparable natural ordering, or by a Comparator provided at queue construction time, depending on which constructor is used. A priority queue does not permit null elements. A priority queue relying on natural ordering also does not permit insertion of non-comparable objects (doing so may result in ClassCastException). The head of this queue is the least element with respect to the specified ordering. If multiple elements are tied for least value, the head is one of those elements -- ties are broken arbitrarily. The queue retrieval operations poll, remove, peek, and element access the element at the head of the queue. A priority queue is unbounded, but has an internal capacity governing the size of an array used to store the elements on the queue. It is always at least as large as the queue size. As elements are added to a priority queue, its capacity grows automatically. The details of the growth policy are not specified. This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces. The Iterator provided in method iterator() is not guaranteed to traverse the elements of the priority queue in any particular order. If you need ordered traversal, consider using Arrays.sort(pq.toArray()). Note that this implementation is not synchronized. Multiple threads should not access a PriorityQueue instance concurrently if any of the threads modifies the queue. Instead, use the thread-safe java.util.concurrent.PriorityBlockingQueue class. Implementation note: this implementation provides O(log(n)) time for the enqueuing and dequeuing methods (offer, poll, remove() and add); linear time for the remove(Object) and contains(Object) methods; and constant time for the retrieval methods (peek, element, and size). This class is a member of the  Java Collections Framework.
java.util.PriorityQueue: java.util.PriorityQueue.PriorityQueue	(	):  Creates a PriorityQueue with the default initial capacity (11) that orders its elements according to their Comparable natural ordering.
java.util.PriorityQueue: java.util.PriorityQueue.PriorityQueue	(	Collection	):  Creates a PriorityQueue containing the elements in the specified collection. If the specified collection is an instance of a SortedSet or is another PriorityQueue, this priority queue will be ordered according to the same ordering. Otherwise, this priority queue will be ordered according to the Comparable natural ordering of its elements.
java.util.PriorityQueue: java.util.PriorityQueue.PriorityQueue	(	Comparator	):  Creates a PriorityQueue with the default initial capacity and whose elements are ordered according to the specified comparator.
java.util.PriorityQueue: java.util.PriorityQueue.PriorityQueue	(	PriorityQueue	):  Creates a PriorityQueue containing the elements in the specified priority queue. This priority queue will be ordered according to the same ordering as the given priority queue.
java.util.PriorityQueue: java.util.PriorityQueue.PriorityQueue	(	SortedSet	):  Creates a PriorityQueue containing the elements in the specified sorted set. This priority queue will be ordered according to the same ordering as the given sorted set.
java.util.PriorityQueue: java.util.PriorityQueue.PriorityQueue	(	int	):  Creates a PriorityQueue with the specified initial capacity that orders its elements according to their Comparable natural ordering.
java.util.PriorityQueue: java.util.PriorityQueue.PriorityQueue	(	int	Comparator	):  Creates a PriorityQueue with the specified initial capacity that orders its elements according to the specified comparator.
java.util.PriorityQueue: java.util.PriorityQueue.PriorityQueueSpliterator.PriorityQueueSpliterator	(	PriorityQueue	int	int	int	):  Creates new spliterator covering the given range 
java.util.PriorityQueue: java.util.PriorityQueue.add	(	E	):  Inserts the specified element into this priority queue.
java.util.PriorityQueue: java.util.PriorityQueue.clear	(	):  Removes all of the elements from this priority queue. The queue will be empty after this call returns.
java.util.PriorityQueue: java.util.PriorityQueue.comparator	(	):  Returns the comparator used to order the elements in this queue, or null if this queue is sorted according to the Comparable natural ordering of its elements.
java.util.PriorityQueue: java.util.PriorityQueue.contains	(	Object	):  Returns true if this queue contains the specified element. More formally, returns true if and only if this queue contains at least one element e such that o.equals(e).
java.util.PriorityQueue: java.util.PriorityQueue.grow	(	int	):  Increases the capacity of the array.
java.util.PriorityQueue: java.util.PriorityQueue.heapify	(	):  Establishes the heap invariant (described above) in the entire tree, assuming nothing about the order of the elements prior to the call.
java.util.PriorityQueue: java.util.PriorityQueue.initFromCollection	(	Collection	):  Initializes queue array with elements from the given Collection.
java.util.PriorityQueue: java.util.PriorityQueue.iterator	(	):  Returns an iterator over the elements in this queue. The iterator does not return the elements in any particular order.
java.util.PriorityQueue: java.util.PriorityQueue.offer	(	E	):  Inserts the specified element into this priority queue.
java.util.PriorityQueue: java.util.PriorityQueue.readObject	(	java.io.ObjectInputStream	):  Reconstitutes the PriorityQueue instance from a stream (that is, deserializes it).
java.util.PriorityQueue: java.util.PriorityQueue.remove	(	Object	):  Removes a single instance of the specified element from this queue, if it is present. More formally, removes an element e such that o.equals(e), if this queue contains one or more such elements. Returns true if and only if this queue contained the specified element (or equivalently, if this queue changed as a result of the call).
java.util.PriorityQueue: java.util.PriorityQueue.removeAt	(	int	):  Removes the ith element from queue. Normally this method leaves the elements at up to i-1, inclusive, untouched. Under these circumstances, it returns null. Occasionally, in order to maintain the heap invariant, it must swap a later element of the list with one earlier than i. Under these circumstances, this method returns the element that was previously at the end of the list and is now at some position before i. This fact is used by iterator.remove so as to avoid missing traversing elements.
java.util.PriorityQueue: java.util.PriorityQueue.removeEq	(	Object	):  Version of remove using reference equality, not equals. Needed by iterator.remove.
java.util.PriorityQueue: java.util.PriorityQueue.siftDown	(	int	E	):  Inserts item x at position k, maintaining heap invariant by demoting x down the tree repeatedly until it is less than or equal to its children or is a leaf.
java.util.PriorityQueue: java.util.PriorityQueue.siftUp	(	int	E	):  Inserts item x at position k, maintaining heap invariant by promoting x up the tree until it is greater than or equal to its parent, or is the root. To simplify and speed up coercions and comparisons. the Comparable and Comparator versions are separated into different methods that are otherwise identical. (Similarly for siftDown.)
java.util.PriorityQueue: java.util.PriorityQueue.spliterator	(	):  Creates a late-binding and fail-fast Spliterator over the elements in this queue. The Spliterator reports SIZED, SUBSIZED, and NONNULL. Overriding implementations should document the reporting of additional characteristic values.
java.util.PriorityQueue: java.util.PriorityQueue.toArray	(	):  Returns an array containing all of the elements in this queue. The elements are in no particular order. The returned array will be "safe" in that no references to it are maintained by this queue. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.PriorityQueue: java.util.PriorityQueue.toArray	(	T[]	):  Returns an array containing all of the elements in this queue; the runtime type of the returned array is that of the specified array. The returned array elements are in no particular order. If the queue fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this queue. If the queue fits in the specified array with room to spare (i.e., the array has more elements than the queue), the element in the array immediately following the end of the collection is set to null. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a queue known to contain only strings. The following code can be used to dump the queue into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.PriorityQueue: java.util.PriorityQueue.writeObject	(	java.io.ObjectOutputStream	):  Saves this queue to a stream (that is, serializes it).
java.util.Vector: java.util.Vector:  The Vector class implements a growable array of objects. Like an array, it contains components that can be accessed using an integer index. However, the size of a Vector can grow or shrink as needed to accommodate adding and removing items after the Vector has been created. Each vector tries to optimize storage management by maintaining a capacity and a capacityIncrement. The capacity is always at least as large as the vector size; it is usually larger because as components are added to the vector, the vector's storage increases in chunks the size of capacityIncrement. An application can increase the capacity of a vector before inserting a large number of components; this reduces the amount of incremental reallocation.  The iterators returned by this class's iterator() and listIterator() methods are fail-fast: if the vector is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove() or add() methods, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. The Enumeration Enumerations returned by the elements() method are not fail-fast. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. As of the Java 2 platform v1.2, this class was retrofitted to implement the List interface, making it a member of the  Java Collections Framework. Unlike the new collection implementations, Vector is synchronized. If a thread-safe implementation is not needed, it is recommended to use ArrayList in place of Vector.
java.util.Vector: java.util.Vector.Itr:  An optimized version of AbstractList.Itr
java.util.Vector: java.util.Vector.ListItr:  An optimized version of AbstractList.ListItr
java.util.Vector: java.util.Vector.Vector	(	):  Constructs an empty vector so that its internal data array has size 10 and its standard capacity increment is zero.
java.util.Vector: java.util.Vector.Vector	(	Collection	):  Constructs a vector containing the elements of the specified collection, in the order they are returned by the collection's iterator.
java.util.Vector: java.util.Vector.Vector	(	int	):  Constructs an empty vector with the specified initial capacity and with its capacity increment equal to zero.
java.util.Vector: java.util.Vector.Vector	(	int	int	):  Constructs an empty vector with the specified initial capacity and capacity increment.
java.util.Vector: java.util.Vector.VectorSpliterator:  Similar to ArrayList Spliterator 
java.util.Vector: java.util.Vector.VectorSpliterator.VectorSpliterator	(	Vector	Object[]	int	int	int	):  Create new spliterator covering the given range 
java.util.Vector: java.util.Vector.add	(	E	):  Appends the specified element to the end of this Vector.
java.util.Vector: java.util.Vector.add	(	int	E	):  Inserts the specified element at the specified position in this Vector. Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices).
java.util.Vector: java.util.Vector.addAll	(	Collection	):  Appends all of the elements in the specified Collection to the end of this Vector, in the order that they are returned by the specified Collection's Iterator. The behavior of this operation is undefined if the specified Collection is modified while the operation is in progress. (This implies that the behavior of this call is undefined if the specified Collection is this Vector, and this Vector is nonempty.)
java.util.Vector: java.util.Vector.addAll	(	int	Collection	):  Inserts all of the elements in the specified Collection into this Vector at the specified position. Shifts the element currently at that position (if any) and any subsequent elements to the right (increases their indices). The new elements will appear in the Vector in the order that they are returned by the specified Collection's iterator.
java.util.Vector: java.util.Vector.addElement	(	E	):  Adds the specified component to the end of this vector, increasing its size by one. The capacity of this vector is increased if its size becomes greater than its capacity. This method is identical in functionality to the add() add(E) method (which is part of the List interface).
java.util.Vector: java.util.Vector.capacity	(	):  Returns the current capacity of this vector.
java.util.Vector: java.util.Vector.clear	(	):  Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).
java.util.Vector: java.util.Vector.clone	(	):  Returns a clone of this vector. The copy will contain a reference to a clone of the internal data array, not a reference to the original internal data array of this Vector object.
java.util.Vector: java.util.Vector.contains	(	Object	):  Returns true if this vector contains the specified element. More formally, returns true if and only if this vector contains at least one element e such that (o==null ? e==null : o.equals(e)).
java.util.Vector: java.util.Vector.containsAll	(	Collection	):  Returns true if this Vector contains all of the elements in the specified Collection.
java.util.Vector: java.util.Vector.copyInto	(	Object[]	):  Copies the components of this vector into the specified array. The item at index k in this vector is copied into component k of anArray.
java.util.Vector: java.util.Vector.elementAt	(	int	):  Returns the component at the specified index. This method is identical in functionality to the get() method (which is part of the List interface).
java.util.Vector: java.util.Vector.elements	(	):  Returns an enumeration of the components of this vector. The returned Enumeration object will generate all items in this vector. The first item generated is the item at index 0, then the item at index 1, and so on.
java.util.Vector: java.util.Vector.ensureCapacity	(	int	):  Increases the capacity of this vector, if necessary, to ensure that it can hold at least the number of components specified by the minimum capacity argument. If the current capacity of this vector is less than minCapacity, then its capacity is increased by replacing its internal data array, kept in the field elementData, with a larger one. The size of the new data array will be the old size plus capacityIncrement, unless the value of capacityIncrement is less than or equal to zero, in which case the new capacity will be twice the old capacity; but if this new size is still smaller than minCapacity, then the new capacity will be minCapacity.
java.util.Vector: java.util.Vector.ensureCapacityHelper	(	int	):  This implements the unsynchronized semantics of ensureCapacity. Synchronized methods in this class can internally call this method for ensuring capacity without incurring the cost of an extra synchronization.
java.util.Vector: java.util.Vector.equals	(	Object	):  Compares the specified Object with this Vector for equality. Returns true if and only if the specified Object is also a List, both Lists have the same size, and all corresponding pairs of elements in the two Lists are equal. (Two elements e1 and e2 are equal if (e1==null ? e2==null : e1.equals(e2)).) In other words, two Lists are defined to be equal if they contain the same elements in the same order.
java.util.Vector: java.util.Vector.firstElement	(	):  Returns the first component (the item at index 0) of this vector.
java.util.Vector: java.util.Vector.get	(	int	):  Returns the element at the specified position in this Vector.
java.util.Vector: java.util.Vector.hashCode	(	):  Returns the hash code value for this Vector.
java.util.Vector: java.util.Vector.indexOf	(	Object	):  Returns the index of the first occurrence of the specified element in this vector, or -1 if this vector does not contain the element. More formally, returns the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.
java.util.Vector: java.util.Vector.indexOf	(	Object	int	):  Returns the index of the first occurrence of the specified element in this vector, searching forwards from index, or returns -1 if the element is not found. More formally, returns the lowest index i such that (i >= index && (o==null ? get(i)==null : o.equals(get(i)))), or -1 if there is no such index.
java.util.Vector: java.util.Vector.insertElementAt	(	E	int	):  Inserts the specified object as a component in this vector at the specified index. Each component in this vector with an index greater or equal to the specified index is shifted upward to have an index one greater than the value it had previously. The index must be a value greater than or equal to 0 and less than or equal to the current size of the vector. (If the index is equal to the current size of the vector, the new element is appended to the Vector.) This method is identical in functionality to the add() add(int, E) method (which is part of the List interface). Note that the add method reverses the order of the parameters, to more closely match array usage.
java.util.Vector: java.util.Vector.isEmpty	(	):  Tests if this vector has no components.
java.util.Vector: java.util.Vector.iterator	(	):  Returns an iterator over the elements in this list in proper sequence. The returned iterator is fail-fast.
java.util.Vector: java.util.Vector.lastElement	(	):  Returns the last component of the vector.
java.util.Vector: java.util.Vector.lastIndexOf	(	Object	):  Returns the index of the last occurrence of the specified element in this vector, or -1 if this vector does not contain the element. More formally, returns the highest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.
java.util.Vector: java.util.Vector.lastIndexOf	(	Object	int	):  Returns the index of the last occurrence of the specified element in this vector, searching backwards from index, or returns -1 if the element is not found. More formally, returns the highest index i such that (i <= index && (o==null ? get(i)==null : o.equals(get(i)))), or -1 if there is no such index.
java.util.Vector: java.util.Vector.listIterator	(	):  Returns a list iterator over the elements in this list (in proper sequence). The returned list iterator is fail-fast.
java.util.Vector: java.util.Vector.listIterator	(	int	):  Returns a list iterator over the elements in this list (in proper sequence), starting at the specified position in the list. The specified index indicates the first element that would be returned by an initial call to next. An initial call to previous would return the element with the specified index minus one. The returned list iterator is fail-fast.
java.util.Vector: java.util.Vector.remove	(	Object	):  Removes the first occurrence of the specified element in this Vector If the Vector does not contain the element, it is unchanged. More formally, removes the element with the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))) (if such an element exists).
java.util.Vector: java.util.Vector.remove	(	int	):  Removes the element at the specified position in this Vector. Shifts any subsequent elements to the left (subtracts one from their indices). Returns the element that was removed from the Vector.
java.util.Vector: java.util.Vector.removeAll	(	Collection	):  Removes from this Vector all of its elements that are contained in the specified Collection.
java.util.Vector: java.util.Vector.removeAllElements	(	):  Removes all components from this vector and sets its size to zero. This method is identical in functionality to the clear method (which is part of the List interface).
java.util.Vector: java.util.Vector.removeElement	(	Object	):  Removes the first (lowest-indexed) occurrence of the argument from this vector. If the object is found in this vector, each component in the vector with an index greater or equal to the object's index is shifted downward to have an index one smaller than the value it had previously. This method is identical in functionality to the remove() method (which is part of the List interface).
java.util.Vector: java.util.Vector.removeElementAt	(	int	):  Deletes the component at the specified index. Each component in this vector with an index greater or equal to the specified index is shifted downward to have an index one smaller than the value it had previously. The size of this vector is decreased by 1. The index must be a value greater than or equal to 0 and less than the current size of the vector. This method is identical in functionality to the remove() method (which is part of the List interface). Note that the remove method returns the old value that was stored at the specified position.
java.util.Vector: java.util.Vector.removeRange	(	int	int	):  Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive. Shifts any succeeding elements to the left (reduces their index). This call shortens the list by (toIndex - fromIndex) elements. (If toIndex==fromIndex, this operation has no effect.)
java.util.Vector: java.util.Vector.retainAll	(	Collection	):  Retains only the elements in this Vector that are contained in the specified Collection. In other words, removes from this Vector all of its elements that are not contained in the specified Collection.
java.util.Vector: java.util.Vector.set	(	int	E	):  Replaces the element at the specified position in this Vector with the specified element.
java.util.Vector: java.util.Vector.setElementAt	(	E	int	):  Sets the component at the specified index of this vector to be the specified object. The previous component at that position is discarded. The index must be a value greater than or equal to 0 and less than the current size of the vector. This method is identical in functionality to the set() set(int, E) method (which is part of the List interface). Note that the set method reverses the order of the parameters, to more closely match array usage. Note also that the set method returns the old value that was stored at the specified position.
java.util.Vector: java.util.Vector.setSize	(	int	):  Sets the size of this vector. If the new size is greater than the current size, new null items are added to the end of the vector. If the new size is less than the current size, all components at index newSize and greater are discarded.
java.util.Vector: java.util.Vector.size	(	):  Returns the number of components in this vector.
java.util.Vector: java.util.Vector.spliterator	(	):  Creates a late-binding and fail-fast Spliterator over the elements in this list. The Spliterator reports SIZED, SUBSIZED, and ORDERED. Overriding implementations should document the reporting of additional characteristic values.
java.util.Vector: java.util.Vector.subList	(	int	int	):  Returns a view of the portion of this List between fromIndex, inclusive, and toIndex, exclusive. (If fromIndex and toIndex are equal, the returned List is empty.) The returned List is backed by this List, so changes in the returned List are reflected in this List, and vice-versa. The returned List supports all of the optional List operations supported by this List. This method eliminates the need for explicit range operations (of the sort that commonly exist for arrays). Any operation that expects a List can be used as a range operation by operating on a subList view instead of a whole List. For example, the following idiom removes a range of elements from a List:  list.subList(from, to).clear();  Similar idioms may be constructed for indexOf and lastIndexOf, and all of the algorithms in the Collections class can be applied to a subList. The semantics of the List returned by this method become undefined if the backing list (i.e., this List) is structurally modified in any way other than via the returned List. (Structural modifications are those that change the size of the List, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.)
java.util.Vector: java.util.Vector.toArray	(	):  Returns an array containing all of the elements in this Vector in the correct order.
java.util.Vector: java.util.Vector.toArray	(	T[]	):  Returns an array containing all of the elements in this Vector in the correct order; the runtime type of the returned array is that of the specified array. If the Vector fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this Vector. If the Vector fits in the specified array with room to spare (i.e., the array has more elements than the Vector), the element in the array immediately following the end of the Vector is set to null. (This is useful in determining the length of the Vector only if the caller knows that the Vector does not contain any null elements.)
java.util.Vector: java.util.Vector.toString	(	):  Returns a string representation of this Vector, containing the String representation of each element.
java.util.Vector: java.util.Vector.trimToSize	(	):  Trims the capacity of this vector to be the vector's current size. If the capacity of this vector is larger than its current size, then the capacity is changed to equal the size by replacing its internal data array, kept in the field elementData, with a smaller one. An application can use this operation to minimize the storage of a vector.
java.util.Vector: java.util.Vector.writeObject	(	java.io.ObjectOutputStream	):  Save the state of the Vector instance to a stream (that is, serialize it). This method performs synchronization to ensure the consistency of the serialized data.
java.util.Hashtable: java.util.Hashtable:  This class implements a hash table, which maps keys to values. Any non-null object can be used as a key or as a value.  To successfully store and retrieve objects from a hashtable, the objects used as keys must implement the hashCode method and the equals method.  An instance of Hashtable has two parameters that affect its performance: initial capacity and load factor. The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. Note that the hash table is open: in the case of a "hash collision", a single bucket stores multiple entries, which must be searched sequentially. The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased. The initial capacity and load factor parameters are merely hints to the implementation. The exact details as to when and whether the rehash method is invoked are implementation-dependent. Generally, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the time cost to look up an entry (which is reflected in most Hashtable operations, including get and put). The initial capacity controls a tradeoff between wasted space and the need for rehash operations, which are time-consuming. No rehash operations will ever occur if the initial capacity is greater than the maximum number of entries the Hashtable will contain divided by its load factor. However, setting the initial capacity too high can waste space. If many entries are to be made into a Hashtable, creating it with a sufficiently large capacity may allow the entries to be inserted more efficiently than letting it perform automatic rehashing as needed to grow the table.  This example creates a hashtable of numbers. It uses the names of the numbers as keys:  Hashtable numbers = new Hashtable(); numbers.put("one", 1); numbers.put("two", 2); numbers.put("three", 3); To retrieve a number, use the following code:  Integer n = numbers.get("two"); if (n != null) System.out.println("two = " + n); }} The iterators returned by the iterator method of the collections returned by all of this class's "collection view methods" are fail-fast: if the Hashtable is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. The Enumerations returned by Hashtable's keys and elements methods are not fail-fast. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. As of the Java 2 platform v1.2, this class was retrofitted to implement the Map interface, making it a member of the  Java Collections Framework. Unlike the new collection implementations, Hashtable is synchronized. If a thread-safe implementation is not needed, it is recommended to use HashMap in place of Hashtable. If a thread-safe highly-concurrent implementation is desired, then it is recommended to use java.util.concurrent.ConcurrentHashMap in place of Hashtable.
java.util.Hashtable: java.util.Hashtable.Entry:  Hashtable bucket collision list entry
java.util.Hashtable: java.util.Hashtable.Enumerator:  A hashtable enumerator class. This class implements both the Enumeration and Iterator interfaces, but individual instances can be created with the Iterator methods disabled. This is necessary to avoid unintentionally increasing the capabilities granted a user by passing an Enumeration.
java.util.Hashtable: java.util.Hashtable.Hashtable	(	):  Constructs a new, empty hashtable with a default initial capacity (11) and load factor (0.75).
java.util.Hashtable: java.util.Hashtable.Hashtable	(	Map	):  Constructs a new hashtable with the same mappings as the given Map. The hashtable is created with an initial capacity sufficient to hold the mappings in the given Map and a default load factor (0.75).
java.util.Hashtable: java.util.Hashtable.Hashtable	(	int	):  Constructs a new, empty hashtable with the specified initial capacity and default load factor (0.75).
java.util.Hashtable: java.util.Hashtable.Hashtable	(	int	float	):  Constructs a new, empty hashtable with the specified initial capacity and the specified load factor.
java.util.Hashtable: java.util.Hashtable.clear	(	):  Clears this hashtable so that it contains no keys.
java.util.Hashtable: java.util.Hashtable.clone	(	):  Creates a shallow copy of this hashtable. All the structure of the hashtable itself is copied, but the keys and values are not cloned. This is a relatively expensive operation.
java.util.Hashtable: java.util.Hashtable.contains	(	Object	):  Tests if some key maps into the specified value in this hashtable. This operation is more expensive than the containsKey method. Note that this method is identical in functionality to containsValue, (which is part of the Map interface in the collections framework).
java.util.Hashtable: java.util.Hashtable.containsKey	(	Object	):  Tests if the specified object is a key in this hashtable.
java.util.Hashtable: java.util.Hashtable.containsValue	(	Object	):  Returns true if this hashtable maps one or more keys to this value. Note that this method is identical in functionality to contains (which predates the Map interface).
java.util.Hashtable: java.util.Hashtable.elements	(	):  Returns an enumeration of the values in this hashtable. Use the Enumeration methods on the returned object to fetch the elements sequentially.
java.util.Hashtable: java.util.Hashtable.entrySet	(	):  Returns a Set view of the mappings contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation, or through the setValue operation on a map entry returned by the iterator) the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.Hashtable: java.util.Hashtable.equals	(	Object	):  Compares the specified Object with this Map for equality, as per the definition in the Map interface.
java.util.Hashtable: java.util.Hashtable.get	(	Object	):  Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that (key.equals(k)), then this method returns v; otherwise it returns null. (There can be at most one such mapping.)
java.util.Hashtable: java.util.Hashtable.hashCode	(	):  Returns the hash code value for this Map as per the definition in the Map interface.
java.util.Hashtable: java.util.Hashtable.isEmpty	(	):  Tests if this hashtable maps no keys to values.
java.util.Hashtable: java.util.Hashtable.keySet	(	):  Returns a Set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.Hashtable: java.util.Hashtable.keys	(	):  Returns an enumeration of the keys in this hashtable.
java.util.Hashtable: java.util.Hashtable.put	(	K	V	):  Maps the specified key to the specified value in this hashtable. Neither the key nor the value can be null.  The value can be retrieved by calling the get method with a key that is equal to the original key.
java.util.Hashtable: java.util.Hashtable.putAll	(	Map	):  Copies all of the mappings from the specified map to this hashtable. These mappings will replace any mappings that this hashtable had for any of the keys currently in the specified map.
java.util.Hashtable: java.util.Hashtable.readObject	(	java.io.ObjectInputStream	):  Reconstitute the Hashtable from a stream (i.e., deserialize it).
java.util.Hashtable: java.util.Hashtable.reconstitutionPut	(	Entry[]	K	V	):  The put method used by readObject. This is provided because put is overridable and should not be called in readObject since the subclass will not yet be initialized. This differs from the regular put method in several ways. No checking for rehashing is necessary since the number of elements initially in the table is known. The modCount is not incremented because we are creating a new instance. Also, no return value is needed.
java.util.Hashtable: java.util.Hashtable.rehash	(	):  Increases the capacity of and internally reorganizes this hashtable, in order to accommodate and access its entries more efficiently. This method is called automatically when the number of keys in the hashtable exceeds this hashtable's capacity and load factor.
java.util.Hashtable: java.util.Hashtable.remove	(	Object	):  Removes the key (and its corresponding value) from this hashtable. This method does nothing if the key is not in the hashtable.
java.util.Hashtable: java.util.Hashtable.size	(	):  Returns the number of keys in this hashtable.
java.util.Hashtable: java.util.Hashtable.toString	(	):  Returns a string representation of this Hashtable object in the form of a set of entries, enclosed in braces and separated by the ASCII characters ", " (comma and space). Each entry is rendered as the key, an equals sign =, and the associated element, where the toString method is used to convert the key and element to strings.
java.util.Hashtable: java.util.Hashtable.values	(	):  Returns a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.Hashtable: java.util.Hashtable.writeObject	(	java.io.ObjectOutputStream	):  Save the state of the Hashtable to a stream (i.e., serialize it).
java.util.concurrent.BlockingQueue: java.util.concurrent.BlockingQueue:  A java.util.Queue that additionally supports operations that wait for the queue to become non-empty when retrieving an element, and wait for space to become available in the queue when storing an element. BlockingQueue methods come in four forms, with different ways of handling operations that cannot be satisfied immediately, but may be satisfied at some point in the future: one throws an exception, the second returns a special value (either null or false, depending on the operation), the third blocks the current thread indefinitely until the operation can succeed, and the fourth blocks for only a given maximum time limit before giving up. These methods are summarized in the following table:  Summary of BlockingQueue methods   Throws exception Special value Blocks Times out   Insert add add(e) offer offer(e) put put(e) offer() offer(e, time, unit)   Remove remove remove() poll poll() take take() poll() poll(time, unit)   Examine element element() peek peek() not applicable not applicable   A BlockingQueue does not accept null elements. Implementations throw NullPointerException on attempts to add, put or offer a null. A null is used as a sentinel value to indicate failure of poll operations. A BlockingQueue may be capacity bounded. At any given time it may have a remainingCapacity beyond which no additional elements can be put without blocking. A BlockingQueue without any intrinsic capacity constraints always reports a remaining capacity of Integer.MAX_VALUE. BlockingQueue implementations are designed to be used primarily for producer-consumer queues, but additionally support the java.util.Collection interface. So, for example, it is possible to remove an arbitrary element from a queue using remove(x). However, such operations are in general not performed very efficiently, and are intended for only occasional use, such as when a queued message is cancelled. BlockingQueue implementations are thread-safe. All queuing methods achieve their effects atomically using internal locks or other forms of concurrency control. However, the bulk Collection operations addAll, containsAll, retainAll and removeAll are not necessarily performed atomically unless specified otherwise in an implementation. So it is possible, for example, for addAll(c) to fail (throwing an exception) after adding only some of the elements in c. A BlockingQueue does not intrinsically support any kind of "close" or "shutdown" operation to indicate that no more items will be added. The needs and usage of such features tend to be implementation-dependent. For example, a common tactic is for producers to insert special end-of-stream or poison objects, that are interpreted accordingly when taken by consumers.  Usage example, based on a typical producer-consumer scenario. Note that a BlockingQueue can safely be used with multiple producers and multiple consumers.  class Producer implements Runnable private final BlockingQueue queue; Producer(BlockingQueue q) { queue = q; } public void run() { try { while (true) { queue.put(produce()); } } catch (InterruptedException ex) { ... handle ...} } Object produce() { ... } } class Consumer implements Runnable { private final BlockingQueue queue; Consumer(BlockingQueue q) { queue = q; } public void run() { try { while (true) { consume(queue.take()); } } catch (InterruptedException ex) { ... handle ...} } void consume(Object x) { ... } } class Setup { void main() { BlockingQueue q = new SomeQueueImplementation(); Producer p = new Producer(q); Consumer c1 = new Consumer(q); Consumer c2 = new Consumer(q); new Thread(p).start(); new Thread(c1).start(); new Thread(c2).start(); } }} Memory consistency effects: As with other concurrent collections, actions in a thread prior to placing an object into a BlockingQueue happen-before actions subsequent to the access or removal of that element from the BlockingQueue in another thread. This interface is a member of the  Java Collections Framework.
java.util.concurrent.BlockingQueue: java.util.concurrent.BlockingQueue.add	(	E	):  Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an IllegalStateException if no space is currently available. When using a capacity-restricted queue, it is generally preferable to use offer().
java.util.concurrent.BlockingQueue: java.util.concurrent.BlockingQueue.contains	(	Object	):  Returns true if this queue contains the specified element. More formally, returns true if and only if this queue contains at least one element e such that o.equals(e).
java.util.concurrent.BlockingQueue: java.util.concurrent.BlockingQueue.drainTo	(	Collection	):  Removes all available elements from this queue and adds them to the given collection. This operation may be more efficient than repeatedly polling this queue. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.BlockingQueue: java.util.concurrent.BlockingQueue.drainTo	(	Collection	int	):  Removes at most the given number of available elements from this queue and adds them to the given collection. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.BlockingQueue: java.util.concurrent.BlockingQueue.offer	(	E	):  Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available. When using a capacity-restricted queue, this method is generally preferable to add, which can fail to insert an element only by throwing an exception.
java.util.concurrent.BlockingQueue: java.util.concurrent.BlockingQueue.offer	(	E	long	TimeUnit	):  Inserts the specified element into this queue, waiting up to the specified wait time if necessary for space to become available.
java.util.concurrent.BlockingQueue: java.util.concurrent.BlockingQueue.poll	(	long	TimeUnit	):  Retrieves and removes the head of this queue, waiting up to the specified wait time if necessary for an element to become available.
java.util.concurrent.BlockingQueue: java.util.concurrent.BlockingQueue.put	(	E	):  Inserts the specified element into this queue, waiting if necessary for space to become available.
java.util.concurrent.BlockingQueue: java.util.concurrent.BlockingQueue.remainingCapacity	(	):  Returns the number of additional elements that this queue can ideally (in the absence of memory or resource constraints) accept without blocking, or Integer.MAX_VALUE if there is no intrinsic limit. Note that you cannot always tell if an attempt to insert an element will succeed by inspecting remainingCapacity because it may be the case that another thread is about to insert or remove an element.
java.util.concurrent.BlockingQueue: java.util.concurrent.BlockingQueue.remove	(	Object	):  Removes a single instance of the specified element from this queue, if it is present. More formally, removes an element e such that o.equals(e), if this queue contains one or more such elements. Returns true if this queue contained the specified element (or equivalently, if this queue changed as a result of the call).
java.util.concurrent.BlockingQueue: java.util.concurrent.BlockingQueue.take	(	):  Retrieves and removes the head of this queue, waiting if necessary until an element becomes available.
java.util.concurrent.ConcurrentMap: java.util.concurrent.ConcurrentMap:  A java.util.Map providing thread safety and atomicity guarantees. Memory consistency effects: As with other concurrent collections, actions in a thread prior to placing an object into a ConcurrentMap as a key or value happen-before actions subsequent to the access or removal of that object from the ConcurrentMap in another thread. This interface is a member of the  Java Collections Framework.
java.util.concurrent.ConcurrentMap: java.util.concurrent.ConcurrentMap.compute	(	K	BiFunction	):  Attempts to compute a mapping for the specified key and its current mapped value (or null if there is no current mapping). For example, to either create or append a String msg to a value mapping:  map.compute(key, (k, v) -> (v == null) ? msg : v.concat(msg)) (Method merge merge() is often simpler to use for such purposes.) If the function returns null, the mapping is removed (or remains absent if initially absent). If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.
java.util.concurrent.ConcurrentMap: java.util.concurrent.ConcurrentMap.computeIfAbsent	(	K	Function	):  If the specified key is not already associated with a value (or is mapped to null), attempts to compute its value using the given mapping function and enters it into this map unless null. If the function returns null no mapping is recorded. If the function itself throws an (unchecked) exception, the exception is rethrown, and no mapping is recorded. The most common usage is to construct a new object serving as an initial mapped value or memoized result, as in:  map.computeIfAbsent(key, k -> new Value(f(k))); Or to implement a multi-value map, Map>, supporting multiple values per key:  map.computeIfAbsent(key, k -> new HashSet()).add(v);
java.util.concurrent.ConcurrentMap: java.util.concurrent.ConcurrentMap.computeIfPresent	(	K	BiFunction	):  If the value for the specified key is present and non-null, attempts to compute a new mapping given the key and its current mapped value. If the function returns null, the mapping is removed. If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.
java.util.concurrent.ConcurrentMap: java.util.concurrent.ConcurrentMap.forEach	(	BiConsumer	):  Performs the given action for each entry in this map until all entries have been processed or the action throws an exception. Unless otherwise specified by the implementing class, actions are performed in the order of entry set iteration (if an iteration order is specified.) Exceptions thrown by the action are relayed to the caller.
java.util.concurrent.ConcurrentMap: java.util.concurrent.ConcurrentMap.getOrDefault	(	Object	V	):  Returns the value to which the specified key is mapped, or defaultValue if this map contains no mapping for the key.
java.util.concurrent.ConcurrentMap: java.util.concurrent.ConcurrentMap.merge	(	K	V	BiFunction	):  If the specified key is not already associated with a value or is associated with null, associates it with the given non-null value. Otherwise, replaces the associated value with the results of the given remapping function, or removes if the result is null. This method may be of use when combining multiple mapped values for a key. For example, to either create or append a String msg to a value mapping:  map.merge(key, msg, String::concat) If the function returns null the mapping is removed. If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.
java.util.concurrent.ConcurrentMap: java.util.concurrent.ConcurrentMap.putIfAbsent	(	K	V	):  If the specified key is not already associated with a value, associate it with the given value. This is equivalent to  if (!map.containsKey(key)) return map.put(key, value); else return map.get(key); except that the action is performed atomically.
java.util.concurrent.ConcurrentMap: java.util.concurrent.ConcurrentMap.remove	(	Object	Object	):  Removes the entry for a key only if currently mapped to a given value. This is equivalent to  if (map.containsKey(key) && Objects.equals(map.get(key), value)) map.remove(key); return true; } else return false; } except that the action is performed atomically.
java.util.concurrent.ConcurrentMap: java.util.concurrent.ConcurrentMap.replace	(	K	V	):  Replaces the entry for a key only if currently mapped to some value. This is equivalent to  if (map.containsKey(key)) return map.put(key, value); } else return null; } except that the action is performed atomically.
java.util.concurrent.ConcurrentMap: java.util.concurrent.ConcurrentMap.replace	(	K	V	V	):  Replaces the entry for a key only if currently mapped to a given value. This is equivalent to  if (map.containsKey(key) && Objects.equals(map.get(key), oldValue)) map.put(key, newValue); return true; } else return false; } except that the action is performed atomically.
java.util.concurrent.ConcurrentMap: java.util.concurrent.ConcurrentMap.replaceAll	(	BiFunction	):  Replaces each entry's value with the result of invoking the given function on that entry until all entries have been processed or the function throws an exception. Exceptions thrown by the function are relayed to the caller.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList:  A thread-safe variant of java.util.ArrayList in which all mutative operations (add, set, and so on) are implemented by making a fresh copy of the underlying array. This is ordinarily too costly, but may be more efficient than alternatives when traversal operations vastly outnumber mutations, and is useful when you cannot or don't want to synchronize traversals, yet need to preclude interference among concurrent threads. The "snapshot" style iterator method uses a reference to the state of the array at the point that the iterator was created. This array never changes during the lifetime of the iterator, so interference is impossible and the iterator is guaranteed not to throw ConcurrentModificationException. The iterator will not reflect additions, removals, or changes to the list since the iterator was created. Element-changing operations on iterators themselves (remove, set, and add) are not supported. These methods throw UnsupportedOperationException. All elements are permitted, including null. Memory consistency effects: As with other concurrent collections, actions in a thread prior to placing an object into a CopyOnWriteArrayList happen-before actions subsequent to the access or removal of that element from the CopyOnWriteArrayList in another thread. This class is a member of the  Java Collections Framework.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.COWIterator.add	(	E	):  Not supported. Always throws UnsupportedOperationException.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.COWIterator.remove	(	):  Not supported. Always throws UnsupportedOperationException.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.COWIterator.set	(	E	):  Not supported. Always throws UnsupportedOperationException.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.COWSubList:  Sublist for CopyOnWriteArrayList. This class extends AbstractList merely for convenience, to avoid having to define addAll, etc. This doesn't hurt, but is wasteful. This class does not need or use modCount mechanics in AbstractList, but does need to check for concurrent modification using similar mechanics. On each operation, the array that we expect the backing list to use is checked and updated. Since we do this for all of the base operations invoked by those defined in AbstractList, all is well. While inefficient, this is not worth improving. The kinds of list operations inherited from AbstractList are already so slow on COW sublists that adding a bit more space/time doesn't seem even noticeable.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.CopyOnWriteArrayList	(	):  Creates an empty list.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.CopyOnWriteArrayList	(	Collection	):  Creates a list containing the elements of the specified collection, in the order they are returned by the collection's iterator.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.CopyOnWriteArrayList	(	E[]	):  Creates a list holding a copy of the given array.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.add	(	E	):  Appends the specified element to the end of this list.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.add	(	int	E	):  Inserts the specified element at the specified position in this list. Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices).
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.addAll	(	Collection	):  Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's iterator.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.addAll	(	int	Collection	):  Inserts all of the elements in the specified collection into this list, starting at the specified position. Shifts the element currently at that position (if any) and any subsequent elements to the right (increases their indices). The new elements will appear in this list in the order that they are returned by the specified collection's iterator.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.addAllAbsent	(	Collection	):  Appends all of the elements in the specified collection that are not already contained in this list, to the end of this list, in the order that they are returned by the specified collection's iterator.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.addIfAbsent	(	E	):  Appends the element, if not present.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.addIfAbsent	(	E	Object[]	):  A version of addIfAbsent using the strong hint that given recent snapshot does not contain e.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.clear	(	):  Removes all of the elements from this list. The list will be empty after this call returns.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.clone	(	):  Returns a shallow copy of this list. (The elements themselves are not copied.)
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.contains	(	Object	):  Returns true if this list contains the specified element. More formally, returns true if and only if this list contains at least one element e such that (o==null ? e==null : o.equals(e)).
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.containsAll	(	Collection	):  Returns true if this list contains all of the elements of the specified collection.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.eq	(	Object	Object	):  Tests for equality, coping with nulls.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.equals	(	Object	):  Compares the specified object with this list for equality. Returns true if the specified object is the same object as this object, or if it is also a List and the sequence of elements returned by an iterator() over the specified list is the same as the sequence returned by an iterator over this list. The two sequences are considered to be the same if they have the same length and corresponding elements at the same position in the sequence are equal. Two elements e1 and e2 are considered equal if (e1==null ? e2==null : e1.equals(e2)).
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.get	(	int	):  Returns the element at the specified position in this list.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.getArray	(	):  Gets the array. Non-private so as to also be accessible from CopyOnWriteArraySet class.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.hashCode	(	):  Returns the hash code value for this list. This implementation uses the definition in hashCode.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.indexOf	(	E	int	):  Returns the index of the first occurrence of the specified element in this list, searching forwards from index, or returns -1 if the element is not found. More formally, returns the lowest index i such that (i >= index && (e==null ? get(i)==null : e.equals(get(i)))), or -1 if there is no such index.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.indexOf	(	Object	):  Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.indexOf	(	Object	Object[]	int	int	):  static version of indexOf, to allow repeated calls without needing to re-acquire array each time.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.isEmpty	(	):  Returns true if this list contains no elements.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.iterator	(	):  Returns an iterator over the elements in this list in proper sequence. The returned iterator provides a snapshot of the state of the list when the iterator was constructed. No synchronization is needed while traversing the iterator. The iterator does NOT support the remove method.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.lastIndexOf	(	E	int	):  Returns the index of the last occurrence of the specified element in this list, searching backwards from index, or returns -1 if the element is not found. More formally, returns the highest index i such that (i <= index && (e==null ? get(i)==null : e.equals(get(i)))), or -1 if there is no such index.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.lastIndexOf	(	Object	):  Returns the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the highest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.lastIndexOf	(	Object	Object[]	int	):  static version of lastIndexOf.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.listIterator	(	):  Returns a list iterator over the elements in this list (in proper sequence). The returned iterator provides a snapshot of the state of the list when the iterator was constructed. No synchronization is needed while traversing the iterator. The iterator does NOT support the remove, set or add methods.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.listIterator	(	int	):  Returns a list iterator over the elements in this list (in proper sequence), starting at the specified position in the list. The specified index indicates the first element that would be returned by an initial call to next. An initial call to previous would return the element with the specified index minus one. The returned iterator provides a snapshot of the state of the list when the iterator was constructed. No synchronization is needed while traversing the iterator. The iterator does NOT support the remove, set or add methods.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.readObject	(	java.io.ObjectInputStream	):  Reconstitutes this list from a stream (that is, deserializes it).
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.remove	(	Object	):  Removes the first occurrence of the specified element from this list, if it is present. If this list does not contain the element, it is unchanged. More formally, removes the element with the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))) (if such an element exists). Returns true if this list contained the specified element (or equivalently, if this list changed as a result of the call).
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.remove	(	Object	Object[]	int	):  A version of remove(Object) using the strong hint that given recent snapshot contains o at the given index.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.remove	(	int	):  Removes the element at the specified position in this list. Shifts any subsequent elements to the left (subtracts one from their indices). Returns the element that was removed from the list.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.removeAll	(	Collection	):  Removes from this list all of its elements that are contained in the specified collection. This is a particularly expensive operation in this class because of the need for an internal temporary array.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.removeRange	(	int	int	):  Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive. Shifts any succeeding elements to the left (reduces their index). This call shortens the list by (toIndex - fromIndex) elements. (If toIndex==fromIndex, this operation has no effect.)
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.retainAll	(	Collection	):  Retains only the elements in this list that are contained in the specified collection. In other words, removes from this list all of its elements that are not contained in the specified collection.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.set	(	int	E	):  Replaces the element at the specified position in this list with the specified element.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.setArray	(	Object[]	):  Sets the array.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.size	(	):  Returns the number of elements in this list.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.spliterator	(	):  Returns a Spliterator over the elements in this list. The Spliterator reports IMMUTABLE, ORDERED, SIZED, and SUBSIZED. The spliterator provides a snapshot of the state of the list when the spliterator was constructed. No synchronization is needed while operating on the spliterator.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.subList	(	int	int	):  Returns a view of the portion of this list between fromIndex, inclusive, and toIndex, exclusive. The returned list is backed by this list, so changes in the returned list are reflected in this list. The semantics of the list returned by this method become undefined if the backing list (i.e., this list) is modified in any way other than via the returned list.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.toArray	(	):  Returns an array containing all of the elements in this list in proper sequence (from first to last element). The returned array will be "safe" in that no references to it are maintained by this list. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.toArray	(	T	):  Returns an array containing all of the elements in this list in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array. If the list fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this list. If this list fits in the specified array with room to spare (i.e., the array has more elements than this list), the element in the array immediately following the end of the list is set to null. (This is useful in determining the length of this list only if the caller knows that this list does not contain any null elements.) Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a list known to contain only strings. The following code can be used to dump the list into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.toString	(	):  Returns a string representation of this list. The string representation consists of the string representations of the list's elements in the order they are returned by its iterator, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (comma and space). Elements are converted to strings as by valueOf().
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.writeObject	(	java.io.ObjectOutputStream	):  Saves this list to a stream (that is, serializes it).
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet:  A java.util.Set that uses an internal CopyOnWriteArrayList for all of its operations. Thus, it shares the same basic properties:  It is best suited for applications in which set sizes generally stay small, read-only operations vastly outnumber mutative operations, and you need to prevent interference among threads during traversal. It is thread-safe. Mutative operations (add, set, remove, etc.) are expensive since they usually entail copying the entire underlying array. Iterators do not support the mutative remove operation. Traversal via iterators is fast and cannot encounter interference from other threads. Iterators rely on unchanging snapshots of the array at the time the iterators were constructed.  Sample Usage. The following code sketch uses a copy-on-write set to maintain a set of Handler objects that perform some action upon state updates.  class Handler { void handle(); ... } class X { private final CopyOnWriteArraySet handlers = new CopyOnWriteArraySet(); public void addHandler(Handler h) { handlers.add(h); } private long internalState; private synchronized void changeState() { internalState = ...; } public void update() { changeState(); for (Handler handler : handlers) handler.handle(); } }} This class is a member of the  Java Collections Framework.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.CopyOnWriteArraySet	(	):  Creates an empty set.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.CopyOnWriteArraySet	(	Collection	):  Creates a set containing all of the elements of the specified collection.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.add	(	E	):  Adds the specified element to this set if it is not already present. More formally, adds the specified element e to this set if the set contains no element e2 such that (e==null ? e2==null : e.equals(e2)). If this set already contains the element, the call leaves the set unchanged and returns false.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.addAll	(	Collection	):  Adds all of the elements in the specified collection to this set if they're not already present. If the specified collection is also a set, the addAll operation effectively modifies this set so that its value is the union of the two sets. The behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.clear	(	):  Removes all of the elements from this set. The set will be empty after this call returns.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.contains	(	Object	):  Returns true if this set contains the specified element. More formally, returns true if and only if this set contains an element e such that (o==null ? e==null : o.equals(e)).
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.containsAll	(	Collection	):  Returns true if this set contains all of the elements of the specified collection. If the specified collection is also a set, this method returns true if it is a subset of this set.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.eq	(	Object	Object	):  Tests for equality, coping with nulls.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.equals	(	Object	):  Compares the specified object with this set for equality. Returns true if the specified object is the same object as this object, or if it is also a Set and the elements returned by an iterator() over the specified set are the same as the elements returned by an iterator over this set. More formally, the two iterators are considered to return the same elements if they return the same number of elements and for every element e1 returned by the iterator over the specified set, there is an element e2 returned by the iterator over this set such that (e1==null ? e2==null : e1.equals(e2)).
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.isEmpty	(	):  Returns true if this set contains no elements.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.iterator	(	):  Returns an iterator over the elements contained in this set in the order in which these elements were added. The returned iterator provides a snapshot of the state of the set when the iterator was constructed. No synchronization is needed while traversing the iterator. The iterator does NOT support the remove method.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.remove	(	Object	):  Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.removeAll	(	Collection	):  Removes from this set all of its elements that are contained in the specified collection. If the specified collection is also a set, this operation effectively modifies this set so that its value is the asymmetric set difference of the two sets.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.retainAll	(	Collection	):  Retains only the elements in this set that are contained in the specified collection. In other words, removes from this set all of its elements that are not contained in the specified collection. If the specified collection is also a set, this operation effectively modifies this set so that its value is the intersection of the two sets.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.size	(	):  Returns the number of elements in this set.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.spliterator	(	):  Returns a Spliterator over the elements in this set in the order in which these elements were added. The Spliterator reports IMMUTABLE, DISTINCT, SIZED, and SUBSIZED. The spliterator provides a snapshot of the state of the set when the spliterator was constructed. No synchronization is needed while operating on the spliterator.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.toArray	(	):  Returns an array containing all of the elements in this set. If this set makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. The returned array will be "safe" in that no references to it are maintained by this set. (In other words, this method must allocate a new array even if this set is backed by an array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.toArray	(	T[]	):  Returns an array containing all of the elements in this set; the runtime type of the returned array is that of the specified array. If the set fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this set. If this set fits in the specified array with room to spare (i.e., the array has more elements than this set), the element in the array immediately following the end of the set is set to null. (This is useful in determining the length of this set only if the caller knows that this set does not contain any null elements.) If this set makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a set known to contain only strings. The following code can be used to dump the set into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.ConcurrentModificationException: java.util.ConcurrentModificationException:  This exception may be thrown by methods that have detected concurrent modification of an object when such modification is not permissible.  For example, it is not generally permissible for one thread to modify a Collection while another thread is iterating over it. In general, the results of the iteration are undefined under these circumstances. Some Iterator implementations (including those of all the general purpose collection implementations provided by the JRE) may choose to throw this exception if this behavior is detected. Iterators that do this are known as fail-fast iterators, as they fail quickly and cleanly, rather that risking arbitrary, non-deterministic behavior at an undetermined time in the future.  Note that this exception does not always indicate that an object has been concurrently modified by a different thread. If a single thread issues a sequence of method invocations that violates the contract of an object, the object may throw this exception. For example, if a thread modifies a collection directly while it is iterating over the collection with a fail-fast iterator, the iterator will throw this exception. Note that fail-fast behavior cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast operations throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: ConcurrentModificationException should be used only to detect bugs.
java.util.ConcurrentModificationException: java.util.ConcurrentModificationException.ConcurrentModificationException	(	):  Constructs a ConcurrentModificationException with no detail message.
java.util.ConcurrentModificationException: java.util.ConcurrentModificationException.ConcurrentModificationException	(	String	):  Constructs a ConcurrentModificationException with the specified detail message.
java.util.ConcurrentModificationException: java.util.ConcurrentModificationException.ConcurrentModificationException	(	String	Throwable	):  Constructs a new exception with the specified detail message and cause. Note that the detail message associated with cause is not automatically incorporated in this exception's detail message.
java.util.ConcurrentModificationException: java.util.ConcurrentModificationException.ConcurrentModificationException	(	Throwable	):  Constructs a new exception with the specified cause and a detail message of (cause==null ? null : cause.toString()) (which typically contains the class and detail message of cause.
java.util.EnumMap: java.util.EnumMap:  A specialized Map implementation for use with enum type keys. All of the keys in an enum map must come from a single enum type that is specified, explicitly or implicitly, when the map is created. Enum maps are represented internally as arrays. This representation is extremely compact and efficient. Enum maps are maintained in the natural order of their keys (the order in which the enum constants are declared). This is reflected in the iterators returned by the collections views (keySet(), entrySet(), and values()). Iterators returned by the collection views are weakly consistent: they will never throw ConcurrentModificationException and they may or may not show the effects of any modifications to the map that occur while the iteration is in progress. Null keys are not permitted. Attempts to insert a null key will throw NullPointerException. Attempts to test for the presence of a null key or to remove one will, however, function properly. Null values are permitted. Like most collection implementations EnumMap is not synchronized. If multiple threads access an enum map concurrently, and at least one of the threads modifies the map, it should be synchronized externally. This is typically accomplished by synchronizing on some object that naturally encapsulates the enum map. If no such object exists, the map should be "wrapped" using the synchronizedMap method. This is best done at creation time, to prevent accidental unsynchronized access:  Map<EnumKey, V> m = Collections.synchronizedMap(new EnumMap<EnumKey, V>(...));  Implementation note: All basic operations execute in constant time. They are likely (though not guaranteed) to be faster than their HashMap counterparts. This class is a member of the  Java Collections Framework.
java.util.EnumMap: java.util.EnumMap.EnumMap	(	Class	):  Creates an empty enum map with the specified key type.
java.util.EnumMap: java.util.EnumMap.EnumMap	(	EnumMap	):  Creates an enum map with the same key type as the specified enum map, initially containing the same mappings (if any).
java.util.EnumMap: java.util.EnumMap.EnumMap	(	Map	):  Creates an enum map initialized from the specified map. If the specified map is an EnumMap instance, this constructor behaves identically to EnumMap(). Otherwise, the specified map must contain at least one mapping (in order to determine the new enum map's key type).
java.util.EnumMap: java.util.EnumMap.clear	(	):  Removes all mappings from this map.
java.util.EnumMap: java.util.EnumMap.clone	(	):  Returns a shallow copy of this enum map. (The values themselves are not cloned.
java.util.EnumMap: java.util.EnumMap.containsKey	(	Object	):  Returns true if this map contains a mapping for the specified key.
java.util.EnumMap: java.util.EnumMap.containsValue	(	Object	):  Returns true if this map maps one or more keys to the specified value.
java.util.EnumMap: java.util.EnumMap.entrySet	(	):  Returns a Set view of the mappings contained in this map. The returned set obeys the general contract outlined in keySet(). The set's iterator will return the mappings in the order their keys appear in map, which is their natural order (the order in which the enum constants are declared).
java.util.EnumMap: java.util.EnumMap.equals	(	Object	):  Compares the specified object with this map for equality. Returns true if the given object is also a map and the two maps represent the same mappings, as specified in the equals() contract.
java.util.EnumMap: java.util.EnumMap.get	(	Object	):  Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that (key == k), then this method returns v; otherwise it returns null. (There can be at most one such mapping.) A return value of null does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to null. The containsKey operation may be used to distinguish these two cases.
java.util.EnumMap: java.util.EnumMap.getKeyUniverse	(	Class	):  Returns all of the values comprising K. The result is uncloned, cached, and shared by all callers.
java.util.EnumMap: java.util.EnumMap.hashCode	(	):  Returns the hash code value for this map. The hash code of a map is defined to be the sum of the hash codes of each entry in the map.
java.util.EnumMap: java.util.EnumMap.isValidKey	(	Object	):  Returns true if key is of the proper type to be a key in this enum map.
java.util.EnumMap: java.util.EnumMap.keySet	(	):  Returns a Set view of the keys contained in this map. The returned set obeys the general contract outlined in keySet(). The set's iterator will return the keys in their natural order (the order in which the enum constants are declared).
java.util.EnumMap: java.util.EnumMap.put	(	K	V	):  Associates the specified value with the specified key in this map. If the map previously contained a mapping for this key, the old value is replaced.
java.util.EnumMap: java.util.EnumMap.putAll	(	Map	):  Copies all of the mappings from the specified map to this map. These mappings will replace any mappings that this map had for any of the keys currently in the specified map.
java.util.EnumMap: java.util.EnumMap.readObject	(	java.io.ObjectInputStream	):  Reconstitute the EnumMap instance from a stream (i.e., deserialize it).
java.util.EnumMap: java.util.EnumMap.remove	(	Object	):  Removes the mapping for this key from this map if present.
java.util.EnumMap: java.util.EnumMap.size	(	):  Returns the number of key-value mappings in this map.
java.util.EnumMap: java.util.EnumMap.typeCheck	(	K	):  Throws an exception if e is not of the correct type for this enum set.
java.util.EnumMap: java.util.EnumMap.values	(	):  Returns a Collection view of the values contained in this map. The returned collection obeys the general contract outlined in values(). The collection's iterator will return the values in the order their corresponding keys appear in map, which is their natural order (the order in which the enum constants are declared).
java.util.EnumMap: java.util.EnumMap.writeObject	(	java.io.ObjectOutputStream	):  Save the state of the EnumMap instance to a stream (i.e., serialize it).
java.util.WeakHashMap: java.util.WeakHashMap:  Hash table based implementation of the Map interface, with weak keys. An entry in a WeakHashMap will automatically be removed when its key is no longer in ordinary use. More precisely, the presence of a mapping for a given key will not prevent the key from being discarded by the garbage collector, that is, made finalizable, finalized, and then reclaimed. When a key has been discarded its entry is effectively removed from the map, so this class behaves somewhat differently from other Map implementations.  Both null values and the null key are supported. This class has performance characteristics similar to those of the HashMap class, and has the same efficiency parameters of initial capacity and load factor.  Like most collection classes, this class is not synchronized. A synchronized WeakHashMap may be constructed using the synchronizedMap Collections.synchronizedMap method.  This class is intended primarily for use with key objects whose equals methods test for object identity using the == operator. Once such a key is discarded it can never be recreated, so it is impossible to do a lookup of that key in a WeakHashMap at some later time and be surprised that its entry has been removed. This class will work perfectly well with key objects whose equals methods are not based upon object identity, such as String instances. With such recreatable key objects, however, the automatic removal of WeakHashMap entries whose keys have been discarded may prove to be confusing.  The behavior of the WeakHashMap class depends in part upon the actions of the garbage collector, so several familiar (though not required) Map invariants do not hold for this class. Because the garbage collector may discard keys at any time, a WeakHashMap may behave as though an unknown thread is silently removing entries. In particular, even if you synchronize on a WeakHashMap instance and invoke none of its mutator methods, it is possible for the size method to return smaller values over time, for the isEmpty method to return false and then true, for the containsKey method to return true and later false for a given key, for the get method to return a value for a given key but later return null, for the put method to return null and the remove method to return false for a key that previously appeared to be in the map, and for successive examinations of the key set, the value collection, and the entry set to yield successively smaller numbers of elements.  Each key object in a WeakHashMap is stored indirectly as the referent of a weak reference. Therefore a key will automatically be removed only after the weak references to it, both inside and outside of the map, have been cleared by the garbage collector.  Implementation note: The value objects in a WeakHashMap are held by ordinary strong references. Thus care should be taken to ensure that value objects do not strongly refer to their own keys, either directly or indirectly, since that will prevent the keys from being discarded. Note that a value object may refer indirectly to its key via the WeakHashMap itself; that is, a value object may strongly refer to some other key object whose associated value object, in turn, strongly refers to the key of the first value object. If the values in the map do not rely on the map holding strong references to them, one way to deal with this is to wrap values themselves within WeakReferences before inserting, as in: m.put(key, new WeakReference(value)), and then unwrapping upon each get. The iterators returned by the iterator method of the collections returned by all of this class's "collection view methods" are fail-fast: if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. This class is a member of the  Java Collections Framework.
java.util.WeakHashMap: java.util.WeakHashMap.Entry:  The entries in this hash table extend WeakReference, using its main ref field as the key.
java.util.WeakHashMap: java.util.WeakHashMap.Entry.Entry	(	Object	V	ReferenceQueue	int	Entry	):  Creates new entry.
java.util.WeakHashMap: java.util.WeakHashMap.HashIterator.nextEntry	(	):  The common parts of next() across different types of iterators 
java.util.WeakHashMap: java.util.WeakHashMap.WeakHashMap	(	):  Constructs a new, empty WeakHashMap with the default initial capacity (16) and load factor (0.75).
java.util.WeakHashMap: java.util.WeakHashMap.WeakHashMap	(	Map	):  Constructs a new WeakHashMap with the same mappings as the specified map. The WeakHashMap is created with the default load factor (0.75) and an initial capacity sufficient to hold the mappings in the specified map.
java.util.WeakHashMap: java.util.WeakHashMap.WeakHashMap	(	int	):  Constructs a new, empty WeakHashMap with the given initial capacity and the default load factor (0.75).
java.util.WeakHashMap: java.util.WeakHashMap.WeakHashMap	(	int	float	):  Constructs a new, empty WeakHashMap with the given initial capacity and the given load factor.
java.util.WeakHashMap: java.util.WeakHashMap.WeakHashMapSpliterator:  Similar form as other hash Spliterators, but skips dead elements.
java.util.WeakHashMap: java.util.WeakHashMap.clear	(	):  Removes all of the mappings from this map. The map will be empty after this call returns.
java.util.WeakHashMap: java.util.WeakHashMap.containsKey	(	Object	):  Returns true if this map contains a mapping for the specified key.
java.util.WeakHashMap: java.util.WeakHashMap.containsNullValue	(	):  Special-case code for containsValue with null argument
java.util.WeakHashMap: java.util.WeakHashMap.containsValue	(	Object	):  Returns true if this map maps one or more keys to the specified value.
java.util.WeakHashMap: java.util.WeakHashMap.entrySet	(	):  Returns a Set view of the mappings contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation, or through the setValue operation on a map entry returned by the iterator) the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.WeakHashMap: java.util.WeakHashMap.eq	(	Object	Object	):  Checks for equality of non-null reference x and possibly-null y. By default uses Object.equals.
java.util.WeakHashMap: java.util.WeakHashMap.expungeStaleEntries	(	):  Expunges stale entries from the table.
java.util.WeakHashMap: java.util.WeakHashMap.get	(	Object	):  Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that (key==null ? k==null : key.equals(k)), then this method returns v; otherwise it returns null. (There can be at most one such mapping.) A return value of null does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to null. The containsKey operation may be used to distinguish these two cases.
java.util.WeakHashMap: java.util.WeakHashMap.getEntry	(	Object	):  Returns the entry associated with the specified key in this map. Returns null if the map contains no mapping for this key.
java.util.WeakHashMap: java.util.WeakHashMap.getTable	(	):  Returns the table after first expunging stale entries.
java.util.WeakHashMap: java.util.WeakHashMap.hash	(	Object	):  Retrieve object hash code and applies a supplemental hash function to the result hash, which defends against poor quality hash functions. This is critical because HashMap uses power-of-two length hash tables, that otherwise encounter collisions for hashCodes that do not differ in lower bits.
java.util.WeakHashMap: java.util.WeakHashMap.indexFor	(	int	int	):  Returns index for hash code h.
java.util.WeakHashMap: java.util.WeakHashMap.isEmpty	(	):  Returns true if this map contains no key-value mappings. This result is a snapshot, and may not reflect unprocessed entries that will be removed before next attempted access because they are no longer referenced.
java.util.WeakHashMap: java.util.WeakHashMap.keySet	(	):  Returns a Set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.WeakHashMap: java.util.WeakHashMap.maskNull	(	Object	):  Use NULL_KEY for key if it is null.
java.util.WeakHashMap: java.util.WeakHashMap.put	(	K	V	):  Associates the specified value with the specified key in this map. If the map previously contained a mapping for this key, the old value is replaced.
java.util.WeakHashMap: java.util.WeakHashMap.putAll	(	Map	):  Copies all of the mappings from the specified map to this map. These mappings will replace any mappings that this map had for any of the keys currently in the specified map.
java.util.WeakHashMap: java.util.WeakHashMap.remove	(	Object	):  Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.
java.util.WeakHashMap: java.util.WeakHashMap.removeMapping	(	Object	):  Special version of remove needed by Entry set 
java.util.WeakHashMap: java.util.WeakHashMap.resize	(	int	):  Rehashes the contents of this map into a new array with a larger capacity. This method is called automatically when the number of keys in this map reaches its threshold. If current capacity is MAXIMUM_CAPACITY, this method does not resize the map, but sets threshold to Integer.MAX_VALUE. This has the effect of preventing future calls.
java.util.WeakHashMap: java.util.WeakHashMap.size	(	):  Returns the number of key-value mappings in this map. This result is a snapshot, and may not reflect unprocessed entries that will be removed before next attempted access because they are no longer referenced.
java.util.WeakHashMap: java.util.WeakHashMap.transfer	(	Entry[]	Entry[]	):  Transfers all entries from src to dest tables 
java.util.WeakHashMap: java.util.WeakHashMap.unmaskNull	(	Object	):  Returns internal representation of null key back to caller as null.
java.util.WeakHashMap: java.util.WeakHashMap.values	(	):  Returns a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.IdentityHashMap: java.util.IdentityHashMap:  This class implements the Map interface with a hash table, using reference-equality in place of object-equality when comparing keys (and values). In other words, in an IdentityHashMap, two keys k1 and k2 are considered equal if and only if (k1==k2). (In normal Map implementations (like HashMap) two keys k1 and k2 are considered equal if and only if (k1==null ? k2==null : k1.equals(k2)).) This class is not a general-purpose Map implementation! While this class implements the Map interface, it intentionally violates Map's general contract, which mandates the use of the equals method when comparing objects. This class is designed for use only in the rare cases wherein reference-equality semantics are required. A typical use of this class is topology-preserving object graph transformations, such as serialization or deep-copying. To perform such a transformation, a program must maintain a "node table" that keeps track of all the object references that have already been processed. The node table must not equate distinct objects even if they happen to be equal. Another typical use of this class is to maintain proxy objects. For example, a debugging facility might wish to maintain a proxy object for each object in the program being debugged. This class provides all of the optional map operations, and permits null values and the null key. This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time. This class provides constant-time performance for the basic operations (get and put), assuming the system identity hash function (identityHashCode()) disperses elements properly among the buckets. This class has one tuning parameter (which affects performance but not semantics): expected maximum size. This parameter is the maximum number of key-value mappings that the map is expected to hold. Internally, this parameter is used to determine the number of buckets initially comprising the hash table. The precise relationship between the expected maximum size and the number of buckets is unspecified. If the size of the map (the number of key-value mappings) sufficiently exceeds the expected maximum size, the number of buckets is increased. Increasing the number of buckets ("rehashing") may be fairly expensive, so it pays to create identity hash maps with a sufficiently large expected maximum size. On the other hand, iteration over collection views requires time proportional to the number of buckets in the hash table, so it pays not to set the expected maximum size too high if you are especially concerned with iteration performance or memory usage. Note that this implementation is not synchronized. If multiple threads access an identity hash map concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more mappings; merely changing the value associated with a key that an instance already contains is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the map. If no such object exists, the map should be "wrapped" using the synchronizedMap Collections.synchronizedMap method. This is best done at creation time, to prevent accidental unsynchronized access to the map: Map m = Collections.synchronizedMap(new IdentityHashMap(...)); The iterators returned by the iterator method of the collections returned by all of this class's "collection view methods" are fail-fast: if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: fail-fast iterators should be used only to detect bugs. Implementation note: This is a simple linear-probe hash table, as described for example in texts by Sedgewick and Knuth. The array alternates holding keys and values. (This has better locality for large tables than does using separate arrays.) For many JRE implementations and operation mixes, this class will yield better performance than HashMap (which uses chaining rather than linear-probing). This class is a member of the  Java Collections Framework.
java.util.IdentityHashMap: java.util.IdentityHashMap.IdentityHashMap	(	):  Constructs a new, empty identity hash map with a default expected maximum size (21).
java.util.IdentityHashMap: java.util.IdentityHashMap.IdentityHashMap	(	Map	):  Constructs a new identity hash map containing the keys-value mappings in the specified map.
java.util.IdentityHashMap: java.util.IdentityHashMap.IdentityHashMap	(	int	):  Constructs a new, empty map with the specified expected maximum size. Putting more than the expected number of key-value mappings into the map may cause the internal data structure to grow, which may be somewhat time-consuming.
java.util.IdentityHashMap: java.util.IdentityHashMap.IdentityHashMapSpliterator:  Similar form as array-based Spliterators, but skips blank elements, and guestimates size as decreasing by half per split.
java.util.IdentityHashMap: java.util.IdentityHashMap.capacity	(	int	):  Returns the appropriate capacity for the given expected maximum size. Returns the smallest power of two between MINIMUM_CAPACITY and MAXIMUM_CAPACITY, inclusive, that is greater than (3 expectedMaxSize)/2, if such a number exists. Otherwise returns MAXIMUM_CAPACITY.
java.util.IdentityHashMap: java.util.IdentityHashMap.clear	(	):  Removes all of the mappings from this map. The map will be empty after this call returns.
java.util.IdentityHashMap: java.util.IdentityHashMap.clone	(	):  Returns a shallow copy of this identity hash map: the keys and values themselves are not cloned.
java.util.IdentityHashMap: java.util.IdentityHashMap.closeDeletion	(	int	):  Rehash all possibly-colliding entries following a deletion. This preserves the linear-probe collision properties required by get, put, etc.
java.util.IdentityHashMap: java.util.IdentityHashMap.containsKey	(	Object	):  Tests whether the specified object reference is a key in this identity hash map.
java.util.IdentityHashMap: java.util.IdentityHashMap.containsMapping	(	Object	Object	):  Tests if the specified key-value mapping is in the map.
java.util.IdentityHashMap: java.util.IdentityHashMap.containsValue	(	Object	):  Tests whether the specified object reference is a value in this identity hash map.
java.util.IdentityHashMap: java.util.IdentityHashMap.entrySet	(	):  Returns a Set view of the mappings contained in this map. Each element in the returned set is a reference-equality-based Map.Entry. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress, the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll and clear methods. It does not support the add or addAll methods. Like the backing map, the Map.Entry objects in the set returned by this method define key and value equality as reference-equality rather than object-equality. This affects the behavior of the equals and hashCode methods of these Map.Entry objects. A reference-equality based Map.Entry e is equal to an object o if and only if o is a Map.Entry and e.getKey()==o.getKey() && e.getValue()==o.getValue(). To accommodate these equals semantics, the hashCode method returns System.identityHashCode(e.getKey()) ^ System.identityHashCode(e.getValue()). Owing to the reference-equality-based semantics of the Map.Entry instances in the set returned by this method, it is possible that the symmetry and transitivity requirements of the equals() contract may be violated if any of the entries in the set is compared to a normal map entry, or if the set returned by this method is compared to a set of normal map entries (such as would be returned by a call to this method on a normal map). However, the Object.equals contract is guaranteed to hold among identity-based map entries, and among sets of such entries. 
java.util.IdentityHashMap: java.util.IdentityHashMap.equals	(	Object	):  Compares the specified object with this map for equality. Returns true if the given object is also a map and the two maps represent identical object-reference mappings. More formally, this map is equal to another map m if and only if this.entrySet().equals(m.entrySet()). Owing to the reference-equality-based semantics of this map it is possible that the symmetry and transitivity requirements of the Object.equals contract may be violated if this map is compared to a normal map. However, the Object.equals contract is guaranteed to hold among IdentityHashMap instances.
java.util.IdentityHashMap: java.util.IdentityHashMap.get	(	Object	):  Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that (key == k), then this method returns v; otherwise it returns null. (There can be at most one such mapping.) A return value of null does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to null. The containsKey operation may be used to distinguish these two cases.
java.util.IdentityHashMap: java.util.IdentityHashMap.hash	(	Object	int	):  Returns index for Object x.
java.util.IdentityHashMap: java.util.IdentityHashMap.hashCode	(	):  Returns the hash code value for this map. The hash code of a map is defined to be the sum of the hash codes of each entry in the map's entrySet() view. This ensures that m1.equals(m2) implies that m1.hashCode()==m2.hashCode() for any two IdentityHashMap instances m1 and m2, as required by the general contract of hashCode. Owing to the reference-equality-based semantics of the Map.Entry instances in the set returned by this map's entrySet method, it is possible that the contractual requirement of Object.hashCode mentioned in the previous paragraph will be violated if one of the two objects being compared is an IdentityHashMap instance and the other is a normal map.
java.util.IdentityHashMap: java.util.IdentityHashMap.init	(	int	):  Initializes object to be an empty map with the specified initial capacity, which is assumed to be a power of two between MINIMUM_CAPACITY and MAXIMUM_CAPACITY inclusive.
java.util.IdentityHashMap: java.util.IdentityHashMap.isEmpty	(	):  Returns true if this identity hash map contains no key-value mappings.
java.util.IdentityHashMap: java.util.IdentityHashMap.keySet	(	):  Returns an identity-based set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress, the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear methods. It does not support the add or addAll methods. While the object returned by this method implements the Set interface, it does not obey Set's general contract. Like its backing map, the set returned by this method defines element equality as reference-equality rather than object-equality. This affects the behavior of its contains, remove, containsAll, equals, and hashCode methods. The equals method of the returned set returns true only if the specified object is a set containing exactly the same object references as the returned set. The symmetry and transitivity requirements of the Object.equals contract may be violated if the set returned by this method is compared to a normal set. However, the Object.equals contract is guaranteed to hold among sets returned by this method. The hashCode method of the returned set returns the sum of the identity hashcodes of the elements in the set, rather than the sum of their hashcodes. This is mandated by the change in the semantics of the equals method, in order to enforce the general contract of the Object.hashCode method among sets returned by this method.
java.util.IdentityHashMap: java.util.IdentityHashMap.maskNull	(	Object	):  Use NULL_KEY for key if it is null.
java.util.IdentityHashMap: java.util.IdentityHashMap.nextKeyIndex	(	int	int	):  Circularly traverses table of size len.
java.util.IdentityHashMap: java.util.IdentityHashMap.put	(	K	V	):  Associates the specified value with the specified key in this identity hash map. If the map previously contained a mapping for the key, the old value is replaced.
java.util.IdentityHashMap: java.util.IdentityHashMap.putAll	(	Map	):  Copies all of the mappings from the specified map to this map. These mappings will replace any mappings that this map had for any of the keys currently in the specified map.
java.util.IdentityHashMap: java.util.IdentityHashMap.putForCreate	(	K	V	):  The put method for readObject. It does not resize the table, update modCount, etc.
java.util.IdentityHashMap: java.util.IdentityHashMap.readObject	(	java.io.ObjectInputStream	):  Reconstitutes the IdentityHashMap instance from a stream (i.e., deserializes it).
java.util.IdentityHashMap: java.util.IdentityHashMap.remove	(	Object	):  Removes the mapping for this key from this map if present.
java.util.IdentityHashMap: java.util.IdentityHashMap.removeMapping	(	Object	Object	):  Removes the specified key-value mapping from the map if it is present.
java.util.IdentityHashMap: java.util.IdentityHashMap.resize	(	int	):  Resizes the table if necessary to hold given capacity.
java.util.IdentityHashMap: java.util.IdentityHashMap.size	(	):  Returns the number of key-value mappings in this identity hash map.
java.util.IdentityHashMap: java.util.IdentityHashMap.unmaskNull	(	Object	):  Returns internal representation of null key back to caller as null.
java.util.IdentityHashMap: java.util.IdentityHashMap.values	(	):  Returns a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress, the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear methods. It does not support the add or addAll methods. While the object returned by this method implements the Collection interface, it does not obey Collection's general contract. Like its backing map, the collection returned by this method defines element equality as reference-equality rather than object-equality. This affects the behavior of its contains, remove and containsAll methods.
java.util.IdentityHashMap: java.util.IdentityHashMap.writeObject	(	java.io.ObjectOutputStream	):  Saves the state of the IdentityHashMap instance to a stream (i.e., serializes it).
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap:  A hash table supporting full concurrency of retrievals and high expected concurrency for updates. This class obeys the same functional specification as java.util.Hashtable, and includes versions of methods corresponding to each method of Hashtable. However, even though all operations are thread-safe, retrieval operations do not entail locking, and there is not any support for locking the entire table in a way that prevents all access. This class is fully interoperable with Hashtable in programs that rely on its thread safety but not on its synchronization details. Retrieval operations (including get) generally do not block, so may overlap with update operations (including put and remove). Retrievals reflect the results of the most recently completed update operations holding upon their onset. (More formally, an update operation for a given key bears a happens-before relation with any (non-null) retrieval for that key reporting the updated value.) For aggregate operations such as putAll and clear, concurrent retrievals may reflect insertion or removal of only some entries. Similarly, Iterators, Spliterators and Enumerations return elements reflecting the state of the hash table at some point at or since the creation of the iterator/enumeration. They do not throw java.util.ConcurrentModificationException ConcurrentModificationException. However, iterators are designed to be used by only one thread at a time. Bear in mind that the results of aggregate status methods including size, isEmpty, and containsValue are typically useful only when a map is not undergoing concurrent updates in other threads. Otherwise the results of these methods reflect transient states that may be adequate for monitoring or estimation purposes, but not for program control. The table is dynamically expanded when there are too many collisions (i.e., keys that have distinct hash codes but fall into the same slot modulo the table size), with the expected average effect of maintaining roughly two bins per mapping (corresponding to a 0.75 load factor threshold for resizing). There may be much variance around this average as mappings are added and removed, but overall, this maintains a commonly accepted time/space tradeoff for hash tables. However, resizing this or any other kind of hash table may be a relatively slow operation. When possible, it is a good idea to provide a size estimate as an optional initialCapacity constructor argument. An additional optional loadFactor constructor argument provides a further means of customizing initial table capacity by specifying the table density to be used in calculating the amount of space to allocate for the given number of elements. Also, for compatibility with previous versions of this class, constructors may optionally specify an expected concurrencyLevel as an additional hint for internal sizing. Note that using many keys with exactly the same hashCode() is a sure way to slow down performance of any hash table. To ameliorate impact, when keys are Comparable, this class may use comparison order among keys to help break ties. A Set projection of a ConcurrentHashMap may be created (using newKeySet() or newKeySet()), or viewed (using keySet() when only keys are of interest, and the mapped values are (perhaps transiently) not used or all take the same mapping value. A ConcurrentHashMap can be used as scalable frequency map (a form of histogram or multiset) by using java.util.concurrent.atomic.LongAdder values and initializing via computeIfAbsent. For example, to add a count to a ConcurrentHashMap freqs, you can use freqs.computeIfAbsent(k -> new LongAdder()).increment(); This class and its views and iterators implement all of the optional methods of the Map and Iterator interfaces. Like Hashtable but unlike HashMap, this class does not allow null to be used as a key or value. ConcurrentHashMaps support a set of sequential and parallel bulk operations that, unlike most Stream methods, are designed to be safely, and often sensibly, applied even with maps that are being concurrently updated by other threads; for example, when computing a snapshot summary of the values in a shared registry. There are three kinds of operation, each with four forms, accepting functions with Keys, Values, Entries, and (Key, Value) arguments and/or return values. Because the elements of a ConcurrentHashMap are not ordered in any particular way, and may be processed in different orders in different parallel executions, the correctness of supplied functions should not depend on any ordering, or on any other objects or values that may transiently change while computation is in progress; and except for forEach actions, should ideally be side-effect-free. Bulk operations on java.util.Map.Entry objects do not support method setValue.   forEach: Perform a given action on each element. A variant form applies a given transformation on each element before performing the action.  search: Return the first available non-null result of applying a given function on each element; skipping further search when a result is found.  reduce: Accumulate each element. The supplied reduction function cannot rely on ordering (more formally, it should be both associative and commutative). There are five variants:   Plain reductions. (There is not a form of this method for (key, value) function arguments since there is no corresponding return type.)  Mapped reductions that accumulate the results of a given function applied to each element.  Reductions to scalar doubles, longs, and ints, using a given basis value.    These bulk operations accept a parallelismThreshold argument. Methods proceed sequentially if the current map size is estimated to be less than the given threshold. Using a value of Long.MAX_VALUE suppresses all parallelism. Using a value of 1 results in maximal parallelism by partitioning into enough subtasks to fully utilize the commonPool() that is used for all parallel computations. Normally, you would initially choose one of these extreme values, and then measure performance of using in-between values that trade off overhead versus throughput. The concurrency properties of bulk operations follow from those of ConcurrentHashMap: Any non-null result returned from get(key) and related access methods bears a happens-before relation with the associated insertion or update. The result of any bulk operation reflects the composition of these per-element relations (but is not necessarily atomic with respect to the map as a whole unless it is somehow known to be quiescent). Conversely, because keys and values in the map are never null, null serves as a reliable atomic indicator of the current lack of any result. To maintain this property, null serves as an implicit basis for all non-scalar reduction operations. For the double, long, and int versions, the basis should be one that, when combined with any other value, returns that other value (more formally, it should be the identity element for the reduction). Most common reductions have these properties; for example, computing a sum with basis 0 or a minimum with basis MAX_VALUE. Search and transformation functions provided as arguments should similarly return null to indicate the lack of any result (in which case it is not used). In the case of mapped reductions, this also enables transformations to serve as filters, returning null (or, in the case of primitive specializations, the identity basis) if the element should not be combined. You can create compound transformations and filterings by composing them yourself under this "null means there is nothing there now" rule before using them in search or reduce operations. Methods accepting and/or returning Entry arguments maintain key-value associations. They may be useful for example when finding the key for the greatest value. Note that "plain" Entry arguments can be supplied using new AbstractMap.SimpleEntry(k,v). Bulk operations may complete abruptly, throwing an exception encountered in the application of a supplied function. Bear in mind when handling such exceptions that other concurrently executing functions could also have thrown exceptions, or would have done so if the first exception had not occurred. Speedups for parallel compared to sequential forms are common but not guaranteed. Parallel operations involving brief functions on small maps may execute more slowly than sequential forms if the underlying work to parallelize the computation is more expensive than the computation itself. Similarly, parallelization may not lead to much actual parallelism if all processors are busy performing unrelated tasks. All arguments to all task methods must be non-null. This class is a member of the  Java Collections Framework.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.BaseIterator:  Base of key, value, and entry Iterators. Adds fields to Traverser to support iterator.remove.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.BulkTask:  Base class for bulk tasks. Repeats some fields and code from class Traverser, because we need to subclass CountedCompleter.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.BulkTask.advance	(	):  Same as Traverser version
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.CollectionView:  Base class for views.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.CollectionView.clear	(	):  Removes all of the elements from this view, by removing all the mappings from the map backing this view.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.CollectionView.getMap	(	):  Returns the map backing this view.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.CollectionView.iterator	(	):  Returns an iterator over the elements in this collection. The returned iterator is weakly consistent.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.CollectionView.toString	(	):  Returns a string representation of this collection. The string representation consists of the string representations of the collection's elements in the order they are returned by its iterator, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (comma and space). Elements are converted to strings as by valueOf().
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.ConcurrentHashMap	(	):  Creates a new, empty map with the default initial table size (16).
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.ConcurrentHashMap	(	Map	):  Creates a new map with the same mappings as the given map.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.ConcurrentHashMap	(	int	):  Creates a new, empty map with an initial table size accommodating the specified number of elements without the need to dynamically resize.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.ConcurrentHashMap	(	int	float	):  Creates a new, empty map with an initial table size based on the given number of elements (initialCapacity) and initial table density (loadFactor).
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.ConcurrentHashMap	(	int	float	int	):  Creates a new, empty map with an initial table size based on the given number of elements (initialCapacity), table density (loadFactor), and number of concurrently updating threads (concurrencyLevel).
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.CounterCell:  A padded cell for distributing counts. Adapted from LongAdder and Striped64. See their internal docs for explanation.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.EntrySetView:  A view of a ConcurrentHashMap as a Set of (key, value) entries. This class cannot be directly instantiated. See entrySet().
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.EntrySetView.iterator	(	):  Returns an iterator over the elements in this collection. The returned iterator is weakly consistent.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.ForwardingNode:  A node inserted at head of bins during transfer operations.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.KeySetView:  A view of a ConcurrentHashMap as a Set of keys, in which additions may optionally be enabled by mapping to a common value. This class cannot be directly instantiated. See keySet() keySet(), keySet() keySet(V), newKeySet() newKeySet(), newKeySet() newKeySet(int).
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.KeySetView.add	(	K	):  Adds the specified key to this set view by mapping the key to the default mapped value in the backing map, if defined.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.KeySetView.addAll	(	Collection	):  Adds all of the elements in the specified collection to this set, as if by calling add on each one.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.KeySetView.contains	(	Object	):  
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.KeySetView.getMappedValue	(	):  Returns the default mapped value for additions, or null if additions are not supported.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.KeySetView.iterator	(	):  Returns an iterator over the elements in this collection. The returned iterator is weakly consistent.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.KeySetView.remove	(	Object	):  Removes the key from this map view, by removing the key (and its corresponding value) from the backing map. This method does nothing if the key is not in the map.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.MapEntry:  Exported Entry for EntryIterator
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.MapEntry.setValue	(	V	):  Sets our entry's value and writes through to the map. The value to return is somewhat arbitrary here. Since we do not necessarily track asynchronous changes, the most recent "previous" value could be different from what we return (or could even have been removed, in which case the put will re-establish). We do not and cannot guarantee more.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.Node:  Key-value entry. This class is never exported out as a user-mutable Map.Entry (i.e., one supporting setValue; see MapEntry below), but can be used for read-only traversals used in bulk tasks. Subclasses of Node with a negative hash field are special, and contain null keys and values (but are never exported). Otherwise, keys and vals are never null.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.Node.find	(	int	Object	):  Virtualized support for map.get(); overridden in subclasses.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.ReservationNode:  A place-holder node used in computeIfAbsent and compute
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.Segment:  Stripped-down version of helper class used in previous version, declared for the sake of serialization compatibility
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TableStack:  Records the table, its length, and current traversal index for a traverser that must process a region of a forwarded table before proceeding with current table.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.Traverser:  Encapsulates traversal for methods such as containsValue; also serves as a base class for other iterators and spliterators. Method advance visits once each still-valid node that was reachable upon iterator construction. It might miss some that were added to a bin after the bin was visited, which is OK wrt consistency guarantees. Maintaining this property in the face of possible ongoing resizes requires a fair amount of bookkeeping state that is difficult to optimize away amidst volatile accesses. Even so, traversal maintains reasonable throughput. Normally, iteration proceeds bin-by-bin traversing lists. However, if the table has been resized, then all future steps must traverse both the bin at the current index as well as at (index + baseSize); and so on for further resizings. To paranoically cope with potential sharing by users of iterators across threads, iteration terminates if a bounds checks fails for a table read.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.Traverser.advance	(	):  Advances if possible, returning next valid node, or null if none.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.Traverser.pushState	(	Node[]	int	int	):  Saves traversal state upon encountering a forwarding node.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.Traverser.recoverState	(	int	):  Possibly pops traversal state.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin:  TreeNodes used at the heads of bins. TreeBins do not hold user keys or values, but instead point to list of TreeNodes and their root. They also maintain a parasitic read-write lock forcing writers (who hold bin lock) to wait for readers (who do not) to complete before tree restructuring operations.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin.TreeBin	(	TreeNode	):  Creates bin with initial set of nodes headed by b.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin.checkInvariants	(	TreeNode	):  Recursive invariant check
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin.contendedLock	(	):  Possibly blocks awaiting root lock.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin.find	(	int	Object	):  Returns matching node or null if none. Tries to search using tree comparisons from root, but continues linear search when lock not available.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin.lockRoot	(	):  Acquires write lock for tree restructuring.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin.putTreeVal	(	int	K	V	):  Finds or adds a node.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin.removeTreeNode	(	TreeNode	):  Removes the given node, that must be present before this call. This is messier than typical red-black deletion code because we cannot swap the contents of an interior node with a leaf successor that is pinned by "next" pointers that are accessible independently of lock. So instead we swap the tree linkages.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin.tieBreakOrder	(	Object	Object	):  Tie-breaking utility for ordering insertions when equal hashCodes and non-comparable. We don't require a total order, just a consistent insertion rule to maintain equivalence across rebalancings. Tie-breaking further than necessary simplifies testing a bit.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin.unlockRoot	(	):  Releases write lock for tree restructuring.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeNode:  Nodes for use in TreeBins
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeNode.findTreeNode	(	int	Object	Class	):  Returns the TreeNode (or null if not found) for the given key starting at given root.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.ValuesView:  A view of a ConcurrentHashMap as a Collection of values, in which additions are disabled. This class cannot be directly instantiated. See values().
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.addCount	(	long	int	):  Adds to count, and if table is too small and not already resizing, initiates transfer. If already resizing, helps perform transfer if work is available. Rechecks occupancy after a transfer to see if another resize is already needed because resizings are lagging additions.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.batchFor	(	long	):  Computes initial batch value for bulk tasks. The returned value is approximately exp2 of the number of times (minus one) to split task by two before executing leaf action. This value is faster to compute and more convenient to use as a guide to splitting than is the depth, since it is used while dividing by two anyway.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.clear	(	):  Removes all of the mappings from this map.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.comparableClassFor	(	Object	):  Returns x's Class if it is of the form "class C implements Comparable", else null.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.compareComparables	(	Class	Object	Object	):  Returns k.compareTo(x) if x matches kc (k's screened comparable class), else 0.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.compute	(	K	BiFunction	):  Attempts to compute a mapping for the specified key and its current mapped value (or null if there is no current mapping). The entire method invocation is performed atomically. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this Map.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.computeIfAbsent	(	K	Function	):  If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless null. The entire method invocation is performed atomically, so the function is applied at most once per key. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this map.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.computeIfPresent	(	K	BiFunction	):  If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value. The entire method invocation is performed atomically. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this map.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.contains	(	Object	):  Legacy method testing if some key maps into the specified value in this table. This method is identical in functionality to containsValue(), and exists solely to ensure full compatibility with class java.util.Hashtable, which supported this method prior to introduction of the Java Collections framework.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.containsKey	(	Object	):  Tests if the specified object is a key in this table.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.containsValue	(	Object	):  Returns true if this map maps one or more keys to the specified value. Note: This method may require a full traversal of the map, and is much slower than method containsKey.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.elements	(	):  Returns an enumeration of the values in this table.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.entrySet	(	):  Returns a Set view of the mappings contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. The view's iterators and spliterators are weakly consistent. The view's spliterator reports CONCURRENT, DISTINCT, and NONNULL.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.equals	(	Object	):  Compares the specified object with this map for equality. Returns true if the given object is a map with the same mappings as this map. This operation may return misleading results if either map is concurrently modified during execution of this method.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.forEach	(	long	BiConsumer	):  Performs the given action for each (key, value).
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.forEach	(	long	BiFunction	Consumer	):  Performs the given action for each non-null transformation of each (key, value).
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.forEachEntry	(	long	Consumer	):  Performs the given action for each entry.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.forEachEntry	(	long	Function	Consumer	):  Performs the given action for each non-null transformation of each entry.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.forEachKey	(	long	Consumer	):  Performs the given action for each key.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.forEachKey	(	long	Function	Consumer	):  Performs the given action for each non-null transformation of each key.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.forEachValue	(	long	Consumer	):  Performs the given action for each value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.forEachValue	(	long	Function	Consumer	):  Performs the given action for each non-null transformation of each value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.get	(	Object	):  Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that key.equals(k), then this method returns v; otherwise it returns null. (There can be at most one such mapping.)
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.getOrDefault	(	Object	V	):  Returns the value to which the specified key is mapped, or the given default value if this map contains no mapping for the key.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.hashCode	(	):  Returns the hash code value for this Map, i.e., the sum of, for each key-value pair in the map, key.hashCode() ^ value.hashCode().
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.helpTransfer	(	Node[]	Node	):  Helps transfer if a resize is in progress.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.initTable	(	):  Initializes table, using the size recorded in sizeCtl.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.isEmpty	(	):  Returns true if this map contains no key-value mappings.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.keySet	(	):  Returns a Set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. The set supports element removal, which removes the corresponding mapping from this map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations. The view's iterators and spliterators are weakly consistent. The view's spliterator reports CONCURRENT, DISTINCT, and NONNULL.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.keySet	(	V	):  Returns a Set view of the keys in this map, using the given common mapped value for any additions (i.e., add and addAll()). This is of course only appropriate if it is acceptable to use the same value for all additions from this view.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.keys	(	):  Returns an enumeration of the keys in this table.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.mappingCount	(	):  Returns the number of mappings. This method should be used instead of size because a ConcurrentHashMap may contain more mappings than can be represented as an int. The value returned is an estimate; the actual count may differ if there are concurrent insertions or removals.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.merge	(	K	V	BiFunction	):  If the specified key is not already associated with a (non-null) value, associates it with the given value. Otherwise, replaces the value with the results of the given remapping function, or removes if null. The entire method invocation is performed atomically. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this Map.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.newKeySet	(	):  Creates a new Set backed by a ConcurrentHashMap from the given type to Boolean.TRUE.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.newKeySet	(	int	):  Creates a new Set backed by a ConcurrentHashMap from the given type to Boolean.TRUE.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.put	(	K	V	):  Maps the specified key to the specified value in this table. Neither the key nor the value can be null. The value can be retrieved by calling the get method with a key that is equal to the original key.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.putAll	(	Map	):  Copies all of the mappings from the specified map to this one. These mappings replace any mappings that this map had for any of the keys currently in the specified map.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.putIfAbsent	(	K	V	):  If the specified key is not already associated with a value (or is mapped to null) associates it with the given value and returns null, else returns the current value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.putVal	(	K	V	boolean	):  Implementation for put and putIfAbsent 
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.readObject	(	java.io.ObjectInputStream	):  Reconstitutes the instance from a stream (that is, deserializes it).
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduce	(	long	BiFunction	BiFunction	):  Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceEntries	(	long	BiFunction	):  Returns the result of accumulating all entries using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceEntries	(	long	Function	BiFunction	):  Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceEntriesToDouble	(	long	ToDoubleFunction	double	DoubleBinaryOperator	):  Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceEntriesToInt	(	long	ToIntFunction	int	IntBinaryOperator	):  Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceEntriesToLong	(	long	ToLongFunction	long	LongBinaryOperator	):  Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceKeys	(	long	BiFunction	):  Returns the result of accumulating all keys using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceKeys	(	long	Function	BiFunction	):  Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceKeysToDouble	(	long	ToDoubleFunction	double	DoubleBinaryOperator	):  Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceKeysToInt	(	long	ToIntFunction	int	IntBinaryOperator	):  Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceKeysToLong	(	long	ToLongFunction	long	LongBinaryOperator	):  Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceToDouble	(	long	ToDoubleBiFunction	double	DoubleBinaryOperator	):  Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceToInt	(	long	ToIntBiFunction	int	IntBinaryOperator	):  Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceToLong	(	long	ToLongBiFunction	long	LongBinaryOperator	):  Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceValues	(	long	BiFunction	):  Returns the result of accumulating all values using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceValues	(	long	Function	BiFunction	):  Returns the result of accumulating the given transformation of all values using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceValuesToDouble	(	long	ToDoubleFunction	double	DoubleBinaryOperator	):  Returns the result of accumulating the given transformation of all values using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceValuesToInt	(	long	ToIntFunction	int	IntBinaryOperator	):  Returns the result of accumulating the given transformation of all values using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceValuesToLong	(	long	ToLongFunction	long	LongBinaryOperator	):  Returns the result of accumulating the given transformation of all values using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.remove	(	Object	):  Removes the key (and its corresponding value) from this map. This method does nothing if the key is not in the map.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.remove	(	Object	Object	):  Removes the entry for the specified key only if it is currently mapped to the specified value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.replace	(	K	V	):  Replaces the entry for the specified key only if it is currently mapped to some value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.replace	(	K	V	V	):  Replaces the entry for the specified key only if currently mapped to the specified value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.replaceNode	(	Object	V	Object	):  Implementation for the four public remove/replace methods: Replaces node value with v, conditional upon match of cv if non-null. If resulting value is null, delete.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.resizeStamp	(	int	):  Returns the stamp bits for resizing a table of size n. Must be negative when shifted left by RESIZE_STAMP_SHIFT.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.search	(	long	BiFunction	):  Returns a non-null result from applying the given search function on each (key, value), or null if none. Upon success, further element processing is suppressed and the results of any other parallel invocations of the search function are ignored.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.searchEntries	(	long	Function	):  Returns a non-null result from applying the given search function on each entry, or null if none. Upon success, further element processing is suppressed and the results of any other parallel invocations of the search function are ignored.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.searchKeys	(	long	Function	):  Returns a non-null result from applying the given search function on each key, or null if none. Upon success, further element processing is suppressed and the results of any other parallel invocations of the search function are ignored.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.searchValues	(	long	Function	):  Returns a non-null result from applying the given search function on each value, or null if none. Upon success, further element processing is suppressed and the results of any other parallel invocations of the search function are ignored.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.size	(	):  Returns the number of key-value mappings in this map. If the map contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.spread	(	int	):  Spreads (XORs) higher bits of hash to lower and also forces top bit to 0. Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.) So we apply a transform that spreads the impact of higher bits downward. There is a tradeoff between speed, utility, and quality of bit-spreading. Because many common sets of hashes are already reasonably distributed (so don't benefit from spreading), and because we use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.tableSizeFor	(	int	):  Returns a power of two table size for the given desired capacity. See Hackers Delight, sec 3.2
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.toString	(	):  Returns a string representation of this map. The string representation consists of a list of key-value mappings (in no particular order) enclosed in braces (" "). Adjacent mappings are separated by the characters ", " (comma and space). Each key-value mapping is rendered as the key followed by an equals sign ("=") followed by the associated value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.transfer	(	Node[]	Node[]	):  Moves and/or copies the nodes in each bin to new table. See above for explanation.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.treeifyBin	(	Node[]	int	):  Replaces all linked nodes in bin at given index unless table is too small, in which case resizes instead.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.tryPresize	(	int	):  Tries to presize table to accommodate the given number of elements.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.untreeify	(	Node	):  Returns a list on non-TreeNodes replacing those in given list.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.values	(	):  Returns a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. The collection supports element removal, which removes the corresponding mapping from this map, via the Iterator.remove, Collection.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations. The view's iterators and spliterators are weakly consistent. The view's spliterator reports CONCURRENT and NONNULL.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.writeObject	(	java.io.ObjectOutputStream	):  Saves the state of the ConcurrentHashMap instance to a stream (i.e., serializes it).
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue:  An optionally-bounded BlockingQueue blocking queue based on linked nodes. This queue orders elements FIFO (first-in-first-out). The head of the queue is that element that has been on the queue the longest time. The tail of the queue is that element that has been on the queue the shortest time. New elements are inserted at the tail of the queue, and the queue retrieval operations obtain elements at the head of the queue. Linked queues typically have higher throughput than array-based queues but less predictable performance in most concurrent applications. The optional capacity bound constructor argument serves as a way to prevent excessive queue expansion. The capacity, if unspecified, is equal to MAX_VALUE. Linked nodes are dynamically created upon each insertion unless this would bring the queue above capacity. This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces. This class is a member of the  Java Collections Framework.
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.Itr.nextNode	(	Node	):  Returns the next live successor of p, or null if no such. Unlike other traversal methods, iterators need to handle both: - dequeued nodes (p.next == p) - (possibly multiple) interior removed nodes (p.item == null)
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.LBQSpliterator:  A customized variant of Spliterators.IteratorSpliterator 
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.LinkedBlockingQueue	(	):  Creates a LinkedBlockingQueue with a capacity of MAX_VALUE.
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.LinkedBlockingQueue	(	Collection	):  Creates a LinkedBlockingQueue with a capacity of MAX_VALUE, initially containing the elements of the given collection, added in traversal order of the collection's iterator.
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.LinkedBlockingQueue	(	int	):  Creates a LinkedBlockingQueue with the given (fixed) capacity.
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.Node:  Linked list node class
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.clear	(	):  Atomically removes all of the elements from this queue. The queue will be empty after this call returns.
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.contains	(	Object	):  Returns true if this queue contains the specified element. More formally, returns true if and only if this queue contains at least one element e such that o.equals(e).
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.dequeue	(	):  Removes a node from head of queue.
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.drainTo	(	Collection	):  Removes all available elements from this queue and adds them to the given collection. This operation may be more efficient than repeatedly polling this queue. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.drainTo	(	Collection	int	):  Removes at most the given number of available elements from this queue and adds them to the given collection. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.enqueue	(	Node	):  Links node at end of queue.
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.fullyLock	(	):  Locks to prevent both puts and takes.
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.fullyUnlock	(	):  Unlocks to allow both puts and takes.
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.iterator	(	):  Returns an iterator over the elements in this queue in proper sequence. The elements will be returned in order from first (head) to last (tail). The returned iterator is weakly consistent.
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.offer	(	E	):  Inserts the specified element at the tail of this queue if it is possible to do so immediately without exceeding the queue's capacity, returning true upon success and false if this queue is full. When using a capacity-restricted queue, this method is generally preferable to method add, which can fail to insert an element only by throwing an exception.
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.offer	(	E	long	TimeUnit	):  Inserts the specified element at the tail of this queue, waiting if necessary up to the specified wait time for space to become available.
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.put	(	E	):  Inserts the specified element at the tail of this queue, waiting if necessary for space to become available.
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.readObject	(	java.io.ObjectInputStream	):  Reconstitutes this queue from a stream (that is, deserializes it).
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.remainingCapacity	(	):  Returns the number of additional elements that this queue can ideally (in the absence of memory or resource constraints) accept without blocking. This is always equal to the initial capacity of this queue less the current size of this queue. Note that you cannot always tell if an attempt to insert an element will succeed by inspecting remainingCapacity because it may be the case that another thread is about to insert or remove an element.
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.remove	(	Object	):  Removes a single instance of the specified element from this queue, if it is present. More formally, removes an element e such that o.equals(e), if this queue contains one or more such elements. Returns true if this queue contained the specified element (or equivalently, if this queue changed as a result of the call).
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.signalNotEmpty	(	):  Signals a waiting take. Called only from put/offer (which do not otherwise ordinarily lock takeLock.)
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.signalNotFull	(	):  Signals a waiting put. Called only from take/poll.
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.size	(	):  Returns the number of elements in this queue.
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.spliterator	(	):  Returns a Spliterator over the elements in this queue. The returned spliterator is weakly consistent. The Spliterator reports CONCURRENT, ORDERED, and NONNULL.
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.toArray	(	):  Returns an array containing all of the elements in this queue, in proper sequence. The returned array will be "safe" in that no references to it are maintained by this queue. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.toArray	(	T[]	):  Returns an array containing all of the elements in this queue, in proper sequence; the runtime type of the returned array is that of the specified array. If the queue fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this queue. If this queue fits in the specified array with room to spare (i.e., the array has more elements than this queue), the element in the array immediately following the end of the queue is set to null. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a queue known to contain only strings. The following code can be used to dump the queue into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.unlink	(	Node	Node	):  Unlinks interior Node p with predecessor trail.
java.util.concurrent.LinkedBlockingQueue: java.util.concurrent.LinkedBlockingQueue.writeObject	(	java.io.ObjectOutputStream	):  Saves this queue to a stream (that is, serializes it).
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue:  A bounded BlockingQueue blocking queue backed by an array. This queue orders elements FIFO (first-in-first-out). The head of the queue is that element that has been on the queue the longest time. The tail of the queue is that element that has been on the queue the shortest time. New elements are inserted at the tail of the queue, and the queue retrieval operations obtain elements at the head of the queue. This is a classic "bounded buffer", in which a fixed-sized array holds elements inserted by producers and extracted by consumers. Once created, the capacity cannot be changed. Attempts to put an element into a full queue will result in the operation blocking; attempts to take an element from an empty queue will similarly block. This class supports an optional fairness policy for ordering waiting producer and consumer threads. By default, this ordering is not guaranteed. However, a queue constructed with fairness set to true grants threads access in FIFO order. Fairness generally decreases throughput but reduces variability and avoids starvation. This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces. This class is a member of the  Java Collections Framework.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.ArrayBlockingQueue	(	int	):  Creates an ArrayBlockingQueue with the given (fixed) capacity and default access policy.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.ArrayBlockingQueue	(	int	boolean	):  Creates an ArrayBlockingQueue with the given (fixed) capacity and the specified access policy.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.ArrayBlockingQueue	(	int	boolean	Collection	):  Creates an ArrayBlockingQueue with the given (fixed) capacity, the specified access policy and initially containing the elements of the given collection, added in traversal order of the collection's iterator.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.Itr:  Iterator for ArrayBlockingQueue. To maintain weak consistency with respect to puts and takes, we read ahead one slot, so as to not report hasNext true but then not have an element to return. We switch into "detached" mode (allowing prompt unlinking from itrs without help from the GC) when all indices are negative, or when hasNext returns false for the first time. This allows the iterator to track concurrent updates completely accurately, except for the corner case of the user calling Iterator.remove() after hasNext() returned false. Even in this case, we ensure that we don't remove the wrong element by keeping track of the expected element to remove, in lastItem. Yes, we may fail to remove lastItem from the queue if it moved due to an interleaved interior remove while in detached mode.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.Itr.detach	(	):  Called when itrs should stop tracking this iterator, either because there are no more indices to update (cursor < 0 && nextIndex < 0 && lastRet < 0) or as a special exception, when lastRet >= 0, because hasNext() is about to return false for the first time. Call only from iterating thread.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.Itr.hasNext	(	):  For performance reasons, we would like not to acquire a lock in hasNext in the common case. To allow for this, we only access fields (i.e. nextItem) that are not modified by update operations triggered by queue modifications.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.Itr.incorporateDequeues	(	):  Adjusts indices to incorporate all dequeues since the last operation on this iterator. Call only from iterating thread.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.Itr.invalidated	(	int	int	long	int	):  Returns true if index is invalidated by the given number of dequeues, starting from prevTakeIndex.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.Itr.removedAt	(	int	):  Called whenever an interior remove (not at takeIndex) occurred.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.Itr.shutdown	(	):  Called to notify the iterator that the queue is empty, or that it has fallen hopelessly behind, so that it should abandon any further iteration, except possibly to return one more element from next(), as promised by returning true from hasNext().
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.Itr.takeIndexWrapped	(	):  Called whenever takeIndex wraps around to zero.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.Itrs:  Shared data between iterators and their queue, allowing queue modifications to update iterators when elements are removed. This adds a lot of complexity for the sake of correctly handling some uncommon operations, but the combination of circular-arrays and supporting interior removes (i.e., those not at head) would cause iterators to sometimes lose their places and/or (re)report elements they shouldn't. To avoid this, when a queue has one or more iterators, it keeps iterator state consistent by: (1) keeping track of the number of "cycles", that is, the number of times takeIndex has wrapped around to 0. (2) notifying all iterators via the callback removedAt whenever an interior element is removed (and thus other elements may be shifted). These suffice to eliminate iterator inconsistencies, but unfortunately add the secondary responsibility of maintaining the list of iterators. We track all active iterators in a simple linked list (accessed only when the queue's lock is held) of weak references to Itr. The list is cleaned up using 3 different mechanisms: (1) Whenever a new iterator is created, do some O(1) checking for stale list elements. (2) Whenever takeIndex wraps around to 0, check for iterators that have been unused for more than one wrap-around cycle. (3) Whenever the queue becomes empty, all iterators are notified and this entire data structure is discarded. So in addition to the removedAt callback that is necessary for correctness, iterators have the shutdown and takeIndexWrapped callbacks that help remove stale iterators from the list. Whenever a list element is examined, it is expunged if either the GC has determined that the iterator is discarded, or if the iterator reports that it is "detached" (does not need any further state updates). Overhead is maximal when takeIndex never advances, iterators are discarded before they are exhausted, and all removals are interior removes, in which case all stale iterators are discovered by the GC. But even in this case we don't increase the amortized complexity. Care must be taken to keep list sweeping methods from reentrantly invoking another such method, causing subtle corruption bugs.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.Itrs.Node:  Node in a linked list of weak iterator references.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.Itrs.doSomeSweeping	(	boolean	):  Sweeps itrs, looking for and expunging stale iterators. If at least one was found, tries harder to find more. Called only from iterating thread.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.Itrs.elementDequeued	(	):  Called whenever an element has been dequeued (at takeIndex).
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.Itrs.queueIsEmpty	(	):  Called whenever the queue becomes empty. Notifies all active iterators that the queue is empty, clears all weak refs, and unlinks the itrs datastructure.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.Itrs.register	(	Itr	):  Adds a new iterator to the linked list of tracked iterators.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.Itrs.removedAt	(	int	):  Called whenever an interior remove (not at takeIndex) occurred. Notifies all iterators, and expunges any that are now stale.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.Itrs.takeIndexWrapped	(	):  Called whenever takeIndex wraps around to 0. Notifies all iterators, and expunges any that are now stale.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.add	(	E	):  Inserts the specified element at the tail of this queue if it is possible to do so immediately without exceeding the queue's capacity, returning true upon success and throwing an IllegalStateException if this queue is full.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.checkNotNull	(	Object	):  Throws NullPointerException if argument is null.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.clear	(	):  Atomically removes all of the elements from this queue. The queue will be empty after this call returns.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.contains	(	Object	):  Returns true if this queue contains the specified element. More formally, returns true if and only if this queue contains at least one element e such that o.equals(e).
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.dec	(	int	):  Circularly decrement i.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.dequeue	(	):  Extracts element at current take position, advances, and signals. Call only when holding lock.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.drainTo	(	Collection	):  Removes all available elements from this queue and adds them to the given collection. This operation may be more efficient than repeatedly polling this queue. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.drainTo	(	Collection	int	):  Removes at most the given number of available elements from this queue and adds them to the given collection. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.enqueue	(	E	):  Inserts element at current put position, advances, and signals. Call only when holding lock.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.itemAt	(	int	):  Returns item at index i.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.iterator	(	):  Returns an iterator over the elements in this queue in proper sequence. The elements will be returned in order from first (head) to last (tail). The returned iterator is weakly consistent.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.offer	(	E	):  Inserts the specified element at the tail of this queue if it is possible to do so immediately without exceeding the queue's capacity, returning true upon success and false if this queue is full. This method is generally preferable to method add, which can fail to insert an element only by throwing an exception.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.offer	(	E	long	TimeUnit	):  Inserts the specified element at the tail of this queue, waiting up to the specified wait time for space to become available if the queue is full.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.put	(	E	):  Inserts the specified element at the tail of this queue, waiting for space to become available if the queue is full.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.remainingCapacity	(	):  Returns the number of additional elements that this queue can ideally (in the absence of memory or resource constraints) accept without blocking. This is always equal to the initial capacity of this queue less the current size of this queue. Note that you cannot always tell if an attempt to insert an element will succeed by inspecting remainingCapacity because it may be the case that another thread is about to insert or remove an element.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.remove	(	Object	):  Removes a single instance of the specified element from this queue, if it is present. More formally, removes an element e such that o.equals(e), if this queue contains one or more such elements. Returns true if this queue contained the specified element (or equivalently, if this queue changed as a result of the call). Removal of interior elements in circular array based queues is an intrinsically slow and disruptive operation, so should be undertaken only in exceptional circumstances, ideally only when the queue is known not to be accessible by other threads.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.removeAt	(	int	):  Deletes item at array index removeIndex. Utility for remove(Object) and iterator.remove. Call only when holding lock.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.size	(	):  Returns the number of elements in this queue.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.spliterator	(	):  Returns a Spliterator over the elements in this queue. The returned spliterator is weakly consistent. The Spliterator reports CONCURRENT, ORDERED, and NONNULL.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.toArray	(	):  Returns an array containing all of the elements in this queue, in proper sequence. The returned array will be "safe" in that no references to it are maintained by this queue. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.concurrent.ArrayBlockingQueue: java.util.concurrent.ArrayBlockingQueue.toArray	(	T[]	):  Returns an array containing all of the elements in this queue, in proper sequence; the runtime type of the returned array is that of the specified array. If the queue fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this queue. If this queue fits in the specified array with room to spare (i.e., the array has more elements than this queue), the element in the array immediately following the end of the queue is set to null. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a queue known to contain only strings. The following code can be used to dump the queue into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue:  An unbounded BlockingQueue blocking queue that uses the same ordering rules as class PriorityQueue and supplies blocking retrieval operations. While this queue is logically unbounded, attempted additions may fail due to resource exhaustion (causing OutOfMemoryError). This class does not permit null elements. A priority queue relying on Comparable natural ordering also does not permit insertion of non-comparable objects (doing so results in ClassCastException). This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces. The Iterator provided in method iterator() is not guaranteed to traverse the elements of the PriorityBlockingQueue in any particular order. If you need ordered traversal, consider using Arrays.sort(pq.toArray()). Also, method drainTo can be used to remove some or all elements in priority order and place them in another collection. Operations on this class make no guarantees about the ordering of elements with equal priority. If you need to enforce an ordering, you can define custom classes or comparators that use a secondary key to break ties in primary priority values. For example, here is a class that applies first-in-first-out tie-breaking to comparable elements. To use it, you would insert a new FIFOEntry(anEntry) instead of a plain entry object.  class FIFOEntry> implements Comparable> static final AtomicLong seq = new AtomicLong(0); final long seqNum; final E entry; public FIFOEntry(E entry) { seqNum = seq.getAndIncrement(); this.entry = entry; } public E getEntry() { return entry; } public int compareTo(FIFOEntry other) { int res = entry.compareTo(other.entry); if (res == 0 && other.entry != this.entry) res = (seqNum < other.seqNum ? -1 : 1); return res; } }} This class is a member of the  Java Collections Framework.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.Itr:  Snapshot iterator that works off copy of underlying q array.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.PriorityBlockingQueue	(	):  Creates a PriorityBlockingQueue with the default initial capacity (11) that orders its elements according to their Comparable natural ordering.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.PriorityBlockingQueue	(	Collection	):  Creates a PriorityBlockingQueue containing the elements in the specified collection. If the specified collection is a SortedSet or a PriorityQueue, this priority queue will be ordered according to the same ordering. Otherwise, this priority queue will be ordered according to the Comparable natural ordering of its elements.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.PriorityBlockingQueue	(	int	):  Creates a PriorityBlockingQueue with the specified initial capacity that orders its elements according to their Comparable natural ordering.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.PriorityBlockingQueue	(	int	Comparator	):  Creates a PriorityBlockingQueue with the specified initial capacity that orders its elements according to the specified comparator.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.add	(	E	):  Inserts the specified element into this priority queue.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.clear	(	):  Atomically removes all of the elements from this queue. The queue will be empty after this call returns.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.comparator	(	):  Returns the comparator used to order the elements in this queue, or null if this queue uses the Comparable natural ordering of its elements.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.contains	(	Object	):  Returns true if this queue contains the specified element. More formally, returns true if and only if this queue contains at least one element e such that o.equals(e).
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.dequeue	(	):  Mechanics for poll(). Call only while holding lock.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.drainTo	(	Collection	):  Removes all available elements from this queue and adds them to the given collection. This operation may be more efficient than repeatedly polling this queue. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.drainTo	(	Collection	int	):  Removes at most the given number of available elements from this queue and adds them to the given collection. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.heapify	(	):  Establishes the heap invariant (described above) in the entire tree, assuming nothing about the order of the elements prior to the call.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.iterator	(	):  Returns an iterator over the elements in this queue. The iterator does not return the elements in any particular order. The returned iterator is weakly consistent.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.offer	(	E	):  Inserts the specified element into this priority queue. As the queue is unbounded, this method will never return false.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.offer	(	E	long	TimeUnit	):  Inserts the specified element into this priority queue. As the queue is unbounded, this method will never block or return false.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.put	(	E	):  Inserts the specified element into this priority queue. As the queue is unbounded, this method will never block.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.readObject	(	java.io.ObjectInputStream	):  Reconstitutes this queue from a stream (that is, deserializes it).
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.remainingCapacity	(	):  Always returns Integer.MAX_VALUE because a PriorityBlockingQueue is not capacity constrained.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.remove	(	Object	):  Removes a single instance of the specified element from this queue, if it is present. More formally, removes an element e such that o.equals(e), if this queue contains one or more such elements. Returns true if and only if this queue contained the specified element (or equivalently, if this queue changed as a result of the call).
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.removeAt	(	int	):  Removes the ith element from queue.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.removeEQ	(	Object	):  Identity-based version for use in Itr.remove
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.siftDownComparable	(	int	T	Object[]	int	):  Inserts item x at position k, maintaining heap invariant by demoting x down the tree repeatedly until it is less than or equal to its children or is a leaf.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.siftUpComparable	(	int	T	Object[]	):  Inserts item x at position k, maintaining heap invariant by promoting x up the tree until it is greater than or equal to its parent, or is the root. To simplify and speed up coercions and comparisons. the Comparable and Comparator versions are separated into different methods that are otherwise identical. (Similarly for siftDown.) These methods are static, with heap state as arguments, to simplify use in light of possible comparator exceptions.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.spliterator	(	):  Returns a Spliterator over the elements in this queue. The returned spliterator is weakly consistent. The Spliterator reports SIZED and NONNULL.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.toArray	(	):  Returns an array containing all of the elements in this queue. The returned array elements are in no particular order. The returned array will be "safe" in that no references to it are maintained by this queue. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.toArray	(	T[]	):  Returns an array containing all of the elements in this queue; the runtime type of the returned array is that of the specified array. The returned array elements are in no particular order. If the queue fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this queue. If this queue fits in the specified array with room to spare (i.e., the array has more elements than this queue), the element in the array immediately following the end of the queue is set to null. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a queue known to contain only strings. The following code can be used to dump the queue into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.tryGrow	(	Object[]	int	):  Tries to grow array to accommodate at least one more element (but normally expand by about 50%), giving up (allowing retry) on contention (which we expect to be rare). Call only while holding lock.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.writeObject	(	java.io.ObjectOutputStream	):  Saves this queue to a stream (that is, serializes it). For compatibility with previous version of this class, elements are first copied to a java.util.PriorityQueue, which is then serialized.
java.util.concurrent.DelayQueue: java.util.concurrent.DelayQueue:  An unbounded BlockingQueue blocking queue of Delayed elements, in which an element can only be taken when its delay has expired. The head of the queue is that Delayed element whose delay expired furthest in the past. If no delay has expired there is no head and poll will return null. Expiration occurs when an element's getDelay(TimeUnit.NANOSECONDS) method returns a value less than or equal to zero. Even though unexpired elements cannot be removed using take or poll, they are otherwise treated as normal elements. For example, the size method returns the count of both expired and unexpired elements. This queue does not permit null elements. This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces. The Iterator provided in method iterator() is not guaranteed to traverse the elements of the DelayQueue in any particular order. This class is a member of the  Java Collections Framework.
java.util.concurrent.DelayQueue: java.util.concurrent.DelayQueue.DelayQueue	(	):  Creates a new DelayQueue that is initially empty.
java.util.concurrent.DelayQueue: java.util.concurrent.DelayQueue.DelayQueue	(	Collection	):  Creates a DelayQueue initially containing the elements of the given collection of Delayed instances.
java.util.concurrent.DelayQueue: java.util.concurrent.DelayQueue.Itr:  Snapshot iterator that works off copy of underlying q array.
java.util.concurrent.DelayQueue: java.util.concurrent.DelayQueue.add	(	E	):  Inserts the specified element into this delay queue.
java.util.concurrent.DelayQueue: java.util.concurrent.DelayQueue.clear	(	):  Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.
java.util.concurrent.DelayQueue: java.util.concurrent.DelayQueue.drainTo	(	Collection	):  Removes all available elements from this queue and adds them to the given collection. This operation may be more efficient than repeatedly polling this queue. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.DelayQueue: java.util.concurrent.DelayQueue.drainTo	(	Collection	int	):  Removes at most the given number of available elements from this queue and adds them to the given collection. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.DelayQueue: java.util.concurrent.DelayQueue.iterator	(	):  Returns an iterator over all the elements (both expired and unexpired) in this queue. The iterator does not return the elements in any particular order. The returned iterator is weakly consistent.
java.util.concurrent.DelayQueue: java.util.concurrent.DelayQueue.offer	(	E	):  Inserts the specified element into this delay queue.
java.util.concurrent.DelayQueue: java.util.concurrent.DelayQueue.offer	(	E	long	TimeUnit	):  Inserts the specified element into this delay queue. As the queue is unbounded this method will never block.
java.util.concurrent.DelayQueue: java.util.concurrent.DelayQueue.peek	(	):  Retrieves, but does not remove, the head of this queue, or returns null if this queue is empty. Unlike poll, if no expired elements are available in the queue, this method returns the element that will expire next, if one exists.
java.util.concurrent.DelayQueue: java.util.concurrent.DelayQueue.peekExpired	(	):  Returns first element only if it is expired. Used only by drainTo. Call only when holding lock.
java.util.concurrent.DelayQueue: java.util.concurrent.DelayQueue.poll	(	):  Retrieves and removes the head of this queue, or returns null if this queue has no elements with an expired delay.
java.util.concurrent.DelayQueue: java.util.concurrent.DelayQueue.poll	(	long	TimeUnit	):  Retrieves and removes the head of this queue, waiting if necessary until an element with an expired delay is available on this queue, or the specified wait time expires.
java.util.concurrent.DelayQueue: java.util.concurrent.DelayQueue.put	(	E	):  Inserts the specified element into this delay queue. As the queue is unbounded this method will never block.
java.util.concurrent.DelayQueue: java.util.concurrent.DelayQueue.remainingCapacity	(	):  Always returns Integer.MAX_VALUE because a DelayQueue is not capacity constrained.
java.util.concurrent.DelayQueue: java.util.concurrent.DelayQueue.remove	(	Object	):  Removes a single instance of the specified element from this queue, if it is present, whether or not it has expired.
java.util.concurrent.DelayQueue: java.util.concurrent.DelayQueue.removeEQ	(	Object	):  Identity-based version for use in Itr.remove
java.util.concurrent.DelayQueue: java.util.concurrent.DelayQueue.take	(	):  Retrieves and removes the head of this queue, waiting if necessary until an element with an expired delay is available on this queue.
java.util.concurrent.DelayQueue: java.util.concurrent.DelayQueue.toArray	(	):  Returns an array containing all of the elements in this queue. The returned array elements are in no particular order. The returned array will be "safe" in that no references to it are maintained by this queue. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.concurrent.DelayQueue: java.util.concurrent.DelayQueue.toArray	(	T[]	):  Returns an array containing all of the elements in this queue; the runtime type of the returned array is that of the specified array. The returned array elements are in no particular order. If the queue fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this queue. If this queue fits in the specified array with room to spare (i.e., the array has more elements than this queue), the element in the array immediately following the end of the queue is set to null. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. The following code can be used to dump a delay queue into a newly allocated array of Delayed:  Delayed[] a = q.toArray(new Delayed[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue:  A BlockingQueue blocking queue in which each insert operation must wait for a corresponding remove operation by another thread, and vice versa. A synchronous queue does not have any internal capacity, not even a capacity of one. You cannot peek at a synchronous queue because an element is only present when you try to remove it; you cannot insert an element (using any method) unless another thread is trying to remove it; you cannot iterate as there is nothing to iterate. The head of the queue is the element that the first queued inserting thread is trying to add to the queue; if there is no such queued thread then no element is available for removal and poll() will return null. For purposes of other Collection methods (for example contains), a SynchronousQueue acts as an empty collection. This queue does not permit null elements. Synchronous queues are similar to rendezvous channels used in CSP and Ada. They are well suited for handoff designs, in which an object running in one thread must sync up with an object running in another thread in order to hand it some information, event, or task. This class supports an optional fairness policy for ordering waiting producer and consumer threads. By default, this ordering is not guaranteed. However, a queue constructed with fairness set to true grants threads access in FIFO order. This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces. This class is a member of the  Java Collections Framework.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.SynchronousQueue	(	):  Creates a SynchronousQueue with nonfair access policy.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.SynchronousQueue	(	boolean	):  Creates a SynchronousQueue with the specified fairness policy.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.TransferQueue:  Dual Queue 
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.TransferQueue.QNode:  Node class for TransferQueue. 
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.TransferQueue.QNode.isOffList	(	):  Returns true if this node is known to be off the queue because its next pointer has been forgotten due to an advanceHead operation.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.TransferQueue.QNode.tryCancel	(	Object	):  Tries to cancel by CAS'ing ref to this as item.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.TransferQueue.advanceHead	(	QNode	QNode	):  Tries to cas nh as new head; if successful, unlink old head's next node to avoid garbage retention.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.TransferQueue.advanceTail	(	QNode	QNode	):  Tries to cas nt as new tail.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.TransferQueue.awaitFulfill	(	QNode	E	boolean	long	):  Spins/blocks until node s is fulfilled.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.TransferQueue.casCleanMe	(	QNode	QNode	):  Tries to CAS cleanMe slot.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.TransferQueue.clean	(	QNode	QNode	):  Gets rid of cancelled node s with original predecessor pred.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.TransferQueue.transfer	(	E	boolean	long	):  Puts or takes an item.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.TransferStack:  Dual stack 
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.TransferStack.SNode:  Node class for TransferStacks. 
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.TransferStack.SNode.tryCancel	(	):  Tries to cancel a wait by matching node to itself.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.TransferStack.SNode.tryMatch	(	SNode	):  Tries to match node s to this node, if so, waking up thread. Fulfillers call tryMatch to identify their waiters. Waiters block until they have been matched.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.TransferStack.awaitFulfill	(	SNode	boolean	long	):  Spins/blocks until node s is matched by a fulfill operation.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.TransferStack.clean	(	SNode	):  Unlinks s from the stack.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.TransferStack.isFulfilling	(	int	):  Returns true if m has fulfilling bit set. 
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.TransferStack.shouldSpin	(	SNode	):  Returns true if node s is at head or there is an active fulfiller.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.TransferStack.snode	(	SNode	Object	SNode	int	):  Creates or resets fields of a node. Called only from transfer where the node to push on stack is lazily created and reused when possible to help reduce intervals between reads and CASes of head and to avoid surges of garbage when CASes to push nodes fail due to contention.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.TransferStack.transfer	(	E	boolean	long	):  Puts or takes an item.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.Transferer:  Shared internal API for dual stacks and queues.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.Transferer.transfer	(	E	boolean	long	):  Performs a put or take.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.clear	(	):  Does nothing. A SynchronousQueue has no internal capacity.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.contains	(	Object	):  Always returns false. A SynchronousQueue has no internal capacity.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.containsAll	(	Collection	):  Returns false unless the given collection is empty. A SynchronousQueue has no internal capacity.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.drainTo	(	Collection	):  Removes all available elements from this queue and adds them to the given collection. This operation may be more efficient than repeatedly polling this queue. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.drainTo	(	Collection	int	):  Removes at most the given number of available elements from this queue and adds them to the given collection. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.isEmpty	(	):  Always returns true. A SynchronousQueue has no internal capacity.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.iterator	(	):  Returns an empty iterator in which hasNext always returns false.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.offer	(	E	):  Inserts the specified element into this queue, if another thread is waiting to receive it.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.offer	(	E	long	TimeUnit	):  Inserts the specified element into this queue, waiting if necessary up to the specified wait time for another thread to receive it.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.peek	(	):  Always returns null. A SynchronousQueue does not return elements unless actively waited on.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.poll	(	):  Retrieves and removes the head of this queue, if another thread is currently making an element available.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.poll	(	long	TimeUnit	):  Retrieves and removes the head of this queue, waiting if necessary up to the specified wait time, for another thread to insert it.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.put	(	E	):  Adds the specified element to this queue, waiting if necessary for another thread to receive it.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.readObject	(	java.io.ObjectInputStream	):  Reconstitutes this queue from a stream (that is, deserializes it).
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.remainingCapacity	(	):  Always returns zero. A SynchronousQueue has no internal capacity.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.remove	(	Object	):  Always returns false. A SynchronousQueue has no internal capacity.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.removeAll	(	Collection	):  Always returns false. A SynchronousQueue has no internal capacity.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.retainAll	(	Collection	):  Always returns false. A SynchronousQueue has no internal capacity.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.size	(	):  Always returns zero. A SynchronousQueue has no internal capacity.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.spliterator	(	):  Returns an empty spliterator in which calls to trySplit() always return null.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.take	(	):  Retrieves and removes the head of this queue, waiting if necessary for another thread to insert it.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.toArray	(	):  Returns a zero-length array.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.toArray	(	T[]	):  Sets the zeroeth element of the specified array to null (if the array has non-zero length) and returns it.
java.util.concurrent.SynchronousQueue: java.util.concurrent.SynchronousQueue.writeObject	(	java.io.ObjectOutputStream	):  Saves this queue to a stream (that is, serializes it).
java.util.concurrent.SynchronousQueue.TransferQueue: java.util.concurrent.SynchronousQueue.TransferQueue:  Dual Queue 
java.util.concurrent.SynchronousQueue.TransferQueue: java.util.concurrent.SynchronousQueue.TransferQueue.QNode:  Node class for TransferQueue. 
java.util.concurrent.SynchronousQueue.TransferQueue: java.util.concurrent.SynchronousQueue.TransferQueue.QNode.isOffList	(	):  Returns true if this node is known to be off the queue because its next pointer has been forgotten due to an advanceHead operation.
java.util.concurrent.SynchronousQueue.TransferQueue: java.util.concurrent.SynchronousQueue.TransferQueue.QNode.tryCancel	(	Object	):  Tries to cancel by CAS'ing ref to this as item.
java.util.concurrent.SynchronousQueue.TransferQueue: java.util.concurrent.SynchronousQueue.TransferQueue.advanceHead	(	QNode	QNode	):  Tries to cas nh as new head; if successful, unlink old head's next node to avoid garbage retention.
java.util.concurrent.SynchronousQueue.TransferQueue: java.util.concurrent.SynchronousQueue.TransferQueue.advanceTail	(	QNode	QNode	):  Tries to cas nt as new tail.
java.util.concurrent.SynchronousQueue.TransferQueue: java.util.concurrent.SynchronousQueue.TransferQueue.awaitFulfill	(	QNode	E	boolean	long	):  Spins/blocks until node s is fulfilled.
java.util.concurrent.SynchronousQueue.TransferQueue: java.util.concurrent.SynchronousQueue.TransferQueue.casCleanMe	(	QNode	QNode	):  Tries to CAS cleanMe slot.
java.util.concurrent.SynchronousQueue.TransferQueue: java.util.concurrent.SynchronousQueue.TransferQueue.clean	(	QNode	QNode	):  Gets rid of cancelled node s with original predecessor pred.
java.util.concurrent.SynchronousQueue.TransferQueue: java.util.concurrent.SynchronousQueue.TransferQueue.transfer	(	E	boolean	long	):  Puts or takes an item.
java.util.EnumSet: java.util.EnumSet:  A specialized Set implementation for use with enum types. All of the elements in an enum set must come from a single enum type that is specified, explicitly or implicitly, when the set is created. Enum sets are represented internally as bit vectors. This representation is extremely compact and efficient. The space and time performance of this class should be good enough to allow its use as a high-quality, typesafe alternative to traditional int-based "bit flags." Even bulk operations (such as containsAll and retainAll) should run very quickly if their argument is also an enum set. The iterator returned by the iterator method traverses the elements in their natural order (the order in which the enum constants are declared). The returned iterator is weakly consistent: it will never throw ConcurrentModificationException and it may or may not show the effects of any modifications to the set that occur while the iteration is in progress. Null elements are not permitted. Attempts to insert a null element will throw NullPointerException. Attempts to test for the presence of a null element or to remove one will, however, function properly. Like most collection implementations, EnumSet is not synchronized. If multiple threads access an enum set concurrently, and at least one of the threads modifies the set, it should be synchronized externally. This is typically accomplished by synchronizing on some object that naturally encapsulates the enum set. If no such object exists, the set should be "wrapped" using the synchronizedSet method. This is best done at creation time, to prevent accidental unsynchronized access:  Set<MyEnum> s = Collections.synchronizedSet(EnumSet.noneOf(MyEnum.class));  Implementation note: All basic operations execute in constant time. They are likely (though not guaranteed) to be much faster than their HashSet counterparts. Even bulk operations execute in constant time if their argument is also an enum set. This class is a member of the  Java Collections Framework.
java.util.EnumSet: java.util.EnumSet.SerializationProxy:  This class is used to serialize all EnumSet instances, regardless of implementation type. It captures their "logical contents" and they are reconstructed using public static factories. This is necessary to ensure that the existence of a particular implementation type is an implementation detail.
java.util.EnumSet: java.util.EnumSet.addAll	(	):  Adds all of the elements from the appropriate enum type to this enum set, which is empty prior to the call.
java.util.EnumSet: java.util.EnumSet.addRange	(	E	E	):  Adds the specified range to this enum set, which is empty prior to the call.
java.util.EnumSet: java.util.EnumSet.allOf	(	Class	):  Creates an enum set containing all of the elements in the specified element type.
java.util.EnumSet: java.util.EnumSet.clone	(	):  Returns a copy of this set.
java.util.EnumSet: java.util.EnumSet.complement	(	):  Complements the contents of this enum set.
java.util.EnumSet: java.util.EnumSet.complementOf	(	EnumSet	):  Creates an enum set with the same element type as the specified enum set, initially containing all the elements of this type that are not contained in the specified set.
java.util.EnumSet: java.util.EnumSet.copyOf	(	Collection	):  Creates an enum set initialized from the specified collection. If the specified collection is an EnumSet instance, this static factory method behaves identically to copyOf(). Otherwise, the specified collection must contain at least one element (in order to determine the new enum set's element type).
java.util.EnumSet: java.util.EnumSet.copyOf	(	EnumSet	):  Creates an enum set with the same element type as the specified enum set, initially containing the same elements (if any).
java.util.EnumSet: java.util.EnumSet.getUniverse	(	Class	):  Returns all of the values comprising E. The result is uncloned, cached, and shared by all callers.
java.util.EnumSet: java.util.EnumSet.noneOf	(	Class	):  Creates an empty enum set with the specified element type.
java.util.EnumSet: java.util.EnumSet.of	(	E	):  Creates an enum set initially containing the specified element. Overloadings of this method exist to initialize an enum set with one through five elements. A sixth overloading is provided that uses the varargs feature. This overloading may be used to create an enum set initially containing an arbitrary number of elements, but is likely to run slower than the overloadings that do not use varargs.
java.util.EnumSet: java.util.EnumSet.of	(	E	E	):  Creates an enum set initially containing the specified elements. This factory, whose parameter list uses the varargs feature, may be used to create an enum set initially containing an arbitrary number of elements, but it is likely to run slower than the overloadings that do not use varargs.
java.util.EnumSet: java.util.EnumSet.of	(	E	E	E	):  Creates an enum set initially containing the specified elements. Overloadings of this method exist to initialize an enum set with one through five elements. A sixth overloading is provided that uses the varargs feature. This overloading may be used to create an enum set initially containing an arbitrary number of elements, but is likely to run slower than the overloadings that do not use varargs.
java.util.EnumSet: java.util.EnumSet.of	(	E	E	E	E	):  Creates an enum set initially containing the specified elements. Overloadings of this method exist to initialize an enum set with one through five elements. A sixth overloading is provided that uses the varargs feature. This overloading may be used to create an enum set initially containing an arbitrary number of elements, but is likely to run slower than the overloadings that do not use varargs.
java.util.EnumSet: java.util.EnumSet.of	(	E	E	E	E	E	):  Creates an enum set initially containing the specified elements. Overloadings of this method exist to initialize an enum set with one through five elements. A sixth overloading is provided that uses the varargs feature. This overloading may be used to create an enum set initially containing an arbitrary number of elements, but is likely to run slower than the overloadings that do not use varargs.
java.util.EnumSet: java.util.EnumSet.range	(	E	E	):  Creates an enum set initially containing all of the elements in the range defined by the two specified endpoints. The returned set will contain the endpoints themselves, which may be identical but must not be out of order.
java.util.EnumSet: java.util.EnumSet.typeCheck	(	E	):  Throws an exception if e is not of the correct type for this enum set.
java.util.Enumeration: java.util.Enumeration:  An object that implements the Enumeration interface generates a series of elements, one at a time. Successive calls to the nextElement method return successive elements of the series.  For example, to print all elements of a Vector<E> v:  for (Enumeration<E> e = v.elements(); e.hasMoreElements();) System.out.println(e.nextElement());  Methods are provided to enumerate through the elements of a vector, the keys of a hashtable, and the values in a hashtable. Enumerations are also used to specify the input streams to a SequenceInputStream.  NOTE: The functionality of this interface is duplicated by the Iterator interface. In addition, Iterator adds an optional remove operation, and has shorter method names. New implementations should consider using Iterator in preference to Enumeration.
java.util.Enumeration: java.util.Enumeration.hasMoreElements	(	):  Tests if this enumeration contains more elements.
java.util.Enumeration: java.util.Enumeration.nextElement	(	):  Returns the next element of this enumeration if this enumeration object has at least one more element to provide.