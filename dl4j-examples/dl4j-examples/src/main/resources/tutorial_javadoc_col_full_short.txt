Lesson: Algorithms The polymorphic algorithms described here are pieces of reusable functionality provided by the Java platform. All of them come from the Collections class, and all take the form of static methods whose first argument is the collection on which the operation is to be performed. The great majority of the algorithms provided by the Java platform operate on List instances, but a few of them operate on arbitrary Collection instances. This section briefly describes the following algorithms: Sorting Shuffling Routine Data Manipulation Searching Composition Finding Extreme Values
Sorting The Collections.sort algorithm reorders a List so that its elements are in ascending order according to an ordering relationship. Two forms of the operation are provided. The simple form takes a List and sorts it according to its elements' natural ordering. If you're unfamiliar with the concept of natural ordering, read the Object Ordering section. The Collections.sort operation uses a slightly optimized merge sort algorithm that is fast and stable: Fast: It is guaranteed to run in n log(n) time and runs substantially faster on nearly sorted lists. Empirical tests showed it to be as fast as a highly optimized quicksort. A quicksort is generally considered to be faster than a merge sort but isn't stable and doesn't guarantee n log(n) performance. Stable: It doesn't reorder equal elements. This is important if you sort the same list repeatedly on different attributes. If a user of a mail program sorts the inbox by mailing date and then sorts it by sender, the user naturally expects that the now-contiguous list of messages from a given sender will (still) be sorted by mailing date. This is guaranteed only if the second sort was stable.
Sorting - part 2 The following trivial program prints out its arguments in lexicographic (alphabetical) order. import java.util.*; public class Sort { public static void main(String[] args) { List<String> list = Arrays.asList(args); Collections.sort(list); System.out.println(list); } } Let's run the program. % java Sort i walk the line The following output is produced. [i, line, the, walk] The program was included only to show you that algorithms really are as easy to use as they appear to be. The second form of Collections.sort takes a Comparator in addition to a List and sorts the elements with the Comparator . Suppose you want to print out the anagram groups from our earlier example in reverse order of size ? largest anagram group first. The example that follows shows you how to achieve this with the help of the second form of the Collections.sort method.
Sorting - part 3 Recall that the anagram groups are stored as values in a Map , in the form of List instances. The revised printing code iterates through the Map 's values view, putting every List that passes the minimum-size test into a List of List s. Then the code sorts this List , using a Comparator that expects List instances, and implements reverse size-ordering. Finally, the code iterates through the sorted List , printing its elements (the anagram groups). The following code replaces the printing code at the end of the main method in the Anagrams example. // Make a List of all anagram groups above size threshold. List<List<String>> winners = new ArrayList<List<String>>(); for (List<String> l : m.values()) if (l.size() >= minGroupSize) winners.add(l); // Sort anagram groups according to size Collections.sort(winners, new Comparator<List<String>>() { public int compare(List<String> o1, List<String> o2) { return o2.size() - o1.size(); }}); // Print anagram groups. for (List<String> l : winners) System.out.println(l.size() + ": " + l); Running the program on the same dictionary as in The Map Interface section, with the same minimum anagram group size (eight), produces the following output. 12: [apers, apres, asper, pares, parse, pears, prase, presa, rapes, reaps, spare, spear] 11: [alerts, alters, artels, estral, laster, ratels, salter, slater, staler, stelar, talers] 10: [least, setal, slate, stale, steal, stela, taels, tales, teals, tesla] 9: [estrin, inerts, insert, inters, niters, nitres, sinter, triens, trines] 9: [capers, crapes, escarp, pacers, parsec, recaps, scrape, secpar, spacer] 9: [palest, palets, pastel, petals, plates, pleats, septal, staple, tepals] 9: [anestri, antsier, nastier, ratines, retains, retinas, retsina, stainer, stearin] 8: [lapse, leaps, pales, peals, pleas, salep, sepal, spale] 8: [aspers, parses, passer, prases, repass, spares, sparse, spears] 8: [enters, nester, renest, rentes, resent, tenser, ternes,treens] 8: [arles, earls, lares, laser, lears, rales, reals, seral] 8: [earings, erasing, gainers, reagins, regains, reginas, searing, seringa] 8: [peris, piers, pries, prise, ripes, speir, spier, spire] 8: [ates, east, eats, etas, sate, seat, seta, teas] 8: [carets, cartes, caster, caters, crates, reacts, recast,traces]
Shuffling The Collections.shuffle algorithm does the opposite of what Collections.sort does, destroying any trace of order that may have been present in a List . That is, this algorithm reorders the List based on input from a source of randomness such that all possible permutations occur with equal likelihood, assuming a fair source of randomness. This algorithm is useful in implementing games of chance. For example, it could be used to shuffle a List of Card objects representing a deck. Also, it's useful for generating test cases. This operation has two forms: one takes a List and uses a default source of randomness, and the other requires the caller to provide a Random object to use as a source of randomness. The code for this algorithm is used as an example in the List section.
Routine Data Manipulation The Collections class provides five algorithms for doing routine data manipulation on List objects, all of which are pretty straightforward: Collections.reverse ? reverses the order of the elements in a List . Collections.fill ? overwrites every element in a List with the specified value. This operation is useful for reinitializing a List . Collections.copy ? takes two arguments, a destination List and a source List , and copies the elements of the source into the destination, overwriting its contents. The destination List must be at least as long as the source. If it is longer, the remaining elements in the destination List are unaffected. Collections.swap ? swaps the elements at the specified positions in a List . Collections.addAll ? adds all the specified elements to a Collection . The elements to be added may be specified individually or as an array.
Searching The Collections.binarySearch algorithm searches for a specified element in a sorted List . This algorithm has two forms. The first takes a List and an element to search for (the "search key"). This form assumes that the List is sorted in ascending order according to the natural ordering of its elements. The second form takes a Comparator in addition to the List and the search key, and assumes that the List is sorted into ascending order according to the specified Comparator . The Collections.sort algorithm can be used to sort the List prior to calling Collections.binarySearch .
Searching - part 2 The return value is the same for both forms. If the List contains the search key, its index is returned. If not, the return value is (-(insertion point) - 1), where the insertion point is the point at which the value would be inserted into the List , or the index of the first element greater than the value or List.size() if all elements in the List are less than the specified value. This admittedly ugly formula guarantees that the return value will be >= 0 if and only if the search key is found. It's basically a hack to combine a boolean (found) and an integer (index) into a single int return value. The following idiom, usable with both forms of the Collections.binarySearch operation, looks for the specified search key and inserts it at the appropriate position if it's not already present. int pos = Collections.binarySearch(list, key); if (pos < 0) l.add(-pos-1);
Composition The frequency and disjoint algorithms test some aspect of the composition of one or more Collections : Collections.frequency ? counts the number of times the specified element occurs in the specified collection Collections.disjoint ? determines whether two Collections are disjoint; that is, whether they contain no elements in common
Finding Extreme Values The Collections.min and the Collections.max algorithms return, respectively, the minimum and maximum element contained in a specified Collection . Both of these operations come in two forms. The simple form takes only a Collection and returns the minimum (or maximum) element according to the elements' natural ordering. The second form takes a Comparator in addition to the Collection and returns the minimum (or maximum) element according to the specified Comparator .
Lesson: Custom Collection Implementations Many programmers will never need to implement their own Collection s classes. You can go pretty far using the implementations described in the preceding sections of this chapter. However, someday you might want to write your own implementation. It is fairly easy to do this with the aid of the abstract implementations provided by the Java platform. Before we discuss how to write an implementation, let's discuss why you might want to write one.
Reasons to Write an Implementation The following list illustrates the sort of custom Collection s you might want to implement. It is not intended to be exhaustive: Persistent: All of the built-in Collection implementations reside in main memory and vanish when the program exits. If you want a collection that will still be present the next time the program starts, you can implement it by building a veneer over an external database. Such a collection might be concurrently accessible by multiple programs. Application-specific: This is a very broad category. One example is an unmodifiable Map containing real-time telemetry data. The keys could represent locations, and the values could be read from sensors at these locations in response to the get operation. High-performance, special-purpose: Many data structures take advantage of restricted usage to offer better performance than is possible with general-purpose implementations. For instance, consider a List containing long runs of identical element values. Such lists, which occur frequently in text processing, can be run-length encoded ? runs can be represented as a single object containing the repeated element and the number of consecutive repetitions. This example is interesting because it trades off two aspects of performance: It requires less space but more time than an ArrayList . High-performance, general-purpose: The Java Collections Framework's designers tried to provide the best general-purpose implementations for each interface, but many, many data structures could have been used, and new ones are invented every day. Maybe you can come up with something faster! Enhanced functionality: Suppose you need an efficient bag implementation (also known as a multiset): a Collection that offers constant-time containment checks while allowing duplicate elements. It's reasonably straightforward to implement such a collection atop a HashMap . Convenience: You may want additional implementations that offer conveniences beyond those offered by the Java platform. For instance, you may frequently need List instances representing a contiguous range of Integer s. Adapter: Suppose you are using a legacy API that has its own ad hoc collections' API. You can write an adapter implementation that permits these collections to operate in the Java Collections Framework. An adapter implementation is a thin veneer that wraps objects of one type and makes them behave like objects of another type by translating operations on the latter type into operations on the former.
How to Write a Custom Implementation Writing a custom implementation is surprisingly easy. The Java Collections Framework provides abstract implementations designed expressly to facilitate custom implementations. We'll start with the following example of an implementation of Arrays.asList . public static <T> List<T> asList(T[] a) { return new MyArrayList<T>(a); } private static class MyArrayList<T> extends AbstractList<T> { private final T[] a; MyArrayList(T[] array) { a = array; } public T get(int index) { return a[index]; } public T set(int index, T element) { T oldValue = a[index]; a[index] = element; return oldValue; } public int size() { return a.length; } } Believe it or not, this is very close to the implementation that is contained in java.util.Arrays . It's that simple! You provide a constructor and the AbstractList.get , AbstractList.set , and AbstractCollection.size methods, and AbstractList does all the rest. You get the ListIterator , bulk operations, search operations, hash code computation, comparison, and string representation for free. Suppose you want to make the implementation a bit faster. The API documentation for abstract implementations describes precisely how each method is implemented, so you'll know which methods to override to get the performance you want. The preceding implementation's performance is fine, but it can be improved a bit. In particular, the AbstractCollection.toArray method iterates over the List, copying one element at a time. Given the internal representation, it's a lot faster and more sensible just to clone the array. public Object[] toArray() { return (Object[]) a.clone(); }
How to Write a Custom Implementation - part 2 With the addition of this override and a few more like it, this implementation is exactly the one found in java.util.Arrays . In the interest of full disclosure, it's a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it's still not that difficult. The following list summarizes the abstract implementations: AbstractCollection ? a Collection that is neither a Set nor a List. At a minimum, you must provide the AbstractList.iterator and the AbstractCollection.size methods. AbstractSet ? a Set ; use is identical to AbstractCollection . AbstractList ? a List backed up by a random-access data store, such as an array. At a minimum, you must provide the positional access methods ( AbstractList.get and, optionally, AbstractList.set , AbstractList.remove , and AbstractList.add ) and the AbstractCollection.size method. The abstract class takes care of AbstractList.listIterator (and AbstractList.iterator ). AbstractSequentialList ? a List backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the AbstractList.listIterator and AbstractCollection.size methods. The abstract class takes care of the positional access methods. (This is the opposite of AbstractList .) AbstractQueue ? at a minimum, you must provide the offer, peek, poll, and AbstractCollection.size methods and an AbstractList.iterator supporting AbstractList.remove . AbstractMap ? a Map . At a minimum you must provide the entrySet view. This is typically implemented with the AbstractSet class. If the Map is modifiable, you must also provide the put method.
List View of an Array The Arrays.asList method returns a List view of its array argument. Changes to the List write through to the array and vice versa. The size of the collection is that of the array and cannot be changed. If the add or the remove method is called on the List, an UnsupportedOperationException will result. The normal use of this implementation is as a bridge between array-based and collection-based APIs. It allows you to pass an array to a method expecting a Collection or a List. However, this implementation also has another use. If you need a fixed-size List, it's more efficient than any general-purpose List implementation. This is the idiom. List<String> list = Arrays.asList(new String[size]); Note that a reference to the backing array is not retained.
Immutable Multiple-Copy List Occasionally you'll need an immutable List consisting of multiple copies of the same element. The Collections.nCopies method returns such a list. This implementation has two main uses. The first is to initialize a newly created List; for example, suppose you want an ArrayList initially consisting of 1,000 null elements. The following incantation does the trick. List<Type> list = new ArrayList<Type>(Collections.nCopies(1000, (Type)null); Of course, the initial value of each element need not be null. The second main use is to grow an existing List. For example, suppose you want to add 69 copies of the string "fruit bat" to the end of a List<String>. It's not clear why you'd want to do such a thing, but let's just suppose you did. The following is how you'd do it. lovablePets.addAll(Collections.nCopies(69, "fruit bat")); By using the form of addAll that takes both an index and a Collection , you can add the new elements to the middle of a List instead of to the end of it.
Immutable Singleton Set Sometimes you'll need an immutable singleton Set , which consists of a single, specified element. The Collections.singleton method returns such a Set . One use of this implementation is to remove all occurrences of a specified element from a Collection . c.removeAll(Collections.singleton(e)); A related idiom removes all elements that map to a specified value from a Map . For example, suppose you have a Map ? job ? that maps people to their line of work and suppose you want to eliminate all the lawyers. The following one-liner will do the deed. job.values().removeAll(Collections.singleton(LAWYER)); One more use of this implementation is to provide a single input value to a method that is written to accept a collection of values.
Empty Set List and Map Constants The Collections class provides methods to return the empty Set , List, and Map ? Collections.emptySet , Collections.emptyList , and Collections.emptyMap . The main use of these constants is as input to methods that take a Collection of values when you don't want to provide any values at all, as in this example. tourist.declarePurchases(Collections.emptySet());
Deque Implementations The Deque interface, pronounced as "deck", represents a double-ended queue. The Deque interface can be implemented as various types of Collections . The Deque interface implementations are grouped into general-purpose and concurrent implementations.
General-Purpose Deque Implementations The general-purpose implementations include LinkedList and ArrayDeque classes. The Deque interface supports insertion, removal and retrieval of elements at both ends. The ArrayDeque class is the resizable array implementation of the Deque interface, whereas the LinkedList class is the list implementation. The basic insertion, removal and retieval operations in the Deque interface addFirst, addLast, removeFirst, removeLast, getFirst and getLast. The method addFirst adds an element at the head whereas addLast adds an element at the tail of the Deque instance. The LinkedList implementation is more flexible than the ArrayDeque implementation. LinkedList implements all optional list operations. null elements are allowed in the LinkedList implementation but not in the ArrayDeque implementation. In terms of efficiency, ArrayDeque is more efficient than the LinkedList for add and remove operation at both ends. The best operation in a LinkedList implementation is removing the current element during the iteration. LinkedList implementations are not ideal structures to iterate. The LinkedList implementation consumes more memory than the ArrayDeque implementation. For the ArrayDeque instance traversal use any of the following:
Concurrent Deque Implementations The LinkedBlockingDeque class is the concurrent implementation of the Deque interface. If the deque is empty then methods such as LinkedBlockingDeque.takeFirst and LinkedBlockingDeque.takeLast wait until the element becomes available, and then retrieves and removes the same element.
Lesson: Implementations - part 2 The general-purpose implementations are summarized in the following table. General-purpose Implementations Interfaces Hash table Implementations Resizable array Implementations Tree Implementations Linked list Implementations Hash table + Linked list Implementations Set HashSet TreeSet LinkedHashSet List ArrayList LinkedList Queue Deque ArrayDeque LinkedList Map HashMap TreeMap LinkedHashMap As you can see from the table, the Java Collections Framework provides several general-purpose implementations of the Set , List , and Map interfaces. In each case, one implementation ? HashSet , ArrayList , and HashMap ? is clearly the one to use for most applications, all other things being equal. Note that the SortedSet and the SortedMap interfaces do not have rows in the table. Each of those interfaces has one implementation ( TreeSet and TreeMap ) and is listed in the Set and the Map rows. There are two general-purpose Queue implementations ? LinkedList , which is also a List implementation, and PriorityQueue , which is omitted from the table. These two implementations provide very different semantics: LinkedList provides FIFO semantics, while PriorityQueue orders its elements according to their values.
Lesson: Implementations - part 3 Each of the general-purpose implementations provides all optional operations contained in its interface. All permit null elements, keys, and values. None are synchronized (thread-safe). All have fail-fast iterators, which detect illegal concurrent modification during iteration and fail quickly and cleanly rather than risking arbitrary, nondeterministic behavior at an undetermined time in the future. All are Serializable and all support a public clone method. The fact that these implementations are unsynchronized represents a break with the past: The legacy collections Vector and Hashtable are synchronized. The present approach was taken because collections are frequently used when the synchronization is of no benefit. Such uses include single-threaded use, read-only use, and use as part of a larger data object that does its own synchronization. In general, it is good API design practice not to make users pay for a feature they don't use. Furthermore, unnecessary synchronization can result in deadlock under certain circumstances.
Lesson: Implementations - part 4 If you need thread-safe collections, the synchronization wrappers, described in the Wrapper Implementations section, allow any collection to be transformed into a synchronized collection. Thus, synchronization is optional for general-purpose implementations, whereas it is mandatory for legacy implementations. Moreover, the java.util.concurrent package provides concurrent implementations of the BlockingQueue interface, which extends Queue, and of the ConcurrentMap interface, which extends Map . These implementations offer much higher concurrency than mere synchronized implementations. As a rule, you should be thinking about the interfaces, BigInteger.not the implementations. That is why there are no programming examples in this section. For the most part, the choice of implementation affects only performance. The preferred style, as mentioned in the Interfaces section, is to choose an implementation when a Collection is created and to immediately assign the new collection to a variable of the corresponding interface type (or to pass the collection to a method expecting an argument of the interface type). In this way, the program does not become dependent on any added methods in a given implementation, leaving the programmer free to change implementations anytime that it is warranted by performance concerns or behavioral details.
General-Purpose List Implementations There are two general-purpose List implementations ? ArrayList and LinkedList . Most of the time, you'll probably use ArrayList , which offers constant-time positional access and is just plain fast. It does not have to allocate a node object for each element in the List, and it can take advantage of System.arraycopy when it has to move multiple elements at the same time. Think of ArrayList as Vector without the synchronization overhead. If you frequently add elements to the beginning of the List or iterate over the List to delete elements from its interior, you should consider using LinkedList . These operations require constant-time in a LinkedList and linear-time in an ArrayList . But you pay a big price in performance. Positional access requires linear-time in a LinkedList and constant-time in an ArrayList . Furthermore, the constant factor for LinkedList is much worse. If you think you want to use a LinkedList , measure the performance of your application with both LinkedList and ArrayList before making your choice; ArrayList is usually faster.
General-Purpose List Implementations - part 2 ArrayList has one tuning parameter ? the initial capacity, which refers to the number of elements the ArrayList can hold before it has to grow. LinkedList has no tuning parameters and seven optional operations, one of which is clone. The other six are LinkedList.addFirst , LinkedList.getFirst , LinkedList.removeFirst , LinkedList.addLast , LinkedList.getLast , and LinkedList.removeLast . LinkedList also implements the Queue interface.
Special-Purpose List Implementations CopyOnWriteArrayList is a List implementation backed up by a copy-on-write array. This implementation is similar in nature to CopyOnWriteArraySet . No synchronization is necessary, even during iteration, and iterators are guaranteed never to throw ConcurrentModificationException . This implementation is well suited to maintaining event-handler lists, in which change is infrequent, and traversal is frequent and potentially time-consuming. If you need synchronization, a Vector will be slightly faster than an ArrayList synchronized with Collections.synchronizedList . But Vector has loads of legacy operations, so be careful to always manipulate the Vector with the List interface or else you won't be able to replace the implementation at a later time. If your List is fixed in size ? that is, you'll never use remove, add, or any of the bulk operations other than containsAll ? you have a third option that's definitely worth considering. See Arrays.asList in the Convenience Implementations section for more information.
Map Implementations Map implementations are grouped into general-purpose, special-purpose, and concurrent implementations.
General-Purpose Map Implementations The three general-purpose Map implementations are HashMap , TreeMap and LinkedHashMap . If you need SortedMap operations or key-ordered Collection -view iteration, use TreeMap ; if you want maximum speed and don't care about iteration order, use HashMap ; if you want near- HashMap performance and insertion-order iteration, use LinkedHashMap . In this respect, the situation for Map is analogous to Set . Likewise, everything else in the Set Implementations section also applies to Map implementations. LinkedHashMap provides two capabilities that are not available with LinkedHashSet . When you create a LinkedHashMap , you can order it based on key access rather than insertion. In other words, merely looking up the value associated with a key brings that key to the end of the map. Also, LinkedHashMap provides the LinkedHashMap.removeEldestEntry method, which may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map. This makes it very easy to implement a custom cache.
Special-Purpose Map Implementations There are three special-purpose Map implementations ? EnumMap , WeakHashMap and IdentityHashMap . EnumMap , which is internally implemented as an array, is a high-performance Map implementation for use with enum keys. This implementation combines the richness and safety of the Map interface with a speed approaching that of an array. If you want to map an enum to a value, you should always use an EnumMap in preference to an array. WeakHashMap is an implementation of the Map interface that stores only weak references to its keys. Storing only weak references allows a key-value pair to be garbage-collected when its key is no longer referenced outside of the WeakHashMap . This class provides the easiest way to harness the power of weak references. It is useful for implementing "registry-like" data structures, where the utility of an entry vanishes when its key is no longer reachable by any thread.
Special-Purpose Map Implementations - part 2 IdentityHashMap is an identity-based Map implementation based on a hash table. This class is useful for topology-preserving object graph transformations, such as serialization or deep-copying. To perform such transformations, you need to maintain an identity-based "node table" that keeps track of which objects have already been seen. Identity-based maps are also used to maintain object-to-meta-information mappings in dynamic debuggers and similar systems. Finally, identity-based maps are useful in thwarting "spoof attacks" that are a result of intentionally perverse equals methods because IdentityHashMap never invokes the equals method on its keys. An added benefit of this implementation is that it is fast.
Concurrent Map Implementations The java.util.concurrent package contains the ConcurrentMap interface, which extends Map with atomic putIfAbsent, remove, and replace methods, and the ConcurrentHashMap implementation of that interface. ConcurrentHashMap is a highly concurrent, high-performance implementation backed up by a hash table. This implementation never blocks when performing retrievals and allows the client to select the concurrency level for updates. It is intended as a drop-in replacement for Hashtable : in addition to implementing ConcurrentMap , it supports all the legacy methods peculiar to Hashtable . Again, if you don't need the legacy operations, be careful to manipulate it with the ConcurrentMap interface.
Questions Question: You plan to write a program that uses several basic collection interfaces: Set , List, Queue, and Map . You're not sure which implementations will work best, so you decide to use general-purpose implementations until you get a better idea how your program will work in the real world. Which implementations are these? Answer: Set : HashSet List: ArrayList Queue: LinkedList Map : HashMap Question: If you need a Set implementation that provides value-ordered iteration, which class should you use? Answer: TreeSet guarantees that the sorted set is in ascending element order, sorted according to the natural order of the elements or by the Comparator provided. Question: Which class do you use to access wrapper implementations? Answer: You use the Collections class, which provides static methods that operate on or return collections.
Exercises Exercise: Write a program that reads a text file, specified by the first command line argument, into a List. The program should then print random lines from the file, the number of lines printed to be specified by the second command line argument. Write the program so that a correctly-sized collection is allocated all at once, instead of being gradually expanded as the file is read in. Hint: To determine the number of lines in the file, use java.io.File.length to obtain the size of the file, then divide by an assumed size of an average line. Answer: Since we are accessing the List randomly, we will use ArrayList . We estimate the number of lines by taking the file size and dividing by 50. We then double that figure, since it is more efficient to overestimate than to underestmate. import java.util.*; import java.io.*; public class FileList { public static void main(String[] args) { final int assumedLineLength = 50; File file = new File(args[0]); List<String> fileList = new ArrayList<String>((int)(file.length() / assumedLineLength) * 2); BufferedReader reader = null; int lineCount = 0; try { reader = new BufferedReader(new FileReader(file)); for (String line = reader.readLine(); line != null; line = reader.readLine()) { fileList.add(line); lineCount++; } } catch (IOException e) { System.err.format("Could not read %s: %s%n", file, e); System.exit(1); } finally { if (reader != null) { try { reader.close(); } catch (IOException e) {} } } int repeats = Integer.parseInt(args[1]); Random random = new Random(); for (int i = 0; i < repeats; i++) { System.out.format("%d: %s%n", i, fileList.get(random.nextInt(lineCount - 1))); } } } This program actually spends most of its time reading in the file, so pre-allocating the ArrayList has little affect on its performance. Specifying an initial capacity in advance is more likely to be useful when your program repeatly creates large ArrayList objects without intervening I/O.
General-Purpose Queue Implementations As mentioned in the previous section, LinkedList implements the Queue interface, providing first in, first out (FIFO) queue operations for add, poll, and so on. The PriorityQueue class is a priority queue based on the heap data structure. This queue orders elements according to the order specified at construction time, which can be the elements' natural ordering or the ordering imposed by an explicit Comparator . The queue retrieval operations ? poll, remove, peek , and element ? access the element at the head of the queue. The Queue.head of the queue is the least element with respect to the specified ordering. If multiple elements are tied for least value, the head is one of those elements; ties are broken arbitrarily. PriorityQueue and its iterator implement all of the optional methods of the Collection and Iterator interfaces. The iterator provided in method iterator is not guaranteed to traverse the elements of the PriorityQueue in any particular order. For ordered traversal, consider using Arrays.sort(pq.toArray()) .
Concurrent Queue Implementations The java.util.concurrent package contains a set of synchronized Queue interfaces and classes. BlockingQueue extends Queue with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes: LinkedBlockingQueue ? an optionally bounded FIFO blocking queue backed by linked nodes ArrayBlockingQueue ? a bounded FIFO blocking queue backed by an array PriorityBlockingQueue ? an unbounded blocking priority queue backed by a heap DelayQueue ? a time-based scheduling queue backed by a heap SynchronousQueue ? a simple rendezvous mechanism that uses the BlockingQueue interface In JDK 7, TransferQueue is a specialized BlockingQueue in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. TransferQueue has a single implementation: LinkedTransferQueue ? an unbounded TransferQueue based on linked nodes
Set Implementations The Set implementations are grouped into general-purpose and special-purpose implementations.
General-Purpose Set Implementations There are three general-purpose Set implementations ? HashSet , TreeSet , and LinkedHashSet . Which of these three to use is generally straightforward. HashSet is much faster than TreeSet (constant-time versus log-time for most operations) but offers no ordering guarantees. If you need to use the operations in the SortedSet interface, or if value-ordered iteration is required, use TreeSet ; otherwise, use HashSet . It's a fair bet that you'll end up using HashSet most of the time. LinkedHashSet is in some sense intermediate between HashSet and TreeSet . Implemented as a hash table with a linked list running through it, it provides insertion-ordered iteration (least recently inserted to most recently) and runs nearly as fast as HashSet . The LinkedHashSet implementation spares its clients from the unspecified, generally chaotic ordering provided by HashSet without incurring the increased cost associated with TreeSet .
General-Purpose Set Implementations - part 2 One thing worth keeping in mind about HashSet is that iteration is linear in the sum of the number of entries and the number of buckets (the capacity). Thus, choosing an initial capacity that's too high can waste both space and time. On the other hand, choosing an initial capacity that's too low wastes time by copying the data structure each time it's forced to increase its capacity. If you don't specify an initial capacity, the default is 16. In the past, there was some advantage to choosing a prime number as the initial capacity. This is no longer true. Internally, the capacity is always rounded up to a power of two. The initial capacity is specified by using the int constructor. The following line of code allocates a HashSet whose initial capacity is 64. Set<String> s = new HashSet<String>(64);
General-Purpose Set Implementations - part 3 The HashSet class has one other tuning parameter called the load factor. If you care a lot about the space consumption of your HashSet , read the HashSet documentation for more information. Otherwise, just accept the default; it's almost always the right thing to do. If you accept the default load factor but want to specify an initial capacity, pick a number that's about twice the size to which you expect the set to grow. If your guess is way off, you may waste a bit of space, time, or both, but it's unlikely to be a big problem. LinkedHashSet has the same tuning parameters as HashSet , but iteration time is not affected by capacity. TreeSet has no tuning parameters.
Special-Purpose Set Implementations There are two special-purpose Set implementations ? EnumSet and CopyOnWriteArraySet . EnumSet is a high-performance Set implementation for enum types. All of the members of an enum set must be of the same enum type. Internally, it is represented by a bit-vector, typically a single long. Enum sets support iteration over ranges of enum types. For example, given the enum declaration for the days of the week, you can iterate over the weekdays. The EnumSet class provides a static factory that makes it easy. for (Day d : EnumSet.range(Day.MONDAY, Day.FRIDAY)) System.out.println(d); Enum sets also provide a rich, typesafe replacement for traditional bit flags. EnumSet.of(Style.BOLD, Style.ITALIC) CopyOnWriteArraySet is a Set implementation backed up by a copy-on-write array. All mutative operations, such as add, set, and remove, are implemented by making a new copy of the array; no locking is ever required. Even iteration may safely proceed concurrently with element insertion and deletion. Unlike most Set implementations, the add, remove, and contains methods require time proportional to the size of the set. This implementation is only appropriate for sets that are rarely modified but frequently iterated. It is well suited to maintaining event-handler lists that must prevent duplicates.
Summary of Implementations Implementations are the data objects used to store collections, which implement the interfaces described in the Interfaces lesson. The Java Collections Framework provides several general-purpose implementations of the core interfaces: For the Set interface, HashSet is the most commonly used implementation. For the List interface, ArrayList is the most commonly used implementation. For the Map interface, HashMap is the most commonly used implementation. For the Queue interface, LinkedList is the most commonly used implementation. For the Deque interface, ArrayDeque is the most commonly used implementation. Each of the general-purpose implementations provides all optional operations contained in its interface. The Java Collections Framework also provides several special-purpose implementations for situations that require nonstandard performance, usage restrictions, or other unusual behavior. The java.util.concurrent package contains several collections implementations, which are thread-safe but not governed by a single exclusion lock.
Summary of Implementations - part 2 The Collections class (as opposed to the Collection interface), provides static methods that operate on or return collections, which are known as Wrapper implementations. Finally, there are several Convenience implementations, which can be more efficient than general-purpose implementations when you don't need their full power. The Convenience implementations are made available through static factory methods.
Wrapper Implementations Wrapper implementations delegate all their real work to a specified collection but add extra functionality on top of what this collection offers. For design pattern fans, this is an example of the decorator pattern. Although it may seem a bit exotic, it's really pretty straightforward. These implementations are anonymous; rather than providing a public class, the library provides a static factory method. All these implementations are found in the Collections class, which consists solely of static methods.
Synchronization Wrappers The synchronization wrappers add automatic synchronization (thread-safety) to an arbitrary collection. Each of the six core collection interfaces ? Collection , Set , List, Map , SortedSet , and SortedMap ? has one static factory method. public static <T> Collection<T> synchronizedCollection(Collection<T> c); public static <T> Set<T> synchronizedSet(Set<T> s); public static <T> List<T> synchronizedList(List<T> list); public static <K,V> Map<K,V> synchronizedMap(Map<K,V> m); public static <T> SortedSet<T> synchronizedSortedSet(SortedSet<T> s); public static <K,V> SortedMap<K,V> synchronizedSortedMap(SortedMap<K,V> m); Each of these methods returns a synchronized (thread-safe) Collection backed up by the specified collection. To guarantee serial access, all access to the backing collection must be accomplished through the returned collection. The easy way to guarantee this is not to keep a reference to the backing collection. Create the synchronized collection with the following trick. List<Type> list = Collections.synchronizedList(new ArrayList<Type>()); A collection created in this fashion is every bit as thread-safe as a normally synchronized collection, such as a Vector . In the face of concurrent access, it is imperative that the user manually synchronize on the returned collection when iterating over it. The reason is that iteration is accomplished via multiple calls into the collection, which must be composed into a single atomic operation. The following is the idiom to iterate over a wrapper-synchronized collection. Collection<Type> c = Collections.synchronizedCollection(myCollection); synchronized(c) { for (Type e : c) foo(e); }
Synchronization Wrappers - part 2 If an explicit iterator is used, the iterator method must be called from within the synchronized block. Failure to follow this advice may result in nondeterministic behavior. The idiom for iterating over a Collection view of a synchronized Map is similar. It is imperative that the user synchronize on the synchronized Map when iterating over any of its Collection views rather than synchronizing on the Collection view itself, as shown in the following example. Map<KeyType, ValType> m = Collections.synchronizedMap(new HashMap<KeyType, ValType>()); ... Set<KeyType> s = m.keySet(); ... // Synchronizing on m, not s! synchronized(m) { while (KeyType k : s) foo(k); } One minor downside of using wrapper implementations is that you do not have the ability to execute any noninterface operations of a wrapped implementation. So, for instance, in the preceding List example, you cannot call ArrayList 's ensureCapacity operation on the wrapped ArrayList .
Unmodifiable Wrappers Unlike synchronization wrappers, which add functionality to the wrapped collection, the unmodifiable wrappers take functionality away. In particular, they take away the ability to modify the collection by intercepting all the operations that would modify the collection and throwing an UnsupportedOperationException . Unmodifiable wrappers have two main uses, as follows: To make a collection immutable once it has been built. In this case, it's good practice not to maintain a reference to the backing collection. This absolutely guarantees immutability. To allow certain clients read-only access to your data structures. You keep a reference to the backing collection but hand out a reference to the wrapper. In this way, clients can look but not modify, while you maintain full access. Like synchronization wrappers, each of the six core Collection interfaces has one static factory method. public static <T> Collection<T> unmodifiableCollection(Collection<? extends T> c); public static <T> Set<T> unmodifiableSet(Set<? extends T> s); public static <T> List<T> unmodifiableList(List<? extends T> list); public static <K,V> Map<K, V> unmodifiableMap(Map<? extends K, ? extends V> m); public static <T> SortedSet<T> unmodifiableSortedSet(SortedSet<? extends T> s); public static <K,V> SortedMap<K, V> unmodifiableSortedMap(SortedMap<K, ? extends V> m);
Checked Interface Wrappers The Collections.checked interface wrappers are provided for use with generic collections. These implementations return a dynamically type-safe view of the specified collection, which throws a ClassCastException if a client attempts to add an element of the wrong type. The generics mechanism in the language provides compile-time (static) type-checking, but it is possible to defeat this mechanism. Dynamically type-safe views eliminate this possibility entirely.
Parameters If your API contains a method that requires a collection on input, it is of paramount importance that you declare the relevant parameter type to be one of the collection interface types. Never use an implementation type because this defeats the purpose of an interface-based Collections Framework, which is to allow collections to be manipulated without regard to implementation details. Further, you should always use the least-specific type that makes sense. For example, don't require a List or a Set if a Collection would do. It's not that you should never require a List or a Set on input; it is correct to do so if a method depends on a property of one of these interfaces. For example, many of the algorithms provided by the Java platform require a List on input because they depend on the fact that lists are ordered. As a general rule, however, the best types to use on input are the most general: Collection and Map . Caution: Never define your own ad hoc collection class and require objects of this class on input. By doing this, you'd lose all the benefits provided by the Java Collections Framework.
Return Values You can afford to be much more flexible with return values than with input parameters. It's fine to return an object of any type that implements or extends one of the collection interfaces. This can be one of the interfaces or a special-purpose type that extends or implements one of these interfaces. For example, one could imagine an image-processing package, called ImageList, that returned objects of a new class that implements List. In addition to the List operations, ImageList could support any application-specific operations that seemed desirable. For example, it might provide an indexImage operation that returned an image containing thumbnail images of each graphic in the ImageList. It's critical to note that even if the API furnishes ImageList instances on output, it should accept arbitrary Collection (or perhaps List) instances on input.
Return Values - part 2 In one sense, return values should have the opposite behavior of input parameters: It's best to return the most specific applicable collection interface rather than the most general. For example, if you're sure that you'll always return a SortedMap , you should give the relevant method the return type of SortedMap rather than Map . SortedMap instances are more time-consuming to build than ordinary Map instances and are also more powerful. Given that your module has already invested the time to build a SortedMap , it makes good sense to give the user access to its increased power. Furthermore, the user will be able to pass the returned object to methods that demand a SortedMap , as well as those that accept any Map .
Compatibility The Java Collections Framework was designed to ensure complete interoperability between the core collection interfaces and the types that were used to represent collections in the early versions of the Java platform: Vector , Hashtable , array, and Enumeration . In this section, you'll learn how to transform old collections to the Java Collections Framework collections and vice versa.
Upward Compatibility Suppose that you're using an API that returns legacy collections in tandem with another API that requires objects implementing the collection interfaces. To make the two APIs interoperate smoothly, you'll have to transform the legacy collections into modern collections. Luckily, the Java Collections Framework makes this easy. Suppose the old API returns an array of objects and the new API requires a Collection . The Collections Framework has a convenience implementation that allows an array of objects to be viewed as a List. You use Arrays.asList to pass an array to any method requiring a Collection or a List. Foo[] result = oldMethod(arg); newMethod(Arrays.asList(result)); If the old API returns a Vector or a Hashtable , you have no work to do at all because Vector was retrofitted to implement the List interface, and Hashtable was retrofitted to implement Map . Therefore, a Vector may be passed directly to any method calling for a Collection or a List. Vector result = oldMethod(arg); newMethod(result); Similarly, a Hashtable may be passed directly to any method calling for a Map . Hashtable result = oldMethod(arg); newMethod(result); Less frequently, an API may return an Enumeration that represents a collection of objects. The Collections.list method translates an Enumeration into a Collection . Enumeration e = oldMethod(arg); newMethod(Collections.list(e));
Backward Compatibility Suppose you're using an API that returns modern collections in tandem with another API that requires you to pass in legacy collections. To make the two APIs interoperate smoothly, you have to transform modern collections into old collections. Again, the Java Collections Framework makes this easy. Suppose the new API returns a Collection , and the old API requires an array of Object . As you're probably aware, the Collection interface contains a Collection.toArray method designed expressly for this situation. Collection c = newMethod(); oldMethod(c.toArray()); What if the old API requires an array of String (or another type) instead of an array of Object ? You just use the other form of Collection.toArray ? the one that takes an array on input. Collection c = newMethod(); oldMethod((String[]) c.toArray(new String[0])); If the old API requires a Vector , the standard collection constructor comes in handy. Collection c = newMethod(); oldMethod(new Vector(c)); The case where the old API requires a Hashtable is handled analogously. Map m = newMethod(); oldMethod(new Hashtable(m));
Backward Compatibility - part 2 Finally, what do you do if the old API requires an Enumeration ? This case isn't common, but it does happen from time to time, and the Collections.enumeration method was provided to handle it. This is a static factory method that takes a Collection and returns an Enumeration over the elements of the Collection . Collection c = newMethod(); oldMethod(Collections.enumeration(c));
What Is a Collections Framework? A collections framework is a unified architecture for representing and manipulating collections. All collections frameworks contain the following: Interfaces: These are abstract data types that represent collections. Interfaces allow collections to be manipulated independently of the details of their representation. In object-oriented languages, interfaces generally form a hierarchy. Implementations: These are the concrete implementations of the collection interfaces. In essence, they are reusable data structures. Algorithms: These are the methods that perform useful computations, such as searching and sorting, on objects that implement collection interfaces. The algorithms are said to be polymorphic: that is, the same method can be used on many different implementations of the appropriate collection interface. In essence, algorithms are reusable functionality. Apart from the Java Collections Framework, the best-known examples of collections frameworks are the C++ Standard Template Library (STL) and Smalltalk's collection hierarchy. Historically, collections frameworks have been quite complex, which gave them a reputation for having a steep learning curve. We believe that the Java Collections Framework breaks with this tradition, as you will learn for yourself in this chapter.
Benefits of the Java Collections Framework The Java Collections Framework provides the following benefits: Reduces programming effort: By providing useful data structures and algorithms, the Collections Framework frees you to concentrate on the important parts of your program rather than on the low-level "plumbing" required to make it work. By facilitating interoperability among unrelated APIs, the Java Collections Framework frees you from writing adapter objects or conversion code to connect APIs. Increases program speed and quality: This Collections Framework provides high-performance, high-quality implementations of useful data structures and algorithms. The various implementations of each interface are interchangeable, so programs can be easily tuned by switching collection implementations. Because you're freed from the drudgery of writing your own data structures, you'll have more time to devote to improving programs' quality and performance. Allows interoperability among unrelated APIs: The collection interfaces are the vernacular by which APIs pass collections back and forth. If my network administration API furnishes a collection of node names and if your GUI toolkit expects a collection of column headings, our APIs will interoperate seamlessly, even though they were written independently. Reduces effort to learn and to use new APIs: Many APIs naturally take collections on input and furnish them as output. In the past, each such API had a small sub-API devoted to manipulating its collections. There was little consistency among these ad hoc collections sub-APIs, so you had to learn each one from scratch, and it was easy to make mistakes when using them. With the advent of standard collection interfaces, the problem went away. Reduces effort to design new APIs: This is the flip side of the previous advantage. Designers and implementers don't have to reinvent the wheel each time they create an API that relies on collections; instead, they can use standard collection interfaces. Fosters software reuse: New data structures that conform to the standard collection interfaces are by nature reusable. The same goes for new algorithms that operate on objects that implement these interfaces.
java.util.Collections: java.util.Collections:  This class consists exclusively of static methods that operate on or return collections. It contains polymorphic algorithms that operate on collections, "wrappers", which return a new collection backed by a specified collection, and a few other odds and ends. The methods of this class all throw a NullPointerException if the collections or class objects provided to them are null. The documentation for the polymorphic algorithms contained in this class generally includes a brief description of the implementation. Such descriptions should be regarded as implementation notes, rather than parts of the specification. Implementors should feel free to substitute other algorithms, so long as the specification itself is adhered to. (For example, the algorithm used by sort does not have to be a mergesort, but it does have to be stable.) The "destructive" algorithms contained in this class, that is, the algorithms that modify the collection on which they operate, are specified to throw UnsupportedOperationException if the collection does not support the appropriate mutation primitive(s), such as the set method. These algorithms may, but are not required to, throw this exception if an invocation would have no effect on the collection. For example, invoking the sort method on an unmodifiable list that is already sorted may or may not throw UnsupportedOperationException. This class is a member of the  Java Collections Framework.
java.util.Collections: java.util.Collections.CheckedList.replaceAll	(	UnaryOperator	):  Replaces each element of this list with the result of applying the operator to that element. Errors or runtime exceptions thrown by the operator are relayed to the caller.
java.util.Collections: java.util.Collections.CheckedMap.CheckedEntrySet:  We need this class in addition to CheckedSet as Map.Entry permits modification of the backing Map via the setValue operation. This class is subtle: there are many possible attacks that must be thwarted.
java.util.Collections: java.util.Collections.CheckedMap.CheckedEntrySet.CheckedEntry:  This "wrapper class" serves two purposes: it prevents the client from modifying the backing Map, by short-circuiting the setValue method, and it protects the backing Map against an ill-behaved Map.Entry that attempts to modify another Map.Entry when asked to perform an equality check.
java.util.Collections: java.util.Collections.CheckedMap.CheckedEntrySet.contains	(	Object	):  This method is overridden to protect the backing set against an object with a nefarious equals function that senses that the equality-candidate is Map.Entry and calls its setValue method.
java.util.Collections: java.util.Collections.CheckedMap.CheckedEntrySet.containsAll	(	Collection	):  The bulk collection methods are overridden to protect against an unscrupulous collection whose contains(Object o) method senses when o is a Map.Entry, and calls o.setValue.
java.util.Collections: java.util.Collections.SynchronizedList.readResolve	(	):  SynchronizedRandomAccessList instances are serialized as SynchronizedList instances to allow them to be deserialized in pre-1.4 JREs (which do not have SynchronizedRandomAccessList). This method inverts the transformation. As a beneficial side-effect, it also grafts the RandomAccess marker onto SynchronizedList instances that were serialized in pre-1.4 JREs. Note: Unfortunately, SynchronizedRandomAccessList instances serialized in 1.4.1 and deserialized in 1.4 will become SynchronizedList instances, as this method was missing in 1.4.
java.util.Collections: java.util.Collections.SynchronizedNavigableMap:  A synchronized NavigableMap.
java.util.Collections: java.util.Collections.SynchronizedRandomAccessList.writeReplace	(	):  Allows instances to be deserialized in pre-1.4 JREs (which do not have SynchronizedRandomAccessList). SynchronizedList has a readResolve method that inverts this transformation upon deserialization.
java.util.Collections: java.util.Collections.UnmodifiableList.readResolve	(	):  UnmodifiableRandomAccessList instances are serialized as UnmodifiableList instances to allow them to be deserialized in pre-1.4 JREs (which do not have UnmodifiableRandomAccessList). This method inverts the transformation. As a beneficial side-effect, it also grafts the RandomAccess marker onto UnmodifiableList instances that were serialized in pre-1.4 JREs. Note: Unfortunately, UnmodifiableRandomAccessList instances serialized in 1.4.1 and deserialized in 1.4 will become UnmodifiableList instances, as this method was missing in 1.4.
java.util.Collections: java.util.Collections.UnmodifiableMap.UnmodifiableEntrySet:  We need this class in addition to UnmodifiableSet as Map.Entries themselves permit modification of the backing Map via their setValue operation. This class is subtle: there are many possible attacks that must be thwarted.
java.util.Collections: java.util.Collections.UnmodifiableMap.UnmodifiableEntrySet.UnmodifiableEntry:  This "wrapper class" serves two purposes: it prevents the client from modifying the backing Map, by short-circuiting the setValue method, and it protects the backing Map against an ill-behaved Map.Entry that attempts to modify another Map Entry when asked to perform an equality check.
java.util.Collections: java.util.Collections.UnmodifiableMap.UnmodifiableEntrySet.contains	(	Object	):  This method is overridden to protect the backing set against an object with a nefarious equals function that senses that the equality-candidate is Map.Entry and calls its setValue method.
java.util.Collections: java.util.Collections.UnmodifiableMap.UnmodifiableEntrySet.containsAll	(	Collection	):  The next two methods are overridden to protect against an unscrupulous List whose contains(Object o) method senses when o is a Map.Entry, and calls o.setValue.
java.util.Collections: java.util.Collections.UnmodifiableNavigableMap.EmptyNavigableMap:  A class for the EMPTY_NAVIGABLE_MAP which needs readResolve to preserve singleton property.
java.util.Collections: java.util.Collections.UnmodifiableNavigableSet:  Wraps a navigable set and disables all of the mutative operations.
java.util.Collections: java.util.Collections.UnmodifiableNavigableSet.EmptyNavigableSet:  A singleton empty unmodifiable navigable set used for emptyNavigableSet().
java.util.Collections: java.util.Collections.UnmodifiableRandomAccessList.writeReplace	(	):  Allows instances to be deserialized in pre-1.4 JREs (which do not have UnmodifiableRandomAccessList). UnmodifiableList has a readResolve method that inverts this transformation upon deserialization.
java.util.Collections: java.util.Collections.addAll	(	Collection	T	):  Adds all of the specified elements to the specified collection. Elements to be added may be specified individually or as an array. The behavior of this convenience method is identical to that of c.addAll(Arrays.asList(elements)), but this method is likely to run significantly faster under most implementations. When elements are specified individually, this method provides a convenient way to add a few elements to an existing collection:  Collections.addAll(flavors, "Peaches 'n Plutonium", "Rocky Racoon"); 
java.util.Collections: java.util.Collections.asLifoQueue	(	Deque	):  Returns a view of a Deque as a Last-in-first-out (Lifo) Queue. Method add is mapped to push, remove is mapped to pop and so on. This view can be useful when you would like to use a method requiring a Queue but you need Lifo ordering. Each method invocation on the queue returned by this method results in exactly one method invocation on the backing deque, with one exception. The addAll method is implemented as a sequence of addFirst invocations on the backing deque.
java.util.Collections: java.util.Collections.binarySearch	(	List	T	):  Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the Comparable natural ordering of its elements (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the list contains multiple elements equal to the specified object, there is no guarantee which one will be found. This method runs in log(n) time for a "random access" list (which provides near-constant-time positional access). If the specified list does not implement the RandomAccess interface and is large, this method will do an iterator-based binary search that performs O(n) link traversals and O(log n) element comparisons.
java.util.Collections: java.util.Collections.binarySearch	(	List	T	Comparator	):  Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort() sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If the list contains multiple elements equal to the specified object, there is no guarantee which one will be found. This method runs in log(n) time for a "random access" list (which provides near-constant-time positional access). If the specified list does not implement the RandomAccess interface and is large, this method will do an iterator-based binary search that performs O(n) link traversals and O(log n) element comparisons.
java.util.Collections: java.util.Collections.checkedCollection	(	Collection	Class	):  Returns a dynamically typesafe view of the specified collection. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a collection contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the collection takes place through the view, it is guaranteed that the collection cannot contain an incorrectly typed element. The generics mechanism in the language provides compile-time (static) type checking, but it is possible to defeat this mechanism with unchecked casts. Usually this is not a problem, as the compiler issues warnings on all such unchecked operations. There are, however, times when static type checking alone is not sufficient. For example, suppose a collection is passed to a third-party library and it is imperative that the library code not corrupt the collection by inserting an element of the wrong type. Another use of dynamically typesafe views is debugging. Suppose a program fails with a ClassCastException, indicating that an incorrectly typed element was put into a parameterized collection. Unfortunately, the exception can occur at any time after the erroneous element is inserted, so it typically provides little or no information as to the real source of the problem. If the problem is reproducible, one can quickly determine its source by temporarily modifying the program to wrap the collection with a dynamically typesafe view. For example, this declaration:  Collection c = new HashSet<>(); may be replaced temporarily by this one:  Collection c = Collections.checkedCollection( new HashSet<>(), String.class); Running the program again will cause it to fail at the point where an incorrectly typed element is inserted into the collection, clearly identifying the source of the problem. Once the problem is fixed, the modified declaration may be reverted back to the original. The returned collection does not pass the hashCode and equals operations through to the backing collection, but relies on Object's equals and hashCode methods. This is necessary to preserve the contracts of these operations in the case that the backing collection is a set or a list. The returned collection will be serializable if the specified collection is serializable. Since null is considered to be a value of any reference type, the returned collection permits insertion of null elements whenever the backing collection does.
java.util.Collections: java.util.Collections.checkedList	(	List	Class	):  Returns a dynamically typesafe view of the specified list. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a list contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the list takes place through the view, it is guaranteed that the list cannot contain an incorrectly typed element. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned list will be serializable if the specified list is serializable. Since null is considered to be a value of any reference type, the returned list permits insertion of null elements whenever the backing list does.
java.util.Collections: java.util.Collections.checkedMap	(	Map	Class	Class	):  Returns a dynamically typesafe view of the specified map. Any attempt to insert a mapping whose key or value have the wrong type will result in an immediate ClassCastException. Similarly, any attempt to modify the value currently associated with a key will result in an immediate ClassCastException, whether the modification is attempted directly through the map itself, or through a Map.Entry instance obtained from the map's entrySet() entry set view. Assuming a map contains no incorrectly typed keys or values prior to the time a dynamically typesafe view is generated, and that all subsequent access to the map takes place through the view (or one of its collection views), it is guaranteed that the map cannot contain an incorrectly typed key or value. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned map will be serializable if the specified map is serializable. Since null is considered to be a value of any reference type, the returned map permits insertion of null keys or values whenever the backing map does.
java.util.Collections: java.util.Collections.checkedNavigableMap	(	NavigableMap	Class	Class	):  Returns a dynamically typesafe view of the specified navigable map. Any attempt to insert a mapping whose key or value have the wrong type will result in an immediate ClassCastException. Similarly, any attempt to modify the value currently associated with a key will result in an immediate ClassCastException, whether the modification is attempted directly through the map itself, or through a Map.Entry instance obtained from the map's entrySet() entry set view. Assuming a map contains no incorrectly typed keys or values prior to the time a dynamically typesafe view is generated, and that all subsequent access to the map takes place through the view (or one of its collection views), it is guaranteed that the map cannot contain an incorrectly typed key or value. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned map will be serializable if the specified map is serializable. Since null is considered to be a value of any reference type, the returned map permits insertion of null keys or values whenever the backing map does.
java.util.Collections: java.util.Collections.checkedNavigableSet	(	NavigableSet	Class	):  Returns a dynamically typesafe view of the specified navigable set. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a navigable set contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the navigable set takes place through the view, it is guaranteed that the navigable set cannot contain an incorrectly typed element. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned navigable set will be serializable if the specified navigable set is serializable. Since null is considered to be a value of any reference type, the returned navigable set permits insertion of null elements whenever the backing sorted set does.
java.util.Collections: java.util.Collections.checkedQueue	(	Queue	Class	):  Returns a dynamically typesafe view of the specified queue. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a queue contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the queue takes place through the view, it is guaranteed that the queue cannot contain an incorrectly typed element. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned queue will be serializable if the specified queue is serializable. Since null is considered to be a value of any reference type, the returned queue permits insertion of null elements whenever the backing queue does.
java.util.Collections: java.util.Collections.checkedSet	(	Set	Class	):  Returns a dynamically typesafe view of the specified set. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a set contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the set takes place through the view, it is guaranteed that the set cannot contain an incorrectly typed element. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned set will be serializable if the specified set is serializable. Since null is considered to be a value of any reference type, the returned set permits insertion of null elements whenever the backing set does.
java.util.Collections: java.util.Collections.checkedSortedMap	(	SortedMap	Class	Class	):  Returns a dynamically typesafe view of the specified sorted map. Any attempt to insert a mapping whose key or value have the wrong type will result in an immediate ClassCastException. Similarly, any attempt to modify the value currently associated with a key will result in an immediate ClassCastException, whether the modification is attempted directly through the map itself, or through a Map.Entry instance obtained from the map's entrySet() entry set view. Assuming a map contains no incorrectly typed keys or values prior to the time a dynamically typesafe view is generated, and that all subsequent access to the map takes place through the view (or one of its collection views), it is guaranteed that the map cannot contain an incorrectly typed key or value. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned map will be serializable if the specified map is serializable. Since null is considered to be a value of any reference type, the returned map permits insertion of null keys or values whenever the backing map does.
java.util.Collections: java.util.Collections.checkedSortedSet	(	SortedSet	Class	):  Returns a dynamically typesafe view of the specified sorted set. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a sorted set contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the sorted set takes place through the view, it is guaranteed that the sorted set cannot contain an incorrectly typed element. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned sorted set will be serializable if the specified sorted set is serializable. Since null is considered to be a value of any reference type, the returned sorted set permits insertion of null elements whenever the backing sorted set does.
java.util.Collections: java.util.Collections.copy	(	List	List	):  Copies all of the elements from one list into another. After the operation, the index of each copied element in the destination list will be identical to its index in the source list. The destination list must be at least as long as the source list. If it is longer, the remaining elements in the destination list are unaffected.  This method runs in linear time.
java.util.Collections: java.util.Collections.disjoint	(	Collection	Collection	):  Returns true if the two specified collections have no elements in common. Care must be exercised if this method is used on collections that do not comply with the general contract for Collection. Implementations may elect to iterate over either collection and test for containment in the other collection (or to perform any equivalent computation). If either collection uses a nonstandard equality test (as does a SortedSet whose ordering is not compatible with equals, or the key set of an IdentityHashMap), both collections must use the same nonstandard equality test, or the result of this method is undefined. Care must also be exercised when using collections that have restrictions on the elements that they may contain. Collection implementations are allowed to throw exceptions for any operation involving elements they deem ineligible. For absolute safety the specified collections should contain only elements which are eligible elements for both collections. Note that it is permissible to pass the same collection in both parameters, in which case the method will return true if and only if the collection is empty.
java.util.Collections: java.util.Collections.emptyEnumeration	(	):  Returns an enumeration that has no elements. More precisely,  hasMoreElements always returns false.  nextElement always throws NoSuchElementException.  Implementations of this method are permitted, but not required, to return the same object from multiple invocations.
java.util.Collections: java.util.Collections.emptyIterator	(	):  Returns an iterator that has no elements. More precisely,  hasNext always returns false. next always throws NoSuchElementException. remove always throws IllegalStateException.  Implementations of this method are permitted, but not required, to return the same object from multiple invocations.
java.util.Collections: java.util.Collections.emptyList	(	):  Returns an empty list (immutable). This list is serializable. This example illustrates the type-safe way to obtain an empty list:  List<String> s = Collections.emptyList(); 
java.util.Collections: java.util.Collections.emptyListIterator	(	):  Returns a list iterator that has no elements. More precisely,  hasNext and hasPrevious always return false. next and previous always throw NoSuchElementException. remove and set always throw IllegalStateException. add always throws UnsupportedOperationException. nextIndex always returns 0. previousIndex always returns -1.  Implementations of this method are permitted, but not required, to return the same object from multiple invocations.
java.util.Collections: java.util.Collections.emptyMap	(	):  Returns an empty map (immutable). This map is serializable. This example illustrates the type-safe way to obtain an empty map:  Map<String, Date> s = Collections.emptyMap(); 
java.util.Collections: java.util.Collections.emptyNavigableMap	(	):  Returns an empty navigable map (immutable). This map is serializable. This example illustrates the type-safe way to obtain an empty map:  NavigableMap s = Collections.emptyNavigableMap();
java.util.Collections: java.util.Collections.emptyNavigableSet	(	):  Returns an empty navigable set (immutable). This set is serializable. This example illustrates the type-safe way to obtain an empty navigable set:  NavigableSet s = Collections.emptyNavigableSet();
java.util.Collections: java.util.Collections.emptySet	(	):  Returns an empty set (immutable). This set is serializable. Unlike the like-named field, this method is parameterized. This example illustrates the type-safe way to obtain an empty set:  Set<String> s = Collections.emptySet(); 
java.util.Collections: java.util.Collections.emptySortedMap	(	):  Returns an empty sorted map (immutable). This map is serializable. This example illustrates the type-safe way to obtain an empty map:  SortedMap s = Collections.emptySortedMap();
java.util.Collections: java.util.Collections.emptySortedSet	(	):  Returns an empty sorted set (immutable). This set is serializable. This example illustrates the type-safe way to obtain an empty sorted set:  SortedSet s = Collections.emptySortedSet();
java.util.Collections: java.util.Collections.enumeration	(	Collection	):  Returns an enumeration over the specified collection. This provides interoperability with legacy APIs that require an enumeration as input.
java.util.Collections: java.util.Collections.eq	(	Object	Object	):  Returns true if the specified arguments are equal, or both null. NB: Do not replace with Object.equals until JDK-8015417 is resolved.
java.util.Collections: java.util.Collections.fill	(	List	T	):  Replaces all of the elements of the specified list with the specified element.  This method runs in linear time.
java.util.Collections: java.util.Collections.frequency	(	Collection	Object	):  Returns the number of elements in the specified collection equal to the specified object. More formally, returns the number of elements e in the collection such that (o == null ? e == null : o.equals(e)).
java.util.Collections: java.util.Collections.get	(	ListIterator	int	):  Gets the ith element from the given list by repositioning the specified list listIterator.
java.util.Collections: java.util.Collections.indexOfSubList	(	List	List	):  Returns the starting position of the first occurrence of the specified target list within the specified source list, or -1 if there is no such occurrence. More formally, returns the lowest index i such that source.subList(i, i+target.size()).equals(target), or -1 if there is no such index. (Returns -1 if target.size() > source.size()) This implementation uses the "brute force" technique of scanning over the source list, looking for a match with the target at each location in turn.
java.util.Collections: java.util.Collections.lastIndexOfSubList	(	List	List	):  Returns the starting position of the last occurrence of the specified target list within the specified source list, or -1 if there is no such occurrence. More formally, returns the highest index i such that source.subList(i, i+target.size()).equals(target), or -1 if there is no such index. (Returns -1 if target.size() > source.size()) This implementation uses the "brute force" technique of iterating over the source list, looking for a match with the target at each location in turn.
java.util.Collections: java.util.Collections.list	(	Enumeration	):  Returns an array list containing the elements returned by the specified enumeration in the order they are returned by the enumeration. This method provides interoperability between legacy APIs that return enumerations and new APIs that require collections.
java.util.Collections: java.util.Collections.max	(	Collection	):  Returns the maximum element of the given collection, according to the natural ordering of its elements. All elements in the collection must implement the Comparable interface. Furthermore, all elements in the collection must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the collection). This method iterates over the entire collection, hence it requires time proportional to the size of the collection.
java.util.Collections: java.util.Collections.max	(	Collection	Comparator	):  Returns the maximum element of the given collection, according to the order induced by the specified comparator. All elements in the collection must be mutually comparable by the specified comparator (that is, comp.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the collection). This method iterates over the entire collection, hence it requires time proportional to the size of the collection.
java.util.Collections: java.util.Collections.min	(	Collection	):  Returns the minimum element of the given collection, according to the natural ordering of its elements. All elements in the collection must implement the Comparable interface. Furthermore, all elements in the collection must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the collection). This method iterates over the entire collection, hence it requires time proportional to the size of the collection.
java.util.Collections: java.util.Collections.min	(	Collection	Comparator	):  Returns the minimum element of the given collection, according to the order induced by the specified comparator. All elements in the collection must be mutually comparable by the specified comparator (that is, comp.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the collection). This method iterates over the entire collection, hence it requires time proportional to the size of the collection.
java.util.Collections: java.util.Collections.nCopies	(	int	T	):  Returns an immutable list consisting of n copies of the specified object. The newly allocated data object is tiny (it contains a single reference to the data object). This method is useful in combination with the List.addAll method to grow lists. The returned list is serializable.
java.util.Collections: java.util.Collections.newSetFromMap	(	Map	):  Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>()); 
java.util.Collections: java.util.Collections.replaceAll	(	List	T	T	):  Replaces all occurrences of one specified value in a list with another. More formally, replaces with newVal each element e in list such that (oldVal==null ? e==null : oldVal.equals(e)). (This method has no effect on the size of the list.)
java.util.Collections: java.util.Collections.reverse	(	List	):  Reverses the order of the elements in the specified list. This method runs in linear time.
java.util.Collections: java.util.Collections.reverseOrder	(	):  Returns a comparator that imposes the reverse of the natural ordering on a collection of objects that implement the Comparable interface. (The natural ordering is the ordering imposed by the objects' own compareTo method.) This enables a simple idiom for sorting (or maintaining) collections (or arrays) of objects that implement the Comparable interface in reverse-natural-order. For example, suppose a is an array of strings. Then:  Arrays.sort(a, Collections.reverseOrder());  sorts the array in reverse-lexicographic (alphabetical) order. The returned comparator is serializable.
java.util.Collections: java.util.Collections.reverseOrder	(	Comparator	):  Returns a comparator that imposes the reverse ordering of the specified comparator. If the specified comparator is null, this method is equivalent to reverseOrder() (in other words, it returns a comparator that imposes the reverse of the natural ordering on a collection of objects that implement the Comparable interface). The returned comparator is serializable (assuming the specified comparator is also serializable or null).
java.util.Collections: java.util.Collections.rotate	(	List	int	):  Rotates the elements in the specified list by the specified distance. After calling this method, the element at index i will be the element previously at index (i - distance) mod list.size(), for all values of i between 0 and list.size()-1, inclusive. (This method has no effect on the size of the list.) For example, suppose list comprises [t, a, n, k, s]. After invoking Collections.rotate(list, 1) (or Collections.rotate(list, -4)), list will comprise [s, t, a, n, k]. Note that this method can usefully be applied to sublists to move one or more elements within a list while preserving the order of the remaining elements. For example, the following idiom moves the element at index j forward to position k (which must be greater than or equal to j):  Collections.rotate(list.subList(j, k+1), -1);  To make this concrete, suppose list comprises [a, b, c, d, e]. To move the element at index 1 (b) forward two positions, perform the following invocation:  Collections.rotate(l.subList(1, 4), -1);  The resulting list is [a, c, d, b, e]. To move more than one element forward, increase the absolute value of the rotation distance. To move elements backward, use a positive shift distance. If the specified list is small or implements the RandomAccess interface, this implementation exchanges the first element into the location it should go, and then repeatedly exchanges the displaced element into the location it should go until a displaced element is swapped into the first element. If necessary, the process is repeated on the second and successive elements, until the rotation is complete. If the specified list is large and doesn't implement the RandomAccess interface, this implementation breaks the list into two sublist views around index -distance mod size. Then the reverse() method is invoked on each sublist view, and finally it is invoked on the entire list. For a more complete description of both algorithms, see Section 2.3 of Jon Bentley's Programming Pearls (Addison-Wesley, 1986).
java.util.Collections: java.util.Collections.shuffle	(	List	):  Randomly permutes the specified list using a default source of randomness. All permutations occur with approximately equal likelihood. The hedge "approximately" is used in the foregoing description because default source of randomness is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm would choose permutations with perfect uniformity. This implementation traverses the list backwards, from the last element up to the second, repeatedly swapping a randomly selected element into the "current position". Elements are randomly selected from the portion of the list that runs from the first element to the current position, inclusive. This method runs in linear time. If the specified list does not implement the RandomAccess interface and is large, this implementation dumps the specified list into an array before shuffling it, and dumps the shuffled array back into the list. This avoids the quadratic behavior that would result from shuffling a "sequential access" list in place.
java.util.Collections: java.util.Collections.shuffle	(	List	Random	):  Randomly permute the specified list using the specified source of randomness. All permutations occur with equal likelihood assuming that the source of randomness is fair. This implementation traverses the list backwards, from the last element up to the second, repeatedly swapping a randomly selected element into the "current position". Elements are randomly selected from the portion of the list that runs from the first element to the current position, inclusive. This method runs in linear time. If the specified list does not implement the RandomAccess interface and is large, this implementation dumps the specified list into an array before shuffling it, and dumps the shuffled array back into the list. This avoids the quadratic behavior that would result from shuffling a "sequential access" list in place.
java.util.Collections: java.util.Collections.singleton	(	T	):  Returns an immutable set containing only the specified object. The returned set is serializable.
java.util.Collections: java.util.Collections.singletonList	(	T	):  Returns an immutable list containing only the specified object. The returned list is serializable.
java.util.Collections: java.util.Collections.singletonMap	(	K	V	):  Returns an immutable map, mapping only the specified key to the specified value. The returned map is serializable.
java.util.Collections: java.util.Collections.singletonSpliterator	(	T	):  Creates a Spliterator with only the specified element
java.util.Collections: java.util.Collections.sort	(	List	):  Sorts the specified list into ascending order, according to the Comparable natural ordering of its elements. All elements in the list must implement the Comparable interface. Furthermore, all elements in the list must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the list). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The specified list must be modifiable, but need not be resizable.
java.util.Collections: java.util.Collections.sort	(	List	Comparator	):  Sorts the specified list according to the order induced by the specified comparator. All elements in the list must be mutually comparable using the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the list). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The specified list must be modifiable, but need not be resizable.
java.util.Collections: java.util.Collections.swap	(	List	int	int	):  Swaps the elements at the specified positions in the specified list. (If the specified positions are equal, invoking this method leaves the list unchanged.)
java.util.Collections: java.util.Collections.swap	(	Object[]	int	int	):  Swaps the two specified elements in the specified array.
java.util.Collections: java.util.Collections.synchronizedCollection	(	Collection	):  Returns a synchronized (thread-safe) collection backed by the specified collection. In order to guarantee serial access, it is critical that all access to the backing collection is accomplished through the returned collection. It is imperative that the user manually synchronize on the returned collection when traversing it via Iterator, Spliterator or Stream:  Collection c = Collections.synchronizedCollection(myCollection); ... synchronized (c) { Iterator i = c.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned collection does not pass the hashCode and equals operations through to the backing collection, but relies on Object's equals and hashCode methods. This is necessary to preserve the contracts of these operations in the case that the backing collection is a set or a list. The returned collection will be serializable if the specified collection is serializable.
java.util.Collections: java.util.Collections.synchronizedList	(	List	):  Returns a synchronized (thread-safe) list backed by the specified list. In order to guarantee serial access, it is critical that all access to the backing list is accomplished through the returned list. It is imperative that the user manually synchronize on the returned list when iterating over it:  List list = Collections.synchronizedList(new ArrayList()); ... synchronized (list) { Iterator i = list.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned list will be serializable if the specified list is serializable.
java.util.Collections: java.util.Collections.synchronizedMap	(	Map	):  Returns a synchronized (thread-safe) map backed by the specified map. In order to guarantee serial access, it is critical that all access to the backing map is accomplished through the returned map. It is imperative that the user manually synchronize on the returned map when iterating over any of its collection views:  Map m = Collections.synchronizedMap(new HashMap()); ... Set s = m.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not s! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned map will be serializable if the specified map is serializable.
java.util.Collections: java.util.Collections.synchronizedNavigableMap	(	NavigableMap	):  Returns a synchronized (thread-safe) navigable map backed by the specified navigable map. In order to guarantee serial access, it is critical that all access to the backing navigable map is accomplished through the returned navigable map (or its views). It is imperative that the user manually synchronize on the returned navigable map when iterating over any of its collection views, or the collections views of any of its subMap, headMap or tailMap views.  NavigableMap m = Collections.synchronizedNavigableMap(new TreeMap()); ... Set s = m.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not s! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  or:  NavigableMap m = Collections.synchronizedNavigableMap(new TreeMap()); NavigableMap m2 = m.subMap(foo, true, bar, false); ... Set s2 = m2.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not m2 or s2! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned navigable map will be serializable if the specified navigable map is serializable.
java.util.Collections: java.util.Collections.synchronizedNavigableSet	(	NavigableSet	):  Returns a synchronized (thread-safe) navigable set backed by the specified navigable set. In order to guarantee serial access, it is critical that all access to the backing navigable set is accomplished through the returned navigable set (or its views). It is imperative that the user manually synchronize on the returned navigable set when iterating over it or any of its subSet, headSet, or tailSet views.  NavigableSet s = Collections.synchronizedNavigableSet(new TreeSet()); ... synchronized (s) { Iterator i = s.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  or:  NavigableSet s = Collections.synchronizedNavigableSet(new TreeSet()); NavigableSet s2 = s.headSet(foo, true); ... synchronized (s) { // Note: s, not s2!!! Iterator i = s2.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned navigable set will be serializable if the specified navigable set is serializable.
java.util.Collections: java.util.Collections.synchronizedSet	(	Set	):  Returns a synchronized (thread-safe) set backed by the specified set. In order to guarantee serial access, it is critical that all access to the backing set is accomplished through the returned set. It is imperative that the user manually synchronize on the returned set when iterating over it:  Set s = Collections.synchronizedSet(new HashSet()); ... synchronized (s) { Iterator i = s.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned set will be serializable if the specified set is serializable.
java.util.Collections: java.util.Collections.synchronizedSortedMap	(	SortedMap	):  Returns a synchronized (thread-safe) sorted map backed by the specified sorted map. In order to guarantee serial access, it is critical that all access to the backing sorted map is accomplished through the returned sorted map (or its views). It is imperative that the user manually synchronize on the returned sorted map when iterating over any of its collection views, or the collections views of any of its subMap, headMap or tailMap views.  SortedMap m = Collections.synchronizedSortedMap(new TreeMap()); ... Set s = m.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not s! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  or:  SortedMap m = Collections.synchronizedSortedMap(new TreeMap()); SortedMap m2 = m.subMap(foo, bar); ... Set s2 = m2.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not m2 or s2! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned sorted map will be serializable if the specified sorted map is serializable.
java.util.Collections: java.util.Collections.synchronizedSortedSet	(	SortedSet	):  Returns a synchronized (thread-safe) sorted set backed by the specified sorted set. In order to guarantee serial access, it is critical that all access to the backing sorted set is accomplished through the returned sorted set (or its views). It is imperative that the user manually synchronize on the returned sorted set when iterating over it or any of its subSet, headSet, or tailSet views.  SortedSet s = Collections.synchronizedSortedSet(new TreeSet()); ... synchronized (s) { Iterator i = s.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  or:  SortedSet s = Collections.synchronizedSortedSet(new TreeSet()); SortedSet s2 = s.headSet(foo); ... synchronized (s) { // Note: s, not s2!!! Iterator i = s2.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned sorted set will be serializable if the specified sorted set is serializable.
java.util.Collections: java.util.Collections.unmodifiableCollection	(	Collection	):  Returns an unmodifiable view of the specified collection. This method allows modules to provide users with "read-only" access to internal collections. Query operations on the returned collection "read through" to the specified collection, and attempts to modify the returned collection, whether direct or via its iterator, result in an UnsupportedOperationException. The returned collection does not pass the hashCode and equals operations through to the backing collection, but relies on Object's equals and hashCode methods. This is necessary to preserve the contracts of these operations in the case that the backing collection is a set or a list. The returned collection will be serializable if the specified collection is serializable.
java.util.Collections: java.util.Collections.unmodifiableList	(	List	):  Returns an unmodifiable view of the specified list. This method allows modules to provide users with "read-only" access to internal lists. Query operations on the returned list "read through" to the specified list, and attempts to modify the returned list, whether direct or via its iterator, result in an UnsupportedOperationException. The returned list will be serializable if the specified list is serializable. Similarly, the returned list will implement RandomAccess if the specified list does.
java.util.Collections: java.util.Collections.unmodifiableMap	(	Map	):  Returns an unmodifiable view of the specified map. This method allows modules to provide users with "read-only" access to internal maps. Query operations on the returned map "read through" to the specified map, and attempts to modify the returned map, whether direct or via its collection views, result in an UnsupportedOperationException. The returned map will be serializable if the specified map is serializable.
java.util.Collections: java.util.Collections.unmodifiableNavigableMap	(	NavigableMap	):  Returns an unmodifiable view of the specified navigable map. This method allows modules to provide users with "read-only" access to internal navigable maps. Query operations on the returned navigable map "read through" to the specified navigable map. Attempts to modify the returned navigable map, whether direct, via its collection views, or via its subMap, headMap, or tailMap views, result in an UnsupportedOperationException. The returned navigable map will be serializable if the specified navigable map is serializable.
java.util.Collections: java.util.Collections.unmodifiableNavigableSet	(	NavigableSet	):  Returns an unmodifiable view of the specified navigable set. This method allows modules to provide users with "read-only" access to internal navigable sets. Query operations on the returned navigable set "read through" to the specified navigable set. Attempts to modify the returned navigable set, whether direct, via its iterator, or via its subSet, headSet, or tailSet views, result in an UnsupportedOperationException. The returned navigable set will be serializable if the specified navigable set is serializable.
java.util.Collections: java.util.Collections.unmodifiableSet	(	Set	):  Returns an unmodifiable view of the specified set. This method allows modules to provide users with "read-only" access to internal sets. Query operations on the returned set "read through" to the specified set, and attempts to modify the returned set, whether direct or via its iterator, result in an UnsupportedOperationException. The returned set will be serializable if the specified set is serializable.
java.util.Collections: java.util.Collections.unmodifiableSortedMap	(	SortedMap	):  Returns an unmodifiable view of the specified sorted map. This method allows modules to provide users with "read-only" access to internal sorted maps. Query operations on the returned sorted map "read through" to the specified sorted map. Attempts to modify the returned sorted map, whether direct, via its collection views, or via its subMap, headMap, or tailMap views, result in an UnsupportedOperationException. The returned sorted map will be serializable if the specified sorted map is serializable.
java.util.Collections: java.util.Collections.unmodifiableSortedSet	(	SortedSet	):  Returns an unmodifiable view of the specified sorted set. This method allows modules to provide users with "read-only" access to internal sorted sets. Query operations on the returned sorted set "read through" to the specified sorted set. Attempts to modify the returned sorted set, whether direct, via its iterator, or via its subSet, headSet, or tailSet views, result in an UnsupportedOperationException. The returned sorted set will be serializable if the specified sorted set is serializable.
java.util.Comparator: java.util.Comparator:  A comparison function, which imposes a total ordering on some collection of objects. Comparators can be passed to a sort method (such as sort() Collections.sort or sort() Arrays.sort) to allow precise control over the sort order. Comparators can also be used to control the order of certain data structures (such as SortedSet sorted sets or SortedMap sorted maps), or to provide an ordering for collections of objects that don't have a Comparable natural ordering. The ordering imposed by a comparator c on a set of elements S is said to be consistent with equals if and only if c.compare(e1, e2)==0 has the same boolean value as e1.equals(e2) for every e1 and e2 in S. Caution should be exercised when using a comparator capable of imposing an ordering inconsistent with equals to order a sorted set (or sorted map). Suppose a sorted set (or sorted map) with an explicit comparator c is used with elements (or keys) drawn from a set S. If the ordering imposed by c on S is inconsistent with equals, the sorted set (or sorted map) will behave "strangely." In particular the sorted set (or sorted map) will violate the general contract for set (or map), which is defined in terms of equals. For example, suppose one adds two elements a and b such that (a.equals(b) && c.compare(a, b) != 0) to an empty TreeSet with comparator c. The second add operation will return true (and the size of the tree set will increase) because a and b are not equivalent from the tree set's perspective, even though this is contrary to the specification of the add Set.add method. Note: It is generally a good idea for comparators to also implement java.io.Serializable, as they may be used as ordering methods in serializable data structures (like TreeSet, TreeMap). In order for the data structure to serialize successfully, the comparator (if provided) must implement Serializable. For the mathematically inclined, the relation that defines the imposed ordering that a given comparator c imposes on a given set of objects S is: {(x, y) such that c.compare(x, y) <= 0}.  The quotient for this total order is: {(x, y) such that c.compare(x, y) == 0}.  It follows immediately from the contract for compare that the quotient is an equivalence relation on S, and that the imposed ordering is a total order on S. When we say that the ordering imposed by c on S is consistent with equals, we mean that the quotient for the ordering is the equivalence relation defined by the objects' equals() equals(Object) method(s): {(x, y) such that x.equals(y)}.  Unlike Comparable, a comparator may optionally permit comparison of null arguments, while maintaining the requirements for an equivalence relation. This interface is a member of the  Java Collections Framework.
java.util.Comparator: java.util.Comparator.compare	(	T	T	):  Compares its two arguments for order. Returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. In the foregoing description, the notation sgn(expression) designates the mathematical signum function, which is defined to return one of -1, 0, or 1 according to whether the value of expression is negative, zero or positive. The implementor must ensure that sgn(compare(x, y)) == -sgn(compare(y, x)) for all x and y. (This implies that compare(x, y) must throw an exception if and only if compare(y, x) throws an exception.) The implementor must also ensure that the relation is transitive: ((compare(x, y)>0) && (compare(y, z)>0)) implies compare(x, z)>0. Finally, the implementor must ensure that compare(x, y)==0 implies that sgn(compare(x, z))==sgn(compare(y, z)) for all z. It is generally the case, but not strictly required that (compare(x, y)==0) == (x.equals(y)). Generally speaking, any comparator that violates this condition should clearly indicate this fact. The recommended language is "Note: this comparator imposes orderings that are inconsistent with equals."
java.util.Comparator: java.util.Comparator.comparing	(	Function	):  Accepts a function that extracts a java.lang.Comparable Comparable sort key from a type T, and returns a Comparator that compares by that sort key. The returned comparator is serializable if the specified function is also serializable.
java.util.Comparator: java.util.Comparator.comparing	(	Function	Comparator	):  Accepts a function that extracts a sort key from a type T, and returns a Comparator that compares by that sort key using the specified Comparator. The returned comparator is serializable if the specified function and comparator are both serializable.
java.util.Comparator: java.util.Comparator.comparingDouble	(	ToDoubleFunction	):  Accepts a function that extracts a double sort key from a type T, and returns a Comparator that compares by that sort key. The returned comparator is serializable if the specified function is also serializable.
java.util.Comparator: java.util.Comparator.comparingInt	(	ToIntFunction	):  Accepts a function that extracts an int sort key from a type T, and returns a Comparator that compares by that sort key. The returned comparator is serializable if the specified function is also serializable.
java.util.Comparator: java.util.Comparator.comparingLong	(	ToLongFunction	):  Accepts a function that extracts a long sort key from a type T, and returns a Comparator that compares by that sort key. The returned comparator is serializable if the specified function is also serializable.
java.util.Comparator: java.util.Comparator.equals	(	Object	):  Indicates whether some other object is "equal to" this comparator. This method must obey the general contract of equals(). Additionally, this method can return true only if the specified object is also a comparator and it imposes the same ordering as this comparator. Thus, comp1.equals(comp2) implies that sgn(comp1.compare(o1, o2))==sgn(comp2.compare(o1, o2)) for every object reference o1 and o2. Note that it is always safe not to override Object.equals(Object). However, overriding this method may, in some cases, improve performance by allowing programs to determine that two distinct comparators impose the same order.
java.util.Comparator: java.util.Comparator.naturalOrder	(	):  Returns a comparator that compares Comparable objects in natural order. The returned comparator is serializable and throws NullPointerException when comparing null.
java.util.Comparator: java.util.Comparator.nullsFirst	(	Comparator	):  Returns a null-friendly comparator that considers null to be less than non-null. When both are null, they are considered equal. If both are non-null, the specified Comparator is used to determine the order. If the specified comparator is null, then the returned comparator considers all non-null values to be equal. The returned comparator is serializable if the specified comparator is serializable.
java.util.Comparator: java.util.Comparator.nullsLast	(	Comparator	):  Returns a null-friendly comparator that considers null to be greater than non-null. When both are null, they are considered equal. If both are non-null, the specified Comparator is used to determine the order. If the specified comparator is null, then the returned comparator considers all non-null values to be equal. The returned comparator is serializable if the specified comparator is serializable.
java.util.Comparator: java.util.Comparator.reverseOrder	(	):  Returns a comparator that imposes the reverse of the natural ordering. The returned comparator is serializable and throws NullPointerException when comparing null.
java.util.Comparator: java.util.Comparator.reversed	(	):  Returns a comparator that imposes the reverse ordering of this comparator.
java.util.Comparator: java.util.Comparator.thenComparing	(	Comparator	):  Returns a lexicographic-order comparator with another comparator. If this Comparator considers two elements equal, i.e. compare(a, b) == 0, other is used to determine the order. The returned comparator is serializable if the specified comparator is also serializable.
java.util.Comparator: java.util.Comparator.thenComparing	(	Function	):  Returns a lexicographic-order comparator with a function that extracts a Comparable sort key.
java.util.Comparator: java.util.Comparator.thenComparing	(	Function	Comparator	):  Returns a lexicographic-order comparator with a function that extracts a key to be compared with the given Comparator.
java.util.Comparator: java.util.Comparator.thenComparingDouble	(	ToDoubleFunction	):  Returns a lexicographic-order comparator with a function that extracts a double sort key.
java.util.Comparator: java.util.Comparator.thenComparingInt	(	ToIntFunction	):  Returns a lexicographic-order comparator with a function that extracts a int sort key.
java.util.Comparator: java.util.Comparator.thenComparingLong	(	ToLongFunction	):  Returns a lexicographic-order comparator with a function that extracts a long sort key.
java.util.Map: java.util.Map:  An object that maps keys to values. A map cannot contain duplicate keys; each key can map to at most one value. This interface takes the place of the Dictionary class, which was a totally abstract class rather than an interface. The Map interface provides three collection views, which allow a map's contents to be viewed as a set of keys, collection of values, or set of key-value mappings. The order of a map is defined as the order in which the iterators on the map's collection views return their elements. Some map implementations, like the TreeMap class, make specific guarantees as to their order; others, like the HashMap class, do not. Note: great care must be exercised if mutable objects are used as map keys. The behavior of a map is not specified if the value of an object is changed in a manner that affects equals comparisons while the object is a key in the map. A special case of this prohibition is that it is not permissible for a map to contain itself as a key. While it is permissible for a map to contain itself as a value, extreme caution is advised: the equals and hashCode methods are no longer well defined on such a map. All general-purpose map implementation classes should provide two "standard" constructors: a void (no arguments) constructor which creates an empty map, and a constructor with a single argument of type Map, which creates a new map with the same key-value mappings as its argument. In effect, the latter constructor allows the user to copy any map, producing an equivalent map of the desired class. There is no way to enforce this recommendation (as interfaces cannot contain constructors) but all of the general-purpose map implementations in the JDK comply. The "destructive" methods contained in this interface, that is, the methods that modify the map on which they operate, are specified to throw UnsupportedOperationException if this map does not support the operation. If this is the case, these methods may, but are not required to, throw an UnsupportedOperationException if the invocation would have no effect on the map. For example, invoking the putAll() method on an unmodifiable map may, but is not required to, throw the exception if the map whose mappings are to be "superimposed" is empty. Some map implementations have restrictions on the keys and values they may contain. For example, some implementations prohibit null keys and values, and some have restrictions on the types of their keys. Attempting to insert an ineligible key or value throws an unchecked exception, typically NullPointerException or ClassCastException. Attempting to query the presence of an ineligible key or value may throw an exception, or it may simply return false; some implementations will exhibit the former behavior and some will exhibit the latter. More generally, attempting an operation on an ineligible key or value whose completion would not result in the insertion of an ineligible element into the map may throw an exception or it may succeed, at the option of the implementation. Such exceptions are marked as "optional" in the specification for this interface. Many methods in Collections Framework interfaces are defined in terms of the equals() method. For example, the specification for the containsKey() containsKey(Object key) method says: "returns true if and only if this map contains a mapping for a key k such that (key==null ? k==null : key.equals(k))." This specification should not be construed to imply that invoking Map.containsKey with a non-null argument key will cause key.equals(k) to be invoked for any key k. Implementations are free to implement optimizations whereby the equals invocation is avoided, for example, by first comparing the hash codes of the two keys. (The hashCode() specification guarantees that two objects with unequal hash codes cannot be equal.) More generally, implementations of the various Collections Framework interfaces are free to take advantage of the specified behavior of underlying Object methods wherever the implementor deems it appropriate. Some map operations which perform recursive traversal of the map may fail with an exception for self-referential instances where the map directly or indirectly contains itself. This includes the clone(), equals(), hashCode() and toString() methods. Implementations may optionally handle the self-referential scenario, however most current implementations do not do so. This interface is a member of the  Java Collections Framework.
java.util.Map: java.util.Map.Entry:  A map entry (key-value pair). The Map.entrySet method returns a collection-view of the map, whose elements are of this class. The only way to obtain a reference to a map entry is from the iterator of this collection-view. These Map.Entry objects are valid only for the duration of the iteration; more formally, the behavior of a map entry is undefined if the backing map has been modified after the entry was returned by the iterator, except through the setValue operation on the map entry.
java.util.Map: java.util.Map.Entry.comparingByKey	(	):  Returns a comparator that compares Map.Entry in natural order on key. The returned comparator is serializable and throws NullPointerException when comparing an entry with a null key.
java.util.Map: java.util.Map.Entry.comparingByKey	(	Comparator	):  Returns a comparator that compares Map.Entry by key using the given Comparator. The returned comparator is serializable if the specified comparator is also serializable.
java.util.Map: java.util.Map.Entry.comparingByValue	(	):  Returns a comparator that compares Map.Entry in natural order on value. The returned comparator is serializable and throws NullPointerException when comparing an entry with null values.
java.util.Map: java.util.Map.Entry.comparingByValue	(	Comparator	):  Returns a comparator that compares Map.Entry by value using the given Comparator. The returned comparator is serializable if the specified comparator is also serializable.
java.util.Map: java.util.Map.Entry.equals	(	Object	):  Compares the specified object with this entry for equality. Returns true if the given object is also a map entry and the two entries represent the same mapping. More formally, two entries e1 and e2 represent the same mapping if (e1.getKey()==null ? e2.getKey()==null : e1.getKey().equals(e2.getKey())) && (e1.getValue()==null ? e2.getValue()==null : e1.getValue().equals(e2.getValue()))  This ensures that the equals method works properly across different implementations of the Map.Entry interface.
java.util.Map: java.util.Map.Entry.getKey	(	):  Returns the key corresponding to this entry.
java.util.Map: java.util.Map.Entry.getValue	(	):  Returns the value corresponding to this entry. If the mapping has been removed from the backing map (by the iterator's remove operation), the results of this call are undefined.
java.util.Map: java.util.Map.Entry.hashCode	(	):  Returns the hash code value for this map entry. The hash code of a map entry e is defined to be:  (e.getKey()==null ? 0 : e.getKey().hashCode()) ^ (e.getValue()==null ? 0 : e.getValue().hashCode())  This ensures that e1.equals(e2) implies that e1.hashCode()==e2.hashCode() for any two Entries e1 and e2, as required by the general contract of Object.hashCode.
java.util.Map: java.util.Map.Entry.setValue	(	V	):  Replaces the value corresponding to this entry with the specified value (optional operation). (Writes through to the map.) The behavior of this call is undefined if the mapping has already been removed from the map (by the iterator's remove operation).
java.util.Map: java.util.Map.clear	(	):  Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.
java.util.Map: java.util.Map.compute	(	K	BiFunction	):  Attempts to compute a mapping for the specified key and its current mapped value (or null if there is no current mapping). For example, to either create or append a String msg to a value mapping:  map.compute(key, (k, v) -> (v == null) ? msg : v.concat(msg)) (Method merge merge() is often simpler to use for such purposes.) If the function returns null, the mapping is removed (or remains absent if initially absent). If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.
java.util.Map: java.util.Map.computeIfAbsent	(	K	Function	):  If the specified key is not already associated with a value (or is mapped to null), attempts to compute its value using the given mapping function and enters it into this map unless null. If the function returns null no mapping is recorded. If the function itself throws an (unchecked) exception, the exception is rethrown, and no mapping is recorded. The most common usage is to construct a new object serving as an initial mapped value or memoized result, as in:  map.computeIfAbsent(key, k -> new Value(f(k))); Or to implement a multi-value map, Map>, supporting multiple values per key:  map.computeIfAbsent(key, k -> new HashSet()).add(v);
java.util.Map: java.util.Map.computeIfPresent	(	K	BiFunction	):  If the value for the specified key is present and non-null, attempts to compute a new mapping given the key and its current mapped value. If the function returns null, the mapping is removed. If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.
java.util.Map: java.util.Map.containsKey	(	Object	):  Returns true if this map contains a mapping for the specified key. More formally, returns true if and only if this map contains a mapping for a key k such that (key==null ? k==null : key.equals(k)). (There can be at most one such mapping.)
java.util.Map: java.util.Map.containsValue	(	Object	):  Returns true if this map maps one or more keys to the specified value. More formally, returns true if and only if this map contains at least one mapping to a value v such that (value==null ? v==null : value.equals(v)). This operation will probably require time linear in the map size for most implementations of the Map interface.
java.util.Map: java.util.Map.entrySet	(	):  Returns a Set view of the mappings contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation, or through the setValue operation on a map entry returned by the iterator) the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.Map: java.util.Map.equals	(	Object	):  Compares the specified object with this map for equality. Returns true if the given object is also a map and the two maps represent the same mappings. More formally, two maps m1 and m2 represent the same mappings if m1.entrySet().equals(m2.entrySet()). This ensures that the equals method works properly across different implementations of the Map interface.
java.util.Map: java.util.Map.forEach	(	BiConsumer	):  Performs the given action for each entry in this map until all entries have been processed or the action throws an exception. Unless otherwise specified by the implementing class, actions are performed in the order of entry set iteration (if an iteration order is specified.) Exceptions thrown by the action are relayed to the caller.
java.util.Map: java.util.Map.get	(	Object	):  Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that (key==null ? k==null : key.equals(k)), then this method returns v; otherwise it returns null. (There can be at most one such mapping.) If this map permits null values, then a return value of null does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to null. The containsKey operation may be used to distinguish these two cases.
java.util.Map: java.util.Map.getOrDefault	(	Object	V	):  Returns the value to which the specified key is mapped, or defaultValue if this map contains no mapping for the key.
java.util.Map: java.util.Map.hashCode	(	):  Returns the hash code value for this map. The hash code of a map is defined to be the sum of the hash codes of each entry in the map's entrySet() view. This ensures that m1.equals(m2) implies that m1.hashCode()==m2.hashCode() for any two maps m1 and m2, as required by the general contract of hashCode.
java.util.Map: java.util.Map.isEmpty	(	):  Returns true if this map contains no key-value mappings.
java.util.Map: java.util.Map.keySet	(	):  Returns a Set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.Map: java.util.Map.merge	(	K	V	BiFunction	):  If the specified key is not already associated with a value or is associated with null, associates it with the given non-null value. Otherwise, replaces the associated value with the results of the given remapping function, or removes if the result is null. This method may be of use when combining multiple mapped values for a key. For example, to either create or append a String msg to a value mapping:  map.merge(key, msg, String::concat) If the function returns null the mapping is removed. If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.
java.util.Map: java.util.Map.put	(	K	V	):  Associates the specified value with the specified key in this map (optional operation). If the map previously contained a mapping for the key, the old value is replaced by the specified value. (A map m is said to contain a mapping for a key k if and only if containsKey() m.containsKey(k) would return true.)
java.util.Map: java.util.Map.putAll	(	Map	):  Copies all of the mappings from the specified map to this map (optional operation). The effect of this call is equivalent to that of calling put() put(k, v) on this map once for each mapping from key k to value v in the specified map. The behavior of this operation is undefined if the specified map is modified while the operation is in progress.
java.util.Map: java.util.Map.putIfAbsent	(	K	V	):  If the specified key is not already associated with a value (or is mapped to null) associates it with the given value and returns null, else returns the current value.
java.util.Map: java.util.Map.remove	(	Object	):  Removes the mapping for a key from this map if it is present (optional operation). More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. If this map permits null values, then a return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.
java.util.Map: java.util.Map.remove	(	Object	Object	):  Removes the entry for the specified key only if it is currently mapped to the specified value.
java.util.Map: java.util.Map.replace	(	K	V	):  Replaces the entry for the specified key only if it is currently mapped to some value.
java.util.Map: java.util.Map.replace	(	K	V	V	):  Replaces the entry for the specified key only if currently mapped to the specified value.
java.util.Map: java.util.Map.replaceAll	(	BiFunction	):  Replaces each entry's value with the result of invoking the given function on that entry until all entries have been processed or the function throws an exception. Exceptions thrown by the function are relayed to the caller.
java.util.Map: java.util.Map.size	(	):  Returns the number of key-value mappings in this map. If the map contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
java.util.Map: java.util.Map.values	(	):  Returns a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.Random: java.util.Random:  An instance of this class is used to generate a stream of pseudorandom numbers. The class uses a 48-bit seed, which is modified using a linear congruential formula. (See Donald Knuth, The Art of Computer Programming, Volume 2, Section 3.2.1.)  If two instances of Random are created with the same seed, and the same sequence of method calls is made for each, they will generate and return identical sequences of numbers. In order to guarantee this property, particular algorithms are specified for the class Random. Java implementations must use all the algorithms shown here for the class Random, for the sake of absolute portability of Java code. However, subclasses of class Random are permitted to use other algorithms, so long as they adhere to the general contracts for all the methods.  The algorithms implemented by class Random use a protected utility method that on each invocation can supply up to 32 pseudorandomly generated bits.  Many applications will find the method random simpler to use. Instances of java.util.Random are threadsafe. However, the concurrent use of the same java.util.Random instance across threads may encounter contention and consequent poor performance. Consider instead using java.util.concurrent.ThreadLocalRandom in multithreaded designs. Instances of java.util.Random are not cryptographically secure. Consider instead using java.security.SecureRandom to get a cryptographically secure pseudo-random number generator for use by security-sensitive applications.
java.util.Random: java.util.Random.Random	(	):  Creates a new random number generator. This constructor sets the seed of the random number generator to a value very likely to be distinct from any other invocation of this constructor.
java.util.Random: java.util.Random.Random	(	long	):  Creates a new random number generator using a single long seed. The seed is the initial value of the internal state of the pseudorandom number generator which is maintained by method next. The invocation new Random(seed) is equivalent to:  Random rnd = new Random(); rnd.setSeed(seed);
java.util.Random: java.util.Random.RandomDoublesSpliterator:  Spliterator for double streams.
java.util.Random: java.util.Random.RandomIntsSpliterator:  Spliterator for int streams. We multiplex the four int versions into one class by treating a bound less than origin as unbounded, and also by treating "infinite" as equivalent to Long.MAX_VALUE. For splits, it uses the standard divide-by-two approach. The long and double versions of this class are identical except for types.
java.util.Random: java.util.Random.RandomLongsSpliterator:  Spliterator for long streams.
java.util.Random: java.util.Random.doubles	(	):  Returns an effectively unlimited stream of pseudorandom double values, each between zero (inclusive) and one (exclusive). A pseudorandom double value is generated as if it's the result of calling the method nextDouble().
java.util.Random: java.util.Random.doubles	(	double	double	):  Returns an effectively unlimited stream of pseudorandom double values, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom double value is generated as if it's the result of calling the following method with the origin and bound:  double nextDouble(double origin, double bound) double r = nextDouble(); r = r * (bound - origin) + origin; if (r >= bound) // correct for rounding r = Math.nextDown(bound); return r; }}
java.util.Random: java.util.Random.doubles	(	long	):  Returns a stream producing the given streamSize number of pseudorandom double values, each between zero (inclusive) and one (exclusive). A pseudorandom double value is generated as if it's the result of calling the method nextDouble().
java.util.Random: java.util.Random.doubles	(	long	double	double	):  Returns a stream producing the given streamSize number of pseudorandom double values, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom double value is generated as if it's the result of calling the following method with the origin and bound:  double nextDouble(double origin, double bound) double r = nextDouble(); r = r * (bound - origin) + origin; if (r >= bound) // correct for rounding r = Math.nextDown(bound); return r; }}
java.util.Random: java.util.Random.internalNextDouble	(	double	double	):  The form of nextDouble used by DoubleStream Spliterators.
java.util.Random: java.util.Random.internalNextInt	(	int	int	):  The form of nextInt used by IntStream Spliterators. For the unbounded case: uses nextInt(). For the bounded case with representable range: uses nextInt(int bound) For the bounded case with unrepresentable range: uses nextInt()
java.util.Random: java.util.Random.internalNextLong	(	long	long	):  The form of nextLong used by LongStream Spliterators. If origin is greater than bound, acts as unbounded form of nextLong, else as bounded form.
java.util.Random: java.util.Random.ints	(	):  Returns an effectively unlimited stream of pseudorandom int values. A pseudorandom int value is generated as if it's the result of calling the method nextInt().
java.util.Random: java.util.Random.ints	(	int	int	):  Returns an effectively unlimited stream of pseudorandom int values, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom int value is generated as if it's the result of calling the following method with the origin and bound:  int nextInt(int origin, int bound) int n = bound - origin; if (n > 0) { return nextInt(n) + origin; } else { // range not representable as int int r; do { r = nextInt(); } while (r < origin || r >= bound); return r; } }}
java.util.Random: java.util.Random.ints	(	long	):  Returns a stream producing the given streamSize number of pseudorandom int values. A pseudorandom int value is generated as if it's the result of calling the method nextInt().
java.util.Random: java.util.Random.ints	(	long	int	int	):  Returns a stream producing the given streamSize number of pseudorandom int values, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom int value is generated as if it's the result of calling the following method with the origin and bound:  int nextInt(int origin, int bound) int n = bound - origin; if (n > 0) { return nextInt(n) + origin; } else { // range not representable as int int r; do { r = nextInt(); } while (r < origin || r >= bound); return r; } }}
java.util.Random: java.util.Random.longs	(	):  Returns an effectively unlimited stream of pseudorandom long values. A pseudorandom long value is generated as if it's the result of calling the method nextLong().
java.util.Random: java.util.Random.longs	(	long	):  Returns a stream producing the given streamSize number of pseudorandom long values. A pseudorandom long value is generated as if it's the result of calling the method nextLong().
java.util.Random: java.util.Random.longs	(	long	long	):  Returns an effectively unlimited stream of pseudorandom long values, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom long value is generated as if it's the result of calling the following method with the origin and bound:  long nextLong(long origin, long bound) long r = nextLong(); long n = bound - origin, m = n - 1; if ((n & m) == 0L) // power of two r = (r & m) + origin; else if (n > 0L) { // reject over-represented candidates for (long u = r >>> 1; // ensure nonnegative u + m - (r = u % n) < 0L; // rejection check u = nextLong() >>> 1) // retry ; r += origin; } else { // range not representable as long while (r < origin || r >= bound) r = nextLong(); } return r; }}
java.util.Random: java.util.Random.longs	(	long	long	long	):  Returns a stream producing the given streamSize number of pseudorandom long, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom long value is generated as if it's the result of calling the following method with the origin and bound:  long nextLong(long origin, long bound) long r = nextLong(); long n = bound - origin, m = n - 1; if ((n & m) == 0L) // power of two r = (r & m) + origin; else if (n > 0L) { // reject over-represented candidates for (long u = r >>> 1; // ensure nonnegative u + m - (r = u % n) < 0L; // rejection check u = nextLong() >>> 1) // retry ; r += origin; } else { // range not representable as long while (r < origin || r >= bound) r = nextLong(); } return r; }}
java.util.Random: java.util.Random.next	(	int	):  Generates the next pseudorandom number. Subclasses should override this, as this is used by all other methods. The general contract of next is that it returns an int value and if the argument bits is between 1 and 32 (inclusive), then that many low-order bits of the returned value will be (approximately) independently chosen bit values, each of which is (approximately) equally likely to be 0 or 1. The method next is implemented by class Random by atomically updating the seed to (seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1) and returning (int)(seed >>> (48 - bits)). This is a linear congruential pseudorandom number generator, as defined by D. H. Lehmer and described by Donald E. Knuth in The Art of Computer Programming, Volume 3: Seminumerical Algorithms, section 3.2.1.
java.util.Random: java.util.Random.nextBoolean	(	):  Returns the next pseudorandom, uniformly distributed boolean value from this random number generator's sequence. The general contract of nextBoolean is that one boolean value is pseudorandomly generated and returned. The values true and false are produced with (approximately) equal probability. The method nextBoolean is implemented by class Random as if by:  public boolean nextBoolean() return next(1) != 0; }}
java.util.Random: java.util.Random.nextBytes	(	byte[]	):  Generates random bytes and places them into a user-supplied byte array. The number of random bytes produced is equal to the length of the byte array. The method nextBytes is implemented by class Random as if by:  public void nextBytes(byte[] bytes) for (int i = 0; i < bytes.length; ) for (int rnd = nextInt(), n = Math.min(bytes.length - i, 4); n-- > 0; rnd >>= 8) bytes[i++] = (byte)rnd; }}
java.util.Random: java.util.Random.nextDouble	(	):  Returns the next pseudorandom, uniformly distributed double value between 0.0 and 1.0 from this random number generator's sequence. The general contract of nextDouble is that one double value, chosen (approximately) uniformly from the range 0.0d (inclusive) to 1.0d (exclusive), is pseudorandomly generated and returned. The method nextDouble is implemented by class Random as if by:  public double nextDouble() return (((long)next(26) << 27) + next(27)) / (double)(1L << 53); }} The hedge "approximately" is used in the foregoing description only because the next method is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm shown would choose double values from the stated range with perfect uniformity. [In early versions of Java, the result was incorrectly calculated as:  return (((long)next(27) << 27) + next(27)) / (double)(1L << 54); This might seem to be equivalent, if not better, but in fact it introduced a large nonuniformity because of the bias in the rounding of floating-point numbers: it was three times as likely that the low-order bit of the significand would be 0 than that it would be 1! This nonuniformity probably doesn't matter much in practice, but we strive for perfection.]
java.util.Random: java.util.Random.nextFloat	(	):  Returns the next pseudorandom, uniformly distributed float value between 0.0 and 1.0 from this random number generator's sequence. The general contract of nextFloat is that one float value, chosen (approximately) uniformly from the range 0.0f (inclusive) to 1.0f (exclusive), is pseudorandomly generated and returned. All 224 possible float values of the form m x 2-24, where m is a positive integer less than 224, are produced with (approximately) equal probability. The method nextFloat is implemented by class Random as if by:  public float nextFloat() return next(24) / ((float)(1 << 24)); }} The hedge "approximately" is used in the foregoing description only because the next method is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm shown would choose float values from the stated range with perfect uniformity. [In early versions of Java, the result was incorrectly calculated as:  return next(30) / ((float)(1 << 30)); This might seem to be equivalent, if not better, but in fact it introduced a slight nonuniformity because of the bias in the rounding of floating-point numbers: it was slightly more likely that the low-order bit of the significand would be 0 than that it would be 1.]
java.util.Random: java.util.Random.nextGaussian	(	):  Returns the next pseudorandom, Gaussian ("normally") distributed double value with mean 0.0 and standard deviation 1.0 from this random number generator's sequence.  The general contract of nextGaussian is that one double value, chosen from (approximately) the usual normal distribution with mean 0.0 and standard deviation 1.0, is pseudorandomly generated and returned. The method nextGaussian is implemented by class Random as if by a threadsafe version of the following:  private double nextNextGaussian; private boolean haveNextNextGaussian = false; public double nextGaussian() if (haveNextNextGaussian) { haveNextNextGaussian = false; return nextNextGaussian; } else { double v1, v2, s; do { v1 = 2 * nextDouble() - 1; // between -1.0 and 1.0 v2 = 2 * nextDouble() - 1; // between -1.0 and 1.0 s = v1 * v1 + v2 * v2; } while (s >= 1 || s == 0); double multiplier = StrictMath.sqrt(-2 * StrictMath.log(s)/s); nextNextGaussian = v2 * multiplier; haveNextNextGaussian = true; return v1 * multiplier; } }} This uses the polar method of G. E. P. Box, M. E. Muller, and G. Marsaglia, as described by Donald E. Knuth in The Art of Computer Programming, Volume 3: Seminumerical Algorithms, section 3.4.1, subsection C, algorithm P. Note that it generates two independent values at the cost of only one call to StrictMath.log and one call to StrictMath.sqrt.
java.util.Random: java.util.Random.nextInt	(	):  Returns the next pseudorandom, uniformly distributed int value from this random number generator's sequence. The general contract of nextInt is that one int value is pseudorandomly generated and returned. All 232 possible int values are produced with (approximately) equal probability. The method nextInt is implemented by class Random as if by:  public int nextInt() return next(32); }}
java.util.Random: java.util.Random.nextInt	(	int	):  Returns a pseudorandom, uniformly distributed int value between 0 (inclusive) and the specified value (exclusive), drawn from this random number generator's sequence. The general contract of nextInt is that one int value in the specified range is pseudorandomly generated and returned. All bound possible int values are produced with (approximately) equal probability. The method nextInt(int bound) is implemented by class Random as if by:  public int nextInt(int bound) if (bound <= 0) throw new IllegalArgumentException("bound must be positive"); if ((bound & -bound) == bound) // i.e., bound is a power of 2 return (int)((bound * (long)next(31)) >> 31); int bits, val; do { bits = next(31); val = bits % bound; } while (bits - val + (bound-1) < 0); return val; }} The hedge "approximately" is used in the foregoing description only because the next method is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm shown would choose int values from the stated range with perfect uniformity.  The algorithm is slightly tricky. It rejects values that would result in an uneven distribution (due to the fact that 2^31 is not divisible by n). The probability of a value being rejected depends on n. The worst case is n=2^30+1, for which the probability of a reject is 1/2, and the expected number of iterations before the loop terminates is 2.  The algorithm treats the case where n is a power of two specially: it returns the correct number of high-order bits from the underlying pseudo-random number generator. In the absence of special treatment, the correct number of low-order bits would be returned. Linear congruential pseudo-random number generators such as the one implemented by this class are known to have short periods in the sequence of values of their low-order bits. Thus, this special case greatly increases the length of the sequence of values returned by successive calls to this method if n is a small power of two.
java.util.Random: java.util.Random.nextLong	(	):  Returns the next pseudorandom, uniformly distributed long value from this random number generator's sequence. The general contract of nextLong is that one long value is pseudorandomly generated and returned. The method nextLong is implemented by class Random as if by:  public long nextLong() return ((long)next(32) << 32) + next(32); }} Because class Random uses a seed with only 48 bits, this algorithm will not return all possible long values.
java.util.Random: java.util.Random.readObject	(	java.io.ObjectInputStream	):  Reconstitute the Random instance from a stream (that is, deserialize it).
java.util.Random: java.util.Random.setSeed	(	long	):  Sets the seed of this random number generator using a single long seed. The general contract of setSeed is that it alters the state of this random number generator object so as to be in exactly the same state as if it had just been created with the argument seed as a seed. The method setSeed is implemented by class Random by atomically updating the seed to (seed ^ 0x5DEECE66DL) & ((1L << 48) - 1) and clearing the haveNextNextGaussian flag used by nextGaussian. The implementation of setSeed by class Random happens to use only 48 bits of the given seed. In general, however, an overriding method may use all 64 bits of the long argument as a seed value.
java.util.Random: java.util.Random.writeObject	(	ObjectOutputStream	):  Save the Random instance to a stream.
java.util.AbstractList: java.util.AbstractList:  This class provides a skeletal implementation of the List interface to minimize the effort required to implement this interface backed by a "random access" data store (such as an array). For sequential access data (such as a linked list), AbstractSequentialList should be used in preference to this class. To implement an unmodifiable list, the programmer needs only to extend this class and provide implementations for the get() and size() size() methods. To implement a modifiable list, the programmer must additionally override the set() set(int, E) method (which otherwise throws an UnsupportedOperationException). If the list is variable-size the programmer must additionally override the add() add(int, E) and remove() methods. The programmer should generally provide a void (no argument) and collection constructor, as per the recommendation in the Collection interface specification. Unlike the other abstract collection implementations, the programmer does not have to provide an iterator implementation; the iterator and list iterator are implemented by this class, on top of the "random access" methods: get(), set() set(int, E), add() add(int, E) and remove(). The documentation for each non-abstract method in this class describes its implementation in detail. Each of these methods may be overridden if the collection being implemented admits a more efficient implementation. This class is a member of the  Java Collections Framework.
java.util.AbstractList: java.util.AbstractList.AbstractList	(	):  Sole constructor. (For invocation by subclass constructors, typically implicit.)
java.util.AbstractList: java.util.AbstractList.add	(	E	):  Appends the specified element to the end of this list (optional operation). Lists that support this operation may place limitations on what elements may be added to this list. In particular, some lists will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. List classes should clearly specify in their documentation any restrictions on what elements may be added. This implementation calls add(size(), e). Note that this implementation throws an UnsupportedOperationException unless add() add(int, E) is overridden.
java.util.AbstractList: java.util.AbstractList.add	(	int	E	):  Inserts the specified element at the specified position in this list (optional operation). Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices). This implementation always throws an UnsupportedOperationException.
java.util.AbstractList: java.util.AbstractList.addAll	(	int	Collection	):  Inserts all of the elements in the specified collection into this list at the specified position (optional operation). Shifts the element currently at that position (if any) and any subsequent elements to the right (increases their indices). The new elements will appear in this list in the order that they are returned by the specified collection's iterator. The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (Note that this will occur if the specified collection is this list, and it's nonempty.) This implementation gets an iterator over the specified collection and iterates over it, inserting the elements obtained from the iterator into this list at the appropriate position, one at a time, using add(int, E). Many implementations will override this method for efficiency. Note that this implementation throws an UnsupportedOperationException unless add() add(int, E) is overridden.
java.util.AbstractList: java.util.AbstractList.clear	(	):  Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.
java.util.AbstractList: java.util.AbstractList.equals	(	Object	):  Compares the specified object with this list for equality. Returns true if and only if the specified object is also a list, both lists have the same size, and all corresponding pairs of elements in the two lists are equal. (Two elements e1 and e2 are equal if (e1==null ? e2==null : e1.equals(e2)).) In other words, two lists are defined to be equal if they contain the same elements in the same order. This implementation first checks if the specified object is this list. If so, it returns true; if not, it checks if the specified object is a list. If not, it returns false; if so, it iterates over both lists, comparing corresponding pairs of elements. If any comparison returns false, this method returns false. If either iterator runs out of elements before the other it returns false (as the lists are of unequal length); otherwise it returns true when the iterations complete.
java.util.AbstractList: java.util.AbstractList.get	(	int	):  Returns the element at the specified position in this list.
java.util.AbstractList: java.util.AbstractList.hashCode	(	):  Returns the hash code value for this list. This implementation uses exactly the code that is used to define the list hash function in the documentation for the hashCode method.
java.util.AbstractList: java.util.AbstractList.indexOf	(	Object	):  Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index. This implementation first gets a list iterator (with listIterator()). Then, it iterates over the list until the specified element is found or the end of the list is reached.
java.util.AbstractList: java.util.AbstractList.iterator	(	):  Returns an iterator over the elements in this list in proper sequence. This implementation returns a straightforward implementation of the iterator interface, relying on the backing list's size(), get(int), and remove(int) methods. Note that the iterator returned by this method will throw an UnsupportedOperationException in response to its remove method unless the list's remove(int) method is overridden. This implementation can be made to throw runtime exceptions in the face of concurrent modification, as described in the specification for the (protected) modCount field.
java.util.AbstractList: java.util.AbstractList.lastIndexOf	(	Object	):  Returns the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the highest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index. This implementation first gets a list iterator that points to the end of the list (with listIterator(size())). Then, it iterates backwards over the list until the specified element is found, or the beginning of the list is reached.
java.util.AbstractList: java.util.AbstractList.listIterator	(	):  Returns a list iterator over the elements in this list (in proper sequence). This implementation returns listIterator(0).
java.util.AbstractList: java.util.AbstractList.listIterator	(	int	):  Returns a list iterator over the elements in this list (in proper sequence), starting at the specified position in the list. The specified index indicates the first element that would be returned by an initial call to next. An initial call to previous would return the element with the specified index minus one. This implementation returns a straightforward implementation of the ListIterator interface that extends the implementation of the Iterator interface returned by the iterator() method. The ListIterator implementation relies on the backing list's get(int), set(int, E), add(int, E) and remove(int) methods. Note that the list iterator returned by this implementation will throw an UnsupportedOperationException in response to its remove, set and add methods unless the list's remove(int), set(int, E), and add(int, E) methods are overridden. This implementation can be made to throw runtime exceptions in the face of concurrent modification, as described in the specification for the (protected) modCount field.
java.util.AbstractList: java.util.AbstractList.remove	(	int	):  Removes the element at the specified position in this list (optional operation). Shifts any subsequent elements to the left (subtracts one from their indices). Returns the element that was removed from the list. This implementation always throws an UnsupportedOperationException.
java.util.AbstractList: java.util.AbstractList.removeRange	(	int	int	):  Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive. Shifts any succeeding elements to the left (reduces their index). This call shortens the list by (toIndex - fromIndex) elements. (If toIndex==fromIndex, this operation has no effect.) This method is called by the clear operation on this list and its subLists. Overriding this method to take advantage of the internals of the list implementation can substantially improve the performance of the clear operation on this list and its subLists. This implementation gets a list iterator positioned before fromIndex, and repeatedly calls ListIterator.next followed by ListIterator.remove until the entire range has been removed. Note: if ListIterator.remove requires linear time, this implementation requires quadratic time.
java.util.AbstractList: java.util.AbstractList.set	(	int	E	):  Replaces the element at the specified position in this list with the specified element (optional operation). This implementation always throws an UnsupportedOperationException.
java.util.AbstractList: java.util.AbstractList.subList	(	int	int	):  Returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive. (If fromIndex and toIndex are equal, the returned list is empty.) The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa. The returned list supports all of the optional list operations supported by this list. This method eliminates the need for explicit range operations (of the sort that commonly exist for arrays). Any operation that expects a list can be used as a range operation by passing a subList view instead of a whole list. For example, the following idiom removes a range of elements from a list: list.subList(from, to).clear(); Similar idioms may be constructed for indexOf and lastIndexOf, and all of the algorithms in the Collections class can be applied to a subList. The semantics of the list returned by this method become undefined if the backing list (i.e., this list) is structurally modified in any way other than via the returned list. (Structural modifications are those that change the size of this list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.) This implementation returns a list that subclasses AbstractList. The subclass stores, in private fields, the offset of the subList within the backing list, the size of the subList (which can change over its lifetime), and the expected modCount value of the backing list. There are two variants of the subclass, one of which implements RandomAccess. If this list implements RandomAccess the returned list will be an instance of the subclass that implements RandomAccess. The subclass's set(int, E), get(int), add(int, E), remove(int), addAll(int, Collection) and removeRange(int, int) methods all delegate to the corresponding methods on the backing abstract list, after bounds-checking the index and adjusting for the offset. The addAll(Collection c) method merely returns addAll(size, c). The listIterator(int) method returns a "wrapper object" over a list iterator on the backing list, which is created with the corresponding method on the backing list. The iterator method merely returns listIterator(), and the size method merely returns the subclass's size field. All methods first check to see if the actual modCount of the backing list is equal to its expected value, and throw a ConcurrentModificationException if it is not.
java.util.AbstractMap: java.util.AbstractMap:  This class provides a skeletal implementation of the Map interface, to minimize the effort required to implement this interface. To implement an unmodifiable map, the programmer needs only to extend this class and provide an implementation for the entrySet method, which returns a set-view of the map's mappings. Typically, the returned set will, in turn, be implemented atop AbstractSet. This set should not support the add or remove methods, and its iterator should not support the remove method. To implement a modifiable map, the programmer must additionally override this class's put method (which otherwise throws an UnsupportedOperationException), and the iterator returned by entrySet().iterator() must additionally implement its remove method. The programmer should generally provide a void (no argument) and map constructor, as per the recommendation in the Map interface specification. The documentation for each non-abstract method in this class describes its implementation in detail. Each of these methods may be overridden if the map being implemented admits a more efficient implementation. This class is a member of the  Java Collections Framework.
java.util.AbstractMap: java.util.AbstractMap.AbstractMap	(	):  Sole constructor. (For invocation by subclass constructors, typically implicit.)
java.util.AbstractMap: java.util.AbstractMap.SimpleEntry:  An Entry maintaining a key and a value. The value may be changed using the setValue method. This class facilitates the process of building custom map implementations. For example, it may be convenient to return arrays of SimpleEntry instances in method Map.entrySet().toArray.
java.util.AbstractMap: java.util.AbstractMap.SimpleEntry.SimpleEntry	(	Entry	):  Creates an entry representing the same mapping as the specified entry.
java.util.AbstractMap: java.util.AbstractMap.SimpleEntry.SimpleEntry	(	K	V	):  Creates an entry representing a mapping from the specified key to the specified value.
java.util.AbstractMap: java.util.AbstractMap.SimpleEntry.equals	(	Object	):  Compares the specified object with this entry for equality. Returns true if the given object is also a map entry and the two entries represent the same mapping. More formally, two entries e1 and e2 represent the same mapping if (e1.getKey()==null ? e2.getKey()==null : e1.getKey().equals(e2.getKey())) && (e1.getValue()==null ? e2.getValue()==null : e1.getValue().equals(e2.getValue())) This ensures that the equals method works properly across different implementations of the Map.Entry interface.
java.util.AbstractMap: java.util.AbstractMap.SimpleEntry.getKey	(	):  Returns the key corresponding to this entry.
java.util.AbstractMap: java.util.AbstractMap.SimpleEntry.getValue	(	):  Returns the value corresponding to this entry.
java.util.AbstractMap: java.util.AbstractMap.SimpleEntry.hashCode	(	):  Returns the hash code value for this map entry. The hash code of a map entry e is defined to be:  (e.getKey()==null ? 0 : e.getKey().hashCode()) ^ (e.getValue()==null ? 0 : e.getValue().hashCode()) This ensures that e1.equals(e2) implies that e1.hashCode()==e2.hashCode() for any two Entries e1 and e2, as required by the general contract of hashCode.
java.util.AbstractMap: java.util.AbstractMap.SimpleEntry.setValue	(	V	):  Replaces the value corresponding to this entry with the specified value.
java.util.AbstractMap: java.util.AbstractMap.SimpleEntry.toString	(	):  Returns a String representation of this map entry. This implementation returns the string representation of this entry's key followed by the equals character ("=") followed by the string representation of this entry's value.
java.util.AbstractMap: java.util.AbstractMap.SimpleImmutableEntry:  An Entry maintaining an immutable key and value. This class does not support method setValue. This class may be convenient in methods that return thread-safe snapshots of key-value mappings.
java.util.AbstractMap: java.util.AbstractMap.SimpleImmutableEntry.SimpleImmutableEntry	(	Entry	):  Creates an entry representing the same mapping as the specified entry.
java.util.AbstractMap: java.util.AbstractMap.SimpleImmutableEntry.SimpleImmutableEntry	(	K	V	):  Creates an entry representing a mapping from the specified key to the specified value.
java.util.AbstractMap: java.util.AbstractMap.SimpleImmutableEntry.equals	(	Object	):  Compares the specified object with this entry for equality. Returns true if the given object is also a map entry and the two entries represent the same mapping. More formally, two entries e1 and e2 represent the same mapping if (e1.getKey()==null ? e2.getKey()==null : e1.getKey().equals(e2.getKey())) && (e1.getValue()==null ? e2.getValue()==null : e1.getValue().equals(e2.getValue())) This ensures that the equals method works properly across different implementations of the Map.Entry interface.
java.util.AbstractMap: java.util.AbstractMap.SimpleImmutableEntry.getKey	(	):  Returns the key corresponding to this entry.
java.util.AbstractMap: java.util.AbstractMap.SimpleImmutableEntry.getValue	(	):  Returns the value corresponding to this entry.
java.util.AbstractMap: java.util.AbstractMap.SimpleImmutableEntry.hashCode	(	):  Returns the hash code value for this map entry. The hash code of a map entry e is defined to be:  (e.getKey()==null ? 0 : e.getKey().hashCode()) ^ (e.getValue()==null ? 0 : e.getValue().hashCode()) This ensures that e1.equals(e2) implies that e1.hashCode()==e2.hashCode() for any two Entries e1 and e2, as required by the general contract of hashCode.
java.util.AbstractMap: java.util.AbstractMap.SimpleImmutableEntry.setValue	(	V	):  Replaces the value corresponding to this entry with the specified value (optional operation). This implementation simply throws UnsupportedOperationException, as this class implements an immutable map entry.
java.util.AbstractMap: java.util.AbstractMap.SimpleImmutableEntry.toString	(	):  Returns a String representation of this map entry. This implementation returns the string representation of this entry's key followed by the equals character ("=") followed by the string representation of this entry's value.
java.util.AbstractMap: java.util.AbstractMap.clear	(	):  Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.
java.util.AbstractMap: java.util.AbstractMap.clone	(	):  Returns a shallow copy of this AbstractMap instance: the keys and values themselves are not cloned.
java.util.AbstractMap: java.util.AbstractMap.containsKey	(	Object	):  Returns true if this map contains a mapping for the specified key. More formally, returns true if and only if this map contains a mapping for a key k such that (key==null ? k==null : key.equals(k)). (There can be at most one such mapping.)
java.util.AbstractMap: java.util.AbstractMap.containsValue	(	Object	):  Returns true if this map maps one or more keys to the specified value. More formally, returns true if and only if this map contains at least one mapping to a value v such that (value==null ? v==null : value.equals(v)). This operation will probably require time linear in the map size for most implementations of the Map interface.
java.util.AbstractMap: java.util.AbstractMap.eq	(	Object	Object	):  Utility method for SimpleEntry and SimpleImmutableEntry. Test for equality, checking for nulls. NB: Do not replace with Object.equals until JDK-8015417 is resolved.
java.util.AbstractMap: java.util.AbstractMap.equals	(	Object	):  Compares the specified object with this map for equality. Returns true if the given object is also a map and the two maps represent the same mappings. More formally, two maps m1 and m2 represent the same mappings if m1.entrySet().equals(m2.entrySet()). This ensures that the equals method works properly across different implementations of the Map interface.
java.util.AbstractMap: java.util.AbstractMap.get	(	Object	):  Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that (key==null ? k==null : key.equals(k)), then this method returns v; otherwise it returns null. (There can be at most one such mapping.) If this map permits null values, then a return value of null does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to null. The containsKey operation may be used to distinguish these two cases.
java.util.AbstractMap: java.util.AbstractMap.hashCode	(	):  Returns the hash code value for this map. The hash code of a map is defined to be the sum of the hash codes of each entry in the map's entrySet() view. This ensures that m1.equals(m2) implies that m1.hashCode()==m2.hashCode() for any two maps m1 and m2, as required by the general contract of hashCode.
java.util.AbstractMap: java.util.AbstractMap.isEmpty	(	):  Returns true if this map contains no key-value mappings.
java.util.AbstractMap: java.util.AbstractMap.keySet	(	):  Returns a Set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.AbstractMap: java.util.AbstractMap.put	(	K	V	):  Associates the specified value with the specified key in this map (optional operation). If the map previously contained a mapping for the key, the old value is replaced by the specified value. (A map m is said to contain a mapping for a key k if and only if containsKey() m.containsKey(k) would return true.)
java.util.AbstractMap: java.util.AbstractMap.putAll	(	Map	):  Copies all of the mappings from the specified map to this map (optional operation). The effect of this call is equivalent to that of calling put() put(k, v) on this map once for each mapping from key k to value v in the specified map. The behavior of this operation is undefined if the specified map is modified while the operation is in progress.
java.util.AbstractMap: java.util.AbstractMap.remove	(	Object	):  Removes the mapping for a key from this map if it is present (optional operation). More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. If this map permits null values, then a return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.
java.util.AbstractMap: java.util.AbstractMap.size	(	):  Returns the number of key-value mappings in this map. If the map contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
java.util.AbstractMap: java.util.AbstractMap.toString	(	):  Returns a string representation of this map. The string representation consists of a list of key-value mappings in the order returned by the map's entrySet view's iterator, enclosed in braces ("{}"). Adjacent mappings are separated by the characters ", " (comma and space). Each key-value mapping is rendered as the key followed by an equals sign ("=") followed by the associated value. Keys and values are converted to strings as by valueOf().
java.util.AbstractMap: java.util.AbstractMap.values	(	):  Returns a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.HashSet: java.util.HashSet:  This class implements the Set interface, backed by a hash table (actually a HashMap instance). It makes no guarantees as to the iteration order of the set; in particular, it does not guarantee that the order will remain constant over time. This class permits the null element. This class offers constant time performance for the basic operations (add, remove, contains and size), assuming the hash function disperses the elements properly among the buckets. Iterating over this set requires time proportional to the sum of the HashSet instance's size (the number of elements) plus the "capacity" of the backing HashMap instance (the number of buckets). Thus, it's very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important. Note that this implementation is not synchronized. If multiple threads access a hash set concurrently, and at least one of the threads modifies the set, it must be synchronized externally. This is typically accomplished by synchronizing on some object that naturally encapsulates the set. If no such object exists, the set should be "wrapped" using the synchronizedSet Collections.synchronizedSet method. This is best done at creation time, to prevent accidental unsynchronized access to the set: Set s = Collections.synchronizedSet(new HashSet(...)); The iterators returned by this class's iterator method are fail-fast: if the set is modified at any time after the iterator is created, in any way except through the iterator's own remove method, the Iterator throws a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. This class is a member of the  Java Collections Framework.
java.util.HashSet: java.util.HashSet.HashSet	(	):  Constructs a new, empty set; the backing HashMap instance has default initial capacity (16) and load factor (0.75).
java.util.HashSet: java.util.HashSet.HashSet	(	Collection	):  Constructs a new set containing the elements in the specified collection. The HashMap is created with default load factor (0.75) and an initial capacity sufficient to contain the elements in the specified collection.
java.util.HashSet: java.util.HashSet.HashSet	(	int	):  Constructs a new, empty set; the backing HashMap instance has the specified initial capacity and default load factor (0.75).
java.util.HashSet: java.util.HashSet.HashSet	(	int	float	):  Constructs a new, empty set; the backing HashMap instance has the specified initial capacity and the specified load factor.
java.util.HashSet: java.util.HashSet.HashSet	(	int	float	boolean	):  Constructs a new, empty linked hash set. (This package private constructor is only used by LinkedHashSet.) The backing HashMap instance is a LinkedHashMap with the specified initial capacity and the specified load factor.
java.util.HashSet: java.util.HashSet.add	(	E	):  Adds the specified element to this set if it is not already present. More formally, adds the specified element e to this set if this set contains no element e2 such that (e==null ? e2==null : e.equals(e2)). If this set already contains the element, the call leaves the set unchanged and returns false.
java.util.HashSet: java.util.HashSet.clear	(	):  Removes all of the elements from this set. The set will be empty after this call returns.
java.util.HashSet: java.util.HashSet.clone	(	):  Returns a shallow copy of this HashSet instance: the elements themselves are not cloned.
java.util.HashSet: java.util.HashSet.contains	(	Object	):  Returns true if this set contains the specified element. More formally, returns true if and only if this set contains an element e such that (o==null ? e==null : o.equals(e)).
java.util.HashSet: java.util.HashSet.isEmpty	(	):  Returns true if this set contains no elements.
java.util.HashSet: java.util.HashSet.iterator	(	):  Returns an iterator over the elements in this set. The elements are returned in no particular order.
java.util.HashSet: java.util.HashSet.readObject	(	java.io.ObjectInputStream	):  Reconstitute the HashSet instance from a stream (that is, deserialize it).
java.util.HashSet: java.util.HashSet.remove	(	Object	):  Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)
java.util.HashSet: java.util.HashSet.size	(	):  Returns the number of elements in this set (its cardinality).
java.util.HashSet: java.util.HashSet.spliterator	(	):  Creates a late-binding and fail-fast Spliterator over the elements in this set. The Spliterator reports SIZED and DISTINCT. Overriding implementations should document the reporting of additional characteristic values.
java.util.HashSet: java.util.HashSet.writeObject	(	java.io.ObjectOutputStream	):  Save the state of this HashSet instance to a stream (that is, serialize it).
java.util.TreeSet: java.util.TreeSet:  A NavigableSet implementation based on a TreeMap. The elements are ordered using their Comparable natural ordering, or by a Comparator provided at set creation time, depending on which constructor is used. This implementation provides guaranteed log(n) time cost for the basic operations (add, remove and contains). Note that the ordering maintained by a set (whether or not an explicit comparator is provided) must be consistent with equals if it is to correctly implement the Set interface. (See Comparable or Comparator for a precise definition of consistent with equals.) This is so because the Set interface is defined in terms of the equals operation, but a TreeSet instance performs all element comparisons using its compareTo (or compare) method, so two elements that are deemed equal by this method are, from the standpoint of the set, equal. The behavior of a set is well-defined even if its ordering is inconsistent with equals; it just fails to obey the general contract of the Set interface. Note that this implementation is not synchronized. If multiple threads access a tree set concurrently, and at least one of the threads modifies the set, it must be synchronized externally. This is typically accomplished by synchronizing on some object that naturally encapsulates the set. If no such object exists, the set should be "wrapped" using the synchronizedSortedSet Collections.synchronizedSortedSet method. This is best done at creation time, to prevent accidental unsynchronized access to the set:  SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...)); The iterators returned by this class's iterator method are fail-fast: if the set is modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. This class is a member of the  Java Collections Framework.
java.util.TreeSet: java.util.TreeSet.TreeSet	(	):  Constructs a new, empty tree set, sorted according to the natural ordering of its elements. All elements inserted into the set must implement the Comparable interface. Furthermore, all such elements must be mutually comparable: e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the set. If the user attempts to add an element to the set that violates this constraint (for example, the user attempts to add a string element to a set whose elements are integers), the add call will throw a ClassCastException.
java.util.TreeSet: java.util.TreeSet.TreeSet	(	Collection	):  Constructs a new tree set containing the elements in the specified collection, sorted according to the natural ordering of its elements. All elements inserted into the set must implement the Comparable interface. Furthermore, all such elements must be mutually comparable: e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the set.
java.util.TreeSet: java.util.TreeSet.TreeSet	(	Comparator	):  Constructs a new, empty tree set, sorted according to the specified comparator. All elements inserted into the set must be mutually comparable by the specified comparator: comparator.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the set. If the user attempts to add an element to the set that violates this constraint, the add call will throw a ClassCastException.
java.util.TreeSet: java.util.TreeSet.TreeSet	(	NavigableMap	):  Constructs a set backed by the specified navigable map.
java.util.TreeSet: java.util.TreeSet.TreeSet	(	SortedSet	):  Constructs a new tree set containing the same elements and using the same ordering as the specified sorted set.
java.util.TreeSet: java.util.TreeSet.add	(	E	):  Adds the specified element to this set if it is not already present. More formally, adds the specified element e to this set if the set contains no element e2 such that (e==null ? e2==null : e.equals(e2)). If this set already contains the element, the call leaves the set unchanged and returns false.
java.util.TreeSet: java.util.TreeSet.addAll	(	Collection	):  Adds all of the elements in the specified collection to this set.
java.util.TreeSet: java.util.TreeSet.ceiling	(	E	):  Returns the least element in this set greater than or equal to the given element, or null if there is no such element.
java.util.TreeSet: java.util.TreeSet.clear	(	):  Removes all of the elements from this set. The set will be empty after this call returns.
java.util.TreeSet: java.util.TreeSet.clone	(	):  Returns a shallow copy of this TreeSet instance. (The elements themselves are not cloned.)
java.util.TreeSet: java.util.TreeSet.contains	(	Object	):  Returns true if this set contains the specified element. More formally, returns true if and only if this set contains an element e such that (o==null ? e==null : o.equals(e)).
java.util.TreeSet: java.util.TreeSet.descendingIterator	(	):  Returns an iterator over the elements in this set in descending order.
java.util.TreeSet: java.util.TreeSet.descendingSet	(	):  Returns a reverse order view of the elements contained in this set. The descending set is backed by this set, so changes to the set are reflected in the descending set, and vice-versa. If either set is modified while an iteration over either set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The returned set has an ordering equivalent to reverseOrder() Collections.reverseOrder(comparator()). The expression s.descendingSet().descendingSet() returns a view of s essentially equivalent to s.
java.util.TreeSet: java.util.TreeSet.first	(	):  Returns the first (lowest) element currently in this set.
java.util.TreeSet: java.util.TreeSet.floor	(	E	):  Returns the greatest element in this set less than or equal to the given element, or null if there is no such element.
java.util.TreeSet: java.util.TreeSet.headSet	(	E	):  Returns a view of the portion of this set whose elements are strictly less than toElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range. Equivalent to headSet(toElement, false).
java.util.TreeSet: java.util.TreeSet.headSet	(	E	boolean	):  Returns a view of the portion of this set whose elements are less than (or equal to, if inclusive is true) toElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range.
java.util.TreeSet: java.util.TreeSet.higher	(	E	):  Returns the least element in this set strictly greater than the given element, or null if there is no such element.
java.util.TreeSet: java.util.TreeSet.isEmpty	(	):  Returns true if this set contains no elements.
java.util.TreeSet: java.util.TreeSet.iterator	(	):  Returns an iterator over the elements in this set in ascending order.
java.util.TreeSet: java.util.TreeSet.last	(	):  Returns the last (highest) element currently in this set.
java.util.TreeSet: java.util.TreeSet.lower	(	E	):  Returns the greatest element in this set strictly less than the given element, or null if there is no such element.
java.util.TreeSet: java.util.TreeSet.pollFirst	(	):  Retrieves and removes the first (lowest) element, or returns null if this set is empty.
java.util.TreeSet: java.util.TreeSet.pollLast	(	):  Retrieves and removes the last (highest) element, or returns null if this set is empty.
java.util.TreeSet: java.util.TreeSet.readObject	(	java.io.ObjectInputStream	):  Reconstitute the TreeSet instance from a stream (that is, deserialize it).
java.util.TreeSet: java.util.TreeSet.remove	(	Object	):  Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)
java.util.TreeSet: java.util.TreeSet.size	(	):  Returns the number of elements in this set (its cardinality).
java.util.TreeSet: java.util.TreeSet.spliterator	(	):  Creates a late-binding and fail-fast Spliterator over the elements in this set. The Spliterator reports SIZED, DISTINCT, SORTED, and ORDERED. Overriding implementations should document the reporting of additional characteristic values. The spliterator's comparator (see getComparator()) is null if the tree set's comparator (see comparator()) is null. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the tree set's comparator.
java.util.TreeSet: java.util.TreeSet.subSet	(	E	E	):  Returns a view of the portion of this set whose elements range from fromElement, inclusive, to toElement, exclusive. (If fromElement and toElement are equal, the returned set is empty.) The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range. Equivalent to subSet(fromElement, true, toElement, false).
java.util.TreeSet: java.util.TreeSet.subSet	(	E	boolean	E	boolean	):  Returns a view of the portion of this set whose elements range from fromElement to toElement. If fromElement and toElement are equal, the returned set is empty unless fromInclusive and toInclusive are both true. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range.
java.util.TreeSet: java.util.TreeSet.tailSet	(	E	):  Returns a view of the portion of this set whose elements are greater than or equal to fromElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range. Equivalent to tailSet(fromElement, true).
java.util.TreeSet: java.util.TreeSet.tailSet	(	E	boolean	):  Returns a view of the portion of this set whose elements are greater than (or equal to, if inclusive is true) fromElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range.
java.util.TreeSet: java.util.TreeSet.writeObject	(	java.io.ObjectOutputStream	):  Save the state of the TreeSet instance to a stream (that is, serialize it).
java.util.TreeMap: java.util.TreeMap:  A Red-Black tree based NavigableMap implementation. The map is sorted according to the Comparable natural ordering of its keys, or by a Comparator provided at map creation time, depending on which constructor is used. This implementation provides guaranteed log(n) time cost for the containsKey, get, put and remove operations. Algorithms are adaptations of those in Cormen, Leiserson, and Rivest's Introduction to Algorithms. Note that the ordering maintained by a tree map, like any sorted map, and whether or not an explicit comparator is provided, must be consistent with equals if this sorted map is to correctly implement the Map interface. (See Comparable or Comparator for a precise definition of consistent with equals.) This is so because the Map interface is defined in terms of the equals operation, but a sorted map performs all key comparisons using its compareTo (or compare) method, so two keys that are deemed equal by this method are, from the standpoint of the sorted map, equal. The behavior of a sorted map is well-defined even if its ordering is inconsistent with equals; it just fails to obey the general contract of the Map interface. Note that this implementation is not synchronized. If multiple threads access a map concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more mappings; merely changing the value associated with an existing key is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the map. If no such object exists, the map should be "wrapped" using the synchronizedSortedMap Collections.synchronizedSortedMap method. This is best done at creation time, to prevent accidental unsynchronized access to the map:  SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...)); The iterators returned by the iterator method of the collections returned by all of this class's "collection view methods" are fail-fast: if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. All Map.Entry pairs returned by methods in this class and its views represent snapshots of mappings at the time they were produced. They do not support the Entry.setValue method. (Note however that it is possible to change mappings in the associated map using put.) This class is a member of the  Java Collections Framework.
java.util.TreeMap: java.util.TreeMap.Entry:  Node in the Tree. Doubles as a means to pass key-value pairs back to user (see Map.Entry).
java.util.TreeMap: java.util.TreeMap.Entry.Entry	(	K	V	Entry	):  Make a new cell with given key, value, and parent, and with null child links, and BLACK color.
java.util.TreeMap: java.util.TreeMap.Entry.getKey	(	):  Returns the key.
java.util.TreeMap: java.util.TreeMap.Entry.getValue	(	):  Returns the value associated with the key.
java.util.TreeMap: java.util.TreeMap.Entry.setValue	(	V	):  Replaces the value currently associated with the key with the given value.
java.util.TreeMap: java.util.TreeMap.NavigableSubMap.SubMapIterator:  Iterators for SubMaps
java.util.TreeMap: java.util.TreeMap.NavigableSubMap.absHighFence	(	):  Returns the absolute high fence for ascending traversal 
java.util.TreeMap: java.util.TreeMap.NavigableSubMap.absLowFence	(	):  Return the absolute low fence for descending traversal 
java.util.TreeMap: java.util.TreeMap.NavigableSubMap.descendingKeyIterator	(	):  Returns descending iterator from the perspective of this submap 
java.util.TreeMap: java.util.TreeMap.NavigableSubMap.keyIterator	(	):  Returns ascending iterator from the perspective of this submap 
java.util.TreeMap: java.util.TreeMap.PrivateEntryIterator:  Base class for TreeMap Iterators
java.util.TreeMap: java.util.TreeMap.SubMap:  This class exists solely for the sake of serialization compatibility with previous releases of TreeMap that did not support NavigableMap. It translates an old-version SubMap into a new-version AscendingSubMap. This class is never otherwise used.
java.util.TreeMap: java.util.TreeMap.TreeMap	(	):  Constructs a new, empty tree map, using the natural ordering of its keys. All keys inserted into the map must implement the Comparable interface. Furthermore, all such keys must be mutually comparable: k1.compareTo(k2) must not throw a ClassCastException for any keys k1 and k2 in the map. If the user attempts to put a key into the map that violates this constraint (for example, the user attempts to put a string key into a map whose keys are integers), the put(Object key, Object value) call will throw a ClassCastException.
java.util.TreeMap: java.util.TreeMap.TreeMap	(	Comparator	):  Constructs a new, empty tree map, ordered according to the given comparator. All keys inserted into the map must be mutually comparable by the given comparator: comparator.compare(k1, k2) must not throw a ClassCastException for any keys k1 and k2 in the map. If the user attempts to put a key into the map that violates this constraint, the put(Object key, Object value) call will throw a ClassCastException.
java.util.TreeMap: java.util.TreeMap.TreeMap	(	Map	):  Constructs a new tree map containing the same mappings as the given map, ordered according to the natural ordering of its keys. All keys inserted into the new map must implement the Comparable interface. Furthermore, all such keys must be mutually comparable: k1.compareTo(k2) must not throw a ClassCastException for any keys k1 and k2 in the map. This method runs in n*log(n) time.
java.util.TreeMap: java.util.TreeMap.TreeMap	(	SortedMap	):  Constructs a new tree map containing the same mappings and using the same ordering as the specified sorted map. This method runs in linear time.
java.util.TreeMap: java.util.TreeMap.TreeMapSpliterator:  Base class for spliterators. Iteration starts at a given origin and continues up to but not including a given fence (or null for end). At top-level, for ascending cases, the first split uses the root as left-fence/right-origin. From there, right-hand splits replace the current fence with its left child, also serving as origin for the split-off spliterator. Left-hands are symmetric. Descending versions place the origin at the end and invert ascending split rules. This base class is non-commital about directionality, or whether the top-level spliterator covers the whole tree. This means that the actual split mechanics are located in subclasses. Some of the subclass trySplit methods are identical (except for return types), but not nicely factorable. Currently, subclass versions exist only for the full map (including descending keys via its descendingMap). Others are possible but currently not worthwhile because submaps require O(n) computations to determine size, which substantially limits potential speed-ups of using custom Spliterators versus default mechanics. To boostrap initialization, external constructors use negative size estimates: -1 for ascend, -2 for descend.
java.util.TreeMap: java.util.TreeMap.addAllForTreeSet	(	SortedSet	V	):  Intended to be called only from TreeSet.addAll 
java.util.TreeMap: java.util.TreeMap.buildFromSorted	(	int	Iterator	java.io.ObjectInputStream	V	):  Linear time tree building algorithm from sorted data. Can accept keys and/or values from iterator or stream. This leads to too many parameters, but seems better than alternatives. The four formats that this method accepts are: 1) An iterator of Map.Entries. (it != null, defaultVal == null). 2) An iterator of keys. (it != null, defaultVal != null). 3) A stream of alternating serialized keys and values. (it == null, defaultVal == null). 4) A stream of serialized keys. (it == null, defaultVal != null). It is assumed that the comparator of the TreeMap is already set prior to calling this method.
java.util.TreeMap: java.util.TreeMap.buildFromSorted	(	int	int	int	int	Iterator	java.io.ObjectInputStream	V	):  Recursive "helper method" that does the real work of the previous method. Identically named parameters have identical definitions. Additional parameters are documented below. It is assumed that the comparator and size fields of the TreeMap are already set prior to calling this method. (It ignores both fields.)
java.util.TreeMap: java.util.TreeMap.ceilingEntry	(	K	):  Returns a key-value mapping associated with the least key greater than or equal to the given key, or null if there is no such key.
java.util.TreeMap: java.util.TreeMap.ceilingKey	(	K	):  Returns the least key greater than or equal to the given key, or null if there is no such key.
java.util.TreeMap: java.util.TreeMap.clear	(	):  Removes all of the mappings from this map. The map will be empty after this call returns.
java.util.TreeMap: java.util.TreeMap.clone	(	):  Returns a shallow copy of this TreeMap instance. (The keys and values themselves are not cloned.)
java.util.TreeMap: java.util.TreeMap.colorOf	(	Entry	):  Balancing operations. Implementations of rebalancings during insertion and deletion are slightly different than the CLR version. Rather than using dummy nilnodes, we use a set of accessors that deal properly with null. They are used to avoid messiness surrounding nullness checks in the main algorithms.
java.util.TreeMap: java.util.TreeMap.compare	(	Object	Object	):  Compares two keys using the correct comparison method for this TreeMap.
java.util.TreeMap: java.util.TreeMap.computeRedLevel	(	int	):  Find the level down to which to assign all nodes BLACK. This is the last `full' level of the complete binary tree produced by buildTree. The remaining nodes are colored RED. (This makes a `nice' set of color assignments wrt future insertions.) This level number is computed by finding the number of splits needed to reach the zeroeth node. (The answer is ~lg(N), but in any case must be computed by same quick O(lg(N)) loop.)
java.util.TreeMap: java.util.TreeMap.containsKey	(	Object	):  Returns true if this map contains a mapping for the specified key.
java.util.TreeMap: java.util.TreeMap.containsValue	(	Object	):  Returns true if this map maps one or more keys to the specified value. More formally, returns true if and only if this map contains at least one mapping to a value v such that (value==null ? v==null : value.equals(v)). This operation will probably require time linear in the map size for most implementations.
java.util.TreeMap: java.util.TreeMap.deleteEntry	(	Entry	):  Delete node p, and then rebalance the tree.
java.util.TreeMap: java.util.TreeMap.descendingKeySet	(	):  Returns a reverse order NavigableSet view of the keys contained in this map. The set's iterator returns the keys in descending order. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.TreeMap: java.util.TreeMap.descendingMap	(	):  Returns a reverse order view of the mappings contained in this map. The descending map is backed by this map, so changes to the map are reflected in the descending map, and vice-versa. If either map is modified while an iteration over a collection view of either map is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The returned map has an ordering equivalent to reverseOrder() Collections.reverseOrder(comparator()). The expression m.descendingMap().descendingMap() returns a view of m essentially equivalent to m.
java.util.TreeMap: java.util.TreeMap.entrySet	(	):  Returns a Set view of the mappings contained in this map. The set's iterator returns the entries in ascending key order. The sets's spliterator is late-binding, fail-fast, and additionally reports SORTED and ORDERED with an encounter order that is ascending key order. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation, or through the setValue operation on a map entry returned by the iterator) the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.TreeMap: java.util.TreeMap.exportEntry	(	TreeMap.Entry	):  Return SimpleImmutableEntry for entry, or null if null
java.util.TreeMap: java.util.TreeMap.firstEntry	(	):  Returns a key-value mapping associated with the least key in this map, or null if the map is empty.
java.util.TreeMap: java.util.TreeMap.firstKey	(	):  Returns the first (lowest) key currently in this map.
java.util.TreeMap: java.util.TreeMap.fixAfterDeletion	(	Entry	):  From CLR 
java.util.TreeMap: java.util.TreeMap.fixAfterInsertion	(	Entry	):  From CLR 
java.util.TreeMap: java.util.TreeMap.floorEntry	(	K	):  Returns a key-value mapping associated with the greatest key less than or equal to the given key, or null if there is no such key.
java.util.TreeMap: java.util.TreeMap.floorKey	(	K	):  Returns the greatest key less than or equal to the given key, or null if there is no such key.
java.util.TreeMap: java.util.TreeMap.get	(	Object	):  Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that key compares equal to k according to the map's ordering, then this method returns v; otherwise it returns null. (There can be at most one such mapping.) A return value of null does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to null. The containsKey operation may be used to distinguish these two cases.
java.util.TreeMap: java.util.TreeMap.getCeilingEntry	(	K	):  Gets the entry corresponding to the specified key; if no such entry exists, returns the entry for the least key greater than the specified key; if no such entry exists (i.e., the greatest key in the Tree is less than the specified key), returns null.
java.util.TreeMap: java.util.TreeMap.getEntry	(	Object	):  Returns this map's entry for the given key, or null if the map does not contain an entry for the key.
java.util.TreeMap: java.util.TreeMap.getEntryUsingComparator	(	Object	):  Version of getEntry using comparator. Split off from getEntry for performance. (This is not worth doing for most methods, that are less dependent on comparator performance, but is worthwhile here.)
java.util.TreeMap: java.util.TreeMap.getFirstEntry	(	):  Returns the first Entry in the TreeMap (according to the TreeMap's key-sort function). Returns null if the TreeMap is empty.
java.util.TreeMap: java.util.TreeMap.getFloorEntry	(	K	):  Gets the entry corresponding to the specified key; if no such entry exists, returns the entry for the greatest key less than the specified key; if no such entry exists, returns null.
java.util.TreeMap: java.util.TreeMap.getHigherEntry	(	K	):  Gets the entry for the least key greater than the specified key; if no such entry exists, returns the entry for the least key greater than the specified key; if no such entry exists returns null.
java.util.TreeMap: java.util.TreeMap.getLastEntry	(	):  Returns the last Entry in the TreeMap (according to the TreeMap's key-sort function). Returns null if the TreeMap is empty.
java.util.TreeMap: java.util.TreeMap.getLowerEntry	(	K	):  Returns the entry for the greatest key less than the specified key; if no such entry exists (i.e., the least key in the Tree is greater than the specified key), returns null.
java.util.TreeMap: java.util.TreeMap.headMap	(	K	):  Returns a view of the portion of this map whose keys are strictly less than toKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range. Equivalent to headMap(toKey, false).
java.util.TreeMap: java.util.TreeMap.headMap	(	K	boolean	):  Returns a view of the portion of this map whose keys are less than (or equal to, if inclusive is true) toKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range.
java.util.TreeMap: java.util.TreeMap.higherEntry	(	K	):  Returns a key-value mapping associated with the least key strictly greater than the given key, or null if there is no such key.
java.util.TreeMap: java.util.TreeMap.higherKey	(	K	):  Returns the least key strictly greater than the given key, or null if there is no such key.
java.util.TreeMap: java.util.TreeMap.key	(	Entry	):  Returns the key corresponding to the specified Entry.
java.util.TreeMap: java.util.TreeMap.keyOrNull	(	TreeMap.Entry	):  Return key for entry, or null if null
java.util.TreeMap: java.util.TreeMap.keySet	(	):  Returns a Set view of the keys contained in this map. The set's iterator returns the keys in ascending order. The set's spliterator is late-binding, fail-fast, and additionally reports SORTED and ORDERED with an encounter order that is ascending key order. The spliterator's comparator (see getComparator()) is null if the tree map's comparator (see comparator()) is null. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the tree map's comparator. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.TreeMap: java.util.TreeMap.keySpliteratorFor	(	NavigableMap	):  Currently, we support Spliterator-based versions only for the full map, in either plain of descending form, otherwise relying on defaults because size estimation for submaps would dominate costs. The type tests needed to check these for key views are not very nice but avoid disrupting existing class structures. Callers must use plain default spliterators if this returns null.
java.util.TreeMap: java.util.TreeMap.lastEntry	(	):  Returns a key-value mapping associated with the greatest key in this map, or null if the map is empty.
java.util.TreeMap: java.util.TreeMap.lastKey	(	):  Returns the last (highest) key currently in this map.
java.util.TreeMap: java.util.TreeMap.lowerEntry	(	K	):  Returns a key-value mapping associated with the greatest key strictly less than the given key, or null if there is no such key.
java.util.TreeMap: java.util.TreeMap.lowerKey	(	K	):  Returns the greatest key strictly less than the given key, or null if there is no such key.
java.util.TreeMap: java.util.TreeMap.navigableKeySet	(	):  Returns a NavigableSet view of the keys contained in this map. The set's iterator returns the keys in ascending order. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.TreeMap: java.util.TreeMap.pollFirstEntry	(	):  Removes and returns a key-value mapping associated with the least key in this map, or null if the map is empty.
java.util.TreeMap: java.util.TreeMap.pollLastEntry	(	):  Removes and returns a key-value mapping associated with the greatest key in this map, or null if the map is empty.
java.util.TreeMap: java.util.TreeMap.predecessor	(	Entry	):  Returns the predecessor of the specified Entry, or null if no such.
java.util.TreeMap: java.util.TreeMap.put	(	K	V	):  Associates the specified value with the specified key in this map. If the map previously contained a mapping for the key, the old value is replaced.
java.util.TreeMap: java.util.TreeMap.putAll	(	Map	):  Copies all of the mappings from the specified map to this map. These mappings replace any mappings that this map had for any of the keys currently in the specified map.
java.util.TreeMap: java.util.TreeMap.readObject	(	java.io.ObjectInputStream	):  Reconstitute the TreeMap instance from a stream (i.e., deserialize it).
java.util.TreeMap: java.util.TreeMap.readTreeSet	(	int	java.io.ObjectInputStream	V	):  Intended to be called only from TreeSet.readObject 
java.util.TreeMap: java.util.TreeMap.remove	(	Object	):  Removes the mapping for this key from this TreeMap if present.
java.util.TreeMap: java.util.TreeMap.rotateLeft	(	Entry	):  From CLR 
java.util.TreeMap: java.util.TreeMap.rotateRight	(	Entry	):  From CLR 
java.util.TreeMap: java.util.TreeMap.size	(	):  Returns the number of key-value mappings in this map.
java.util.TreeMap: java.util.TreeMap.subMap	(	K	K	):  Returns a view of the portion of this map whose keys range from fromKey, inclusive, to toKey, exclusive. (If fromKey and toKey are equal, the returned map is empty.) The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range. Equivalent to subMap(fromKey, true, toKey, false).
java.util.TreeMap: java.util.TreeMap.subMap	(	K	boolean	K	boolean	):  Returns a view of the portion of this map whose keys range from fromKey to toKey. If fromKey and toKey are equal, the returned map is empty unless fromInclusive and toInclusive are both true. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside of its range, or to construct a submap either of whose endpoints lie outside its range.
java.util.TreeMap: java.util.TreeMap.successor	(	Entry	):  Returns the successor of the specified Entry, or null if no such.
java.util.TreeMap: java.util.TreeMap.tailMap	(	K	):  Returns a view of the portion of this map whose keys are greater than or equal to fromKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range. Equivalent to tailMap(fromKey, true).
java.util.TreeMap: java.util.TreeMap.tailMap	(	K	boolean	):  Returns a view of the portion of this map whose keys are greater than (or equal to, if inclusive is true) fromKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range.
java.util.TreeMap: java.util.TreeMap.valEquals	(	Object	Object	):  Test two values for equality. Differs from o1.equals(o2) only in that it copes with null o1 properly.
java.util.TreeMap: java.util.TreeMap.values	(	):  Returns a Collection view of the values contained in this map. The collection's iterator returns the values in ascending order of the corresponding keys. The collection's spliterator is late-binding, fail-fast, and additionally reports ORDERED with an encounter order that is ascending order of the corresponding keys. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.TreeMap: java.util.TreeMap.writeObject	(	java.io.ObjectOutputStream	):  Save the state of the TreeMap instance to a stream (i.e., serialize it).
java.util.Vector: java.util.Vector:  The Vector class implements a growable array of objects. Like an array, it contains components that can be accessed using an integer index. However, the size of a Vector can grow or shrink as needed to accommodate adding and removing items after the Vector has been created. Each vector tries to optimize storage management by maintaining a capacity and a capacityIncrement. The capacity is always at least as large as the vector size; it is usually larger because as components are added to the vector, the vector's storage increases in chunks the size of capacityIncrement. An application can increase the capacity of a vector before inserting a large number of components; this reduces the amount of incremental reallocation.  The iterators returned by this class's iterator() and listIterator() methods are fail-fast: if the vector is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove() or add() methods, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. The Enumeration Enumerations returned by the elements() method are not fail-fast. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. As of the Java 2 platform v1.2, this class was retrofitted to implement the List interface, making it a member of the  Java Collections Framework. Unlike the new collection implementations, Vector is synchronized. If a thread-safe implementation is not needed, it is recommended to use ArrayList in place of Vector.
java.util.Vector: java.util.Vector.Itr:  An optimized version of AbstractList.Itr
java.util.Vector: java.util.Vector.ListItr:  An optimized version of AbstractList.ListItr
java.util.Vector: java.util.Vector.Vector	(	):  Constructs an empty vector so that its internal data array has size 10 and its standard capacity increment is zero.
java.util.Vector: java.util.Vector.Vector	(	Collection	):  Constructs a vector containing the elements of the specified collection, in the order they are returned by the collection's iterator.
java.util.Vector: java.util.Vector.Vector	(	int	):  Constructs an empty vector with the specified initial capacity and with its capacity increment equal to zero.
java.util.Vector: java.util.Vector.Vector	(	int	int	):  Constructs an empty vector with the specified initial capacity and capacity increment.
java.util.Vector: java.util.Vector.VectorSpliterator:  Similar to ArrayList Spliterator 
java.util.Vector: java.util.Vector.VectorSpliterator.VectorSpliterator	(	Vector	Object[]	int	int	int	):  Create new spliterator covering the given range 
java.util.Vector: java.util.Vector.add	(	E	):  Appends the specified element to the end of this Vector.
java.util.Vector: java.util.Vector.add	(	int	E	):  Inserts the specified element at the specified position in this Vector. Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices).
java.util.Vector: java.util.Vector.addAll	(	Collection	):  Appends all of the elements in the specified Collection to the end of this Vector, in the order that they are returned by the specified Collection's Iterator. The behavior of this operation is undefined if the specified Collection is modified while the operation is in progress. (This implies that the behavior of this call is undefined if the specified Collection is this Vector, and this Vector is nonempty.)
java.util.Vector: java.util.Vector.addAll	(	int	Collection	):  Inserts all of the elements in the specified Collection into this Vector at the specified position. Shifts the element currently at that position (if any) and any subsequent elements to the right (increases their indices). The new elements will appear in the Vector in the order that they are returned by the specified Collection's iterator.
java.util.Vector: java.util.Vector.addElement	(	E	):  Adds the specified component to the end of this vector, increasing its size by one. The capacity of this vector is increased if its size becomes greater than its capacity. This method is identical in functionality to the add() add(E) method (which is part of the List interface).
java.util.Vector: java.util.Vector.capacity	(	):  Returns the current capacity of this vector.
java.util.Vector: java.util.Vector.clear	(	):  Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).
java.util.Vector: java.util.Vector.clone	(	):  Returns a clone of this vector. The copy will contain a reference to a clone of the internal data array, not a reference to the original internal data array of this Vector object.
java.util.Vector: java.util.Vector.contains	(	Object	):  Returns true if this vector contains the specified element. More formally, returns true if and only if this vector contains at least one element e such that (o==null ? e==null : o.equals(e)).
java.util.Vector: java.util.Vector.containsAll	(	Collection	):  Returns true if this Vector contains all of the elements in the specified Collection.
java.util.Vector: java.util.Vector.copyInto	(	Object[]	):  Copies the components of this vector into the specified array. The item at index k in this vector is copied into component k of anArray.
java.util.Vector: java.util.Vector.elementAt	(	int	):  Returns the component at the specified index. This method is identical in functionality to the get() method (which is part of the List interface).
java.util.Vector: java.util.Vector.elements	(	):  Returns an enumeration of the components of this vector. The returned Enumeration object will generate all items in this vector. The first item generated is the item at index 0, then the item at index 1, and so on.
java.util.Vector: java.util.Vector.ensureCapacity	(	int	):  Increases the capacity of this vector, if necessary, to ensure that it can hold at least the number of components specified by the minimum capacity argument. If the current capacity of this vector is less than minCapacity, then its capacity is increased by replacing its internal data array, kept in the field elementData, with a larger one. The size of the new data array will be the old size plus capacityIncrement, unless the value of capacityIncrement is less than or equal to zero, in which case the new capacity will be twice the old capacity; but if this new size is still smaller than minCapacity, then the new capacity will be minCapacity.
java.util.Vector: java.util.Vector.ensureCapacityHelper	(	int	):  This implements the unsynchronized semantics of ensureCapacity. Synchronized methods in this class can internally call this method for ensuring capacity without incurring the cost of an extra synchronization.
java.util.Vector: java.util.Vector.equals	(	Object	):  Compares the specified Object with this Vector for equality. Returns true if and only if the specified Object is also a List, both Lists have the same size, and all corresponding pairs of elements in the two Lists are equal. (Two elements e1 and e2 are equal if (e1==null ? e2==null : e1.equals(e2)).) In other words, two Lists are defined to be equal if they contain the same elements in the same order.
java.util.Vector: java.util.Vector.firstElement	(	):  Returns the first component (the item at index 0) of this vector.
java.util.Vector: java.util.Vector.get	(	int	):  Returns the element at the specified position in this Vector.
java.util.Vector: java.util.Vector.hashCode	(	):  Returns the hash code value for this Vector.
java.util.Vector: java.util.Vector.indexOf	(	Object	):  Returns the index of the first occurrence of the specified element in this vector, or -1 if this vector does not contain the element. More formally, returns the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.
java.util.Vector: java.util.Vector.indexOf	(	Object	int	):  Returns the index of the first occurrence of the specified element in this vector, searching forwards from index, or returns -1 if the element is not found. More formally, returns the lowest index i such that (i >= index && (o==null ? get(i)==null : o.equals(get(i)))), or -1 if there is no such index.
java.util.Vector: java.util.Vector.insertElementAt	(	E	int	):  Inserts the specified object as a component in this vector at the specified index. Each component in this vector with an index greater or equal to the specified index is shifted upward to have an index one greater than the value it had previously. The index must be a value greater than or equal to 0 and less than or equal to the current size of the vector. (If the index is equal to the current size of the vector, the new element is appended to the Vector.) This method is identical in functionality to the add() add(int, E) method (which is part of the List interface). Note that the add method reverses the order of the parameters, to more closely match array usage.
java.util.Vector: java.util.Vector.isEmpty	(	):  Tests if this vector has no components.
java.util.Vector: java.util.Vector.iterator	(	):  Returns an iterator over the elements in this list in proper sequence. The returned iterator is fail-fast.
java.util.Vector: java.util.Vector.lastElement	(	):  Returns the last component of the vector.
java.util.Vector: java.util.Vector.lastIndexOf	(	Object	):  Returns the index of the last occurrence of the specified element in this vector, or -1 if this vector does not contain the element. More formally, returns the highest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.
java.util.Vector: java.util.Vector.lastIndexOf	(	Object	int	):  Returns the index of the last occurrence of the specified element in this vector, searching backwards from index, or returns -1 if the element is not found. More formally, returns the highest index i such that (i <= index && (o==null ? get(i)==null : o.equals(get(i)))), or -1 if there is no such index.
java.util.Vector: java.util.Vector.listIterator	(	):  Returns a list iterator over the elements in this list (in proper sequence). The returned list iterator is fail-fast.
java.util.Vector: java.util.Vector.listIterator	(	int	):  Returns a list iterator over the elements in this list (in proper sequence), starting at the specified position in the list. The specified index indicates the first element that would be returned by an initial call to next. An initial call to previous would return the element with the specified index minus one. The returned list iterator is fail-fast.
java.util.Vector: java.util.Vector.remove	(	Object	):  Removes the first occurrence of the specified element in this Vector If the Vector does not contain the element, it is unchanged. More formally, removes the element with the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))) (if such an element exists).
java.util.Vector: java.util.Vector.remove	(	int	):  Removes the element at the specified position in this Vector. Shifts any subsequent elements to the left (subtracts one from their indices). Returns the element that was removed from the Vector.
java.util.Vector: java.util.Vector.removeAll	(	Collection	):  Removes from this Vector all of its elements that are contained in the specified Collection.
java.util.Vector: java.util.Vector.removeAllElements	(	):  Removes all components from this vector and sets its size to zero. This method is identical in functionality to the clear method (which is part of the List interface).
java.util.Vector: java.util.Vector.removeElement	(	Object	):  Removes the first (lowest-indexed) occurrence of the argument from this vector. If the object is found in this vector, each component in the vector with an index greater or equal to the object's index is shifted downward to have an index one smaller than the value it had previously. This method is identical in functionality to the remove() method (which is part of the List interface).
java.util.Vector: java.util.Vector.removeElementAt	(	int	):  Deletes the component at the specified index. Each component in this vector with an index greater or equal to the specified index is shifted downward to have an index one smaller than the value it had previously. The size of this vector is decreased by 1. The index must be a value greater than or equal to 0 and less than the current size of the vector. This method is identical in functionality to the remove() method (which is part of the List interface). Note that the remove method returns the old value that was stored at the specified position.
java.util.Vector: java.util.Vector.removeRange	(	int	int	):  Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive. Shifts any succeeding elements to the left (reduces their index). This call shortens the list by (toIndex - fromIndex) elements. (If toIndex==fromIndex, this operation has no effect.)
java.util.Vector: java.util.Vector.retainAll	(	Collection	):  Retains only the elements in this Vector that are contained in the specified Collection. In other words, removes from this Vector all of its elements that are not contained in the specified Collection.
java.util.Vector: java.util.Vector.set	(	int	E	):  Replaces the element at the specified position in this Vector with the specified element.
java.util.Vector: java.util.Vector.setElementAt	(	E	int	):  Sets the component at the specified index of this vector to be the specified object. The previous component at that position is discarded. The index must be a value greater than or equal to 0 and less than the current size of the vector. This method is identical in functionality to the set() set(int, E) method (which is part of the List interface). Note that the set method reverses the order of the parameters, to more closely match array usage. Note also that the set method returns the old value that was stored at the specified position.
java.util.Vector: java.util.Vector.setSize	(	int	):  Sets the size of this vector. If the new size is greater than the current size, new null items are added to the end of the vector. If the new size is less than the current size, all components at index newSize and greater are discarded.
java.util.Vector: java.util.Vector.size	(	):  Returns the number of components in this vector.
java.util.Vector: java.util.Vector.spliterator	(	):  Creates a late-binding and fail-fast Spliterator over the elements in this list. The Spliterator reports SIZED, SUBSIZED, and ORDERED. Overriding implementations should document the reporting of additional characteristic values.
java.util.Vector: java.util.Vector.subList	(	int	int	):  Returns a view of the portion of this List between fromIndex, inclusive, and toIndex, exclusive. (If fromIndex and toIndex are equal, the returned List is empty.) The returned List is backed by this List, so changes in the returned List are reflected in this List, and vice-versa. The returned List supports all of the optional List operations supported by this List. This method eliminates the need for explicit range operations (of the sort that commonly exist for arrays). Any operation that expects a List can be used as a range operation by operating on a subList view instead of a whole List. For example, the following idiom removes a range of elements from a List:  list.subList(from, to).clear();  Similar idioms may be constructed for indexOf and lastIndexOf, and all of the algorithms in the Collections class can be applied to a subList. The semantics of the List returned by this method become undefined if the backing list (i.e., this List) is structurally modified in any way other than via the returned List. (Structural modifications are those that change the size of the List, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.)
java.util.Vector: java.util.Vector.toArray	(	):  Returns an array containing all of the elements in this Vector in the correct order.
java.util.Vector: java.util.Vector.toArray	(	T[]	):  Returns an array containing all of the elements in this Vector in the correct order; the runtime type of the returned array is that of the specified array. If the Vector fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this Vector. If the Vector fits in the specified array with room to spare (i.e., the array has more elements than the Vector), the element in the array immediately following the end of the Vector is set to null. (This is useful in determining the length of the Vector only if the caller knows that the Vector does not contain any null elements.)
java.util.Vector: java.util.Vector.toString	(	):  Returns a string representation of this Vector, containing the String representation of each element.
java.util.Vector: java.util.Vector.trimToSize	(	):  Trims the capacity of this vector to be the vector's current size. If the capacity of this vector is larger than its current size, then the capacity is changed to equal the size by replacing its internal data array, kept in the field elementData, with a smaller one. An application can use this operation to minimize the storage of a vector.
java.util.Vector: java.util.Vector.writeObject	(	java.io.ObjectOutputStream	):  Save the state of the Vector instance to a stream (that is, serialize it). This method performs synchronization to ensure the consistency of the serialized data.
java.util.Hashtable: java.util.Hashtable:  This class implements a hash table, which maps keys to values. Any non-null object can be used as a key or as a value.  To successfully store and retrieve objects from a hashtable, the objects used as keys must implement the hashCode method and the equals method.  An instance of Hashtable has two parameters that affect its performance: initial capacity and load factor. The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. Note that the hash table is open: in the case of a "hash collision", a single bucket stores multiple entries, which must be searched sequentially. The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased. The initial capacity and load factor parameters are merely hints to the implementation. The exact details as to when and whether the rehash method is invoked are implementation-dependent. Generally, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the time cost to look up an entry (which is reflected in most Hashtable operations, including get and put). The initial capacity controls a tradeoff between wasted space and the need for rehash operations, which are time-consuming. No rehash operations will ever occur if the initial capacity is greater than the maximum number of entries the Hashtable will contain divided by its load factor. However, setting the initial capacity too high can waste space. If many entries are to be made into a Hashtable, creating it with a sufficiently large capacity may allow the entries to be inserted more efficiently than letting it perform automatic rehashing as needed to grow the table.  This example creates a hashtable of numbers. It uses the names of the numbers as keys:  Hashtable numbers = new Hashtable(); numbers.put("one", 1); numbers.put("two", 2); numbers.put("three", 3); To retrieve a number, use the following code:  Integer n = numbers.get("two"); if (n != null) System.out.println("two = " + n); }} The iterators returned by the iterator method of the collections returned by all of this class's "collection view methods" are fail-fast: if the Hashtable is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. The Enumerations returned by Hashtable's keys and elements methods are not fail-fast. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. As of the Java 2 platform v1.2, this class was retrofitted to implement the Map interface, making it a member of the  Java Collections Framework. Unlike the new collection implementations, Hashtable is synchronized. If a thread-safe implementation is not needed, it is recommended to use HashMap in place of Hashtable. If a thread-safe highly-concurrent implementation is desired, then it is recommended to use java.util.concurrent.ConcurrentHashMap in place of Hashtable.
java.util.Hashtable: java.util.Hashtable.Entry:  Hashtable bucket collision list entry
java.util.Hashtable: java.util.Hashtable.Enumerator:  A hashtable enumerator class. This class implements both the Enumeration and Iterator interfaces, but individual instances can be created with the Iterator methods disabled. This is necessary to avoid unintentionally increasing the capabilities granted a user by passing an Enumeration.
java.util.Hashtable: java.util.Hashtable.Hashtable	(	):  Constructs a new, empty hashtable with a default initial capacity (11) and load factor (0.75).
java.util.Hashtable: java.util.Hashtable.Hashtable	(	Map	):  Constructs a new hashtable with the same mappings as the given Map. The hashtable is created with an initial capacity sufficient to hold the mappings in the given Map and a default load factor (0.75).
java.util.Hashtable: java.util.Hashtable.Hashtable	(	int	):  Constructs a new, empty hashtable with the specified initial capacity and default load factor (0.75).
java.util.Hashtable: java.util.Hashtable.Hashtable	(	int	float	):  Constructs a new, empty hashtable with the specified initial capacity and the specified load factor.
java.util.Hashtable: java.util.Hashtable.clear	(	):  Clears this hashtable so that it contains no keys.
java.util.Hashtable: java.util.Hashtable.clone	(	):  Creates a shallow copy of this hashtable. All the structure of the hashtable itself is copied, but the keys and values are not cloned. This is a relatively expensive operation.
java.util.Hashtable: java.util.Hashtable.contains	(	Object	):  Tests if some key maps into the specified value in this hashtable. This operation is more expensive than the containsKey method. Note that this method is identical in functionality to containsValue, (which is part of the Map interface in the collections framework).
java.util.Hashtable: java.util.Hashtable.containsKey	(	Object	):  Tests if the specified object is a key in this hashtable.
java.util.Hashtable: java.util.Hashtable.containsValue	(	Object	):  Returns true if this hashtable maps one or more keys to this value. Note that this method is identical in functionality to contains (which predates the Map interface).
java.util.Hashtable: java.util.Hashtable.elements	(	):  Returns an enumeration of the values in this hashtable. Use the Enumeration methods on the returned object to fetch the elements sequentially.
java.util.Hashtable: java.util.Hashtable.entrySet	(	):  Returns a Set view of the mappings contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation, or through the setValue operation on a map entry returned by the iterator) the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.Hashtable: java.util.Hashtable.equals	(	Object	):  Compares the specified Object with this Map for equality, as per the definition in the Map interface.
java.util.Hashtable: java.util.Hashtable.get	(	Object	):  Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that (key.equals(k)), then this method returns v; otherwise it returns null. (There can be at most one such mapping.)
java.util.Hashtable: java.util.Hashtable.hashCode	(	):  Returns the hash code value for this Map as per the definition in the Map interface.
java.util.Hashtable: java.util.Hashtable.isEmpty	(	):  Tests if this hashtable maps no keys to values.
java.util.Hashtable: java.util.Hashtable.keySet	(	):  Returns a Set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.Hashtable: java.util.Hashtable.keys	(	):  Returns an enumeration of the keys in this hashtable.
java.util.Hashtable: java.util.Hashtable.put	(	K	V	):  Maps the specified key to the specified value in this hashtable. Neither the key nor the value can be null.  The value can be retrieved by calling the get method with a key that is equal to the original key.
java.util.Hashtable: java.util.Hashtable.putAll	(	Map	):  Copies all of the mappings from the specified map to this hashtable. These mappings will replace any mappings that this hashtable had for any of the keys currently in the specified map.
java.util.Hashtable: java.util.Hashtable.readObject	(	java.io.ObjectInputStream	):  Reconstitute the Hashtable from a stream (i.e., deserialize it).
java.util.Hashtable: java.util.Hashtable.reconstitutionPut	(	Entry[]	K	V	):  The put method used by readObject. This is provided because put is overridable and should not be called in readObject since the subclass will not yet be initialized. This differs from the regular put method in several ways. No checking for rehashing is necessary since the number of elements initially in the table is known. The modCount is not incremented because we are creating a new instance. Also, no return value is needed.
java.util.Hashtable: java.util.Hashtable.rehash	(	):  Increases the capacity of and internally reorganizes this hashtable, in order to accommodate and access its entries more efficiently. This method is called automatically when the number of keys in the hashtable exceeds this hashtable's capacity and load factor.
java.util.Hashtable: java.util.Hashtable.remove	(	Object	):  Removes the key (and its corresponding value) from this hashtable. This method does nothing if the key is not in the hashtable.
java.util.Hashtable: java.util.Hashtable.size	(	):  Returns the number of keys in this hashtable.
java.util.Hashtable: java.util.Hashtable.toString	(	):  Returns a string representation of this Hashtable object in the form of a set of entries, enclosed in braces and separated by the ASCII characters ", " (comma and space). Each entry is rendered as the key, an equals sign =, and the associated element, where the toString method is used to convert the key and element to strings.
java.util.Hashtable: java.util.Hashtable.values	(	):  Returns a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.Hashtable: java.util.Hashtable.writeObject	(	java.io.ObjectOutputStream	):  Save the state of the Hashtable to a stream (i.e., serialize it).
java.util.ConcurrentModificationException: java.util.ConcurrentModificationException:  This exception may be thrown by methods that have detected concurrent modification of an object when such modification is not permissible.  For example, it is not generally permissible for one thread to modify a Collection while another thread is iterating over it. In general, the results of the iteration are undefined under these circumstances. Some Iterator implementations (including those of all the general purpose collection implementations provided by the JRE) may choose to throw this exception if this behavior is detected. Iterators that do this are known as fail-fast iterators, as they fail quickly and cleanly, rather that risking arbitrary, non-deterministic behavior at an undetermined time in the future.  Note that this exception does not always indicate that an object has been concurrently modified by a different thread. If a single thread issues a sequence of method invocations that violates the contract of an object, the object may throw this exception. For example, if a thread modifies a collection directly while it is iterating over the collection with a fail-fast iterator, the iterator will throw this exception. Note that fail-fast behavior cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast operations throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: ConcurrentModificationException should be used only to detect bugs.
java.util.ConcurrentModificationException: java.util.ConcurrentModificationException.ConcurrentModificationException	(	):  Constructs a ConcurrentModificationException with no detail message.
java.util.ConcurrentModificationException: java.util.ConcurrentModificationException.ConcurrentModificationException	(	String	):  Constructs a ConcurrentModificationException with the specified detail message.
java.util.ConcurrentModificationException: java.util.ConcurrentModificationException.ConcurrentModificationException	(	String	Throwable	):  Constructs a new exception with the specified detail message and cause. Note that the detail message associated with cause is not automatically incorporated in this exception's detail message.
java.util.ConcurrentModificationException: java.util.ConcurrentModificationException.ConcurrentModificationException	(	Throwable	):  Constructs a new exception with the specified cause and a detail message of (cause==null ? null : cause.toString()) (which typically contains the class and detail message of cause.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap:  A hash table supporting full concurrency of retrievals and high expected concurrency for updates. This class obeys the same functional specification as java.util.Hashtable, and includes versions of methods corresponding to each method of Hashtable. However, even though all operations are thread-safe, retrieval operations do not entail locking, and there is not any support for locking the entire table in a way that prevents all access. This class is fully interoperable with Hashtable in programs that rely on its thread safety but not on its synchronization details. Retrieval operations (including get) generally do not block, so may overlap with update operations (including put and remove). Retrievals reflect the results of the most recently completed update operations holding upon their onset. (More formally, an update operation for a given key bears a happens-before relation with any (non-null) retrieval for that key reporting the updated value.) For aggregate operations such as putAll and clear, concurrent retrievals may reflect insertion or removal of only some entries. Similarly, Iterators, Spliterators and Enumerations return elements reflecting the state of the hash table at some point at or since the creation of the iterator/enumeration. They do not throw java.util.ConcurrentModificationException ConcurrentModificationException. However, iterators are designed to be used by only one thread at a time. Bear in mind that the results of aggregate status methods including size, isEmpty, and containsValue are typically useful only when a map is not undergoing concurrent updates in other threads. Otherwise the results of these methods reflect transient states that may be adequate for monitoring or estimation purposes, but not for program control. The table is dynamically expanded when there are too many collisions (i.e., keys that have distinct hash codes but fall into the same slot modulo the table size), with the expected average effect of maintaining roughly two bins per mapping (corresponding to a 0.75 load factor threshold for resizing). There may be much variance around this average as mappings are added and removed, but overall, this maintains a commonly accepted time/space tradeoff for hash tables. However, resizing this or any other kind of hash table may be a relatively slow operation. When possible, it is a good idea to provide a size estimate as an optional initialCapacity constructor argument. An additional optional loadFactor constructor argument provides a further means of customizing initial table capacity by specifying the table density to be used in calculating the amount of space to allocate for the given number of elements. Also, for compatibility with previous versions of this class, constructors may optionally specify an expected concurrencyLevel as an additional hint for internal sizing. Note that using many keys with exactly the same hashCode() is a sure way to slow down performance of any hash table. To ameliorate impact, when keys are Comparable, this class may use comparison order among keys to help break ties. A Set projection of a ConcurrentHashMap may be created (using newKeySet() or newKeySet()), or viewed (using keySet() when only keys are of interest, and the mapped values are (perhaps transiently) not used or all take the same mapping value. A ConcurrentHashMap can be used as scalable frequency map (a form of histogram or multiset) by using java.util.concurrent.atomic.LongAdder values and initializing via computeIfAbsent. For example, to add a count to a ConcurrentHashMap freqs, you can use freqs.computeIfAbsent(k -> new LongAdder()).increment(); This class and its views and iterators implement all of the optional methods of the Map and Iterator interfaces. Like Hashtable but unlike HashMap, this class does not allow null to be used as a key or value. ConcurrentHashMaps support a set of sequential and parallel bulk operations that, unlike most Stream methods, are designed to be safely, and often sensibly, applied even with maps that are being concurrently updated by other threads; for example, when computing a snapshot summary of the values in a shared registry. There are three kinds of operation, each with four forms, accepting functions with Keys, Values, Entries, and (Key, Value) arguments and/or return values. Because the elements of a ConcurrentHashMap are not ordered in any particular way, and may be processed in different orders in different parallel executions, the correctness of supplied functions should not depend on any ordering, or on any other objects or values that may transiently change while computation is in progress; and except for forEach actions, should ideally be side-effect-free. Bulk operations on java.util.Map.Entry objects do not support method setValue.   forEach: Perform a given action on each element. A variant form applies a given transformation on each element before performing the action.  search: Return the first available non-null result of applying a given function on each element; skipping further search when a result is found.  reduce: Accumulate each element. The supplied reduction function cannot rely on ordering (more formally, it should be both associative and commutative). There are five variants:   Plain reductions. (There is not a form of this method for (key, value) function arguments since there is no corresponding return type.)  Mapped reductions that accumulate the results of a given function applied to each element.  Reductions to scalar doubles, longs, and ints, using a given basis value.    These bulk operations accept a parallelismThreshold argument. Methods proceed sequentially if the current map size is estimated to be less than the given threshold. Using a value of Long.MAX_VALUE suppresses all parallelism. Using a value of 1 results in maximal parallelism by partitioning into enough subtasks to fully utilize the commonPool() that is used for all parallel computations. Normally, you would initially choose one of these extreme values, and then measure performance of using in-between values that trade off overhead versus throughput. The concurrency properties of bulk operations follow from those of ConcurrentHashMap: Any non-null result returned from get(key) and related access methods bears a happens-before relation with the associated insertion or update. The result of any bulk operation reflects the composition of these per-element relations (but is not necessarily atomic with respect to the map as a whole unless it is somehow known to be quiescent). Conversely, because keys and values in the map are never null, null serves as a reliable atomic indicator of the current lack of any result. To maintain this property, null serves as an implicit basis for all non-scalar reduction operations. For the double, long, and int versions, the basis should be one that, when combined with any other value, returns that other value (more formally, it should be the identity element for the reduction). Most common reductions have these properties; for example, computing a sum with basis 0 or a minimum with basis MAX_VALUE. Search and transformation functions provided as arguments should similarly return null to indicate the lack of any result (in which case it is not used). In the case of mapped reductions, this also enables transformations to serve as filters, returning null (or, in the case of primitive specializations, the identity basis) if the element should not be combined. You can create compound transformations and filterings by composing them yourself under this "null means there is nothing there now" rule before using them in search or reduce operations. Methods accepting and/or returning Entry arguments maintain key-value associations. They may be useful for example when finding the key for the greatest value. Note that "plain" Entry arguments can be supplied using new AbstractMap.SimpleEntry(k,v). Bulk operations may complete abruptly, throwing an exception encountered in the application of a supplied function. Bear in mind when handling such exceptions that other concurrently executing functions could also have thrown exceptions, or would have done so if the first exception had not occurred. Speedups for parallel compared to sequential forms are common but not guaranteed. Parallel operations involving brief functions on small maps may execute more slowly than sequential forms if the underlying work to parallelize the computation is more expensive than the computation itself. Similarly, parallelization may not lead to much actual parallelism if all processors are busy performing unrelated tasks. All arguments to all task methods must be non-null. This class is a member of the  Java Collections Framework.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.BaseIterator:  Base of key, value, and entry Iterators. Adds fields to Traverser to support iterator.remove.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.BulkTask:  Base class for bulk tasks. Repeats some fields and code from class Traverser, because we need to subclass CountedCompleter.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.BulkTask.advance	(	):  Same as Traverser version
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.CollectionView:  Base class for views.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.CollectionView.clear	(	):  Removes all of the elements from this view, by removing all the mappings from the map backing this view.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.CollectionView.getMap	(	):  Returns the map backing this view.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.CollectionView.iterator	(	):  Returns an iterator over the elements in this collection. The returned iterator is weakly consistent.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.CollectionView.toString	(	):  Returns a string representation of this collection. The string representation consists of the string representations of the collection's elements in the order they are returned by its iterator, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (comma and space). Elements are converted to strings as by valueOf().
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.ConcurrentHashMap	(	):  Creates a new, empty map with the default initial table size (16).
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.ConcurrentHashMap	(	Map	):  Creates a new map with the same mappings as the given map.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.ConcurrentHashMap	(	int	):  Creates a new, empty map with an initial table size accommodating the specified number of elements without the need to dynamically resize.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.ConcurrentHashMap	(	int	float	):  Creates a new, empty map with an initial table size based on the given number of elements (initialCapacity) and initial table density (loadFactor).
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.ConcurrentHashMap	(	int	float	int	):  Creates a new, empty map with an initial table size based on the given number of elements (initialCapacity), table density (loadFactor), and number of concurrently updating threads (concurrencyLevel).
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.CounterCell:  A padded cell for distributing counts. Adapted from LongAdder and Striped64. See their internal docs for explanation.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.EntrySetView:  A view of a ConcurrentHashMap as a Set of (key, value) entries. This class cannot be directly instantiated. See entrySet().
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.EntrySetView.iterator	(	):  Returns an iterator over the elements in this collection. The returned iterator is weakly consistent.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.ForwardingNode:  A node inserted at head of bins during transfer operations.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.KeySetView:  A view of a ConcurrentHashMap as a Set of keys, in which additions may optionally be enabled by mapping to a common value. This class cannot be directly instantiated. See keySet() keySet(), keySet() keySet(V), newKeySet() newKeySet(), newKeySet() newKeySet(int).
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.KeySetView.add	(	K	):  Adds the specified key to this set view by mapping the key to the default mapped value in the backing map, if defined.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.KeySetView.addAll	(	Collection	):  Adds all of the elements in the specified collection to this set, as if by calling add on each one.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.KeySetView.contains	(	Object	):  
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.KeySetView.getMappedValue	(	):  Returns the default mapped value for additions, or null if additions are not supported.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.KeySetView.iterator	(	):  Returns an iterator over the elements in this collection. The returned iterator is weakly consistent.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.KeySetView.remove	(	Object	):  Removes the key from this map view, by removing the key (and its corresponding value) from the backing map. This method does nothing if the key is not in the map.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.MapEntry:  Exported Entry for EntryIterator
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.MapEntry.setValue	(	V	):  Sets our entry's value and writes through to the map. The value to return is somewhat arbitrary here. Since we do not necessarily track asynchronous changes, the most recent "previous" value could be different from what we return (or could even have been removed, in which case the put will re-establish). We do not and cannot guarantee more.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.Node:  Key-value entry. This class is never exported out as a user-mutable Map.Entry (i.e., one supporting setValue; see MapEntry below), but can be used for read-only traversals used in bulk tasks. Subclasses of Node with a negative hash field are special, and contain null keys and values (but are never exported). Otherwise, keys and vals are never null.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.Node.find	(	int	Object	):  Virtualized support for map.get(); overridden in subclasses.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.ReservationNode:  A place-holder node used in computeIfAbsent and compute
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.Segment:  Stripped-down version of helper class used in previous version, declared for the sake of serialization compatibility
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TableStack:  Records the table, its length, and current traversal index for a traverser that must process a region of a forwarded table before proceeding with current table.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.Traverser:  Encapsulates traversal for methods such as containsValue; also serves as a base class for other iterators and spliterators. Method advance visits once each still-valid node that was reachable upon iterator construction. It might miss some that were added to a bin after the bin was visited, which is OK wrt consistency guarantees. Maintaining this property in the face of possible ongoing resizes requires a fair amount of bookkeeping state that is difficult to optimize away amidst volatile accesses. Even so, traversal maintains reasonable throughput. Normally, iteration proceeds bin-by-bin traversing lists. However, if the table has been resized, then all future steps must traverse both the bin at the current index as well as at (index + baseSize); and so on for further resizings. To paranoically cope with potential sharing by users of iterators across threads, iteration terminates if a bounds checks fails for a table read.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.Traverser.advance	(	):  Advances if possible, returning next valid node, or null if none.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.Traverser.pushState	(	Node[]	int	int	):  Saves traversal state upon encountering a forwarding node.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.Traverser.recoverState	(	int	):  Possibly pops traversal state.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin:  TreeNodes used at the heads of bins. TreeBins do not hold user keys or values, but instead point to list of TreeNodes and their root. They also maintain a parasitic read-write lock forcing writers (who hold bin lock) to wait for readers (who do not) to complete before tree restructuring operations.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin.TreeBin	(	TreeNode	):  Creates bin with initial set of nodes headed by b.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin.checkInvariants	(	TreeNode	):  Recursive invariant check
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin.contendedLock	(	):  Possibly blocks awaiting root lock.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin.find	(	int	Object	):  Returns matching node or null if none. Tries to search using tree comparisons from root, but continues linear search when lock not available.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin.lockRoot	(	):  Acquires write lock for tree restructuring.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin.putTreeVal	(	int	K	V	):  Finds or adds a node.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin.removeTreeNode	(	TreeNode	):  Removes the given node, that must be present before this call. This is messier than typical red-black deletion code because we cannot swap the contents of an interior node with a leaf successor that is pinned by "next" pointers that are accessible independently of lock. So instead we swap the tree linkages.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin.tieBreakOrder	(	Object	Object	):  Tie-breaking utility for ordering insertions when equal hashCodes and non-comparable. We don't require a total order, just a consistent insertion rule to maintain equivalence across rebalancings. Tie-breaking further than necessary simplifies testing a bit.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin.unlockRoot	(	):  Releases write lock for tree restructuring.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeNode:  Nodes for use in TreeBins
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeNode.findTreeNode	(	int	Object	Class	):  Returns the TreeNode (or null if not found) for the given key starting at given root.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.ValuesView:  A view of a ConcurrentHashMap as a Collection of values, in which additions are disabled. This class cannot be directly instantiated. See values().
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.addCount	(	long	int	):  Adds to count, and if table is too small and not already resizing, initiates transfer. If already resizing, helps perform transfer if work is available. Rechecks occupancy after a transfer to see if another resize is already needed because resizings are lagging additions.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.batchFor	(	long	):  Computes initial batch value for bulk tasks. The returned value is approximately exp2 of the number of times (minus one) to split task by two before executing leaf action. This value is faster to compute and more convenient to use as a guide to splitting than is the depth, since it is used while dividing by two anyway.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.clear	(	):  Removes all of the mappings from this map.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.comparableClassFor	(	Object	):  Returns x's Class if it is of the form "class C implements Comparable", else null.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.compareComparables	(	Class	Object	Object	):  Returns k.compareTo(x) if x matches kc (k's screened comparable class), else 0.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.compute	(	K	BiFunction	):  Attempts to compute a mapping for the specified key and its current mapped value (or null if there is no current mapping). The entire method invocation is performed atomically. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this Map.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.computeIfAbsent	(	K	Function	):  If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless null. The entire method invocation is performed atomically, so the function is applied at most once per key. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this map.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.computeIfPresent	(	K	BiFunction	):  If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value. The entire method invocation is performed atomically. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this map.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.contains	(	Object	):  Legacy method testing if some key maps into the specified value in this table. This method is identical in functionality to containsValue(), and exists solely to ensure full compatibility with class java.util.Hashtable, which supported this method prior to introduction of the Java Collections framework.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.containsKey	(	Object	):  Tests if the specified object is a key in this table.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.containsValue	(	Object	):  Returns true if this map maps one or more keys to the specified value. Note: This method may require a full traversal of the map, and is much slower than method containsKey.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.elements	(	):  Returns an enumeration of the values in this table.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.entrySet	(	):  Returns a Set view of the mappings contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. The view's iterators and spliterators are weakly consistent. The view's spliterator reports CONCURRENT, DISTINCT, and NONNULL.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.equals	(	Object	):  Compares the specified object with this map for equality. Returns true if the given object is a map with the same mappings as this map. This operation may return misleading results if either map is concurrently modified during execution of this method.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.forEach	(	long	BiConsumer	):  Performs the given action for each (key, value).
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.forEach	(	long	BiFunction	Consumer	):  Performs the given action for each non-null transformation of each (key, value).
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.forEachEntry	(	long	Consumer	):  Performs the given action for each entry.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.forEachEntry	(	long	Function	Consumer	):  Performs the given action for each non-null transformation of each entry.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.forEachKey	(	long	Consumer	):  Performs the given action for each key.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.forEachKey	(	long	Function	Consumer	):  Performs the given action for each non-null transformation of each key.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.forEachValue	(	long	Consumer	):  Performs the given action for each value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.forEachValue	(	long	Function	Consumer	):  Performs the given action for each non-null transformation of each value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.get	(	Object	):  Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that key.equals(k), then this method returns v; otherwise it returns null. (There can be at most one such mapping.)
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.getOrDefault	(	Object	V	):  Returns the value to which the specified key is mapped, or the given default value if this map contains no mapping for the key.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.hashCode	(	):  Returns the hash code value for this Map, i.e., the sum of, for each key-value pair in the map, key.hashCode() ^ value.hashCode().
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.helpTransfer	(	Node[]	Node	):  Helps transfer if a resize is in progress.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.initTable	(	):  Initializes table, using the size recorded in sizeCtl.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.isEmpty	(	):  Returns true if this map contains no key-value mappings.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.keySet	(	):  Returns a Set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. The set supports element removal, which removes the corresponding mapping from this map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations. The view's iterators and spliterators are weakly consistent. The view's spliterator reports CONCURRENT, DISTINCT, and NONNULL.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.keySet	(	V	):  Returns a Set view of the keys in this map, using the given common mapped value for any additions (i.e., add and addAll()). This is of course only appropriate if it is acceptable to use the same value for all additions from this view.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.keys	(	):  Returns an enumeration of the keys in this table.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.mappingCount	(	):  Returns the number of mappings. This method should be used instead of size because a ConcurrentHashMap may contain more mappings than can be represented as an int. The value returned is an estimate; the actual count may differ if there are concurrent insertions or removals.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.merge	(	K	V	BiFunction	):  If the specified key is not already associated with a (non-null) value, associates it with the given value. Otherwise, replaces the value with the results of the given remapping function, or removes if null. The entire method invocation is performed atomically. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this Map.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.newKeySet	(	):  Creates a new Set backed by a ConcurrentHashMap from the given type to Boolean.TRUE.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.newKeySet	(	int	):  Creates a new Set backed by a ConcurrentHashMap from the given type to Boolean.TRUE.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.put	(	K	V	):  Maps the specified key to the specified value in this table. Neither the key nor the value can be null. The value can be retrieved by calling the get method with a key that is equal to the original key.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.putAll	(	Map	):  Copies all of the mappings from the specified map to this one. These mappings replace any mappings that this map had for any of the keys currently in the specified map.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.putIfAbsent	(	K	V	):  If the specified key is not already associated with a value (or is mapped to null) associates it with the given value and returns null, else returns the current value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.putVal	(	K	V	boolean	):  Implementation for put and putIfAbsent 
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.readObject	(	java.io.ObjectInputStream	):  Reconstitutes the instance from a stream (that is, deserializes it).
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduce	(	long	BiFunction	BiFunction	):  Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceEntries	(	long	BiFunction	):  Returns the result of accumulating all entries using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceEntries	(	long	Function	BiFunction	):  Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceEntriesToDouble	(	long	ToDoubleFunction	double	DoubleBinaryOperator	):  Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceEntriesToInt	(	long	ToIntFunction	int	IntBinaryOperator	):  Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceEntriesToLong	(	long	ToLongFunction	long	LongBinaryOperator	):  Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceKeys	(	long	BiFunction	):  Returns the result of accumulating all keys using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceKeys	(	long	Function	BiFunction	):  Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceKeysToDouble	(	long	ToDoubleFunction	double	DoubleBinaryOperator	):  Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceKeysToInt	(	long	ToIntFunction	int	IntBinaryOperator	):  Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceKeysToLong	(	long	ToLongFunction	long	LongBinaryOperator	):  Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceToDouble	(	long	ToDoubleBiFunction	double	DoubleBinaryOperator	):  Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceToInt	(	long	ToIntBiFunction	int	IntBinaryOperator	):  Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceToLong	(	long	ToLongBiFunction	long	LongBinaryOperator	):  Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceValues	(	long	BiFunction	):  Returns the result of accumulating all values using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceValues	(	long	Function	BiFunction	):  Returns the result of accumulating the given transformation of all values using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceValuesToDouble	(	long	ToDoubleFunction	double	DoubleBinaryOperator	):  Returns the result of accumulating the given transformation of all values using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceValuesToInt	(	long	ToIntFunction	int	IntBinaryOperator	):  Returns the result of accumulating the given transformation of all values using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceValuesToLong	(	long	ToLongFunction	long	LongBinaryOperator	):  Returns the result of accumulating the given transformation of all values using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.remove	(	Object	):  Removes the key (and its corresponding value) from this map. This method does nothing if the key is not in the map.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.remove	(	Object	Object	):  Removes the entry for the specified key only if it is currently mapped to the specified value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.replace	(	K	V	):  Replaces the entry for the specified key only if it is currently mapped to some value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.replace	(	K	V	V	):  Replaces the entry for the specified key only if currently mapped to the specified value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.replaceNode	(	Object	V	Object	):  Implementation for the four public remove/replace methods: Replaces node value with v, conditional upon match of cv if non-null. If resulting value is null, delete.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.resizeStamp	(	int	):  Returns the stamp bits for resizing a table of size n. Must be negative when shifted left by RESIZE_STAMP_SHIFT.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.search	(	long	BiFunction	):  Returns a non-null result from applying the given search function on each (key, value), or null if none. Upon success, further element processing is suppressed and the results of any other parallel invocations of the search function are ignored.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.searchEntries	(	long	Function	):  Returns a non-null result from applying the given search function on each entry, or null if none. Upon success, further element processing is suppressed and the results of any other parallel invocations of the search function are ignored.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.searchKeys	(	long	Function	):  Returns a non-null result from applying the given search function on each key, or null if none. Upon success, further element processing is suppressed and the results of any other parallel invocations of the search function are ignored.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.searchValues	(	long	Function	):  Returns a non-null result from applying the given search function on each value, or null if none. Upon success, further element processing is suppressed and the results of any other parallel invocations of the search function are ignored.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.size	(	):  Returns the number of key-value mappings in this map. If the map contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.spread	(	int	):  Spreads (XORs) higher bits of hash to lower and also forces top bit to 0. Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.) So we apply a transform that spreads the impact of higher bits downward. There is a tradeoff between speed, utility, and quality of bit-spreading. Because many common sets of hashes are already reasonably distributed (so don't benefit from spreading), and because we use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.tableSizeFor	(	int	):  Returns a power of two table size for the given desired capacity. See Hackers Delight, sec 3.2
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.toString	(	):  Returns a string representation of this map. The string representation consists of a list of key-value mappings (in no particular order) enclosed in braces (" "). Adjacent mappings are separated by the characters ", " (comma and space). Each key-value mapping is rendered as the key followed by an equals sign ("=") followed by the associated value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.transfer	(	Node[]	Node[]	):  Moves and/or copies the nodes in each bin to new table. See above for explanation.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.treeifyBin	(	Node[]	int	):  Replaces all linked nodes in bin at given index unless table is too small, in which case resizes instead.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.tryPresize	(	int	):  Tries to presize table to accommodate the given number of elements.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.untreeify	(	Node	):  Returns a list on non-TreeNodes replacing those in given list.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.values	(	):  Returns a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. The collection supports element removal, which removes the corresponding mapping from this map, via the Iterator.remove, Collection.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations. The view's iterators and spliterators are weakly consistent. The view's spliterator reports CONCURRENT and NONNULL.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.writeObject	(	java.io.ObjectOutputStream	):  Saves the state of the ConcurrentHashMap instance to a stream (i.e., serializes it).
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue:  An unbounded BlockingQueue blocking queue that uses the same ordering rules as class PriorityQueue and supplies blocking retrieval operations. While this queue is logically unbounded, attempted additions may fail due to resource exhaustion (causing OutOfMemoryError). This class does not permit null elements. A priority queue relying on Comparable natural ordering also does not permit insertion of non-comparable objects (doing so results in ClassCastException). This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces. The Iterator provided in method iterator() is not guaranteed to traverse the elements of the PriorityBlockingQueue in any particular order. If you need ordered traversal, consider using Arrays.sort(pq.toArray()). Also, method drainTo can be used to remove some or all elements in priority order and place them in another collection. Operations on this class make no guarantees about the ordering of elements with equal priority. If you need to enforce an ordering, you can define custom classes or comparators that use a secondary key to break ties in primary priority values. For example, here is a class that applies first-in-first-out tie-breaking to comparable elements. To use it, you would insert a new FIFOEntry(anEntry) instead of a plain entry object.  class FIFOEntry> implements Comparable> static final AtomicLong seq = new AtomicLong(0); final long seqNum; final E entry; public FIFOEntry(E entry) { seqNum = seq.getAndIncrement(); this.entry = entry; } public E getEntry() { return entry; } public int compareTo(FIFOEntry other) { int res = entry.compareTo(other.entry); if (res == 0 && other.entry != this.entry) res = (seqNum < other.seqNum ? -1 : 1); return res; } }} This class is a member of the  Java Collections Framework.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.Itr:  Snapshot iterator that works off copy of underlying q array.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.PriorityBlockingQueue	(	):  Creates a PriorityBlockingQueue with the default initial capacity (11) that orders its elements according to their Comparable natural ordering.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.PriorityBlockingQueue	(	Collection	):  Creates a PriorityBlockingQueue containing the elements in the specified collection. If the specified collection is a SortedSet or a PriorityQueue, this priority queue will be ordered according to the same ordering. Otherwise, this priority queue will be ordered according to the Comparable natural ordering of its elements.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.PriorityBlockingQueue	(	int	):  Creates a PriorityBlockingQueue with the specified initial capacity that orders its elements according to their Comparable natural ordering.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.PriorityBlockingQueue	(	int	Comparator	):  Creates a PriorityBlockingQueue with the specified initial capacity that orders its elements according to the specified comparator.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.add	(	E	):  Inserts the specified element into this priority queue.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.clear	(	):  Atomically removes all of the elements from this queue. The queue will be empty after this call returns.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.comparator	(	):  Returns the comparator used to order the elements in this queue, or null if this queue uses the Comparable natural ordering of its elements.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.contains	(	Object	):  Returns true if this queue contains the specified element. More formally, returns true if and only if this queue contains at least one element e such that o.equals(e).
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.dequeue	(	):  Mechanics for poll(). Call only while holding lock.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.drainTo	(	Collection	):  Removes all available elements from this queue and adds them to the given collection. This operation may be more efficient than repeatedly polling this queue. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.drainTo	(	Collection	int	):  Removes at most the given number of available elements from this queue and adds them to the given collection. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.heapify	(	):  Establishes the heap invariant (described above) in the entire tree, assuming nothing about the order of the elements prior to the call.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.iterator	(	):  Returns an iterator over the elements in this queue. The iterator does not return the elements in any particular order. The returned iterator is weakly consistent.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.offer	(	E	):  Inserts the specified element into this priority queue. As the queue is unbounded, this method will never return false.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.offer	(	E	long	TimeUnit	):  Inserts the specified element into this priority queue. As the queue is unbounded, this method will never block or return false.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.put	(	E	):  Inserts the specified element into this priority queue. As the queue is unbounded, this method will never block.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.readObject	(	java.io.ObjectInputStream	):  Reconstitutes this queue from a stream (that is, deserializes it).
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.remainingCapacity	(	):  Always returns Integer.MAX_VALUE because a PriorityBlockingQueue is not capacity constrained.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.remove	(	Object	):  Removes a single instance of the specified element from this queue, if it is present. More formally, removes an element e such that o.equals(e), if this queue contains one or more such elements. Returns true if and only if this queue contained the specified element (or equivalently, if this queue changed as a result of the call).
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.removeAt	(	int	):  Removes the ith element from queue.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.removeEQ	(	Object	):  Identity-based version for use in Itr.remove
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.siftDownComparable	(	int	T	Object[]	int	):  Inserts item x at position k, maintaining heap invariant by demoting x down the tree repeatedly until it is less than or equal to its children or is a leaf.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.siftUpComparable	(	int	T	Object[]	):  Inserts item x at position k, maintaining heap invariant by promoting x up the tree until it is greater than or equal to its parent, or is the root. To simplify and speed up coercions and comparisons. the Comparable and Comparator versions are separated into different methods that are otherwise identical. (Similarly for siftDown.) These methods are static, with heap state as arguments, to simplify use in light of possible comparator exceptions.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.spliterator	(	):  Returns a Spliterator over the elements in this queue. The returned spliterator is weakly consistent. The Spliterator reports SIZED and NONNULL.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.toArray	(	):  Returns an array containing all of the elements in this queue. The returned array elements are in no particular order. The returned array will be "safe" in that no references to it are maintained by this queue. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.toArray	(	T[]	):  Returns an array containing all of the elements in this queue; the runtime type of the returned array is that of the specified array. The returned array elements are in no particular order. If the queue fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this queue. If this queue fits in the specified array with room to spare (i.e., the array has more elements than this queue), the element in the array immediately following the end of the queue is set to null. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a queue known to contain only strings. The following code can be used to dump the queue into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.tryGrow	(	Object[]	int	):  Tries to grow array to accommodate at least one more element (but normally expand by about 50%), giving up (allowing retry) on contention (which we expect to be rare). Call only while holding lock.
java.util.concurrent.PriorityBlockingQueue: java.util.concurrent.PriorityBlockingQueue.writeObject	(	java.io.ObjectOutputStream	):  Saves this queue to a stream (that is, serializes it). For compatibility with previous version of this class, elements are first copied to a java.util.PriorityQueue, which is then serialized.
java.util.concurrent.SynchronousQueue.TransferQueue: java.util.concurrent.SynchronousQueue.TransferQueue:  Dual Queue 
java.util.concurrent.SynchronousQueue.TransferQueue: java.util.concurrent.SynchronousQueue.TransferQueue.QNode:  Node class for TransferQueue. 
java.util.concurrent.SynchronousQueue.TransferQueue: java.util.concurrent.SynchronousQueue.TransferQueue.QNode.isOffList	(	):  Returns true if this node is known to be off the queue because its next pointer has been forgotten due to an advanceHead operation.
java.util.concurrent.SynchronousQueue.TransferQueue: java.util.concurrent.SynchronousQueue.TransferQueue.QNode.tryCancel	(	Object	):  Tries to cancel by CAS'ing ref to this as item.
java.util.concurrent.SynchronousQueue.TransferQueue: java.util.concurrent.SynchronousQueue.TransferQueue.advanceHead	(	QNode	QNode	):  Tries to cas nh as new head; if successful, unlink old head's next node to avoid garbage retention.
java.util.concurrent.SynchronousQueue.TransferQueue: java.util.concurrent.SynchronousQueue.TransferQueue.advanceTail	(	QNode	QNode	):  Tries to cas nt as new tail.
java.util.concurrent.SynchronousQueue.TransferQueue: java.util.concurrent.SynchronousQueue.TransferQueue.awaitFulfill	(	QNode	E	boolean	long	):  Spins/blocks until node s is fulfilled.
java.util.concurrent.SynchronousQueue.TransferQueue: java.util.concurrent.SynchronousQueue.TransferQueue.casCleanMe	(	QNode	QNode	):  Tries to CAS cleanMe slot.
java.util.concurrent.SynchronousQueue.TransferQueue: java.util.concurrent.SynchronousQueue.TransferQueue.clean	(	QNode	QNode	):  Gets rid of cancelled node s with original predecessor pred.
java.util.concurrent.SynchronousQueue.TransferQueue: java.util.concurrent.SynchronousQueue.TransferQueue.transfer	(	E	boolean	long	):  Puts or takes an item.