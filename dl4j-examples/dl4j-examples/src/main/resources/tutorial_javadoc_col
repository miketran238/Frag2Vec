Lesson: Algorithms The polymorphic algorithms described here are pieces of reusable functionality provided by the Java platform. All of them come from the Collections class, and all take the form of static methods whose first argument is the collection on which the operation is to be performed. The great majority of the algorithms provided by the Java platform operate on List instances, but a few of them operate on arbitrary Collection instances. This section briefly describes the following algorithms: Sorting Shuffling Routine Data Manipulation Searching Composition Finding Extreme Values
Sorting The Collections.sort algorithm reorders a List so that its elements are in ascending order according to an ordering relationship. Two forms of the operation are provided. The simple form takes a List and sorts it according to its elements' natural ordering. If you're unfamiliar with the concept of natural ordering, read the Object Ordering section. The Collections.sort operation uses a slightly optimized merge sort algorithm that is fast and stable: Fast: It is guaranteed to run in n log(n) time and runs substantially faster on nearly sorted lists. Empirical tests showed it to be as fast as a highly optimized quicksort. A quicksort is generally considered to be faster than a merge sort but isn't stable and doesn't guarantee n log(n) performance. Stable: It doesn't reorder equal elements. This is important if you sort the same list repeatedly on different attributes. If a user of a mail program sorts the inbox by mailing date and then sorts it by sender, the user naturally expects that the now-contiguous list of messages from a given sender will (still) be sorted by mailing date. This is guaranteed only if the second sort was stable.
Sorting - part 2 The following trivial program prints out its arguments in lexicographic (alphabetical) order. import java.util.*; public class Sort { public static void main(String[] args) { List<String> list = Arrays.asList(args); Collections.sort(list); System.out.println(list); } } Let's run the program. % java Sort i walk the line The following output is produced. [i, line, the, walk] The program was included only to show you that algorithms really are as easy to use as they appear to be. The second form of Collections.sort takes a Comparator in addition to a List and sorts the elements with the Comparator . Suppose you want to print out the anagram groups from our earlier example in reverse order of size ? largest anagram group first. The example that follows shows you how to achieve this with the help of the second form of the Collections.sort method.
Sorting - part 3 Recall that the anagram groups are stored as values in a Map , in the form of List instances. The revised printing code iterates through the Map 's values view, putting every List that passes the minimum-size test into a List of List s. Then the code sorts this List , using a Comparator that expects List instances, and implements reverse size-ordering. Finally, the code iterates through the sorted List , printing its elements (the anagram groups). The following code replaces the printing code at the end of the main method in the Anagrams example. // Make a List of all anagram groups above size threshold. List<List<String>> winners = new ArrayList<List<String>>(); for (List<String> l : m.values()) if (l.size() >= minGroupSize) winners.add(l); // Sort anagram groups according to size Collections.sort(winners, new Comparator<List<String>>() { public int compare(List<String> o1, List<String> o2) { return o2.size() - o1.size(); }}); // Print anagram groups. for (List<String> l : winners) System.out.println(l.size() + ": " + l); Running the program on the same dictionary as in The Map Interface section, with the same minimum anagram group size (eight), produces the following output. 12: [apers, apres, asper, pares, parse, pears, prase, presa, rapes, reaps, spare, spear] 11: [alerts, alters, artels, estral, laster, ratels, salter, slater, staler, stelar, talers] 10: [least, setal, slate, stale, steal, stela, taels, tales, teals, tesla] 9: [estrin, inerts, insert, inters, niters, nitres, sinter, triens, trines] 9: [capers, crapes, escarp, pacers, parsec, recaps, scrape, secpar, spacer] 9: [palest, palets, pastel, petals, plates, pleats, septal, staple, tepals] 9: [anestri, antsier, nastier, ratines, retains, retinas, retsina, stainer, stearin] 8: [lapse, leaps, pales, peals, pleas, salep, sepal, spale] 8: [aspers, parses, passer, prases, repass, spares, sparse, spears] 8: [enters, nester, renest, rentes, resent, tenser, ternes,treens] 8: [arles, earls, lares, laser, lears, rales, reals, seral] 8: [earings, erasing, gainers, reagins, regains, reginas, searing, seringa] 8: [peris, piers, pries, prise, ripes, speir, spier, spire] 8: [ates, east, eats, etas, sate, seat, seta, teas] 8: [carets, cartes, caster, caters, crates, reacts, recast,traces]
Shuffling The Collections.shuffle algorithm does the opposite of what Collections.sort does, destroying any trace of order that may have been present in a List . That is, this algorithm reorders the List based on input from a source of randomness such that all possible permutations occur with equal likelihood, assuming a fair source of randomness. This algorithm is useful in implementing games of chance. For example, it could be used to shuffle a List of Card objects representing a deck. Also, it's useful for generating test cases. This operation has two forms: one takes a List and uses a default source of randomness, and the other requires the caller to provide a Random object to use as a source of randomness. The code for this algorithm is used as an example in the List section.
Routine Data Manipulation The Collections class provides five algorithms for doing routine data manipulation on List objects, all of which are pretty straightforward: Collections.reverse ? reverses the order of the elements in a List . Collections.fill ? overwrites every element in a List with the specified value. This operation is useful for reinitializing a List . Collections.copy ? takes two arguments, a destination List and a source List , and copies the elements of the source into the destination, overwriting its contents. The destination List must be at least as long as the source. If it is longer, the remaining elements in the destination List are unaffected. Collections.swap ? swaps the elements at the specified positions in a List . Collections.addAll ? adds all the specified elements to a Collection . The elements to be added may be specified individually or as an array.
Searching The Collections.binarySearch algorithm searches for a specified element in a sorted List . This algorithm has two forms. The first takes a List and an element to search for (the "search key"). This form assumes that the List is sorted in ascending order according to the natural ordering of its elements. The second form takes a Comparator in addition to the List and the search key, and assumes that the List is sorted into ascending order according to the specified Comparator . The Collections.sort algorithm can be used to sort the List prior to calling Collections.binarySearch .
Searching - part 2 The return value is the same for both forms. If the List contains the search key, its index is returned. If not, the return value is (-(insertion point) - 1), where the insertion point is the point at which the value would be inserted into the List , or the index of the first element greater than the value or List.size() if all elements in the List are less than the specified value. This admittedly ugly formula guarantees that the return value will be >= 0 if and only if the search key is found. It's basically a hack to combine a boolean (found) and an integer (index) into a single int return value. The following idiom, usable with both forms of the Collections.binarySearch operation, looks for the specified search key and inserts it at the appropriate position if it's not already present. int pos = Collections.binarySearch(list, key); if (pos < 0) l.add(-pos-1);
Composition The frequency and disjoint algorithms test some aspect of the composition of one or more Collections : Collections.frequency ? counts the number of times the specified element occurs in the specified collection Collections.disjoint ? determines whether two Collections are disjoint; that is, whether they contain no elements in common
Finding Extreme Values The Collections.min and the Collections.max algorithms return, respectively, the minimum and maximum element contained in a specified Collection . Both of these operations come in two forms. The simple form takes only a Collection and returns the minimum (or maximum) element according to the elements' natural ordering. The second form takes a Comparator in addition to the Collection and returns the minimum (or maximum) element according to the specified Comparator .
Lesson: Custom Collection Implementations Many programmers will never need to implement their own Collection s classes. You can go pretty far using the implementations described in the preceding sections of this chapter. However, someday you might want to write your own implementation. It is fairly easy to do this with the aid of the abstract implementations provided by the Java platform. Before we discuss how to write an implementation, let's discuss why you might want to write one.
Reasons to Write an Implementation The following list illustrates the sort of custom Collection s you might want to implement. It is not intended to be exhaustive: Persistent: All of the built-in Collection implementations reside in main memory and vanish when the program exits. If you want a collection that will still be present the next time the program starts, you can implement it by building a veneer over an external database. Such a collection might be concurrently accessible by multiple programs. Application-specific: This is a very broad category. One example is an unmodifiable Map containing real-time telemetry data. The keys could represent locations, and the values could be read from sensors at these locations in response to the get operation. High-performance, special-purpose: Many data structures take advantage of restricted usage to offer better performance than is possible with general-purpose implementations. For instance, consider a List containing long runs of identical element values. Such lists, which occur frequently in text processing, can be run-length encoded ? runs can be represented as a single object containing the repeated element and the number of consecutive repetitions. This example is interesting because it trades off two aspects of performance: It requires less space but more time than an ArrayList . High-performance, general-purpose: The Java Collections Framework's designers tried to provide the best general-purpose implementations for each interface, but many, many data structures could have been used, and new ones are invented every day. Maybe you can come up with something faster! Enhanced functionality: Suppose you need an efficient bag implementation (also known as a multiset): a Collection that offers constant-time containment checks while allowing duplicate elements. It's reasonably straightforward to implement such a collection atop a HashMap . Convenience: You may want additional implementations that offer conveniences beyond those offered by the Java platform. For instance, you may frequently need List instances representing a contiguous range of Integer s. Adapter: Suppose you are using a legacy API that has its own ad hoc collections' API. You can write an adapter implementation that permits these collections to operate in the Java Collections Framework. An adapter implementation is a thin veneer that wraps objects of one type and makes them behave like objects of another type by translating operations on the latter type into operations on the former.
How to Write a Custom Implementation Writing a custom implementation is surprisingly easy. The Java Collections Framework provides abstract implementations designed expressly to facilitate custom implementations. We'll start with the following example of an implementation of Arrays.asList . public static <T> List<T> asList(T[] a) { return new MyArrayList<T>(a); } private static class MyArrayList<T> extends AbstractList<T> { private final T[] a; MyArrayList(T[] array) { a = array; } public T get(int index) { return a[index]; } public T set(int index, T element) { T oldValue = a[index]; a[index] = element; return oldValue; } public int size() { return a.length; } } Believe it or not, this is very close to the implementation that is contained in java.util.Arrays . It's that simple! You provide a constructor and the AbstractList.get , AbstractList.set , and AbstractCollection.size methods, and AbstractList does all the rest. You get the ListIterator , bulk operations, search operations, hash code computation, comparison, and string representation for free. Suppose you want to make the implementation a bit faster. The API documentation for abstract implementations describes precisely how each method is implemented, so you'll know which methods to override to get the performance you want. The preceding implementation's performance is fine, but it can be improved a bit. In particular, the AbstractCollection.toArray method iterates over the List, copying one element at a time. Given the internal representation, it's a lot faster and more sensible just to clone the array. public Object[] toArray() { return (Object[]) a.clone(); }
How to Write a Custom Implementation - part 2 With the addition of this override and a few more like it, this implementation is exactly the one found in java.util.Arrays . In the interest of full disclosure, it's a bit tougher to use the other abstract implementations because you will have to write your own iterator, but it's still not that difficult. The following list summarizes the abstract implementations: AbstractCollection ? a Collection that is neither a Set nor a List. At a minimum, you must provide the AbstractList.iterator and the AbstractCollection.size methods. AbstractSet ? a Set ; use is identical to AbstractCollection . AbstractList ? a List backed up by a random-access data store, such as an array. At a minimum, you must provide the positional access methods ( AbstractList.get and, optionally, AbstractList.set , AbstractList.remove , and AbstractList.add ) and the AbstractCollection.size method. The abstract class takes care of AbstractList.listIterator (and AbstractList.iterator ). AbstractSequentialList ? a List backed up by a sequential-access data store, such as a linked list. At a minimum, you must provide the AbstractList.listIterator and AbstractCollection.size methods. The abstract class takes care of the positional access methods. (This is the opposite of AbstractList .) AbstractQueue ? at a minimum, you must provide the offer, peek, poll, and AbstractCollection.size methods and an AbstractList.iterator supporting AbstractList.remove . AbstractMap ? a Map . At a minimum you must provide the entrySet view. This is typically implemented with the AbstractSet class. If the Map is modifiable, you must also provide the put method.
List View of an Array The Arrays.asList method returns a List view of its array argument. Changes to the List write through to the array and vice versa. The size of the collection is that of the array and cannot be changed. If the add or the remove method is called on the List, an UnsupportedOperationException will result. The normal use of this implementation is as a bridge between array-based and collection-based APIs. It allows you to pass an array to a method expecting a Collection or a List. However, this implementation also has another use. If you need a fixed-size List, it's more efficient than any general-purpose List implementation. This is the idiom. List<String> list = Arrays.asList(new String[size]); Note that a reference to the backing array is not retained.
Immutable Multiple-Copy List Occasionally you'll need an immutable List consisting of multiple copies of the same element. The Collections.nCopies method returns such a list. This implementation has two main uses. The first is to initialize a newly created List; for example, suppose you want an ArrayList initially consisting of 1,000 null elements. The following incantation does the trick. List<Type> list = new ArrayList<Type>(Collections.nCopies(1000, (Type)null); Of course, the initial value of each element need not be null. The second main use is to grow an existing List. For example, suppose you want to add 69 copies of the string "fruit bat" to the end of a List<String>. It's not clear why you'd want to do such a thing, but let's just suppose you did. The following is how you'd do it. lovablePets.addAll(Collections.nCopies(69, "fruit bat")); By using the form of addAll that takes both an index and a Collection , you can add the new elements to the middle of a List instead of to the end of it.
Immutable Singleton Set Sometimes you'll need an immutable singleton Set , which consists of a single, specified element. The Collections.singleton method returns such a Set . One use of this implementation is to remove all occurrences of a specified element from a Collection . c.removeAll(Collections.singleton(e)); A related idiom removes all elements that map to a specified value from a Map . For example, suppose you have a Map ? job ? that maps people to their line of work and suppose you want to eliminate all the lawyers. The following one-liner will do the deed. job.values().removeAll(Collections.singleton(LAWYER)); One more use of this implementation is to provide a single input value to a method that is written to accept a collection of values.
Empty Set List and Map Constants The Collections class provides methods to return the empty Set , List, and Map ? Collections.emptySet , Collections.emptyList , and Collections.emptyMap . The main use of these constants is as input to methods that take a Collection of values when you don't want to provide any values at all, as in this example. tourist.declarePurchases(Collections.emptySet());
Deque Implementations The Deque interface, pronounced as "deck", represents a double-ended queue. The Deque interface can be implemented as various types of Collections . The Deque interface implementations are grouped into general-purpose and concurrent implementations.
General-Purpose Deque Implementations The general-purpose implementations include LinkedList and ArrayDeque classes. The Deque interface supports insertion, removal and retrieval of elements at both ends. The ArrayDeque class is the resizable array implementation of the Deque interface, whereas the LinkedList class is the list implementation. The basic insertion, removal and retieval operations in the Deque interface addFirst, addLast, removeFirst, removeLast, getFirst and getLast. The method addFirst adds an element at the head whereas addLast adds an element at the tail of the Deque instance. The LinkedList implementation is more flexible than the ArrayDeque implementation. LinkedList implements all optional list operations. null elements are allowed in the LinkedList implementation but not in the ArrayDeque implementation. In terms of efficiency, ArrayDeque is more efficient than the LinkedList for add and remove operation at both ends. The best operation in a LinkedList implementation is removing the current element during the iteration. LinkedList implementations are not ideal structures to iterate. The LinkedList implementation consumes more memory than the ArrayDeque implementation. For the ArrayDeque instance traversal use any of the following:
Concurrent Deque Implementations The LinkedBlockingDeque class is the concurrent implementation of the Deque interface. If the deque is empty then methods such as LinkedBlockingDeque.takeFirst and LinkedBlockingDeque.takeLast wait until the element becomes available, and then retrieves and removes the same element.
Lesson: Implementations - part 2 The general-purpose implementations are summarized in the following table. General-purpose Implementations Interfaces Hash table Implementations Resizable array Implementations Tree Implementations Linked list Implementations Hash table + Linked list Implementations Set HashSet TreeSet LinkedHashSet List ArrayList LinkedList Queue Deque ArrayDeque LinkedList Map HashMap TreeMap LinkedHashMap As you can see from the table, the Java Collections Framework provides several general-purpose implementations of the Set , List , and Map interfaces. In each case, one implementation ? HashSet , ArrayList , and HashMap ? is clearly the one to use for most applications, all other things being equal. Note that the SortedSet and the SortedMap interfaces do not have rows in the table. Each of those interfaces has one implementation ( TreeSet and TreeMap ) and is listed in the Set and the Map rows. There are two general-purpose Queue implementations ? LinkedList , which is also a List implementation, and PriorityQueue , which is omitted from the table. These two implementations provide very different semantics: LinkedList provides FIFO semantics, while PriorityQueue orders its elements according to their values.
Lesson: Implementations - part 3 Each of the general-purpose implementations provides all optional operations contained in its interface. All permit null elements, keys, and values. None are synchronized (thread-safe). All have fail-fast iterators, which detect illegal concurrent modification during iteration and fail quickly and cleanly rather than risking arbitrary, nondeterministic behavior at an undetermined time in the future. All are Serializable and all support a public clone method. The fact that these implementations are unsynchronized represents a break with the past: The legacy collections Vector and Hashtable are synchronized. The present approach was taken because collections are frequently used when the synchronization is of no benefit. Such uses include single-threaded use, read-only use, and use as part of a larger data object that does its own synchronization. In general, it is good API design practice not to make users pay for a feature they don't use. Furthermore, unnecessary synchronization can result in deadlock under certain circumstances.
Lesson: Implementations - part 4 If you need thread-safe collections, the synchronization wrappers, described in the Wrapper Implementations section, allow any collection to be transformed into a synchronized collection. Thus, synchronization is optional for general-purpose implementations, whereas it is mandatory for legacy implementations. Moreover, the java.util.concurrent package provides concurrent implementations of the BlockingQueue interface, which extends Queue, and of the ConcurrentMap interface, which extends Map . These implementations offer much higher concurrency than mere synchronized implementations. As a rule, you should be thinking about the interfaces, BigInteger.not the implementations. That is why there are no programming examples in this section. For the most part, the choice of implementation affects only performance. The preferred style, as mentioned in the Interfaces section, is to choose an implementation when a Collection is created and to immediately assign the new collection to a variable of the corresponding interface type (or to pass the collection to a method expecting an argument of the interface type). In this way, the program does not become dependent on any added methods in a given implementation, leaving the programmer free to change implementations anytime that it is warranted by performance concerns or behavioral details.
General-Purpose List Implementations There are two general-purpose List implementations ? ArrayList and LinkedList . Most of the time, you'll probably use ArrayList , which offers constant-time positional access and is just plain fast. It does not have to allocate a node object for each element in the List, and it can take advantage of System.arraycopy when it has to move multiple elements at the same time. Think of ArrayList as Vector without the synchronization overhead. If you frequently add elements to the beginning of the List or iterate over the List to delete elements from its interior, you should consider using LinkedList . These operations require constant-time in a LinkedList and linear-time in an ArrayList . But you pay a big price in performance. Positional access requires linear-time in a LinkedList and constant-time in an ArrayList . Furthermore, the constant factor for LinkedList is much worse. If you think you want to use a LinkedList , measure the performance of your application with both LinkedList and ArrayList before making your choice; ArrayList is usually faster.
General-Purpose List Implementations - part 2 ArrayList has one tuning parameter ? the initial capacity, which refers to the number of elements the ArrayList can hold before it has to grow. LinkedList has no tuning parameters and seven optional operations, one of which is clone. The other six are LinkedList.addFirst , LinkedList.getFirst , LinkedList.removeFirst , LinkedList.addLast , LinkedList.getLast , and LinkedList.removeLast . LinkedList also implements the Queue interface.
Special-Purpose List Implementations CopyOnWriteArrayList is a List implementation backed up by a copy-on-write array. This implementation is similar in nature to CopyOnWriteArraySet . No synchronization is necessary, even during iteration, and iterators are guaranteed never to throw ConcurrentModificationException . This implementation is well suited to maintaining event-handler lists, in which change is infrequent, and traversal is frequent and potentially time-consuming. If you need synchronization, a Vector will be slightly faster than an ArrayList synchronized with Collections.synchronizedList . But Vector has loads of legacy operations, so be careful to always manipulate the Vector with the List interface or else you won't be able to replace the implementation at a later time. If your List is fixed in size ? that is, you'll never use remove, add, or any of the bulk operations other than containsAll ? you have a third option that's definitely worth considering. See Arrays.asList in the Convenience Implementations section for more information.
Map Implementations Map implementations are grouped into general-purpose, special-purpose, and concurrent implementations.
General-Purpose Map Implementations The three general-purpose Map implementations are HashMap , TreeMap and LinkedHashMap . If you need SortedMap operations or key-ordered Collection -view iteration, use TreeMap ; if you want maximum speed and don't care about iteration order, use HashMap ; if you want near- HashMap performance and insertion-order iteration, use LinkedHashMap . In this respect, the situation for Map is analogous to Set . Likewise, everything else in the Set Implementations section also applies to Map implementations. LinkedHashMap provides two capabilities that are not available with LinkedHashSet . When you create a LinkedHashMap , you can order it based on key access rather than insertion. In other words, merely looking up the value associated with a key brings that key to the end of the map. Also, LinkedHashMap provides the LinkedHashMap.removeEldestEntry method, which may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map. This makes it very easy to implement a custom cache.
Special-Purpose Map Implementations There are three special-purpose Map implementations ? EnumMap , WeakHashMap and IdentityHashMap . EnumMap , which is internally implemented as an array, is a high-performance Map implementation for use with enum keys. This implementation combines the richness and safety of the Map interface with a speed approaching that of an array. If you want to map an enum to a value, you should always use an EnumMap in preference to an array. WeakHashMap is an implementation of the Map interface that stores only weak references to its keys. Storing only weak references allows a key-value pair to be garbage-collected when its key is no longer referenced outside of the WeakHashMap . This class provides the easiest way to harness the power of weak references. It is useful for implementing "registry-like" data structures, where the utility of an entry vanishes when its key is no longer reachable by any thread.
Special-Purpose Map Implementations - part 2 IdentityHashMap is an identity-based Map implementation based on a hash table. This class is useful for topology-preserving object graph transformations, such as serialization or deep-copying. To perform such transformations, you need to maintain an identity-based "node table" that keeps track of which objects have already been seen. Identity-based maps are also used to maintain object-to-meta-information mappings in dynamic debuggers and similar systems. Finally, identity-based maps are useful in thwarting "spoof attacks" that are a result of intentionally perverse equals methods because IdentityHashMap never invokes the equals method on its keys. An added benefit of this implementation is that it is fast.
Concurrent Map Implementations The java.util.concurrent package contains the ConcurrentMap interface, which extends Map with atomic putIfAbsent, remove, and replace methods, and the ConcurrentHashMap implementation of that interface. ConcurrentHashMap is a highly concurrent, high-performance implementation backed up by a hash table. This implementation never blocks when performing retrievals and allows the client to select the concurrency level for updates. It is intended as a drop-in replacement for Hashtable : in addition to implementing ConcurrentMap , it supports all the legacy methods peculiar to Hashtable . Again, if you don't need the legacy operations, be careful to manipulate it with the ConcurrentMap interface.
Questions Question: You plan to write a program that uses several basic collection interfaces: Set , List, Queue, and Map . You're not sure which implementations will work best, so you decide to use general-purpose implementations until you get a better idea how your program will work in the real world. Which implementations are these? Answer: Set : HashSet List: ArrayList Queue: LinkedList Map : HashMap Question: If you need a Set implementation that provides value-ordered iteration, which class should you use? Answer: TreeSet guarantees that the sorted set is in ascending element order, sorted according to the natural order of the elements or by the Comparator provided. Question: Which class do you use to access wrapper implementations? Answer: You use the Collections class, which provides static methods that operate on or return collections.
Exercises Exercise: Write a program that reads a text file, specified by the first command line argument, into a List. The program should then print random lines from the file, the number of lines printed to be specified by the second command line argument. Write the program so that a correctly-sized collection is allocated all at once, instead of being gradually expanded as the file is read in. Hint: To determine the number of lines in the file, use java.io.File.length to obtain the size of the file, then divide by an assumed size of an average line. Answer: Since we are accessing the List randomly, we will use ArrayList . We estimate the number of lines by taking the file size and dividing by 50. We then double that figure, since it is more efficient to overestimate than to underestmate. import java.util.*; import java.io.*; public class FileList { public static void main(String[] args) { final int assumedLineLength = 50; File file = new File(args[0]); List<String> fileList = new ArrayList<String>((int)(file.length() / assumedLineLength) * 2); BufferedReader reader = null; int lineCount = 0; try { reader = new BufferedReader(new FileReader(file)); for (String line = reader.readLine(); line != null; line = reader.readLine()) { fileList.add(line); lineCount++; } } catch (IOException e) { System.err.format("Could not read %s: %s%n", file, e); System.exit(1); } finally { if (reader != null) { try { reader.close(); } catch (IOException e) {} } } int repeats = Integer.parseInt(args[1]); Random random = new Random(); for (int i = 0; i < repeats; i++) { System.out.format("%d: %s%n", i, fileList.get(random.nextInt(lineCount - 1))); } } } This program actually spends most of its time reading in the file, so pre-allocating the ArrayList has little affect on its performance. Specifying an initial capacity in advance is more likely to be useful when your program repeatly creates large ArrayList objects without intervening I/O.
General-Purpose Queue Implementations As mentioned in the previous section, LinkedList implements the Queue interface, providing first in, first out (FIFO) queue operations for add, poll, and so on. The PriorityQueue class is a priority queue based on the heap data structure. This queue orders elements according to the order specified at construction time, which can be the elements' natural ordering or the ordering imposed by an explicit Comparator . The queue retrieval operations ? poll, remove, peek , and element ? access the element at the head of the queue. The Queue.head of the queue is the least element with respect to the specified ordering. If multiple elements are tied for least value, the head is one of those elements; ties are broken arbitrarily. PriorityQueue and its iterator implement all of the optional methods of the Collection and Iterator interfaces. The iterator provided in method iterator is not guaranteed to traverse the elements of the PriorityQueue in any particular order. For ordered traversal, consider using Arrays.sort(pq.toArray()) .
Concurrent Queue Implementations The java.util.concurrent package contains a set of synchronized Queue interfaces and classes. BlockingQueue extends Queue with operations that wait for the queue to become nonempty when retrieving an element and for space to become available in the queue when storing an element. This interface is implemented by the following classes: LinkedBlockingQueue ? an optionally bounded FIFO blocking queue backed by linked nodes ArrayBlockingQueue ? a bounded FIFO blocking queue backed by an array PriorityBlockingQueue ? an unbounded blocking priority queue backed by a heap DelayQueue ? a time-based scheduling queue backed by a heap SynchronousQueue ? a simple rendezvous mechanism that uses the BlockingQueue interface In JDK 7, TransferQueue is a specialized BlockingQueue in which code that adds an element to the queue has the option of waiting (blocking) for code in another thread to retrieve the element. TransferQueue has a single implementation: LinkedTransferQueue ? an unbounded TransferQueue based on linked nodes
Set Implementations The Set implementations are grouped into general-purpose and special-purpose implementations.
General-Purpose Set Implementations There are three general-purpose Set implementations ? HashSet , TreeSet , and LinkedHashSet . Which of these three to use is generally straightforward. HashSet is much faster than TreeSet (constant-time versus log-time for most operations) but offers no ordering guarantees. If you need to use the operations in the SortedSet interface, or if value-ordered iteration is required, use TreeSet ; otherwise, use HashSet . It's a fair bet that you'll end up using HashSet most of the time. LinkedHashSet is in some sense intermediate between HashSet and TreeSet . Implemented as a hash table with a linked list running through it, it provides insertion-ordered iteration (least recently inserted to most recently) and runs nearly as fast as HashSet . The LinkedHashSet implementation spares its clients from the unspecified, generally chaotic ordering provided by HashSet without incurring the increased cost associated with TreeSet .
General-Purpose Set Implementations - part 2 One thing worth keeping in mind about HashSet is that iteration is linear in the sum of the number of entries and the number of buckets (the capacity). Thus, choosing an initial capacity that's too high can waste both space and time. On the other hand, choosing an initial capacity that's too low wastes time by copying the data structure each time it's forced to increase its capacity. If you don't specify an initial capacity, the default is 16. In the past, there was some advantage to choosing a prime number as the initial capacity. This is no longer true. Internally, the capacity is always rounded up to a power of two. The initial capacity is specified by using the int constructor. The following line of code allocates a HashSet whose initial capacity is 64. Set<String> s = new HashSet<String>(64);
General-Purpose Set Implementations - part 3 The HashSet class has one other tuning parameter called the load factor. If you care a lot about the space consumption of your HashSet , read the HashSet documentation for more information. Otherwise, just accept the default; it's almost always the right thing to do. If you accept the default load factor but want to specify an initial capacity, pick a number that's about twice the size to which you expect the set to grow. If your guess is way off, you may waste a bit of space, time, or both, but it's unlikely to be a big problem. LinkedHashSet has the same tuning parameters as HashSet , but iteration time is not affected by capacity. TreeSet has no tuning parameters.
Special-Purpose Set Implementations There are two special-purpose Set implementations ? EnumSet and CopyOnWriteArraySet . EnumSet is a high-performance Set implementation for enum types. All of the members of an enum set must be of the same enum type. Internally, it is represented by a bit-vector, typically a single long. Enum sets support iteration over ranges of enum types. For example, given the enum declaration for the days of the week, you can iterate over the weekdays. The EnumSet class provides a static factory that makes it easy. for (Day d : EnumSet.range(Day.MONDAY, Day.FRIDAY)) System.out.println(d); Enum sets also provide a rich, typesafe replacement for traditional bit flags. EnumSet.of(Style.BOLD, Style.ITALIC) CopyOnWriteArraySet is a Set implementation backed up by a copy-on-write array. All mutative operations, such as add, set, and remove, are implemented by making a new copy of the array; no locking is ever required. Even iteration may safely proceed concurrently with element insertion and deletion. Unlike most Set implementations, the add, remove, and contains methods require time proportional to the size of the set. This implementation is only appropriate for sets that are rarely modified but frequently iterated. It is well suited to maintaining event-handler lists that must prevent duplicates.
Summary of Implementations Implementations are the data objects used to store collections, which implement the interfaces described in the Interfaces lesson. The Java Collections Framework provides several general-purpose implementations of the core interfaces: For the Set interface, HashSet is the most commonly used implementation. For the List interface, ArrayList is the most commonly used implementation. For the Map interface, HashMap is the most commonly used implementation. For the Queue interface, LinkedList is the most commonly used implementation. For the Deque interface, ArrayDeque is the most commonly used implementation. Each of the general-purpose implementations provides all optional operations contained in its interface. The Java Collections Framework also provides several special-purpose implementations for situations that require nonstandard performance, usage restrictions, or other unusual behavior. The java.util.concurrent package contains several collections implementations, which are thread-safe but not governed by a single exclusion lock.
Summary of Implementations - part 2 The Collections class (as opposed to the Collection interface), provides static methods that operate on or return collections, which are known as Wrapper implementations. Finally, there are several Convenience implementations, which can be more efficient than general-purpose implementations when you don't need their full power. The Convenience implementations are made available through static factory methods.
Wrapper Implementations Wrapper implementations delegate all their real work to a specified collection but add extra functionality on top of what this collection offers. For design pattern fans, this is an example of the decorator pattern. Although it may seem a bit exotic, it's really pretty straightforward. These implementations are anonymous; rather than providing a public class, the library provides a static factory method. All these implementations are found in the Collections class, which consists solely of static methods.
Synchronization Wrappers The synchronization wrappers add automatic synchronization (thread-safety) to an arbitrary collection. Each of the six core collection interfaces ? Collection , Set , List, Map , SortedSet , and SortedMap ? has one static factory method. public static <T> Collection<T> synchronizedCollection(Collection<T> c); public static <T> Set<T> synchronizedSet(Set<T> s); public static <T> List<T> synchronizedList(List<T> list); public static <K,V> Map<K,V> synchronizedMap(Map<K,V> m); public static <T> SortedSet<T> synchronizedSortedSet(SortedSet<T> s); public static <K,V> SortedMap<K,V> synchronizedSortedMap(SortedMap<K,V> m); Each of these methods returns a synchronized (thread-safe) Collection backed up by the specified collection. To guarantee serial access, all access to the backing collection must be accomplished through the returned collection. The easy way to guarantee this is not to keep a reference to the backing collection. Create the synchronized collection with the following trick. List<Type> list = Collections.synchronizedList(new ArrayList<Type>()); A collection created in this fashion is every bit as thread-safe as a normally synchronized collection, such as a Vector . In the face of concurrent access, it is imperative that the user manually synchronize on the returned collection when iterating over it. The reason is that iteration is accomplished via multiple calls into the collection, which must be composed into a single atomic operation. The following is the idiom to iterate over a wrapper-synchronized collection. Collection<Type> c = Collections.synchronizedCollection(myCollection); synchronized(c) { for (Type e : c) foo(e); }
Synchronization Wrappers - part 2 If an explicit iterator is used, the iterator method must be called from within the synchronized block. Failure to follow this advice may result in nondeterministic behavior. The idiom for iterating over a Collection view of a synchronized Map is similar. It is imperative that the user synchronize on the synchronized Map when iterating over any of its Collection views rather than synchronizing on the Collection view itself, as shown in the following example. Map<KeyType, ValType> m = Collections.synchronizedMap(new HashMap<KeyType, ValType>()); ... Set<KeyType> s = m.keySet(); ... // Synchronizing on m, not s! synchronized(m) { while (KeyType k : s) foo(k); } One minor downside of using wrapper implementations is that you do not have the ability to execute any noninterface operations of a wrapped implementation. So, for instance, in the preceding List example, you cannot call ArrayList 's ensureCapacity operation on the wrapped ArrayList .
Unmodifiable Wrappers Unlike synchronization wrappers, which add functionality to the wrapped collection, the unmodifiable wrappers take functionality away. In particular, they take away the ability to modify the collection by intercepting all the operations that would modify the collection and throwing an UnsupportedOperationException . Unmodifiable wrappers have two main uses, as follows: To make a collection immutable once it has been built. In this case, it's good practice not to maintain a reference to the backing collection. This absolutely guarantees immutability. To allow certain clients read-only access to your data structures. You keep a reference to the backing collection but hand out a reference to the wrapper. In this way, clients can look but not modify, while you maintain full access. Like synchronization wrappers, each of the six core Collection interfaces has one static factory method. public static <T> Collection<T> unmodifiableCollection(Collection<? extends T> c); public static <T> Set<T> unmodifiableSet(Set<? extends T> s); public static <T> List<T> unmodifiableList(List<? extends T> list); public static <K,V> Map<K, V> unmodifiableMap(Map<? extends K, ? extends V> m); public static <T> SortedSet<T> unmodifiableSortedSet(SortedSet<? extends T> s); public static <K,V> SortedMap<K, V> unmodifiableSortedMap(SortedMap<K, ? extends V> m);
Checked Interface Wrappers The Collections.checked interface wrappers are provided for use with generic collections. These implementations return a dynamically type-safe view of the specified collection, which throws a ClassCastException if a client attempts to add an element of the wrong type. The generics mechanism in the language provides compile-time (static) type-checking, but it is possible to defeat this mechanism. Dynamically type-safe views eliminate this possibility entirely.
Parameters If your API contains a method that requires a collection on input, it is of paramount importance that you declare the relevant parameter type to be one of the collection interface types. Never use an implementation type because this defeats the purpose of an interface-based Collections Framework, which is to allow collections to be manipulated without regard to implementation details. Further, you should always use the least-specific type that makes sense. For example, don't require a List or a Set if a Collection would do. It's not that you should never require a List or a Set on input; it is correct to do so if a method depends on a property of one of these interfaces. For example, many of the algorithms provided by the Java platform require a List on input because they depend on the fact that lists are ordered. As a general rule, however, the best types to use on input are the most general: Collection and Map . Caution: Never define your own ad hoc collection class and require objects of this class on input. By doing this, you'd lose all the benefits provided by the Java Collections Framework.
Return Values You can afford to be much more flexible with return values than with input parameters. It's fine to return an object of any type that implements or extends one of the collection interfaces. This can be one of the interfaces or a special-purpose type that extends or implements one of these interfaces. For example, one could imagine an image-processing package, called ImageList, that returned objects of a new class that implements List. In addition to the List operations, ImageList could support any application-specific operations that seemed desirable. For example, it might provide an indexImage operation that returned an image containing thumbnail images of each graphic in the ImageList. It's critical to note that even if the API furnishes ImageList instances on output, it should accept arbitrary Collection (or perhaps List) instances on input.
Return Values - part 2 In one sense, return values should have the opposite behavior of input parameters: It's best to return the most specific applicable collection interface rather than the most general. For example, if you're sure that you'll always return a SortedMap , you should give the relevant method the return type of SortedMap rather than Map . SortedMap instances are more time-consuming to build than ordinary Map instances and are also more powerful. Given that your module has already invested the time to build a SortedMap , it makes good sense to give the user access to its increased power. Furthermore, the user will be able to pass the returned object to methods that demand a SortedMap , as well as those that accept any Map .
Compatibility The Java Collections Framework was designed to ensure complete interoperability between the core collection interfaces and the types that were used to represent collections in the early versions of the Java platform: Vector , Hashtable , array, and Enumeration . In this section, you'll learn how to transform old collections to the Java Collections Framework collections and vice versa.
Upward Compatibility Suppose that you're using an API that returns legacy collections in tandem with another API that requires objects implementing the collection interfaces. To make the two APIs interoperate smoothly, you'll have to transform the legacy collections into modern collections. Luckily, the Java Collections Framework makes this easy. Suppose the old API returns an array of objects and the new API requires a Collection . The Collections Framework has a convenience implementation that allows an array of objects to be viewed as a List. You use Arrays.asList to pass an array to any method requiring a Collection or a List. Foo[] result = oldMethod(arg); newMethod(Arrays.asList(result)); If the old API returns a Vector or a Hashtable , you have no work to do at all because Vector was retrofitted to implement the List interface, and Hashtable was retrofitted to implement Map . Therefore, a Vector may be passed directly to any method calling for a Collection or a List. Vector result = oldMethod(arg); newMethod(result); Similarly, a Hashtable may be passed directly to any method calling for a Map . Hashtable result = oldMethod(arg); newMethod(result); Less frequently, an API may return an Enumeration that represents a collection of objects. The Collections.list method translates an Enumeration into a Collection . Enumeration e = oldMethod(arg); newMethod(Collections.list(e));
Backward Compatibility Suppose you're using an API that returns modern collections in tandem with another API that requires you to pass in legacy collections. To make the two APIs interoperate smoothly, you have to transform modern collections into old collections. Again, the Java Collections Framework makes this easy. Suppose the new API returns a Collection , and the old API requires an array of Object . As you're probably aware, the Collection interface contains a Collection.toArray method designed expressly for this situation. Collection c = newMethod(); oldMethod(c.toArray()); What if the old API requires an array of String (or another type) instead of an array of Object ? You just use the other form of Collection.toArray ? the one that takes an array on input. Collection c = newMethod(); oldMethod((String[]) c.toArray(new String[0])); If the old API requires a Vector , the standard collection constructor comes in handy. Collection c = newMethod(); oldMethod(new Vector(c)); The case where the old API requires a Hashtable is handled analogously. Map m = newMethod(); oldMethod(new Hashtable(m));
Backward Compatibility - part 2 Finally, what do you do if the old API requires an Enumeration ? This case isn't common, but it does happen from time to time, and the Collections.enumeration method was provided to handle it. This is a static factory method that takes a Collection and returns an Enumeration over the elements of the Collection . Collection c = newMethod(); oldMethod(Collections.enumeration(c));
What Is a Collections Framework? A collections framework is a unified architecture for representing and manipulating collections. All collections frameworks contain the following: Interfaces: These are abstract data types that represent collections. Interfaces allow collections to be manipulated independently of the details of their representation. In object-oriented languages, interfaces generally form a hierarchy. Implementations: These are the concrete implementations of the collection interfaces. In essence, they are reusable data structures. Algorithms: These are the methods that perform useful computations, such as searching and sorting, on objects that implement collection interfaces. The algorithms are said to be polymorphic: that is, the same method can be used on many different implementations of the appropriate collection interface. In essence, algorithms are reusable functionality. Apart from the Java Collections Framework, the best-known examples of collections frameworks are the C++ Standard Template Library (STL) and Smalltalk's collection hierarchy. Historically, collections frameworks have been quite complex, which gave them a reputation for having a steep learning curve. We believe that the Java Collections Framework breaks with this tradition, as you will learn for yourself in this chapter.
Benefits of the Java Collections Framework The Java Collections Framework provides the following benefits: Reduces programming effort: By providing useful data structures and algorithms, the Collections Framework frees you to concentrate on the important parts of your program rather than on the low-level "plumbing" required to make it work. By facilitating interoperability among unrelated APIs, the Java Collections Framework frees you from writing adapter objects or conversion code to connect APIs. Increases program speed and quality: This Collections Framework provides high-performance, high-quality implementations of useful data structures and algorithms. The various implementations of each interface are interchangeable, so programs can be easily tuned by switching collection implementations. Because you're freed from the drudgery of writing your own data structures, you'll have more time to devote to improving programs' quality and performance. Allows interoperability among unrelated APIs: The collection interfaces are the vernacular by which APIs pass collections back and forth. If my network administration API furnishes a collection of node names and if your GUI toolkit expects a collection of column headings, our APIs will interoperate seamlessly, even though they were written independently. Reduces effort to learn and to use new APIs: Many APIs naturally take collections on input and furnish them as output. In the past, each such API had a small sub-API devoted to manipulating its collections. There was little consistency among these ad hoc collections sub-APIs, so you had to learn each one from scratch, and it was easy to make mistakes when using them. With the advent of standard collection interfaces, the problem went away. Reduces effort to design new APIs: This is the flip side of the previous advantage. Designers and implementers don't have to reinvent the wheel each time they create an API that relies on collections; instead, they can use standard collection interfaces. Fosters software reuse: New data structures that conform to the standard collection interfaces are by nature reusable. The same goes for new algorithms that operate on objects that implement these interfaces.
java.util.Collections:  This class consists exclusively of static methods that operate on or return collections. It contains polymorphic algorithms that operate on collections, "wrappers", which return a new collection backed by a specified collection, and a few other odds and ends. The methods of this class all throw a NullPointerException if the collections or class objects provided to them are null. The documentation for the polymorphic algorithms contained in this class generally includes a brief description of the implementation. Such descriptions should be regarded as implementation notes, rather than parts of the specification. Implementors should feel free to substitute other algorithms, so long as the specification itself is adhered to. (For example, the algorithm used by sort does not have to be a mergesort, but it does have to be stable.) The "destructive" algorithms contained in this class, that is, the algorithms that modify the collection on which they operate, are specified to throw UnsupportedOperationException if the collection does not support the appropriate mutation primitive(s), such as the set method. These algorithms may, but are not required to, throw this exception if an invocation would have no effect on the collection. For example, invoking the sort method on an unmodifiable list that is already sorted may or may not throw UnsupportedOperationException. This class is a member of the  Java Collections Framework.
java.util.Collections.CheckedList.replaceAll	(	UnaryOperator	):  Replaces each element of this list with the result of applying the operator to that element. Errors or runtime exceptions thrown by the operator are relayed to the caller.
java.util.Collections.CheckedMap.CheckedEntrySet:  We need this class in addition to CheckedSet as Map.Entry permits modification of the backing Map via the setValue operation. This class is subtle: there are many possible attacks that must be thwarted.
java.util.Collections.CheckedMap.CheckedEntrySet.CheckedEntry:  This "wrapper class" serves two purposes: it prevents the client from modifying the backing Map, by short-circuiting the setValue method, and it protects the backing Map against an ill-behaved Map.Entry that attempts to modify another Map.Entry when asked to perform an equality check.
java.util.Collections.CheckedMap.CheckedEntrySet.contains	(	Object	):  This method is overridden to protect the backing set against an object with a nefarious equals function that senses that the equality-candidate is Map.Entry and calls its setValue method.
java.util.Collections.CheckedMap.CheckedEntrySet.containsAll	(	Collection	):  The bulk collection methods are overridden to protect against an unscrupulous collection whose contains(Object o) method senses when o is a Map.Entry, and calls o.setValue.
java.util.Collections.SynchronizedList.readResolve	(	):  SynchronizedRandomAccessList instances are serialized as SynchronizedList instances to allow them to be deserialized in pre-1.4 JREs (which do not have SynchronizedRandomAccessList). This method inverts the transformation. As a beneficial side-effect, it also grafts the RandomAccess marker onto SynchronizedList instances that were serialized in pre-1.4 JREs. Note: Unfortunately, SynchronizedRandomAccessList instances serialized in 1.4.1 and deserialized in 1.4 will become SynchronizedList instances, as this method was missing in 1.4.
java.util.Collections.SynchronizedNavigableMap:  A synchronized NavigableMap.
java.util.Collections.SynchronizedRandomAccessList.writeReplace	(	):  Allows instances to be deserialized in pre-1.4 JREs (which do not have SynchronizedRandomAccessList). SynchronizedList has a readResolve method that inverts this transformation upon deserialization.
java.util.Collections.UnmodifiableList.readResolve	(	):  UnmodifiableRandomAccessList instances are serialized as UnmodifiableList instances to allow them to be deserialized in pre-1.4 JREs (which do not have UnmodifiableRandomAccessList). This method inverts the transformation. As a beneficial side-effect, it also grafts the RandomAccess marker onto UnmodifiableList instances that were serialized in pre-1.4 JREs. Note: Unfortunately, UnmodifiableRandomAccessList instances serialized in 1.4.1 and deserialized in 1.4 will become UnmodifiableList instances, as this method was missing in 1.4.
java.util.Collections.UnmodifiableMap.UnmodifiableEntrySet:  We need this class in addition to UnmodifiableSet as Map.Entries themselves permit modification of the backing Map via their setValue operation. This class is subtle: there are many possible attacks that must be thwarted.
java.util.Collections.UnmodifiableMap.UnmodifiableEntrySet.UnmodifiableEntry:  This "wrapper class" serves two purposes: it prevents the client from modifying the backing Map, by short-circuiting the setValue method, and it protects the backing Map against an ill-behaved Map.Entry that attempts to modify another Map Entry when asked to perform an equality check.
java.util.Collections.UnmodifiableMap.UnmodifiableEntrySet.contains	(	Object	):  This method is overridden to protect the backing set against an object with a nefarious equals function that senses that the equality-candidate is Map.Entry and calls its setValue method.
java.util.Collections.UnmodifiableMap.UnmodifiableEntrySet.containsAll	(	Collection	):  The next two methods are overridden to protect against an unscrupulous List whose contains(Object o) method senses when o is a Map.Entry, and calls o.setValue.
java.util.Collections.UnmodifiableNavigableMap.EmptyNavigableMap:  A class for the EMPTY_NAVIGABLE_MAP which needs readResolve to preserve singleton property.
java.util.Collections.UnmodifiableNavigableSet:  Wraps a navigable set and disables all of the mutative operations.
java.util.Collections.UnmodifiableNavigableSet.EmptyNavigableSet:  A singleton empty unmodifiable navigable set used for emptyNavigableSet().
java.util.Collections.UnmodifiableRandomAccessList.writeReplace	(	):  Allows instances to be deserialized in pre-1.4 JREs (which do not have UnmodifiableRandomAccessList). UnmodifiableList has a readResolve method that inverts this transformation upon deserialization.
java.util.Collections.addAll	(	Collection	T	):  Adds all of the specified elements to the specified collection. Elements to be added may be specified individually or as an array. The behavior of this convenience method is identical to that of c.addAll(Arrays.asList(elements)), but this method is likely to run significantly faster under most implementations. When elements are specified individually, this method provides a convenient way to add a few elements to an existing collection:  Collections.addAll(flavors, "Peaches 'n Plutonium", "Rocky Racoon"); 
java.util.Collections.asLifoQueue	(	Deque	):  Returns a view of a Deque as a Last-in-first-out (Lifo) Queue. Method add is mapped to push, remove is mapped to pop and so on. This view can be useful when you would like to use a method requiring a Queue but you need Lifo ordering. Each method invocation on the queue returned by this method results in exactly one method invocation on the backing deque, with one exception. The addAll method is implemented as a sequence of addFirst invocations on the backing deque.
java.util.Collections.binarySearch	(	List	T	):  Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the Comparable natural ordering of its elements (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the list contains multiple elements equal to the specified object, there is no guarantee which one will be found. This method runs in log(n) time for a "random access" list (which provides near-constant-time positional access). If the specified list does not implement the RandomAccess interface and is large, this method will do an iterator-based binary search that performs O(n) link traversals and O(log n) element comparisons.
java.util.Collections.binarySearch	(	List	T	Comparator	):  Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort() sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If the list contains multiple elements equal to the specified object, there is no guarantee which one will be found. This method runs in log(n) time for a "random access" list (which provides near-constant-time positional access). If the specified list does not implement the RandomAccess interface and is large, this method will do an iterator-based binary search that performs O(n) link traversals and O(log n) element comparisons.
java.util.Collections.checkedCollection	(	Collection	Class	):  Returns a dynamically typesafe view of the specified collection. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a collection contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the collection takes place through the view, it is guaranteed that the collection cannot contain an incorrectly typed element. The generics mechanism in the language provides compile-time (static) type checking, but it is possible to defeat this mechanism with unchecked casts. Usually this is not a problem, as the compiler issues warnings on all such unchecked operations. There are, however, times when static type checking alone is not sufficient. For example, suppose a collection is passed to a third-party library and it is imperative that the library code not corrupt the collection by inserting an element of the wrong type. Another use of dynamically typesafe views is debugging. Suppose a program fails with a ClassCastException, indicating that an incorrectly typed element was put into a parameterized collection. Unfortunately, the exception can occur at any time after the erroneous element is inserted, so it typically provides little or no information as to the real source of the problem. If the problem is reproducible, one can quickly determine its source by temporarily modifying the program to wrap the collection with a dynamically typesafe view. For example, this declaration:  Collection c = new HashSet<>(); may be replaced temporarily by this one:  Collection c = Collections.checkedCollection( new HashSet<>(), String.class); Running the program again will cause it to fail at the point where an incorrectly typed element is inserted into the collection, clearly identifying the source of the problem. Once the problem is fixed, the modified declaration may be reverted back to the original. The returned collection does not pass the hashCode and equals operations through to the backing collection, but relies on Object's equals and hashCode methods. This is necessary to preserve the contracts of these operations in the case that the backing collection is a set or a list. The returned collection will be serializable if the specified collection is serializable. Since null is considered to be a value of any reference type, the returned collection permits insertion of null elements whenever the backing collection does.
java.util.Collections.checkedList	(	List	Class	):  Returns a dynamically typesafe view of the specified list. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a list contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the list takes place through the view, it is guaranteed that the list cannot contain an incorrectly typed element. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned list will be serializable if the specified list is serializable. Since null is considered to be a value of any reference type, the returned list permits insertion of null elements whenever the backing list does.
java.util.Collections.checkedMap	(	Map	Class	Class	):  Returns a dynamically typesafe view of the specified map. Any attempt to insert a mapping whose key or value have the wrong type will result in an immediate ClassCastException. Similarly, any attempt to modify the value currently associated with a key will result in an immediate ClassCastException, whether the modification is attempted directly through the map itself, or through a Map.Entry instance obtained from the map's entrySet() entry set view. Assuming a map contains no incorrectly typed keys or values prior to the time a dynamically typesafe view is generated, and that all subsequent access to the map takes place through the view (or one of its collection views), it is guaranteed that the map cannot contain an incorrectly typed key or value. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned map will be serializable if the specified map is serializable. Since null is considered to be a value of any reference type, the returned map permits insertion of null keys or values whenever the backing map does.
java.util.Collections.checkedNavigableMap	(	NavigableMap	Class	Class	):  Returns a dynamically typesafe view of the specified navigable map. Any attempt to insert a mapping whose key or value have the wrong type will result in an immediate ClassCastException. Similarly, any attempt to modify the value currently associated with a key will result in an immediate ClassCastException, whether the modification is attempted directly through the map itself, or through a Map.Entry instance obtained from the map's entrySet() entry set view. Assuming a map contains no incorrectly typed keys or values prior to the time a dynamically typesafe view is generated, and that all subsequent access to the map takes place through the view (or one of its collection views), it is guaranteed that the map cannot contain an incorrectly typed key or value. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned map will be serializable if the specified map is serializable. Since null is considered to be a value of any reference type, the returned map permits insertion of null keys or values whenever the backing map does.
java.util.Collections.checkedNavigableSet	(	NavigableSet	Class	):  Returns a dynamically typesafe view of the specified navigable set. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a navigable set contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the navigable set takes place through the view, it is guaranteed that the navigable set cannot contain an incorrectly typed element. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned navigable set will be serializable if the specified navigable set is serializable. Since null is considered to be a value of any reference type, the returned navigable set permits insertion of null elements whenever the backing sorted set does.
java.util.Collections.checkedQueue	(	Queue	Class	):  Returns a dynamically typesafe view of the specified queue. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a queue contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the queue takes place through the view, it is guaranteed that the queue cannot contain an incorrectly typed element. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned queue will be serializable if the specified queue is serializable. Since null is considered to be a value of any reference type, the returned queue permits insertion of null elements whenever the backing queue does.
java.util.Collections.checkedSet	(	Set	Class	):  Returns a dynamically typesafe view of the specified set. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a set contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the set takes place through the view, it is guaranteed that the set cannot contain an incorrectly typed element. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned set will be serializable if the specified set is serializable. Since null is considered to be a value of any reference type, the returned set permits insertion of null elements whenever the backing set does.
java.util.Collections.checkedSortedMap	(	SortedMap	Class	Class	):  Returns a dynamically typesafe view of the specified sorted map. Any attempt to insert a mapping whose key or value have the wrong type will result in an immediate ClassCastException. Similarly, any attempt to modify the value currently associated with a key will result in an immediate ClassCastException, whether the modification is attempted directly through the map itself, or through a Map.Entry instance obtained from the map's entrySet() entry set view. Assuming a map contains no incorrectly typed keys or values prior to the time a dynamically typesafe view is generated, and that all subsequent access to the map takes place through the view (or one of its collection views), it is guaranteed that the map cannot contain an incorrectly typed key or value. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned map will be serializable if the specified map is serializable. Since null is considered to be a value of any reference type, the returned map permits insertion of null keys or values whenever the backing map does.
java.util.Collections.checkedSortedSet	(	SortedSet	Class	):  Returns a dynamically typesafe view of the specified sorted set. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a sorted set contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the sorted set takes place through the view, it is guaranteed that the sorted set cannot contain an incorrectly typed element. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned sorted set will be serializable if the specified sorted set is serializable. Since null is considered to be a value of any reference type, the returned sorted set permits insertion of null elements whenever the backing sorted set does.
java.util.Collections.copy	(	List	List	):  Copies all of the elements from one list into another. After the operation, the index of each copied element in the destination list will be identical to its index in the source list. The destination list must be at least as long as the source list. If it is longer, the remaining elements in the destination list are unaffected.  This method runs in linear time.
java.util.Collections.disjoint	(	Collection	Collection	):  Returns true if the two specified collections have no elements in common. Care must be exercised if this method is used on collections that do not comply with the general contract for Collection. Implementations may elect to iterate over either collection and test for containment in the other collection (or to perform any equivalent computation). If either collection uses a nonstandard equality test (as does a SortedSet whose ordering is not compatible with equals, or the key set of an IdentityHashMap), both collections must use the same nonstandard equality test, or the result of this method is undefined. Care must also be exercised when using collections that have restrictions on the elements that they may contain. Collection implementations are allowed to throw exceptions for any operation involving elements they deem ineligible. For absolute safety the specified collections should contain only elements which are eligible elements for both collections. Note that it is permissible to pass the same collection in both parameters, in which case the method will return true if and only if the collection is empty.
java.util.Collections.emptyEnumeration	(	):  Returns an enumeration that has no elements. More precisely,  hasMoreElements always returns false.  nextElement always throws NoSuchElementException.  Implementations of this method are permitted, but not required, to return the same object from multiple invocations.
java.util.Collections.emptyIterator	(	):  Returns an iterator that has no elements. More precisely,  hasNext always returns false. next always throws NoSuchElementException. remove always throws IllegalStateException.  Implementations of this method are permitted, but not required, to return the same object from multiple invocations.
java.util.Collections.emptyList	(	):  Returns an empty list (immutable). This list is serializable. This example illustrates the type-safe way to obtain an empty list:  List<String> s = Collections.emptyList(); 
java.util.Collections.emptyListIterator	(	):  Returns a list iterator that has no elements. More precisely,  hasNext and hasPrevious always return false. next and previous always throw NoSuchElementException. remove and set always throw IllegalStateException. add always throws UnsupportedOperationException. nextIndex always returns 0. previousIndex always returns -1.  Implementations of this method are permitted, but not required, to return the same object from multiple invocations.
java.util.Collections.emptyMap	(	):  Returns an empty map (immutable). This map is serializable. This example illustrates the type-safe way to obtain an empty map:  Map<String, Date> s = Collections.emptyMap(); 
java.util.Collections.emptyNavigableMap	(	):  Returns an empty navigable map (immutable). This map is serializable. This example illustrates the type-safe way to obtain an empty map:  NavigableMap s = Collections.emptyNavigableMap();
java.util.Collections.emptyNavigableSet	(	):  Returns an empty navigable set (immutable). This set is serializable. This example illustrates the type-safe way to obtain an empty navigable set:  NavigableSet s = Collections.emptyNavigableSet();
java.util.Collections.emptySet	(	):  Returns an empty set (immutable). This set is serializable. Unlike the like-named field, this method is parameterized. This example illustrates the type-safe way to obtain an empty set:  Set<String> s = Collections.emptySet(); 
java.util.Collections.emptySortedMap	(	):  Returns an empty sorted map (immutable). This map is serializable. This example illustrates the type-safe way to obtain an empty map:  SortedMap s = Collections.emptySortedMap();
java.util.Collections.emptySortedSet	(	):  Returns an empty sorted set (immutable). This set is serializable. This example illustrates the type-safe way to obtain an empty sorted set:  SortedSet s = Collections.emptySortedSet();
java.util.Collections.enumeration	(	Collection	):  Returns an enumeration over the specified collection. This provides interoperability with legacy APIs that require an enumeration as input.
java.util.Collections.eq	(	Object	Object	):  Returns true if the specified arguments are equal, or both null. NB: Do not replace with Object.equals until JDK-8015417 is resolved.
java.util.Collections.fill	(	List	T	):  Replaces all of the elements of the specified list with the specified element.  This method runs in linear time.
java.util.Collections.frequency	(	Collection	Object	):  Returns the number of elements in the specified collection equal to the specified object. More formally, returns the number of elements e in the collection such that (o == null ? e == null : o.equals(e)).
java.util.Collections.get	(	ListIterator	int	):  Gets the ith element from the given list by repositioning the specified list listIterator.
java.util.Collections.indexOfSubList	(	List	List	):  Returns the starting position of the first occurrence of the specified target list within the specified source list, or -1 if there is no such occurrence. More formally, returns the lowest index i such that source.subList(i, i+target.size()).equals(target), or -1 if there is no such index. (Returns -1 if target.size() > source.size()) This implementation uses the "brute force" technique of scanning over the source list, looking for a match with the target at each location in turn.
java.util.Collections.lastIndexOfSubList	(	List	List	):  Returns the starting position of the last occurrence of the specified target list within the specified source list, or -1 if there is no such occurrence. More formally, returns the highest index i such that source.subList(i, i+target.size()).equals(target), or -1 if there is no such index. (Returns -1 if target.size() > source.size()) This implementation uses the "brute force" technique of iterating over the source list, looking for a match with the target at each location in turn.
java.util.Collections.list	(	Enumeration	):  Returns an array list containing the elements returned by the specified enumeration in the order they are returned by the enumeration. This method provides interoperability between legacy APIs that return enumerations and new APIs that require collections.
java.util.Collections.max	(	Collection	):  Returns the maximum element of the given collection, according to the natural ordering of its elements. All elements in the collection must implement the Comparable interface. Furthermore, all elements in the collection must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the collection). This method iterates over the entire collection, hence it requires time proportional to the size of the collection.
java.util.Collections.max	(	Collection	Comparator	):  Returns the maximum element of the given collection, according to the order induced by the specified comparator. All elements in the collection must be mutually comparable by the specified comparator (that is, comp.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the collection). This method iterates over the entire collection, hence it requires time proportional to the size of the collection.
java.util.Collections.min	(	Collection	):  Returns the minimum element of the given collection, according to the natural ordering of its elements. All elements in the collection must implement the Comparable interface. Furthermore, all elements in the collection must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the collection). This method iterates over the entire collection, hence it requires time proportional to the size of the collection.
java.util.Collections.min	(	Collection	Comparator	):  Returns the minimum element of the given collection, according to the order induced by the specified comparator. All elements in the collection must be mutually comparable by the specified comparator (that is, comp.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the collection). This method iterates over the entire collection, hence it requires time proportional to the size of the collection.
java.util.Collections.nCopies	(	int	T	):  Returns an immutable list consisting of n copies of the specified object. The newly allocated data object is tiny (it contains a single reference to the data object). This method is useful in combination with the List.addAll method to grow lists. The returned list is serializable.
java.util.Collections.newSetFromMap	(	Map	):  Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>()); 
java.util.Collections.replaceAll	(	List	T	T	):  Replaces all occurrences of one specified value in a list with another. More formally, replaces with newVal each element e in list such that (oldVal==null ? e==null : oldVal.equals(e)). (This method has no effect on the size of the list.)
java.util.Collections.reverse	(	List	):  Reverses the order of the elements in the specified list. This method runs in linear time.
java.util.Collections.reverseOrder	(	):  Returns a comparator that imposes the reverse of the natural ordering on a collection of objects that implement the Comparable interface. (The natural ordering is the ordering imposed by the objects' own compareTo method.) This enables a simple idiom for sorting (or maintaining) collections (or arrays) of objects that implement the Comparable interface in reverse-natural-order. For example, suppose a is an array of strings. Then:  Arrays.sort(a, Collections.reverseOrder());  sorts the array in reverse-lexicographic (alphabetical) order. The returned comparator is serializable.
java.util.Collections.reverseOrder	(	Comparator	):  Returns a comparator that imposes the reverse ordering of the specified comparator. If the specified comparator is null, this method is equivalent to reverseOrder() (in other words, it returns a comparator that imposes the reverse of the natural ordering on a collection of objects that implement the Comparable interface). The returned comparator is serializable (assuming the specified comparator is also serializable or null).
java.util.Collections.rotate	(	List	int	):  Rotates the elements in the specified list by the specified distance. After calling this method, the element at index i will be the element previously at index (i - distance) mod list.size(), for all values of i between 0 and list.size()-1, inclusive. (This method has no effect on the size of the list.) For example, suppose list comprises [t, a, n, k, s]. After invoking Collections.rotate(list, 1) (or Collections.rotate(list, -4)), list will comprise [s, t, a, n, k]. Note that this method can usefully be applied to sublists to move one or more elements within a list while preserving the order of the remaining elements. For example, the following idiom moves the element at index j forward to position k (which must be greater than or equal to j):  Collections.rotate(list.subList(j, k+1), -1);  To make this concrete, suppose list comprises [a, b, c, d, e]. To move the element at index 1 (b) forward two positions, perform the following invocation:  Collections.rotate(l.subList(1, 4), -1);  The resulting list is [a, c, d, b, e]. To move more than one element forward, increase the absolute value of the rotation distance. To move elements backward, use a positive shift distance. If the specified list is small or implements the RandomAccess interface, this implementation exchanges the first element into the location it should go, and then repeatedly exchanges the displaced element into the location it should go until a displaced element is swapped into the first element. If necessary, the process is repeated on the second and successive elements, until the rotation is complete. If the specified list is large and doesn't implement the RandomAccess interface, this implementation breaks the list into two sublist views around index -distance mod size. Then the reverse() method is invoked on each sublist view, and finally it is invoked on the entire list. For a more complete description of both algorithms, see Section 2.3 of Jon Bentley's Programming Pearls (Addison-Wesley, 1986).
java.util.Collections.shuffle	(	List	):  Randomly permutes the specified list using a default source of randomness. All permutations occur with approximately equal likelihood. The hedge "approximately" is used in the foregoing description because default source of randomness is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm would choose permutations with perfect uniformity. This implementation traverses the list backwards, from the last element up to the second, repeatedly swapping a randomly selected element into the "current position". Elements are randomly selected from the portion of the list that runs from the first element to the current position, inclusive. This method runs in linear time. If the specified list does not implement the RandomAccess interface and is large, this implementation dumps the specified list into an array before shuffling it, and dumps the shuffled array back into the list. This avoids the quadratic behavior that would result from shuffling a "sequential access" list in place.
java.util.Collections.shuffle	(	List	Random	):  Randomly permute the specified list using the specified source of randomness. All permutations occur with equal likelihood assuming that the source of randomness is fair. This implementation traverses the list backwards, from the last element up to the second, repeatedly swapping a randomly selected element into the "current position". Elements are randomly selected from the portion of the list that runs from the first element to the current position, inclusive. This method runs in linear time. If the specified list does not implement the RandomAccess interface and is large, this implementation dumps the specified list into an array before shuffling it, and dumps the shuffled array back into the list. This avoids the quadratic behavior that would result from shuffling a "sequential access" list in place.
java.util.Collections.singleton	(	T	):  Returns an immutable set containing only the specified object. The returned set is serializable.
java.util.Collections.singletonList	(	T	):  Returns an immutable list containing only the specified object. The returned list is serializable.
java.util.Collections.singletonMap	(	K	V	):  Returns an immutable map, mapping only the specified key to the specified value. The returned map is serializable.
java.util.Collections.singletonSpliterator	(	T	):  Creates a Spliterator with only the specified element
java.util.Collections.sort	(	List	):  Sorts the specified list into ascending order, according to the Comparable natural ordering of its elements. All elements in the list must implement the Comparable interface. Furthermore, all elements in the list must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the list). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The specified list must be modifiable, but need not be resizable.
java.util.Collections.sort	(	List	Comparator	):  Sorts the specified list according to the order induced by the specified comparator. All elements in the list must be mutually comparable using the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the list). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The specified list must be modifiable, but need not be resizable.
java.util.Collections.swap	(	List	int	int	):  Swaps the elements at the specified positions in the specified list. (If the specified positions are equal, invoking this method leaves the list unchanged.)
java.util.Collections.swap	(	Object[]	int	int	):  Swaps the two specified elements in the specified array.
java.util.Collections.synchronizedCollection	(	Collection	):  Returns a synchronized (thread-safe) collection backed by the specified collection. In order to guarantee serial access, it is critical that all access to the backing collection is accomplished through the returned collection. It is imperative that the user manually synchronize on the returned collection when traversing it via Iterator, Spliterator or Stream:  Collection c = Collections.synchronizedCollection(myCollection); ... synchronized (c) { Iterator i = c.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned collection does not pass the hashCode and equals operations through to the backing collection, but relies on Object's equals and hashCode methods. This is necessary to preserve the contracts of these operations in the case that the backing collection is a set or a list. The returned collection will be serializable if the specified collection is serializable.
java.util.Collections.synchronizedList	(	List	):  Returns a synchronized (thread-safe) list backed by the specified list. In order to guarantee serial access, it is critical that all access to the backing list is accomplished through the returned list. It is imperative that the user manually synchronize on the returned list when iterating over it:  List list = Collections.synchronizedList(new ArrayList()); ... synchronized (list) { Iterator i = list.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned list will be serializable if the specified list is serializable.
java.util.Collections.synchronizedMap	(	Map	):  Returns a synchronized (thread-safe) map backed by the specified map. In order to guarantee serial access, it is critical that all access to the backing map is accomplished through the returned map. It is imperative that the user manually synchronize on the returned map when iterating over any of its collection views:  Map m = Collections.synchronizedMap(new HashMap()); ... Set s = m.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not s! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned map will be serializable if the specified map is serializable.
java.util.Collections.synchronizedNavigableMap	(	NavigableMap	):  Returns a synchronized (thread-safe) navigable map backed by the specified navigable map. In order to guarantee serial access, it is critical that all access to the backing navigable map is accomplished through the returned navigable map (or its views). It is imperative that the user manually synchronize on the returned navigable map when iterating over any of its collection views, or the collections views of any of its subMap, headMap or tailMap views.  NavigableMap m = Collections.synchronizedNavigableMap(new TreeMap()); ... Set s = m.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not s! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  or:  NavigableMap m = Collections.synchronizedNavigableMap(new TreeMap()); NavigableMap m2 = m.subMap(foo, true, bar, false); ... Set s2 = m2.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not m2 or s2! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned navigable map will be serializable if the specified navigable map is serializable.
java.util.Collections.synchronizedNavigableSet	(	NavigableSet	):  Returns a synchronized (thread-safe) navigable set backed by the specified navigable set. In order to guarantee serial access, it is critical that all access to the backing navigable set is accomplished through the returned navigable set (or its views). It is imperative that the user manually synchronize on the returned navigable set when iterating over it or any of its subSet, headSet, or tailSet views.  NavigableSet s = Collections.synchronizedNavigableSet(new TreeSet()); ... synchronized (s) { Iterator i = s.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  or:  NavigableSet s = Collections.synchronizedNavigableSet(new TreeSet()); NavigableSet s2 = s.headSet(foo, true); ... synchronized (s) { // Note: s, not s2!!! Iterator i = s2.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned navigable set will be serializable if the specified navigable set is serializable.
java.util.Collections.synchronizedSet	(	Set	):  Returns a synchronized (thread-safe) set backed by the specified set. In order to guarantee serial access, it is critical that all access to the backing set is accomplished through the returned set. It is imperative that the user manually synchronize on the returned set when iterating over it:  Set s = Collections.synchronizedSet(new HashSet()); ... synchronized (s) { Iterator i = s.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned set will be serializable if the specified set is serializable.
java.util.Collections.synchronizedSortedMap	(	SortedMap	):  Returns a synchronized (thread-safe) sorted map backed by the specified sorted map. In order to guarantee serial access, it is critical that all access to the backing sorted map is accomplished through the returned sorted map (or its views). It is imperative that the user manually synchronize on the returned sorted map when iterating over any of its collection views, or the collections views of any of its subMap, headMap or tailMap views.  SortedMap m = Collections.synchronizedSortedMap(new TreeMap()); ... Set s = m.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not s! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  or:  SortedMap m = Collections.synchronizedSortedMap(new TreeMap()); SortedMap m2 = m.subMap(foo, bar); ... Set s2 = m2.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not m2 or s2! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned sorted map will be serializable if the specified sorted map is serializable.
java.util.Collections.synchronizedSortedSet	(	SortedSet	):  Returns a synchronized (thread-safe) sorted set backed by the specified sorted set. In order to guarantee serial access, it is critical that all access to the backing sorted set is accomplished through the returned sorted set (or its views). It is imperative that the user manually synchronize on the returned sorted set when iterating over it or any of its subSet, headSet, or tailSet views.  SortedSet s = Collections.synchronizedSortedSet(new TreeSet()); ... synchronized (s) { Iterator i = s.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  or:  SortedSet s = Collections.synchronizedSortedSet(new TreeSet()); SortedSet s2 = s.headSet(foo); ... synchronized (s) { // Note: s, not s2!!! Iterator i = s2.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned sorted set will be serializable if the specified sorted set is serializable.
java.util.Collections.unmodifiableCollection	(	Collection	):  Returns an unmodifiable view of the specified collection. This method allows modules to provide users with "read-only" access to internal collections. Query operations on the returned collection "read through" to the specified collection, and attempts to modify the returned collection, whether direct or via its iterator, result in an UnsupportedOperationException. The returned collection does not pass the hashCode and equals operations through to the backing collection, but relies on Object's equals and hashCode methods. This is necessary to preserve the contracts of these operations in the case that the backing collection is a set or a list. The returned collection will be serializable if the specified collection is serializable.
java.util.Collections.unmodifiableList	(	List	):  Returns an unmodifiable view of the specified list. This method allows modules to provide users with "read-only" access to internal lists. Query operations on the returned list "read through" to the specified list, and attempts to modify the returned list, whether direct or via its iterator, result in an UnsupportedOperationException. The returned list will be serializable if the specified list is serializable. Similarly, the returned list will implement RandomAccess if the specified list does.
java.util.Collections.unmodifiableMap	(	Map	):  Returns an unmodifiable view of the specified map. This method allows modules to provide users with "read-only" access to internal maps. Query operations on the returned map "read through" to the specified map, and attempts to modify the returned map, whether direct or via its collection views, result in an UnsupportedOperationException. The returned map will be serializable if the specified map is serializable.
java.util.Collections.unmodifiableNavigableMap	(	NavigableMap	):  Returns an unmodifiable view of the specified navigable map. This method allows modules to provide users with "read-only" access to internal navigable maps. Query operations on the returned navigable map "read through" to the specified navigable map. Attempts to modify the returned navigable map, whether direct, via its collection views, or via its subMap, headMap, or tailMap views, result in an UnsupportedOperationException. The returned navigable map will be serializable if the specified navigable map is serializable.
java.util.Collections.unmodifiableNavigableSet	(	NavigableSet	):  Returns an unmodifiable view of the specified navigable set. This method allows modules to provide users with "read-only" access to internal navigable sets. Query operations on the returned navigable set "read through" to the specified navigable set. Attempts to modify the returned navigable set, whether direct, via its iterator, or via its subSet, headSet, or tailSet views, result in an UnsupportedOperationException. The returned navigable set will be serializable if the specified navigable set is serializable.
java.util.Collections.unmodifiableSet	(	Set	):  Returns an unmodifiable view of the specified set. This method allows modules to provide users with "read-only" access to internal sets. Query operations on the returned set "read through" to the specified set, and attempts to modify the returned set, whether direct or via its iterator, result in an UnsupportedOperationException. The returned set will be serializable if the specified set is serializable.
java.util.Collections.unmodifiableSortedMap	(	SortedMap	):  Returns an unmodifiable view of the specified sorted map. This method allows modules to provide users with "read-only" access to internal sorted maps. Query operations on the returned sorted map "read through" to the specified sorted map. Attempts to modify the returned sorted map, whether direct, via its collection views, or via its subMap, headMap, or tailMap views, result in an UnsupportedOperationException. The returned sorted map will be serializable if the specified sorted map is serializable.
java.util.Collections.unmodifiableSortedSet	(	SortedSet	):  Returns an unmodifiable view of the specified sorted set. This method allows modules to provide users with "read-only" access to internal sorted sets. Query operations on the returned sorted set "read through" to the specified sorted set. Attempts to modify the returned sorted set, whether direct, via its iterator, or via its subSet, headSet, or tailSet views, result in an UnsupportedOperationException. The returned sorted set will be serializable if the specified sorted set is serializable.