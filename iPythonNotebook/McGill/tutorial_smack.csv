,"Data Forms","Create a Form to fill out","<div class=""subheader""><h3> 
 <a name=""gather"">Create a Form to fill out</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> An XMPP entity may need to gather data from another XMPP entity. Therefore, the data-gathering entity will need to create a new Form, specify the fields that will conform the Form and finally send the Form to the data-providing entity.</p> 
<b>Usage</b> 
<p> In order to create a Form to fill out use the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.Form"" api=""Form"" kind=""class"">
     Form 
   </clt></b></i>'s constructor passing the constant <b> 
  <clt fqn=""org.jivesoftware.smackx.Form"" api=""Form"" kind=""class"">
    Form.TYPE_FORM 
  </clt></b> as the parameter. The next step is to create the form fields and add them to the form. In order to create and customize a <i><b> 
   <clt fqn=""org.jivesoftware.smackx.FormField"" api=""FormField"" kind=""class"">
     FormField 
   </clt></b></i> use the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.FormField"" api=""FormField"" kind=""class"">
     FormField 
   </clt></b></i>'s constructor specifying the variable name of the field as the parameter. Then use <b> 
  <clt fqn=""org.jivesoftware.smackx.FormField.setType"" api=""FormField"" kind=""method"">
   FormField.setType(String type)
  </clt></b> to set the field's type (e.g. FormField.TYPE_HIDDEN, FormField.TYPE_TEXT_SINGLE). Once we have the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.Form"" api=""Form"" kind=""class"">
     Form 
   </clt></b></i> instance and the <i><b>FormFields</b></i> the last step is to send <b> 
  <clt fqn=""org.jivesoftware.smackx.Form.addField"" api=""Form"" kind=""method"">
   Form.addField(FormField field)
  </clt></b> for each field that we want to add to the form.</p> 
<p> Once the form to fill out is finished we will want to send it in a message. Send <b> 
  <clt fqn=""org.jivesoftware.smackx.Form.getDataFormToSend"" api=""Form"" kind=""method"">
   Form.getDataFormToSend()
  </clt></b> to the form and add the answer as an extension to the message to send.</p> 
<b>Examples</b> 
<p> In this example we can see how to create and send a form to fill out: </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Create a new form to gather data</font>
Form formToSend = new Form(Form.TYPE_FORM);
formToSend.setInstructions(
&quot;Fill out this form to report your case.\nThe case will be created automatically.&quot;);
formToSend.setTitle(&quot;Case configurations&quot;);
<font color=""#3f7f5f"">// Add a hidden variable to the form</font>
FormField field = new FormField(&quot;hidden_var&quot;);
field.setType(FormField.TYPE_HIDDEN);
field.addValue(&quot;Some value for the hidden variable&quot;);
formToSend.addField(field);
<font color=""#3f7f5f"">// Add a fixed variable to the form</font>
field = new FormField();
field.addValue(&quot;Section 1: Case description&quot;);
formToSend.addField(field);
<font color=""#3f7f5f"">// Add a text-single variable to the form</font>
field = new FormField(&quot;name&quot;);
field.setLabel(&quot;Enter a name for the case&quot;);
field.setType(FormField.TYPE_TEXT_SINGLE);
formToSend.addField(field);
<font color=""#3f7f5f"">// Add a text-multi variable to the form</font>
field = new FormField(&quot;description&quot;);
field.setLabel(&quot;Enter a description&quot;);
field.setType(FormField.TYPE_TEXT_MULTI);
formToSend.addField(field);
<font color=""#3f7f5f"">// Create a chat with &quot;user2@host.com&quot;</font>
Chat chat = conn1.createChat(&quot;user2@host.com&quot; );
Message msg = chat.createMessage();
msg.setBody(&quot;To enter a case please fill out this form and send it back to me&quot;);
<font color=""#3f7f5f"">// Add the form to fill out to the message to send</font>
msg.addExtension(formToSend.getDataFormToSend());
<font color=""#3f7f5f"">// Send the message with the form to fill out</font>
chat.sendMessage(msg);
</pre> 
</blockquote>","Form","org.jivesoftware.smackx.Form","class",1
,"Data Forms","Create a Form to fill out","<div class=""subheader""><h3> 
 <a name=""gather"">Create a Form to fill out</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> An XMPP entity may need to gather data from another XMPP entity. Therefore, the data-gathering entity will need to create a new Form, specify the fields that will conform the Form and finally send the Form to the data-providing entity.</p> 
<b>Usage</b> 
<p> In order to create a Form to fill out use the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.Form"" api=""Form"" kind=""class"">
     Form 
   </clt></b></i>'s constructor passing the constant <b> 
  <clt fqn=""org.jivesoftware.smackx.Form"" api=""Form"" kind=""class"">
    Form.TYPE_FORM 
  </clt></b> as the parameter. The next step is to create the form fields and add them to the form. In order to create and customize a <i><b> 
   <clt fqn=""org.jivesoftware.smackx.FormField"" api=""FormField"" kind=""class"">
     FormField 
   </clt></b></i> use the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.FormField"" api=""FormField"" kind=""class"">
     FormField 
   </clt></b></i>'s constructor specifying the variable name of the field as the parameter. Then use <b> 
  <clt fqn=""org.jivesoftware.smackx.FormField.setType"" api=""FormField"" kind=""method"">
   FormField.setType(String type)
  </clt></b> to set the field's type (e.g. FormField.TYPE_HIDDEN, FormField.TYPE_TEXT_SINGLE). Once we have the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.Form"" api=""Form"" kind=""class"">
     Form 
   </clt></b></i> instance and the <i><b>FormFields</b></i> the last step is to send <b> 
  <clt fqn=""org.jivesoftware.smackx.Form.addField"" api=""Form"" kind=""method"">
   Form.addField(FormField field)
  </clt></b> for each field that we want to add to the form.</p> 
<p> Once the form to fill out is finished we will want to send it in a message. Send <b> 
  <clt fqn=""org.jivesoftware.smackx.Form.getDataFormToSend"" api=""Form"" kind=""method"">
   Form.getDataFormToSend()
  </clt></b> to the form and add the answer as an extension to the message to send.</p> 
<b>Examples</b> 
<p> In this example we can see how to create and send a form to fill out: </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Create a new form to gather data</font>
Form formToSend = new Form(Form.TYPE_FORM);
formToSend.setInstructions(
&quot;Fill out this form to report your case.\nThe case will be created automatically.&quot;);
formToSend.setTitle(&quot;Case configurations&quot;);
<font color=""#3f7f5f"">// Add a hidden variable to the form</font>
FormField field = new FormField(&quot;hidden_var&quot;);
field.setType(FormField.TYPE_HIDDEN);
field.addValue(&quot;Some value for the hidden variable&quot;);
formToSend.addField(field);
<font color=""#3f7f5f"">// Add a fixed variable to the form</font>
field = new FormField();
field.addValue(&quot;Section 1: Case description&quot;);
formToSend.addField(field);
<font color=""#3f7f5f"">// Add a text-single variable to the form</font>
field = new FormField(&quot;name&quot;);
field.setLabel(&quot;Enter a name for the case&quot;);
field.setType(FormField.TYPE_TEXT_SINGLE);
formToSend.addField(field);
<font color=""#3f7f5f"">// Add a text-multi variable to the form</font>
field = new FormField(&quot;description&quot;);
field.setLabel(&quot;Enter a description&quot;);
field.setType(FormField.TYPE_TEXT_MULTI);
formToSend.addField(field);
<font color=""#3f7f5f"">// Create a chat with &quot;user2@host.com&quot;</font>
Chat chat = conn1.createChat(&quot;user2@host.com&quot; );
Message msg = chat.createMessage();
msg.setBody(&quot;To enter a case please fill out this form and send it back to me&quot;);
<font color=""#3f7f5f"">// Add the form to fill out to the message to send</font>
msg.addExtension(formToSend.getDataFormToSend());
<font color=""#3f7f5f"">// Send the message with the form to fill out</font>
chat.sendMessage(msg);
</pre> 
</blockquote>","FormField","org.jivesoftware.smackx.FormField","class",1
,"Data Forms","Answer a Form","<div class=""subheader""> <h3>
 <a name=""fillout"">Answer a Form</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> Under many situations an XMPP entity could receive a form to fill out. For example, some hosts may require to fill out a form in order to register new users. Smack lets the data-providing entity to complete the form in an easy way and send it back to the data-gathering entity.</p> 
<b>Usage</b> 
<p> The form to fill out contains useful information that could be used for rendering the form. But it cannot be used to actually complete it. Instead it's necessary to create a new form based on the original form whose purpose is to hold all the answers.</p> 
<p> In order to create a new <i><b> 
   <clt fqn=""org.jivesoftware.smackx.Form"" api=""Form"" kind=""class"">
     Form 
   </clt></b></i> to complete based on the original <i><b> 
   <clt fqn=""org.jivesoftware.smackx.Form"" api=""Form"" kind=""class"">
     Form 
   </clt></b></i> just send <b> 
  <clt fqn=""org.jivesoftware.smackx.Form.createAnswerForm"" api=""Form"" kind=""method"">
   Form.createAnswerForm()
  </clt></b> to the original <i><b> 
   <clt fqn=""org.jivesoftware.smackx.Form"" api=""Form"" kind=""class"">
     Form 
   </clt></b></i>. Once you have a valid form that could be actually completed all you have to do is send <b> 
  <clt fqn=""org.jivesoftware.smackx.Form.setAnswer"" api=""Form"" kind=""method"">
   Form.setAnswer(String variable, String value)
  </clt></b> to the form where variable is the variable of the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.FormField"" api=""FormField"" kind=""class"">
     FormField 
   </clt></b></i> that you want to answer and value is the String representation of the answer. If the answer consist of several values you could then use <b> 
  <clt fqn=""org.jivesoftware.smackx.Form.setAnswer"" api=""Form"" kind=""method"">
   Form.setAnswer(String variable, List values)
  </clt></b> where values is a List of Strings.</p>","Form","org.jivesoftware.smackx.Form","class",1
,"Data Forms","Answer a Form","<div class=""subheader""> <h3>
 <a name=""fillout"">Answer a Form</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> Under many situations an XMPP entity could receive a form to fill out. For example, some hosts may require to fill out a form in order to register new users. Smack lets the data-providing entity to complete the form in an easy way and send it back to the data-gathering entity.</p> 
<b>Usage</b> 
<p> The form to fill out contains useful information that could be used for rendering the form. But it cannot be used to actually complete it. Instead it's necessary to create a new form based on the original form whose purpose is to hold all the answers.</p> 
<p> In order to create a new <i><b> 
   <clt fqn=""org.jivesoftware.smackx.Form"" api=""Form"" kind=""class"">
     Form 
   </clt></b></i> to complete based on the original <i><b> 
   <clt fqn=""org.jivesoftware.smackx.Form"" api=""Form"" kind=""class"">
     Form 
   </clt></b></i> just send <b> 
  <clt fqn=""org.jivesoftware.smackx.Form.createAnswerForm"" api=""Form"" kind=""method"">
   Form.createAnswerForm()
  </clt></b> to the original <i><b> 
   <clt fqn=""org.jivesoftware.smackx.Form"" api=""Form"" kind=""class"">
     Form 
   </clt></b></i>. Once you have a valid form that could be actually completed all you have to do is send <b> 
  <clt fqn=""org.jivesoftware.smackx.Form.setAnswer"" api=""Form"" kind=""method"">
   Form.setAnswer(String variable, String value)
  </clt></b> to the form where variable is the variable of the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.FormField"" api=""FormField"" kind=""class"">
     FormField 
   </clt></b></i> that you want to answer and value is the String representation of the answer. If the answer consist of several values you could then use <b> 
  <clt fqn=""org.jivesoftware.smackx.Form.setAnswer"" api=""Form"" kind=""method"">
   Form.setAnswer(String variable, List values)
  </clt></b> where values is a List of Strings.</p>","FormField","org.jivesoftware.smackx.FormField","class",0
,"Data Forms","Answer a Form - part 2","<h3>Answer a Form - part 2</h3>
<p> Once the form has been completed we will want to send it back in a message. Send <b> 
  <clt fqn=""org.jivesoftware.smackx.Form.getDataFormToSend"" api=""Form"" kind=""method"">
   Form.getDataFormToSend()
  </clt></b> to the form and add the answer as an extension to the message to send back.</p> 
<b>Examples</b> 
<p> In this example we can see how to retrieve a form to fill out, complete the form and send it back: </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Get the message with the form to fill out</font>
Message msg2 = chat2.nextMessage();
<font color=""#3f7f5f"">// Retrieve the form to fill out from the message</font>
Form formToRespond = Form.getFormFrom(msg2);
<font color=""#3f7f5f"">// Obtain the form to send with the replies</font>
Form completedForm = formToRespond.createAnswerForm();
<font color=""#3f7f5f"">// Add the answers to the form</font>
completedForm.setAnswer(&quot;name&quot;, &quot;Credit card number invalid&quot;);
completedForm.setAnswer(
&quot;description&quot;,
&quot;The ATM says that my credit card number is invalid. What's going on?&quot;);
msg2 = chat2.createMessage();
msg2.setBody(&quot;To enter a case please fill out this form and send it back to me&quot;);
<font color=""#3f7f5f"">// Add the completed form to the message to send back</font>
msg2.addExtension(completedForm.getDataFormToSend());
<font color=""#3f7f5f"">// Send the message with the completed form</font>
chat2.sendMessage(msg2);
</pre> 
</blockquote>","Form","org.jivesoftware.smackx.Form","class",1
,"File Transfer","Send a file to another user","<div class=""subheader""> <h3>
 <a name=""sendfile"">Send a file to another user</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> A user may wish to send a file to another user. The other user has the option of acception, rejecting, or ignoring the users request. Smack provides a simple interface in order to enable the user to easily send a file. <b>Usage</b></p> 
<p> In order to send a file you must first construct an instance of the <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransferManager"" api=""FileTransferManager"" kind=""class"">
     FileTransferManager 
   </clt></i></b> class. This class has one constructor with one parameter which is your Connection. In order to instantiate the manager you should call <i> 
  <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransferManager.FileTransferManager"" api=""FileTransferManager"" kind=""method"">
   new FileTransferManager.FileTransferManager(connection)
  </clt></i> </p> 
<p>Once you have your <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransferManager"" api=""FileTransferManager"" kind=""class"">
     FileTransferManager 
   </clt></i></b> you will need to create an outgoing file transfer to send a file. The method to use on the <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransferManager"" api=""FileTransferManager"" kind=""class"">
     FileTransferManager 
   </clt></i></b> is the <b> 
  <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransferManager.createOutgoingFileTransfer"" api=""FileTransferManager"" kind=""method"">
   FileTransferManager.createOutgoingFileTransfer(userID)
  </clt></b> method. The userID you provide to this method is the fully-qualified jabber ID of the user you wish to send the file to. A fully-qualified jabber ID consists of a node, a domain, and a resource, the user must be connected to the resource in order to be able to recieve the file transfer. </p>","FileTransferManager","org.jivesoftware.smackx.filetransfer.FileTransferManager","class",1
,"File Transfer","Send a file to another user - part 2","<h3>Send a file to another user - part 2</h3>
<p>Now that you have your <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.OutgoingFileTransfer"" api=""OutgoingFileTransfer"" kind=""class"">
     OutgoingFileTransfer 
   </clt></i></b> instance you will want to send the file. The method to send a file is <b> 
  <clt fqn=""org.jivesoftware.smackx.filetransfer.OutgoingFileTransfer.sendFile"" api=""OutgoingFileTransfer"" kind=""method"">
   OutgoingFileTransfer.sendFile(file, description)
  </clt></b>. The file you provide to this method should be a readable file on the local file system, and the description is a short description of the file to help the user decide whether or not they would like to recieve the file. </p> 
<p>For information on monitoring the progress of a file transfer see the <a href=""#monitorprogress"">monitoring progress</a> section of this document. </p> 
<p>Other means to send a file are also provided as part of the <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.OutgoingFileTransfer"" api=""OutgoingFileTransfer"" kind=""class"">
     OutgoingFileTransfer 
   </clt></i></b>. Please consult the Javadoc for more information. <b>Examples</b></p> 
<p> In this example we can see how to send a file: </p> 
<blockquote> 
 <pre>
<font color=""#3f7f5f"">// Create the file transfer manager</font>
FileTransferManager manager = new FileTransferManager(connection);
<font color=""#3f7f5f"">// Create the outgoing file transfer</font>
OutgoingFileTransfer transfer = manager.createOutgoingFileTransfer(<font color=""#0000FF"">&quot;romeo@montague.net&quot;</font>);
<font color=""#3f7f5f"">// Send the file</font>
transfer.sendFile(new File(<font color=""#0000FF"">&quot;shakespeare_complete_works.txt&quot;</font>), <font color=""#0000FF"">&quot;You won't believe this!&quot;</font>);
</pre> 
</blockquote>","OutgoingFileTransfer","org.jivesoftware.smackx.filetransfer.OutgoingFileTransfer","class",1
,"File Transfer","Recieving a file from another user","<div class=""subheader""> <h3>
 <a name=""recievefile"">Recieving a file from another user</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> The user may wish to recieve files from another user. The process of recieving a file is event driven, new file transfer requests are recieved from other users via a listener registered with the file transfer manager.</p> 
<b>Usage</b> 
<p> In order to recieve a file you must first construct an instance of the <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransferManager"" api=""FileTransferManager"" kind=""class"">
     FileTransferManager 
   </clt></i></b> class. This class has one constructor with one parameter which is your Connection. In order to instantiate the manager you should call <i> 
  <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransferManager.FileTransferManager"" api=""FileTransferManager"" kind=""method"">
   new FileTransferManager.FileTransferManager(connection)
  </clt></i> </p> 
<p>Once you have your <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransferManager"" api=""FileTransferManager"" kind=""class"">
     FileTransferManager 
   </clt></i></b> you will need to register a listener with it. The FileTransferListner interface has one method, <b> 
  <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransferListener.fileTransferRequest"" api=""FileTransferListener"" kind=""method"">
   FileTransferListener.fileTransferRequest(request)
  </clt></b>. When a request is recieved through this method, you can either accept or reject the request. To help you make your decision there are several methods in the <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransferRequest"" api=""FileTransferRequest"" kind=""class"">
     FileTransferRequest 
   </clt></i></b> class that return information about the transfer request. </p>","FileTransferManager","org.jivesoftware.smackx.filetransfer.FileTransferManager","class",1
,"File Transfer","Recieving a file from another user","<div class=""subheader""> <h3>
 <a name=""recievefile"">Recieving a file from another user</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> The user may wish to recieve files from another user. The process of recieving a file is event driven, new file transfer requests are recieved from other users via a listener registered with the file transfer manager.</p> 
<b>Usage</b> 
<p> In order to recieve a file you must first construct an instance of the <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransferManager"" api=""FileTransferManager"" kind=""class"">
     FileTransferManager 
   </clt></i></b> class. This class has one constructor with one parameter which is your Connection. In order to instantiate the manager you should call <i> 
  <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransferManager.FileTransferManager"" api=""FileTransferManager"" kind=""method"">
   new FileTransferManager.FileTransferManager(connection)
  </clt></i> </p> 
<p>Once you have your <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransferManager"" api=""FileTransferManager"" kind=""class"">
     FileTransferManager 
   </clt></i></b> you will need to register a listener with it. The FileTransferListner interface has one method, <b> 
  <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransferListener.fileTransferRequest"" api=""FileTransferListener"" kind=""method"">
   FileTransferListener.fileTransferRequest(request)
  </clt></b>. When a request is recieved through this method, you can either accept or reject the request. To help you make your decision there are several methods in the <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransferRequest"" api=""FileTransferRequest"" kind=""class"">
     FileTransferRequest 
   </clt></i></b> class that return information about the transfer request. </p>","FileTransferListener","org.jivesoftware.smackx.filetransfer.FileTransferListener","class",1
,"File Transfer","Recieving a file from another user","<div class=""subheader""> <h3>
 <a name=""recievefile"">Recieving a file from another user</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> The user may wish to recieve files from another user. The process of recieving a file is event driven, new file transfer requests are recieved from other users via a listener registered with the file transfer manager.</p> 
<b>Usage</b> 
<p> In order to recieve a file you must first construct an instance of the <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransferManager"" api=""FileTransferManager"" kind=""class"">
     FileTransferManager 
   </clt></i></b> class. This class has one constructor with one parameter which is your Connection. In order to instantiate the manager you should call <i> 
  <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransferManager.FileTransferManager"" api=""FileTransferManager"" kind=""method"">
   new FileTransferManager.FileTransferManager(connection)
  </clt></i> </p> 
<p>Once you have your <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransferManager"" api=""FileTransferManager"" kind=""class"">
     FileTransferManager 
   </clt></i></b> you will need to register a listener with it. The FileTransferListner interface has one method, <b> 
  <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransferListener.fileTransferRequest"" api=""FileTransferListener"" kind=""method"">
   FileTransferListener.fileTransferRequest(request)
  </clt></b>. When a request is recieved through this method, you can either accept or reject the request. To help you make your decision there are several methods in the <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransferRequest"" api=""FileTransferRequest"" kind=""class"">
     FileTransferRequest 
   </clt></i></b> class that return information about the transfer request. </p>","FileTransferRequest","org.jivesoftware.smackx.filetransfer.FileTransferRequest","class",0
,"File Transfer","Recieving a file from another user - part 2","<h3>Recieving a file from another user - part 2</h3>
<p>To accept the file transfer, call the <b> 
  <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransferRequest.accept"" api=""FileTransferRequest"" kind=""method"">
   FileTransferRequest.accept()
  </clt></b>, this method will create an <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.IncomingFileTransfer"" api=""IncomingFileTransfer"" kind=""class"">
     IncomingFileTransfer 
   </clt></i></b>. After you have the file transfer you may start to transfer the file by calling the <b> 
  <clt fqn=""org.jivesoftware.smackx.filetransfer.IncomingFileTransfer.recieveFile"" api=""IncomingFileTransfer"" kind=""method"">
   IncomingFileTransfer.recieveFile(file)
  </clt></b> method. The file provided to this method will be where the data from thefile transfer is saved.</p> 
<p>Finally, to reject the file transfer the only method you need to call is <b> 
  <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransferRequest.reject"" api=""FileTransferRequest"" kind=""method"">
   FileTransferRequest.reject()
  </clt></b> on the <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.IncomingFileTransfer"" api=""IncomingFileTransfer"" kind=""class"">
     IncomingFileTransfer 
   </clt></i></b>. </p> 
<p>For information on monitoring the progress of a file transfer see the <a href=""#monitorprogress"">monitoring progress</a> section of this document. </p> 
<p>Other means to recieve a file are also provided as part of the <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.IncomingFileTransfer"" api=""IncomingFileTransfer"" kind=""class"">
     IncomingFileTransfer 
   </clt></i></b>. Please consult the Javadoc for more information. <b>Examples</b></p> 
<p> In this example we can see how to approve or reject a file transfer request: </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Create the file transfer manager</font>
final FileTransferManager manager = new FileTransferManager(connection);
<font color=""#3f7f5f"">// Create the listener</font>
manager.addFileTransferListener(new FileTransferListener() {
public void fileTransferRequest(FileTransferRequest request) {
<font color=""#3f7f5f"">// Check to see if the request should be accepted</font>
if(shouldAccept(request)) {
<font color=""#3f7f5f"">// Accept it</font>
IncomingFileTransfer transfer = request.accept();
transfer.recieveFile(new File(<font color=""#0000FF"">&quot;shakespeare_complete_works.txt&quot;</font>));
} else {
<font color=""#3f7f5f"">// Reject it</font>
request.reject();
}
}
});
</pre> 
</blockquote>","FileTransferRequest","org.jivesoftware.smackx.filetransfer.FileTransferRequest","class",1
,"File Transfer","Recieving a file from another user - part 2","<h3>Recieving a file from another user - part 2</h3>
<p>To accept the file transfer, call the <b> 
  <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransferRequest.accept"" api=""FileTransferRequest"" kind=""method"">
   FileTransferRequest.accept()
  </clt></b>, this method will create an <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.IncomingFileTransfer"" api=""IncomingFileTransfer"" kind=""class"">
     IncomingFileTransfer 
   </clt></i></b>. After you have the file transfer you may start to transfer the file by calling the <b> 
  <clt fqn=""org.jivesoftware.smackx.filetransfer.IncomingFileTransfer.recieveFile"" api=""IncomingFileTransfer"" kind=""method"">
   IncomingFileTransfer.recieveFile(file)
  </clt></b> method. The file provided to this method will be where the data from thefile transfer is saved.</p> 
<p>Finally, to reject the file transfer the only method you need to call is <b> 
  <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransferRequest.reject"" api=""FileTransferRequest"" kind=""method"">
   FileTransferRequest.reject()
  </clt></b> on the <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.IncomingFileTransfer"" api=""IncomingFileTransfer"" kind=""class"">
     IncomingFileTransfer 
   </clt></i></b>. </p> 
<p>For information on monitoring the progress of a file transfer see the <a href=""#monitorprogress"">monitoring progress</a> section of this document. </p> 
<p>Other means to recieve a file are also provided as part of the <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.IncomingFileTransfer"" api=""IncomingFileTransfer"" kind=""class"">
     IncomingFileTransfer 
   </clt></i></b>. Please consult the Javadoc for more information. <b>Examples</b></p> 
<p> In this example we can see how to approve or reject a file transfer request: </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Create the file transfer manager</font>
final FileTransferManager manager = new FileTransferManager(connection);
<font color=""#3f7f5f"">// Create the listener</font>
manager.addFileTransferListener(new FileTransferListener() {
public void fileTransferRequest(FileTransferRequest request) {
<font color=""#3f7f5f"">// Check to see if the request should be accepted</font>
if(shouldAccept(request)) {
<font color=""#3f7f5f"">// Accept it</font>
IncomingFileTransfer transfer = request.accept();
transfer.recieveFile(new File(<font color=""#0000FF"">&quot;shakespeare_complete_works.txt&quot;</font>));
} else {
<font color=""#3f7f5f"">// Reject it</font>
request.reject();
}
}
});
</pre> 
</blockquote>","IncomingFileTransfer","org.jivesoftware.smackx.filetransfer.IncomingFileTransfer","class",1
,"File Transfer","Monitoring the progress of a file transfer","<div class=""subheader""><h3> 
 <a name=""monitorprogress"">Monitoring the progress of a file transfer</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> While a file transfer is in progress you may wish to monitor the progress of a file transfer.</p> 
<b>Usage</b> 
<p>Both the <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.IncomingFileTransfer"" api=""IncomingFileTransfer"" kind=""class"">
     IncomingFileTransfer 
   </clt></i></b> and the <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.OutgoingFileTransfer"" api=""OutgoingFileTransfer"" kind=""class"">
     OutgoingFileTransfer 
   </clt></i></b> extend the <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransfer"" api=""FileTransfer"" kind=""class"">
     FileTransfer 
   </clt></i></b> class which provides several methods to monitor how a file transfer is progressing: </p> 
<ul> 
 <li><b> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransfer.getStatus"" api=""FileTransfer"" kind=""method"">
    FileTransfer.getStatus()
   </clt></b> - The file transfer can be in several states, negotiating, rejected, canceled, in progress, error, and complete. This method will return which state the file transfer is currently in. </li> 
 <li><b> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransfer.getProgress"" api=""FileTransfer"" kind=""method"">
    FileTransfer.getProgress()
   </clt></b> - if the status of the file transfer is in progress this method will return a number between 0 and 1, 0 being the transfer has not yet started and 1 being the transfer is complete. It may also return a -1 if the transfer is not in progress. </li> 
 <li><b> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransfer.isDone"" api=""FileTransfer"" kind=""method"">
    FileTransfer.isDone()
   </clt></b> - Similar to getProgress() except it returns a <i>boolean</i>. If the state is rejected, canceled, error, or complete then true will be returned and false otherwise. </li> 
 <li><b> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransfer.getError"" api=""FileTransfer"" kind=""method"">
    FileTransfer.getError()
   </clt></b> - If there is an error during the file transfer this method will return the type of error that occured. </li> 
</ul> 
<b>Examples</b> 
<p> In this example we can see how to monitor a file transfer: </p> 
<blockquote> 
 <pre>      while(!transfer.isDone()) {
if(transfer.getStatus().equals(Status.ERROR)) {
System.out.println(<font color=""#0000FF"">&quot;ERROR!!! &quot;</font> + transfer.getError());
} else {
System.out.println(transfer.getStatus());
System.out.println(transfer.getProgress());
}
sleep(1000);
}
</pre> 
</blockquote>","IncomingFileTransfer","org.jivesoftware.smackx.filetransfer.IncomingFileTransfer","class",0
,"File Transfer","Monitoring the progress of a file transfer","<div class=""subheader""><h3> 
 <a name=""monitorprogress"">Monitoring the progress of a file transfer</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> While a file transfer is in progress you may wish to monitor the progress of a file transfer.</p> 
<b>Usage</b> 
<p>Both the <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.IncomingFileTransfer"" api=""IncomingFileTransfer"" kind=""class"">
     IncomingFileTransfer 
   </clt></i></b> and the <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.OutgoingFileTransfer"" api=""OutgoingFileTransfer"" kind=""class"">
     OutgoingFileTransfer 
   </clt></i></b> extend the <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransfer"" api=""FileTransfer"" kind=""class"">
     FileTransfer 
   </clt></i></b> class which provides several methods to monitor how a file transfer is progressing: </p> 
<ul> 
 <li><b> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransfer.getStatus"" api=""FileTransfer"" kind=""method"">
    FileTransfer.getStatus()
   </clt></b> - The file transfer can be in several states, negotiating, rejected, canceled, in progress, error, and complete. This method will return which state the file transfer is currently in. </li> 
 <li><b> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransfer.getProgress"" api=""FileTransfer"" kind=""method"">
    FileTransfer.getProgress()
   </clt></b> - if the status of the file transfer is in progress this method will return a number between 0 and 1, 0 being the transfer has not yet started and 1 being the transfer is complete. It may also return a -1 if the transfer is not in progress. </li> 
 <li><b> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransfer.isDone"" api=""FileTransfer"" kind=""method"">
    FileTransfer.isDone()
   </clt></b> - Similar to getProgress() except it returns a <i>boolean</i>. If the state is rejected, canceled, error, or complete then true will be returned and false otherwise. </li> 
 <li><b> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransfer.getError"" api=""FileTransfer"" kind=""method"">
    FileTransfer.getError()
   </clt></b> - If there is an error during the file transfer this method will return the type of error that occured. </li> 
</ul> 
<b>Examples</b> 
<p> In this example we can see how to monitor a file transfer: </p> 
<blockquote> 
 <pre>      while(!transfer.isDone()) {
if(transfer.getStatus().equals(Status.ERROR)) {
System.out.println(<font color=""#0000FF"">&quot;ERROR!!! &quot;</font> + transfer.getError());
} else {
System.out.println(transfer.getStatus());
System.out.println(transfer.getProgress());
}
sleep(1000);
}
</pre> 
</blockquote>","OutgoingFileTransfer","org.jivesoftware.smackx.filetransfer.OutgoingFileTransfer","class",0
,"File Transfer","Monitoring the progress of a file transfer","<div class=""subheader""><h3> 
 <a name=""monitorprogress"">Monitoring the progress of a file transfer</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> While a file transfer is in progress you may wish to monitor the progress of a file transfer.</p> 
<b>Usage</b> 
<p>Both the <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.IncomingFileTransfer"" api=""IncomingFileTransfer"" kind=""class"">
     IncomingFileTransfer 
   </clt></i></b> and the <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.OutgoingFileTransfer"" api=""OutgoingFileTransfer"" kind=""class"">
     OutgoingFileTransfer 
   </clt></i></b> extend the <b><i> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransfer"" api=""FileTransfer"" kind=""class"">
     FileTransfer 
   </clt></i></b> class which provides several methods to monitor how a file transfer is progressing: </p> 
<ul> 
 <li><b> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransfer.getStatus"" api=""FileTransfer"" kind=""method"">
    FileTransfer.getStatus()
   </clt></b> - The file transfer can be in several states, negotiating, rejected, canceled, in progress, error, and complete. This method will return which state the file transfer is currently in. </li> 
 <li><b> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransfer.getProgress"" api=""FileTransfer"" kind=""method"">
    FileTransfer.getProgress()
   </clt></b> - if the status of the file transfer is in progress this method will return a number between 0 and 1, 0 being the transfer has not yet started and 1 being the transfer is complete. It may also return a -1 if the transfer is not in progress. </li> 
 <li><b> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransfer.isDone"" api=""FileTransfer"" kind=""method"">
    FileTransfer.isDone()
   </clt></b> - Similar to getProgress() except it returns a <i>boolean</i>. If the state is rejected, canceled, error, or complete then true will be returned and false otherwise. </li> 
 <li><b> 
   <clt fqn=""org.jivesoftware.smackx.filetransfer.FileTransfer.getError"" api=""FileTransfer"" kind=""method"">
    FileTransfer.getError()
   </clt></b> - If there is an error during the file transfer this method will return the type of error that occured. </li> 
</ul> 
<b>Examples</b> 
<p> In this example we can see how to monitor a file transfer: </p> 
<blockquote> 
 <pre>      while(!transfer.isDone()) {
if(transfer.getStatus().equals(Status.ERROR)) {
System.out.println(<font color=""#0000FF"">&quot;ERROR!!! &quot;</font> + transfer.getError());
} else {
System.out.println(transfer.getStatus());
System.out.println(transfer.getProgress());
}
sleep(1000);
}
</pre> 
</blockquote>","FileTransfer","org.jivesoftware.smackx.filetransfer.FileTransfer","class",1
,"Processing Incoming Packets","Processing Incoming Packets","<div class=""header""><h3>
  Processing Incoming Packets </h3>
</div> 
<p> Smack provides a flexible framework for processing incoming packets using two constructs: </p> 
<ul> 
 <li><tt> 
   <clt fqn=""org.jivesoftware.smack.PacketCollector"" api=""PacketCollector"" kind=""class"">
     org.jivesoftware.smack.PacketCollector 
   </clt></tt> -- a class that lets you synchronously wait for new packets. </li> 
 <li><tt> 
   <clt fqn=""org.jivesoftware.smack.PacketListener"" api=""PacketListener"" kind=""class"">
     org.jivesoftware.smack.PacketListener 
   </clt></tt> -- an interface for asynchronously notifying you of incoming packets. </li> 
</ul> A packet listener is used for event style programming, while a packet collector has a result queue of packets that you can do polling and blocking operations on. So, a packet listener is useful when you want to take some action whenever a packet happens to come in, while a packet collector is useful when you want to wait for a specific packet to arrive. Packet collectors and listeners can be created using an 
<tt> 
 <clt fqn=""org.jivesoftware.smack.Connection"" api=""Connection"" kind=""class"">
   Connection 
 </clt></tt> instance. 
<p> The <tt> 
  <clt fqn=""org.jivesoftware.smack.filter.PacketFilter"" api=""PacketFilter"" kind=""class"">
    org.jivesoftware.smack.filter.PacketFilter 
  </clt></tt> interface determines which specific packets will be delivered to a <tt> 
  <clt fqn=""org.jivesoftware.smack.PacketCollector"" api=""PacketCollector"" kind=""class"">
    PacketCollector 
  </clt></tt> or <tt> 
  <clt fqn=""org.jivesoftware.smack.PacketListener"" api=""PacketListener"" kind=""class"">
    PacketListener 
  </clt></tt>. Many pre-defined filters can be found in the <tt>org.jivesoftware.smack.filter</tt> package. </p> 
<p> The following code snippet demonstrates registering both a packet collector and a packet listener:</p> 
<div class=""code""> 
 <pre>
<font color=""gray""><i>// Create a packet filter to listen for new messages from a particular</i></font>
<font color=""gray""><i>// user. We use an AndFilter to combine two other filters.</i></font>
PacketFilter filter = new AndFilter(new PacketTypeFilter(<b>Message.class</b>), 
new FromContainsFilter(<font color=""green"">&quot;mary@jivesoftware.com&quot;</font>));
<font color=""gray""><i>// Assume we've created a Connection name &quot;connection&quot;.</i></font>
<font color=""gray""><i>// First, register a packet collector using the filter we created.</i></font>
PacketCollector myCollector = connection.createPacketCollector(filter);
<font color=""gray""><i>// Normally, you'd do something with the collector, like wait for new packets.</i></font>
<font color=""gray""><i>// Next, create a packet listener. We use an anonymous inner class for brevity.</i></font>
PacketListener myListener = new PacketListener() {
<b>public</b> <b>void</b> processPacket(Packet packet) {
<font color=""gray""><i>// Do something with the incoming packet here.</i></font>
}
};
<font color=""gray""><i>// Register the listener.</i></font>
connection.addPacketListener(myListener, filter);
</pre> 
</div>","PacketCollector","org.jivesoftware.smack.PacketCollector","class",1
,"Processing Incoming Packets","Processing Incoming Packets","<div class=""header""><h3>
  Processing Incoming Packets </h3>
</div> 
<p> Smack provides a flexible framework for processing incoming packets using two constructs: </p> 
<ul> 
 <li><tt> 
   <clt fqn=""org.jivesoftware.smack.PacketCollector"" api=""PacketCollector"" kind=""class"">
     org.jivesoftware.smack.PacketCollector 
   </clt></tt> -- a class that lets you synchronously wait for new packets. </li> 
 <li><tt> 
   <clt fqn=""org.jivesoftware.smack.PacketListener"" api=""PacketListener"" kind=""class"">
     org.jivesoftware.smack.PacketListener 
   </clt></tt> -- an interface for asynchronously notifying you of incoming packets. </li> 
</ul> A packet listener is used for event style programming, while a packet collector has a result queue of packets that you can do polling and blocking operations on. So, a packet listener is useful when you want to take some action whenever a packet happens to come in, while a packet collector is useful when you want to wait for a specific packet to arrive. Packet collectors and listeners can be created using an 
<tt> 
 <clt fqn=""org.jivesoftware.smack.Connection"" api=""Connection"" kind=""class"">
   Connection 
 </clt></tt> instance. 
<p> The <tt> 
  <clt fqn=""org.jivesoftware.smack.filter.PacketFilter"" api=""PacketFilter"" kind=""class"">
    org.jivesoftware.smack.filter.PacketFilter 
  </clt></tt> interface determines which specific packets will be delivered to a <tt> 
  <clt fqn=""org.jivesoftware.smack.PacketCollector"" api=""PacketCollector"" kind=""class"">
    PacketCollector 
  </clt></tt> or <tt> 
  <clt fqn=""org.jivesoftware.smack.PacketListener"" api=""PacketListener"" kind=""class"">
    PacketListener 
  </clt></tt>. Many pre-defined filters can be found in the <tt>org.jivesoftware.smack.filter</tt> package. </p> 
<p> The following code snippet demonstrates registering both a packet collector and a packet listener:</p> 
<div class=""code""> 
 <pre>
<font color=""gray""><i>// Create a packet filter to listen for new messages from a particular</i></font>
<font color=""gray""><i>// user. We use an AndFilter to combine two other filters.</i></font>
PacketFilter filter = new AndFilter(new PacketTypeFilter(<b>Message.class</b>), 
new FromContainsFilter(<font color=""green"">&quot;mary@jivesoftware.com&quot;</font>));
<font color=""gray""><i>// Assume we've created a Connection name &quot;connection&quot;.</i></font>
<font color=""gray""><i>// First, register a packet collector using the filter we created.</i></font>
PacketCollector myCollector = connection.createPacketCollector(filter);
<font color=""gray""><i>// Normally, you'd do something with the collector, like wait for new packets.</i></font>
<font color=""gray""><i>// Next, create a packet listener. We use an anonymous inner class for brevity.</i></font>
PacketListener myListener = new PacketListener() {
<b>public</b> <b>void</b> processPacket(Packet packet) {
<font color=""gray""><i>// Do something with the incoming packet here.</i></font>
}
};
<font color=""gray""><i>// Register the listener.</i></font>
connection.addPacketListener(myListener, filter);
</pre> 
</div>","PacketListener","org.jivesoftware.smack.PacketListener","class",1
,"Processing Incoming Packets","Processing Incoming Packets","<div class=""header""><h3>
  Processing Incoming Packets </h3>
</div> 
<p> Smack provides a flexible framework for processing incoming packets using two constructs: </p> 
<ul> 
 <li><tt> 
   <clt fqn=""org.jivesoftware.smack.PacketCollector"" api=""PacketCollector"" kind=""class"">
     org.jivesoftware.smack.PacketCollector 
   </clt></tt> -- a class that lets you synchronously wait for new packets. </li> 
 <li><tt> 
   <clt fqn=""org.jivesoftware.smack.PacketListener"" api=""PacketListener"" kind=""class"">
     org.jivesoftware.smack.PacketListener 
   </clt></tt> -- an interface for asynchronously notifying you of incoming packets. </li> 
</ul> A packet listener is used for event style programming, while a packet collector has a result queue of packets that you can do polling and blocking operations on. So, a packet listener is useful when you want to take some action whenever a packet happens to come in, while a packet collector is useful when you want to wait for a specific packet to arrive. Packet collectors and listeners can be created using an 
<tt> 
 <clt fqn=""org.jivesoftware.smack.Connection"" api=""Connection"" kind=""class"">
   Connection 
 </clt></tt> instance. 
<p> The <tt> 
  <clt fqn=""org.jivesoftware.smack.filter.PacketFilter"" api=""PacketFilter"" kind=""class"">
    org.jivesoftware.smack.filter.PacketFilter 
  </clt></tt> interface determines which specific packets will be delivered to a <tt> 
  <clt fqn=""org.jivesoftware.smack.PacketCollector"" api=""PacketCollector"" kind=""class"">
    PacketCollector 
  </clt></tt> or <tt> 
  <clt fqn=""org.jivesoftware.smack.PacketListener"" api=""PacketListener"" kind=""class"">
    PacketListener 
  </clt></tt>. Many pre-defined filters can be found in the <tt>org.jivesoftware.smack.filter</tt> package. </p> 
<p> The following code snippet demonstrates registering both a packet collector and a packet listener:</p> 
<div class=""code""> 
 <pre>
<font color=""gray""><i>// Create a packet filter to listen for new messages from a particular</i></font>
<font color=""gray""><i>// user. We use an AndFilter to combine two other filters.</i></font>
PacketFilter filter = new AndFilter(new PacketTypeFilter(<b>Message.class</b>), 
new FromContainsFilter(<font color=""green"">&quot;mary@jivesoftware.com&quot;</font>));
<font color=""gray""><i>// Assume we've created a Connection name &quot;connection&quot;.</i></font>
<font color=""gray""><i>// First, register a packet collector using the filter we created.</i></font>
PacketCollector myCollector = connection.createPacketCollector(filter);
<font color=""gray""><i>// Normally, you'd do something with the collector, like wait for new packets.</i></font>
<font color=""gray""><i>// Next, create a packet listener. We use an anonymous inner class for brevity.</i></font>
PacketListener myListener = new PacketListener() {
<b>public</b> <b>void</b> processPacket(Packet packet) {
<font color=""gray""><i>// Do something with the incoming packet here.</i></font>
}
};
<font color=""gray""><i>// Register the listener.</i></font>
connection.addPacketListener(myListener, filter);
</pre> 
</div>","Connection","org.jivesoftware.smack.Connection","class",0
,"Processing Incoming Packets","Processing Incoming Packets","<div class=""header""><h3>
  Processing Incoming Packets </h3>
</div> 
<p> Smack provides a flexible framework for processing incoming packets using two constructs: </p> 
<ul> 
 <li><tt> 
   <clt fqn=""org.jivesoftware.smack.PacketCollector"" api=""PacketCollector"" kind=""class"">
     org.jivesoftware.smack.PacketCollector 
   </clt></tt> -- a class that lets you synchronously wait for new packets. </li> 
 <li><tt> 
   <clt fqn=""org.jivesoftware.smack.PacketListener"" api=""PacketListener"" kind=""class"">
     org.jivesoftware.smack.PacketListener 
   </clt></tt> -- an interface for asynchronously notifying you of incoming packets. </li> 
</ul> A packet listener is used for event style programming, while a packet collector has a result queue of packets that you can do polling and blocking operations on. So, a packet listener is useful when you want to take some action whenever a packet happens to come in, while a packet collector is useful when you want to wait for a specific packet to arrive. Packet collectors and listeners can be created using an 
<tt> 
 <clt fqn=""org.jivesoftware.smack.Connection"" api=""Connection"" kind=""class"">
   Connection 
 </clt></tt> instance. 
<p> The <tt> 
  <clt fqn=""org.jivesoftware.smack.filter.PacketFilter"" api=""PacketFilter"" kind=""class"">
    org.jivesoftware.smack.filter.PacketFilter 
  </clt></tt> interface determines which specific packets will be delivered to a <tt> 
  <clt fqn=""org.jivesoftware.smack.PacketCollector"" api=""PacketCollector"" kind=""class"">
    PacketCollector 
  </clt></tt> or <tt> 
  <clt fqn=""org.jivesoftware.smack.PacketListener"" api=""PacketListener"" kind=""class"">
    PacketListener 
  </clt></tt>. Many pre-defined filters can be found in the <tt>org.jivesoftware.smack.filter</tt> package. </p> 
<p> The following code snippet demonstrates registering both a packet collector and a packet listener:</p> 
<div class=""code""> 
 <pre>
<font color=""gray""><i>// Create a packet filter to listen for new messages from a particular</i></font>
<font color=""gray""><i>// user. We use an AndFilter to combine two other filters.</i></font>
PacketFilter filter = new AndFilter(new PacketTypeFilter(<b>Message.class</b>), 
new FromContainsFilter(<font color=""green"">&quot;mary@jivesoftware.com&quot;</font>));
<font color=""gray""><i>// Assume we've created a Connection name &quot;connection&quot;.</i></font>
<font color=""gray""><i>// First, register a packet collector using the filter we created.</i></font>
PacketCollector myCollector = connection.createPacketCollector(filter);
<font color=""gray""><i>// Normally, you'd do something with the collector, like wait for new packets.</i></font>
<font color=""gray""><i>// Next, create a packet listener. We use an anonymous inner class for brevity.</i></font>
PacketListener myListener = new PacketListener() {
<b>public</b> <b>void</b> processPacket(Packet packet) {
<font color=""gray""><i>// Do something with the incoming packet here.</i></font>
}
};
<font color=""gray""><i>// Register the listener.</i></font>
connection.addPacketListener(myListener, filter);
</pre> 
</div>","PacketFilter","org.jivesoftware.smack.filter.PacketFilter","class",0
,"Provider Architecture: Packet Extensions and Custom IQ's","Provider Architecture: Packet Extensions and Custom IQ's","<div class=""header""><h3>
  Provider Architecture: Packet Extensions and Custom IQ's </h3>
</div> 
<p> The Smack provider architecture is a system for plugging in custom XML parsing of packet extensions and IQ packets. The standard <a href=""extensions/index.html"">Smack Extensions</a> are built using the provider architecture. Two types of providers exist:</p> 
<ul> 
 <li><tt> 
   <clt fqn=""org.jivesoftware.smack.provider.IQProvider"" api=""IQProvider"" kind=""class"">
     IQProvider 
   </clt></tt> -- parses IQ requests into Java objects. </li> 
 <li><tt> 
   <clt fqn=""org.jivesoftware.smack.packet.PacketExtension"" api=""PacketExtension"" kind=""class"">
     PacketExtension 
   </clt></tt> -- parses XML sub-documents attached to packets into PacketExtension instances.</li> 
</ul>","IQProvider","org.jivesoftware.smack.provider.IQProvider","class",0
,"Provider Architecture: Packet Extensions and Custom IQ's","Provider Architecture: Packet Extensions and Custom IQ's","<div class=""header""><h3>
  Provider Architecture: Packet Extensions and Custom IQ's </h3>
</div> 
<p> The Smack provider architecture is a system for plugging in custom XML parsing of packet extensions and IQ packets. The standard <a href=""extensions/index.html"">Smack Extensions</a> are built using the provider architecture. Two types of providers exist:</p> 
<ul> 
 <li><tt> 
   <clt fqn=""org.jivesoftware.smack.provider.IQProvider"" api=""IQProvider"" kind=""class"">
     IQProvider 
   </clt></tt> -- parses IQ requests into Java objects. </li> 
 <li><tt> 
   <clt fqn=""org.jivesoftware.smack.packet.PacketExtension"" api=""PacketExtension"" kind=""class"">
     PacketExtension 
   </clt></tt> -- parses XML sub-documents attached to packets into PacketExtension instances.</li> 
</ul>","PacketExtension","org.jivesoftware.smack.packet.PacketExtension","class",0
,"Pubsub","Node creation and configuration","<div class=""subheader""><h3> 
 <a name=""create"">Node creation and configuration</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> Allowed users may create and configure pubsub nodes. There are two types of nodes that can be created, leaf nodes and collection nodes. </p> 
<li>Leaf Nodes - contains only messages</li> 
<li>Collection Nodes - contains only nodes (both Leaf and Collection are allowed), but no messages</li> The current version of this API only supports Leaf Nodes. There are many configuration options available for nodes, but the two main options are whether the node is 
<b>persistent</b> or not and whether it will deliver payload or not. 
<b>Usage</b> 
<p> In order to create a node you will need to first create an instance of <i><b> 
   <clt fqn=""org.jivesoftware.smackx.pubsub.PubSubManager"" api=""PubSubManager"" kind=""class"">
     PubSubManager 
   </clt></b></i>. There are several options for node creation which range from creating an instant node, default configuration, or a fully configured node.</p> 
<p> <b>Examples</b></p> 
<p> Create an instant node: </p> 
<blockquote> 
 <pre>
<font color=""#3f7f5f"">// Create a pubsub manager using an existing Connection</font>
PubSubManager mgr = new PubSubManager(con);
<font color=""#3f7f5f"">// Create the node</font>
LeafNode leaf = mgr.createNode();
</pre> 
</blockquote> Create a node with default configuration and then configure it: 
<blockquote> 
 <pre>
<font color=""#3f7f5f"">// Create a pubsub manager using an existing Connection</font>
PubSubManager mgr = new PubSubManager(con);
<font color=""#3f7f5f"">// Create the node</font>
LeafNode leaf = mgr.createNode(<font color=""#0000FF"">&quot;testNode&quot;</font>);
ConfigureForm form = new ConfigureForm(FormType.submit);
form.setAccessModel(AccessModel.open);
form.setDeliverPayloads(false);
form.setNotifyRetract(true);
form.setPersistentItems(true);
form.setPublishModel(PublishModel.open);
leaf.sendConfigurationForm(form);
</pre> 
</blockquote> Create and configure a node: 
<blockquote> 
 <pre>
<font color=""#3f7f5f"">// Create a pubsub manager using an existing Connection</font>
PubSubManager mgr = new PubSubManager(con);
<font color=""#3f7f5f"">// Create the node</font>
ConfigureForm form = new ConfigureForm(FormType.submit);
form.setAccessModel(AccessModel.open);
form.setDeliverPayloads(false);
form.setNotifyRetract(true);
form.setPersistentItems(true);
form.setPublishModel(PublishModel.open);
LeafNode leaf = mgr.createNode(<font color=""#0000FF"">&quot;testNode&quot;</font>, form);
</pre> 
</blockquote>","PubSubManager","org.jivesoftware.smackx.pubsub.PubSubManager","class",1
,"Pubsub","Publishing to a node","<div class=""subheader""> <h3>
 <a name=""publish"">Publishing to a node</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> This section deals with the <b> 
  <clt fqn=""org.jivesoftware.smackx.pubsub.LeafNode.publish"" api=""LeafNode"" kind=""method"">
   LeafNode.publish
  </clt></b> portion of pubsub. Usage of a node typically involves either sending or receiving data, referred to as items. Depending on the context of the nodes usage, the item being sent to it can have different properties. It can contain application data known as payload, or the publisher may choose to supply meaningful unique id's. Determination of an items acceptable properties is defined by a combination of node configuration and its purpose. </p> 
<b>Usage</b> 
<p> To publish to a node, you will have to either create or retrieve an existing node and then create and send items to that node. The ability for any given person to publish to the node will be dependent on its configuration. </p> 
<b>Examples</b> 
<p> In this example we publish an item to a node that does not take payload: </p> 
<blockquote> 
 <pre>
<font color=""#3f7f5f"">// Create a pubsub manager using an existing Connection</font>
PubSubManager mgr = new PubSubManager(con);
<font color=""#3f7f5f"">// Get the node</font>
LeafNode node = mgr.getNode(<font color=""#0000FF"">&quot;testNode&quot;</font>);
<font color=""#3f7f5f"">// Publish an Item, let service set the id</font>
node.send(new Item());
<font color=""#3f7f5f"">// Publish an Item with the specified id</font>
node.send(new Item(<font color=""#0000FF"">&quot;123abc&quot;</font>));
</pre> 
</blockquote> In this example we publish an item to a node that does take payload: 
<blockquote> 
 <pre>
<font color=""#3f7f5f"">// Create a pubsub manager using an existing Connection</font>
PubSubManager mgr = new PubSubManager(con);
<font color=""#3f7f5f"">// Get the node</font>
LeafNode node = mgr.getNode(<font color=""#0000FF"">&quot;testNode&quot;</font>);
<font color=""#3f7f5f"">// Publish an Item with payload</font>
node.send(new PayloadItem(<font color=""#0000FF"">&quot;test&quot;</font> + System.currentTimeMillis(), 
new SimplePayload(<font color=""#0000FF"">&quot;book&quot;</font>, <font color=""#0000FF"">&quot;pubsub:test:book&quot;</font>, 
<font color=""#0000FF"">&quot;Two Towers&quot;</font>)));
</pre> 
</blockquote>","LeafNode","org.jivesoftware.smackx.pubsub.LeafNode","class",0
,"Pubsub","Receiving pubsub messages","<div class=""subheader""> <h3>
 <a name=""subscribe"">Receiving pubsub messages</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> This section deals with the <b> 
  <clt fqn=""org.jivesoftware.smackx.pubsub.Node.subscribe"" api=""Node"" kind=""method"">
   Node.subscribe
  </clt></b> portion of pubsub. As mentioned in the last section, usage of a node typically involves either sending or receiving items. Subscribers are interested in being notified when items are published to the pubsub node. These items may or may not have application specific data (payload), as that is dependent on the context in which the node is being used. </p> 
<b>Usage</b> 
<p> To get messages asynchronously when items are published to a node, you will have to </p> 
<li>Get a node.</li> 
<li>Create and register a listener.</li> 
<li>Subscribe to the node.</li> 
<p> Please note that you should register the listener before subscribing so that all messages sent after subscribing are received. If done in the reverse order, messages that are sent after subscribing but before registering a listener may not be processed as expected. </p>","Node","org.jivesoftware.smackx.pubsub.Node","class",1
,"Pubsub","Retrieving persisted pubsub messages","<div class=""subheader""> <h3>
 <a name=""retrieve"">Retrieving persisted pubsub messages</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> When persistent nodes are used, the subscription and registration methods described in the last section will not enable the retrieval of items that already exist in the node. This section deals with the specific methods for retrieving these items. There are several means of retrieving existing items. You can retrieve all items at once, the last N items, or the items specified by a collection of id's. Please note that the service may, according to the pubsub specification, reply with a list of items that contains only the item id's (no payload) to save on bandwidth. This will not occur when the id's are specified since this is the means of guaranteeing retrieval of payload.</p> 
<b>Usage</b> 
<p> To synchronously retrieve existing items from a persistent node, you will have to get an instance of a <i><b> 
   <clt fqn=""org.jivesoftware.smackx.pubsub.LeafNode"" api=""LeafNode"" kind=""class"">
     LeafNode 
   </clt></b></i> and call one of the retrieve methods. </p> 
<p> <b>Examples</b></p> 
<p> In this example we can see how to retrieve the existing items from a node: </p> 
<blockquote> 
 <pre>      
<font color=""#3f7f5f"">// Create a pubsub manager using an existing Connection</font>
PubSubManager mgr = new PubSubManager(con);
<font color=""#3f7f5f"">// Get the node</font>
LeafNode node = mgr.getNode(<font color=""#0000FF"">&quot;testNode&quot;</font>);
Collection&lt;? extends Item&gt; items = node.getItems();
</pre> 
</blockquote> In this example we can see how to retrieve the last N existing items: 
<blockquote> 
 <pre>      
<font color=""#3f7f5f"">// Create a pubsub manager using an existing Connection</font>
PubSubManager mgr = new PubSubManager(con);
<font color=""#3f7f5f"">// Get the node</font>
LeafNode node = mgr.getNode(<font color=""#0000FF"">&quot;testNode&quot;</font>);
List&lt;? extends Item&gt; items = node.getItems(100);
</pre> 
</blockquote> In this example we can see how to retrieve the specified existing items: 
<blockquote> 
 <pre>      
<font color=""#3f7f5f"">// Create a pubsub manager using an existing Connection</font>
PubSubManager mgr = new PubSubManager(con);
<font color=""#3f7f5f"">// Get the node</font>
LeafNode node = mgr.getNode(<font color=""#0000FF"">&quot;testNode&quot;</font>);
Collection&lt;String&gt; ids = new ArrayList&lt;String&gt;(3);
ids.add(&quot;1&quot;);
ids.add(&quot;3&quot;);
ids.add(&quot;4&quot;);
List&lt;? extends Item&gt; items = node.getItems(ids);
</pre> 
</blockquote>","LeafNode","org.jivesoftware.smackx.pubsub.LeafNode","class",1
,"Pubsub","Discover pubsub information","<div class=""subheader""> <h3>
 <a name=""discopubsub"">Discover pubsub information</a> </3>
</div> 
<p> <b>Description</b></p> 
<p> A user may want to query a server or node for a variety of pubsub related information.</p> 
<b>Usage</b> 
<p> To retrieve information, a user will simply use either the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.pubsub.PubSubManager"" api=""PubSubManager"" kind=""class"">
     PubSubManager 
   </clt></b></i> or <i><b> 
   <clt fqn=""org.jivesoftware.smackx.pubsub.Node"" api=""Node"" kind=""class"">
     Node 
   </clt></b></i> classes depending on what type of information is required. <b>Examples</b></p> 
<p> In this example we can see how to get pubsub capabilities: </p> 
<blockquote> 
 <pre>      
<font color=""#3f7f5f"">// Create a pubsub manager using an existing Connection</font>
PubSubManager mgr = new PubSubManager(con);
<font color=""#3f7f5f"">// Get the pubsub features that are supported</font>
DiscoverInfo supportedFeatures = mgr.getSupportedFeatures();
</pre> 
</blockquote> In this example we can see how to get pubsub subscriptions for all nodes: 
<blockquote> 
 <pre>      
<font color=""#3f7f5f"">// Create a pubsub manager using an existing Connection</font>
PubSubManager mgr = new PubSubManager(con);
<font color=""#3f7f5f"">// Get all the subscriptions in the pubsub service</font>
List&lt;Subscription&gt; subscriptions = mgr.getSubscriptions();
</pre> 
</blockquote> In this example we can see how to get all affiliations for the users bare JID on the pubsub service: 
<blockquote> 
 <pre>      
<font color=""#3f7f5f"">// Create a pubsub manager using an existing Connection</font>
PubSubManager mgr = new PubSubManager(con);
<font color=""#3f7f5f"">// Get the affiliations for the users bare JID</font>
List&lt;Affiliation&gt; affiliations = mgr.getAffiliations();
</pre> 
</blockquote> In this example we can see how to get information about the node: 
<blockquote> 
 <pre>      
<font color=""#3f7f5f"">// Create a pubsub manager using an existing Connection</font>
PubSubManager mgr = new PubSubManager(con);
Node node = mgr.getNode(<font color=""#0000FF"">&quot;testNode&quot;</font>);
<font color=""#3f7f5f"">// Get the node information</font>
DiscoverInfo nodeInfo = node.discoverInfo();
</pre> 
</blockquote> In this example we can see how to discover the node items: 
<blockquote> 
 <pre>      
<font color=""#3f7f5f"">// Create a pubsub manager using an existing Connection</font>
PubSubManager mgr = new PubSubManager(con);
Node node = mgr.getNode(<font color=""#0000FF"">&quot;testNode&quot;</font>);
<font color=""#3f7f5f"">// Discover the node items</font>
DiscoverItems nodeItems = node.discoverItems();
</pre> 
</blockquote> In this example we can see how to get node subscriptions: 
<blockquote> 
 <pre>      
<font color=""#3f7f5f"">// Create a pubsub manager using an existing Connection</font>
PubSubManager mgr = new PubSubManager(con);
Node node = mgr.getNode(<font color=""#0000FF"">&quot;testNode&quot;</font>);
<font color=""#3f7f5f"">// Discover the node subscriptions</font>
List&lt;Subscription&gt; subscriptions = node.getSubscriptions();
</pre> 
</blockquote>","PubSubManager","org.jivesoftware.smackx.pubsub.PubSubManager","class",1
,"Pubsub","Discover pubsub information","<div class=""subheader""> <h3>
 <a name=""discopubsub"">Discover pubsub information</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> A user may want to query a server or node for a variety of pubsub related information.</p> 
<b>Usage</b> 
<p> To retrieve information, a user will simply use either the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.pubsub.PubSubManager"" api=""PubSubManager"" kind=""class"">
     PubSubManager 
   </clt></b></i> or <i><b> 
   <clt fqn=""org.jivesoftware.smackx.pubsub.Node"" api=""Node"" kind=""class"">
     Node 
   </clt></b></i> classes depending on what type of information is required. <b>Examples</b></p> 
<p> In this example we can see how to get pubsub capabilities: </p> 
<blockquote> 
 <pre>      
<font color=""#3f7f5f"">// Create a pubsub manager using an existing Connection</font>
PubSubManager mgr = new PubSubManager(con);
<font color=""#3f7f5f"">// Get the pubsub features that are supported</font>
DiscoverInfo supportedFeatures = mgr.getSupportedFeatures();
</pre> 
</blockquote> In this example we can see how to get pubsub subscriptions for all nodes: 
<blockquote> 
 <pre>      
<font color=""#3f7f5f"">// Create a pubsub manager using an existing Connection</font>
PubSubManager mgr = new PubSubManager(con);
<font color=""#3f7f5f"">// Get all the subscriptions in the pubsub service</font>
List&lt;Subscription&gt; subscriptions = mgr.getSubscriptions();
</pre> 
</blockquote> In this example we can see how to get all affiliations for the users bare JID on the pubsub service: 
<blockquote> 
 <pre>      
<font color=""#3f7f5f"">// Create a pubsub manager using an existing Connection</font>
PubSubManager mgr = new PubSubManager(con);
<font color=""#3f7f5f"">// Get the affiliations for the users bare JID</font>
List&lt;Affiliation&gt; affiliations = mgr.getAffiliations();
</pre> 
</blockquote> In this example we can see how to get information about the node: 
<blockquote> 
 <pre>      
<font color=""#3f7f5f"">// Create a pubsub manager using an existing Connection</font>
PubSubManager mgr = new PubSubManager(con);
Node node = mgr.getNode(<font color=""#0000FF"">&quot;testNode&quot;</font>);
<font color=""#3f7f5f"">// Get the node information</font>
DiscoverInfo nodeInfo = node.discoverInfo();
</pre> 
</blockquote> In this example we can see how to discover the node items: 
<blockquote> 
 <pre>      
<font color=""#3f7f5f"">// Create a pubsub manager using an existing Connection</font>
PubSubManager mgr = new PubSubManager(con);
Node node = mgr.getNode(<font color=""#0000FF"">&quot;testNode&quot;</font>);
<font color=""#3f7f5f"">// Discover the node items</font>
DiscoverItems nodeItems = node.discoverItems();
</pre> 
</blockquote> In this example we can see how to get node subscriptions: 
<blockquote> 
 <pre>      
<font color=""#3f7f5f"">// Create a pubsub manager using an existing Connection</font>
PubSubManager mgr = new PubSubManager(con);
Node node = mgr.getNode(<font color=""#0000FF"">&quot;testNode&quot;</font>);
<font color=""#3f7f5f"">// Discover the node subscriptions</font>
List&lt;Subscription&gt; subscriptions = node.getSubscriptions();
</pre> 
</blockquote>","Node","org.jivesoftware.smackx.pubsub.Node","class",1
,"Debugging with Smack","Debugging with Smack","<div class=""header""><h3>
  Debugging with Smack </h3>
</div> 
<p> Smack includes two built-in debugging consoles that will let you track all XML traffic between the client and server. A <a href=""#lite"">lite debugger</a> which is part of the <tt>smack.jar</tt> and an <a href=""#enhanced"">enhanced debugger</a> contained in <tt>smackx-debug.jar</tt>. </p> 
<p> Debugging mode can be enabled in two different ways: </p> 
<ol> 
 <li>Add the following line of code <b>before</b> creating new connections:<p> <tt> 
    <clt fqn=""org.jivesoftware.smack.Connection.DEBUG_ENABLED"" api=""Connection"" kind=""field"">
     Connection.DEBUG_ENABLED = true;
    </clt></tt></p></li> 
 <li>Set the Java system property <tt>smack.debugEnabled</tt> to true. The system property can be set on the command line such as:<p> <tt>java -Dsmack.debugEnabled=true SomeApp </tt> </p></li> 
</ol> 
<p> If you wish to explicitly disable debug mode in your application, including using the command-line parameter, add the following line to your application before opening new connections: </p> 
<p> <tt> 
  <clt fqn=""org.jivesoftware.smack.Connection.DEBUG_ENABLED"" api=""Connection"" kind=""field"">
    Connection.DEBUG_ENABLED = false; 
  </clt></tt> </p> 
<p> Smack uses the following logic to decide the debugger console to use: </p> 
<li>It will first try use the debugger class specified in the Java system property <tt>smack.debuggerClass</tt>. If you need to develop your own debugger, implement the <tt> 
  <clt fqn=""org.jivesoftware.smack.debugger.SmackDebugger"" api=""SmackDebugger"" kind=""class"">
    SmackDebugger 
  </clt></tt> interface and then set the system property on the command line such as:<p> <tt>java -Dsmack.debuggerClass=my.company.com.MyDebugger SomeApp </tt></p></li>","Connection","org.jivesoftware.smack.Connection","class",1
,"Debugging with Smack","Debugging with Smack","<div class=""header""><h3>
  Debugging with Smack </h3>
</div> 
<p> Smack includes two built-in debugging consoles that will let you track all XML traffic between the client and server. A <a href=""#lite"">lite debugger</a> which is part of the <tt>smack.jar</tt> and an <a href=""#enhanced"">enhanced debugger</a> contained in <tt>smackx-debug.jar</tt>. </p> 
<p> Debugging mode can be enabled in two different ways: </p> 
<ol> 
 <li>Add the following line of code <b>before</b> creating new connections:<p> <tt> 
    <clt fqn=""org.jivesoftware.smack.Connection.DEBUG_ENABLED"" api=""Connection"" kind=""field"">
     Connection.DEBUG_ENABLED = true;
    </clt></tt></p></li> 
 <li>Set the Java system property <tt>smack.debugEnabled</tt> to true. The system property can be set on the command line such as:<p> <tt>java -Dsmack.debugEnabled=true SomeApp </tt> </p></li> 
</ol> 
<p> If you wish to explicitly disable debug mode in your application, including using the command-line parameter, add the following line to your application before opening new connections: </p> 
<p> <tt> 
  <clt fqn=""org.jivesoftware.smack.Connection.DEBUG_ENABLED"" api=""Connection"" kind=""field"">
    Connection.DEBUG_ENABLED = false; 
  </clt></tt> </p> 
<p> Smack uses the following logic to decide the debugger console to use: </p> 
<li>It will first try use the debugger class specified in the Java system property <tt>smack.debuggerClass</tt>. If you need to develop your own debugger, implement the <tt> 
  <clt fqn=""org.jivesoftware.smack.debugger.SmackDebugger"" api=""SmackDebugger"" kind=""class"">
    SmackDebugger 
  </clt></tt> interface and then set the system property on the command line such as:<p> <tt>java -Dsmack.debuggerClass=my.company.com.MyDebugger SomeApp </tt></p></li>","SmackDebugger","org.jivesoftware.smack.debugger.SmackDebugger","class",0
,"Service Discovery","Manage XMPP entity features","<div class=""subheader""> <h3>
 <a name=""discoregister"">Manage XMPP entity features</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> Any XMPP entity may receive a discovery request and must answer with its associated items or information. Therefore, your Smack client may receive a discovery request that must respond to (i.e., if your client supports XHTML-IM). This extension automatically responds to a discovery request with the information that you previously configured.</p> 
<b>Usage</b> 
<p> In order to configure the supported features by your client you should first obtain the ServiceDiscoveryManager associated with your Connection. To get your ServiceDiscoveryManager send <b> 
  <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager.getInstanceFor"" api=""ServiceDiscoveryManager"" kind=""method"">
   ServiceDiscoveryManager.getInstanceFor(connection)
  </clt></b> to the class <i><b> 
   <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager"" api=""ServiceDiscoveryManager"" kind=""class"">
     ServiceDiscoveryManager 
   </clt></b></i> where connection is your Connection. </p> 
<p>Once you have your ServiceDiscoveryManager you will be able to manage the supported features. To register a new feature send <b> 
  <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager.addFeature"" api=""ServiceDiscoveryManager"" kind=""method"">
   ServiceDiscoveryManager.addFeature(feature)
  </clt></b> to your <i><b> 
   <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager"" api=""ServiceDiscoveryManager"" kind=""class"">
     ServiceDiscoveryManager 
   </clt></b></i> where feature is a String that represents the supported feature. To remove a supported feature send <b> 
  <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager.removeFeature"" api=""ServiceDiscoveryManager"" kind=""method"">
   ServiceDiscoveryManager.removeFeature(feature)
  </clt></b> to your <i><b> 
   <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager"" api=""ServiceDiscoveryManager"" kind=""class"">
     ServiceDiscoveryManager 
   </clt></b></i> where feature is a String that represents the feature to remove.</p> 
<b>Examples</b> 
<p> In this example we can see how to add and remove supported features: </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Obtain the ServiceDiscoveryManager associated with my Connection</font>
ServiceDiscoveryManager discoManager = ServiceDiscoveryManager.getInstanceFor(connection);
<font color=""#3f7f5f"">// Register that a new feature is supported by this XMPP entity</font>
discoManager.addFeature(namespace1);
<font color=""#3f7f5f"">// Remove the specified feature from the supported features by this XMPP entity</font>
discoManager.removeFeature(namespace2);
</pre> 
</blockquote>","ServiceDiscoveryManager","org.jivesoftware.smackx.ServiceDiscoveryManager","class",1
,"Service Discovery","Provide node information","<div class=""subheader""> <h3>
 <a name=""disconodeinfo"">Provide node information</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> Your XMPP entity may receive a discovery request for items non-addressable as a JID such as the MUC rooms where you are joined. In order to answer the correct information it is necessary to configure the information providers associated to the items/nodes within the Smack client.</p> 
<b>Usage</b> 
<p> In order to configure the associated nodes within the Smack client you will need to create a NodeInformationProvider and register it with the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager"" api=""ServiceDiscoveryManager"" kind=""class"">
     ServiceDiscoveryManager 
   </clt></b></i>. To get your ServiceDiscoveryManager send <b> 
  <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager.getInstanceFor"" api=""ServiceDiscoveryManager"" kind=""method"">
   ServiceDiscoveryManager.getInstanceFor(connection)
  </clt></b> to the class <i><b> 
   <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager"" api=""ServiceDiscoveryManager"" kind=""class"">
     ServiceDiscoveryManager 
   </clt></b></i> where connection is your Connection. </p> 
<p>Once you have your ServiceDiscoveryManager you will be able to register information providers for the XMPP entity's nodes. To register a new node information provider send <b> 
  <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager.setNodeInformationProvider"" api=""ServiceDiscoveryManager"" kind=""method"">
   ServiceDiscoveryManager.setNodeInformationProvider(String node, NodeInformationProvider listener)
  </clt></b> to your <i><b> 
   <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager"" api=""ServiceDiscoveryManager"" kind=""class"">
     ServiceDiscoveryManager 
   </clt></b></i> where node is the item non-addressable as a JID and listener is the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.NodeInformationProvider"" api=""NodeInformationProvider"" kind=""class"">
     NodeInformationProvider 
   </clt></b></i> to register. To unregister a <i><b> 
   <clt fqn=""org.jivesoftware.smackx.NodeInformationProvider"" api=""NodeInformationProvider"" kind=""class"">
     NodeInformationProvider 
   </clt></b></i> send <b> 
  <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager.removeNodeInformationProvider"" api=""ServiceDiscoveryManager"" kind=""method"">
   ServiceDiscoveryManager.removeNodeInformationProvider(String node)
  </clt></b> to your <i><b> 
   <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager"" api=""ServiceDiscoveryManager"" kind=""class"">
     ServiceDiscoveryManager 
   </clt></b></i> where node is the item non-addressable as a JID whose information provider we want to unregister.</p> 
<b>Examples</b> 
<p> In this example we can see how to register a NodeInformationProvider with a ServiceDiscoveryManager that will provide information concerning a node named &quot;http://jabber.org/protocol/muc#rooms&quot;: </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Set the NodeInformationProvider that will provide information about the</font>
<font color=""#3f7f5f"">// joined rooms whenever a disco request is received </font>
ServiceDiscoveryManager.getInstanceFor(connection).setNodeInformationProvider(
<font color=""#0000FF"">&quot;http://jabber.org/protocol/muc#rooms&quot;</font>,
new NodeInformationProvider() {
public Iterator getNodeItems() {
ArrayList answer = new ArrayList();
Iterator rooms = MultiUserChat.getJoinedRooms(connection);
while (rooms.hasNext()) {
answer.add(new DiscoverItems.Item((String)rooms.next()));
}
return answer.iterator(); 
}
});
</pre> 
</blockquote>","ServiceDiscoveryManager","org.jivesoftware.smackx.ServiceDiscoveryManager","class",1
,"Service Discovery","Provide node information","<div class=""subheader""> <h3>
 <a name=""disconodeinfo"">Provide node information</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> Your XMPP entity may receive a discovery request for items non-addressable as a JID such as the MUC rooms where you are joined. In order to answer the correct information it is necessary to configure the information providers associated to the items/nodes within the Smack client.</p> 
<b>Usage</b> 
<p> In order to configure the associated nodes within the Smack client you will need to create a NodeInformationProvider and register it with the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager"" api=""ServiceDiscoveryManager"" kind=""class"">
     ServiceDiscoveryManager 
   </clt></b></i>. To get your ServiceDiscoveryManager send <b> 
  <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager.getInstanceFor"" api=""ServiceDiscoveryManager"" kind=""method"">
   ServiceDiscoveryManager.getInstanceFor(connection)
  </clt></b> to the class <i><b> 
   <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager"" api=""ServiceDiscoveryManager"" kind=""class"">
     ServiceDiscoveryManager 
   </clt></b></i> where connection is your Connection. </p> 
<p>Once you have your ServiceDiscoveryManager you will be able to register information providers for the XMPP entity's nodes. To register a new node information provider send <b> 
  <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager.setNodeInformationProvider"" api=""ServiceDiscoveryManager"" kind=""method"">
   ServiceDiscoveryManager.setNodeInformationProvider(String node, NodeInformationProvider listener)
  </clt></b> to your <i><b> 
   <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager"" api=""ServiceDiscoveryManager"" kind=""class"">
     ServiceDiscoveryManager 
   </clt></b></i> where node is the item non-addressable as a JID and listener is the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.NodeInformationProvider"" api=""NodeInformationProvider"" kind=""class"">
     NodeInformationProvider 
   </clt></b></i> to register. To unregister a <i><b> 
   <clt fqn=""org.jivesoftware.smackx.NodeInformationProvider"" api=""NodeInformationProvider"" kind=""class"">
     NodeInformationProvider 
   </clt></b></i> send <b> 
  <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager.removeNodeInformationProvider"" api=""ServiceDiscoveryManager"" kind=""method"">
   ServiceDiscoveryManager.removeNodeInformationProvider(String node)
  </clt></b> to your <i><b> 
   <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager"" api=""ServiceDiscoveryManager"" kind=""class"">
     ServiceDiscoveryManager 
   </clt></b></i> where node is the item non-addressable as a JID whose information provider we want to unregister.</p> 
<b>Examples</b> 
<p> In this example we can see how to register a NodeInformationProvider with a ServiceDiscoveryManager that will provide information concerning a node named &quot;http://jabber.org/protocol/muc#rooms&quot;: </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Set the NodeInformationProvider that will provide information about the</font>
<font color=""#3f7f5f"">// joined rooms whenever a disco request is received </font>
ServiceDiscoveryManager.getInstanceFor(connection).setNodeInformationProvider(
<font color=""#0000FF"">&quot;http://jabber.org/protocol/muc#rooms&quot;</font>,
new NodeInformationProvider() {
public Iterator getNodeItems() {
ArrayList answer = new ArrayList();
Iterator rooms = MultiUserChat.getJoinedRooms(connection);
while (rooms.hasNext()) {
answer.add(new DiscoverItems.Item((String)rooms.next()));
}
return answer.iterator(); 
}
});
</pre> 
</blockquote>","NodeInformationProvider","org.jivesoftware.smackx.NodeInformationProvider","class",1
,"Service Discovery","Discover items associated with an XMPP entity","<div class=""subheader""> <h3>
 <a name=""discoitems"">Discover items associated with an XMPP entity</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> In order to obtain information about a specific item you have to first discover the items available in an XMPP entity.</p> 
<b>Usage</b> 
<p>Once you have your ServiceDiscoveryManager you will be able to discover items associated with an XMPP entity. To discover the items of a given XMPP entity send <b> 
  <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager.discoverItems"" api=""ServiceDiscoveryManager"" kind=""method"">
   ServiceDiscoveryManager.discoverItems(entityID)
  </clt></b> to your <i><b> 
   <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager"" api=""ServiceDiscoveryManager"" kind=""class"">
     ServiceDiscoveryManager 
   </clt></b></i> where entityID is the ID of the entity. The message <b> 
  <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager.discoverItems"" api=""ServiceDiscoveryManager"" kind=""method"">
   ServiceDiscoveryManager.discoverItems(entityID)
  </clt></b> will answer an instance of <i><b> 
   <clt fqn=""org.jivesoftware.smackx.packet.DiscoverItems"" api=""DiscoverItems"" kind=""class"">
     DiscoverItems 
   </clt></b></i> that contains the discovered items.</p> 
<b>Examples</b> 
<p> In this example we can see how to discover the items associated with an online catalog service: </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Obtain the ServiceDiscoveryManager associated with my Connection</font>
ServiceDiscoveryManager discoManager = ServiceDiscoveryManager.getInstanceFor(connection);
<font color=""#3f7f5f"">// Get the items of a given XMPP entity</font>
<font color=""#3f7f5f"">// This example gets the items associated with online catalog service</font>
DiscoverItems discoItems = discoManager.discoverItems(&quot;plays.shakespeare.lit&quot;);
<font color=""#3f7f5f"">// Get the discovered items of the queried XMPP entity</font>
Iterator it = discoItems.getItems();
<font color=""#3f7f5f"">// Display the items of the remote XMPP entity</font>
while (it.hasNext()) {
DiscoverItems.Item item = (DiscoverItems.Item) it.next();
System.out.println(item.getEntityID());
System.out.println(item.getNode());
System.out.println(item.getName());
}
</pre> 
</blockquote>","ServiceDiscoveryManager","org.jivesoftware.smackx.ServiceDiscoveryManager","class",1
,"Service Discovery","Discover items associated with an XMPP entity","<div class=""subheader""> <h3>
 <a name=""discoitems"">Discover items associated with an XMPP entity</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> In order to obtain information about a specific item you have to first discover the items available in an XMPP entity.</p> 
<b>Usage</b> 
<p>Once you have your ServiceDiscoveryManager you will be able to discover items associated with an XMPP entity. To discover the items of a given XMPP entity send <b> 
  <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager.discoverItems"" api=""ServiceDiscoveryManager"" kind=""method"">
   ServiceDiscoveryManager.discoverItems(entityID)
  </clt></b> to your <i><b> 
   <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager"" api=""ServiceDiscoveryManager"" kind=""class"">
     ServiceDiscoveryManager 
   </clt></b></i> where entityID is the ID of the entity. The message <b> 
  <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager.discoverItems"" api=""ServiceDiscoveryManager"" kind=""method"">
   ServiceDiscoveryManager.discoverItems(entityID)
  </clt></b> will answer an instance of <i><b> 
   <clt fqn=""org.jivesoftware.smackx.packet.DiscoverItems"" api=""DiscoverItems"" kind=""class"">
     DiscoverItems 
   </clt></b></i> that contains the discovered items.</p> 
<b>Examples</b> 
<p> In this example we can see how to discover the items associated with an online catalog service: </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Obtain the ServiceDiscoveryManager associated with my Connection</font>
ServiceDiscoveryManager discoManager = ServiceDiscoveryManager.getInstanceFor(connection);
<font color=""#3f7f5f"">// Get the items of a given XMPP entity</font>
<font color=""#3f7f5f"">// This example gets the items associated with online catalog service</font>
DiscoverItems discoItems = discoManager.discoverItems(&quot;plays.shakespeare.lit&quot;);
<font color=""#3f7f5f"">// Get the discovered items of the queried XMPP entity</font>
Iterator it = discoItems.getItems();
<font color=""#3f7f5f"">// Display the items of the remote XMPP entity</font>
while (it.hasNext()) {
DiscoverItems.Item item = (DiscoverItems.Item) it.next();
System.out.println(item.getEntityID());
System.out.println(item.getNode());
System.out.println(item.getName());
}
</pre> 
</blockquote>","DiscoverItems","org.jivesoftware.smackx.packet.DiscoverItems","class",0
,"Service Discovery","Discover information about an XMPP entity","<div class=""subheader""> <h3>
 <a name=""discoinfo"">Discover information about an XMPP entity</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> Once you have discovered the entity ID and name of an item, you may want to find out more about the item. The information desired generally is of two kinds: 1) The item's identity and 2) The features offered by the item.</p> 
<p>This information helps you determine what actions are possible with regard to this item (registration, search, join, etc.) as well as specific feature types of interest, if any (e.g., for the purpose of feature negotiation).</p> 
<b>Usage</b> 
<p>Once you have your ServiceDiscoveryManager you will be able to discover information associated with an XMPP entity. To discover the information of a given XMPP entity send <b> 
  <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager.discoverInfo"" api=""ServiceDiscoveryManager"" kind=""method"">
   ServiceDiscoveryManager.discoverInfo(entityID)
  </clt></b> to your <i><b> 
   <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager"" api=""ServiceDiscoveryManager"" kind=""class"">
     ServiceDiscoveryManager 
   </clt></b></i> where entityID is the ID of the entity. The message <b> 
  <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager.discoverInfo"" api=""ServiceDiscoveryManager"" kind=""method"">
   ServiceDiscoveryManager.discoverInfo(entityID)
  </clt></b> will answer an instance of <i><b> 
   <clt fqn=""org.jivesoftware.smackx.packet.DiscoverInfo"" api=""DiscoverInfo"" kind=""class"">
     DiscoverInfo 
   </clt></b></i> that contains the discovered information.</p> 
<b>Examples</b> 
<p> In this example we can see how to discover the information of a conference room: </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Obtain the ServiceDiscoveryManager associated with my Connection</font>
ServiceDiscoveryManager discoManager = ServiceDiscoveryManager.getInstanceFor(connection);
<font color=""#3f7f5f"">// Get the information of a given XMPP entity</font>
<font color=""#3f7f5f"">// This example gets the information of a conference room</font>
DiscoverInfo discoInfo = discoManager.discoverInfo(&quot;balconyscene@plays.shakespeare.lit&quot;);
<font color=""#3f7f5f"">// Get the discovered identities of the remote XMPP entity</font>
Iterator it = discoInfo.getIdentities();
<font color=""#3f7f5f"">// Display the identities of the remote XMPP entity</font>
while (it.hasNext()) {
DiscoverInfo.Identity identity = (DiscoverInfo.Identity) it.next();
System.out.println(identity.getName());
System.out.println(identity.getType());
System.out.println(identity.getCategory());
}
<font color=""#3f7f5f"">// Check if room is password protected</font>
discoInfo.containsFeature(&quot;muc_passwordprotected&quot;);
</pre> 
</blockquote>","ServiceDiscoveryManager","org.jivesoftware.smackx.ServiceDiscoveryManager","class",1
,"Service Discovery","Discover information about an XMPP entity","<div class=""subheader""> <h3>
 <a name=""discoinfo"">Discover information about an XMPP entity</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> Once you have discovered the entity ID and name of an item, you may want to find out more about the item. The information desired generally is of two kinds: 1) The item's identity and 2) The features offered by the item.</p> 
<p>This information helps you determine what actions are possible with regard to this item (registration, search, join, etc.) as well as specific feature types of interest, if any (e.g., for the purpose of feature negotiation).</p> 
<b>Usage</b> 
<p>Once you have your ServiceDiscoveryManager you will be able to discover information associated with an XMPP entity. To discover the information of a given XMPP entity send <b> 
  <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager.discoverInfo"" api=""ServiceDiscoveryManager"" kind=""method"">
   ServiceDiscoveryManager.discoverInfo(entityID)
  </clt></b> to your <i><b> 
   <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager"" api=""ServiceDiscoveryManager"" kind=""class"">
     ServiceDiscoveryManager 
   </clt></b></i> where entityID is the ID of the entity. The message <b> 
  <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager.discoverInfo"" api=""ServiceDiscoveryManager"" kind=""method"">
   ServiceDiscoveryManager.discoverInfo(entityID)
  </clt></b> will answer an instance of <i><b> 
   <clt fqn=""org.jivesoftware.smackx.packet.DiscoverInfo"" api=""DiscoverInfo"" kind=""class"">
     DiscoverInfo 
   </clt></b></i> that contains the discovered information.</p> 
<b>Examples</b> 
<p> In this example we can see how to discover the information of a conference room: </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Obtain the ServiceDiscoveryManager associated with my Connection</font>
ServiceDiscoveryManager discoManager = ServiceDiscoveryManager.getInstanceFor(connection);
<font color=""#3f7f5f"">// Get the information of a given XMPP entity</font>
<font color=""#3f7f5f"">// This example gets the information of a conference room</font>
DiscoverInfo discoInfo = discoManager.discoverInfo(&quot;balconyscene@plays.shakespeare.lit&quot;);
<font color=""#3f7f5f"">// Get the discovered identities of the remote XMPP entity</font>
Iterator it = discoInfo.getIdentities();
<font color=""#3f7f5f"">// Display the identities of the remote XMPP entity</font>
while (it.hasNext()) {
DiscoverInfo.Identity identity = (DiscoverInfo.Identity) it.next();
System.out.println(identity.getName());
System.out.println(identity.getType());
System.out.println(identity.getCategory());
}
<font color=""#3f7f5f"">// Check if room is password protected</font>
discoInfo.containsFeature(&quot;muc_passwordprotected&quot;);
</pre> 
</blockquote>","DiscoverInfo","org.jivesoftware.smackx.packet.DiscoverInfo","class",0
,"Service Discovery","Publish publicly available items","<div class=""subheader""> <h3>
 <a name=""discopublish"">Publish publicly available items</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> Publish your entity items to some kind of persistent storage. This enables other entities to query that entity using the disco#items namespace and receive a result even when the entity being queried is not online (or available).</p> 
<b>Usage</b> 
<p>Once you have your ServiceDiscoveryManager you will be able to publish items to some kind of persistent storage. To publish the items of a given XMPP entity you have to first create an instance of <i><b> 
   <clt fqn=""org.jivesoftware.smackx.packet.DiscoverItems"" api=""DiscoverItems"" kind=""class"">
     DiscoverItems 
   </clt></b></i> and configure it with the items to publish. Then you will have to send <b> 
  <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager.publishItems"" api=""ServiceDiscoveryManager"" kind=""method"">
   ServiceDiscoveryManager.publishItems(String entityID, DiscoverItems discoverItems)
  </clt></b> to your <i><b> 
   <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager"" api=""ServiceDiscoveryManager"" kind=""class"">
     ServiceDiscoveryManager 
   </clt></b></i> where entityID is the address of the XMPP entity that will persist the items and discoverItems contains the items to publish.</p> 
<b>Examples</b> 
<p> In this example we can see how to publish new items: </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Obtain the ServiceDiscoveryManager associated with my Connection</font>
ServiceDiscoveryManager discoManager = ServiceDiscoveryManager.getInstanceFor(connection);
<font color=""#3f7f5f"">// Create a DiscoverItems with the items to publish</font>
DiscoverItems itemsToPublish = new DiscoverItems();
DiscoverItems.Item itemToPublish = new DiscoverItems.Item(&quot;pubsub.shakespeare.lit&quot;);
itemToPublish.setName(&quot;Avatar&quot;);
itemToPublish.setNode(&quot;romeo/avatar&quot;);
itemToPublish.setAction(DiscoverItems.Item.UPDATE_ACTION);
itemsToPublish.addItem(itemToPublish);
<font color=""#3f7f5f"">// Publish the new items by sending them to the server</font>
discoManager.publishItems(&quot;host&quot;, itemsToPublish);
</pre> 
</blockquote>","DiscoverItems","org.jivesoftware.smackx.packet.DiscoverItems","class",1
,"Service Discovery","Publish publicly available items","<div class=""subheader""> <h3>
 <a name=""discopublish"">Publish publicly available items</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> Publish your entity items to some kind of persistent storage. This enables other entities to query that entity using the disco#items namespace and receive a result even when the entity being queried is not online (or available).</p> 
<b>Usage</b> 
<p>Once you have your ServiceDiscoveryManager you will be able to publish items to some kind of persistent storage. To publish the items of a given XMPP entity you have to first create an instance of <i><b> 
   <clt fqn=""org.jivesoftware.smackx.packet.DiscoverItems"" api=""DiscoverItems"" kind=""class"">
     DiscoverItems 
   </clt></b></i> and configure it with the items to publish. Then you will have to send <b> 
  <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager.publishItems"" api=""ServiceDiscoveryManager"" kind=""method"">
   ServiceDiscoveryManager.publishItems(String entityID, DiscoverItems discoverItems)
  </clt></b> to your <i><b> 
   <clt fqn=""org.jivesoftware.smackx.ServiceDiscoveryManager"" api=""ServiceDiscoveryManager"" kind=""class"">
     ServiceDiscoveryManager 
   </clt></b></i> where entityID is the address of the XMPP entity that will persist the items and discoverItems contains the items to publish.</p> 
<b>Examples</b> 
<p> In this example we can see how to publish new items: </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Obtain the ServiceDiscoveryManager associated with my Connection</font>
ServiceDiscoveryManager discoManager = ServiceDiscoveryManager.getInstanceFor(connection);
<font color=""#3f7f5f"">// Create a DiscoverItems with the items to publish</font>
DiscoverItems itemsToPublish = new DiscoverItems();
DiscoverItems.Item itemToPublish = new DiscoverItems.Item(&quot;pubsub.shakespeare.lit&quot;);
itemToPublish.setName(&quot;Avatar&quot;);
itemToPublish.setNode(&quot;romeo/avatar&quot;);
itemToPublish.setAction(DiscoverItems.Item.UPDATE_ACTION);
itemsToPublish.addItem(itemToPublish);
<font color=""#3f7f5f"">// Publish the new items by sending them to the server</font>
discoManager.publishItems(&quot;host&quot;, itemsToPublish);
</pre> 
</blockquote>","ServiceDiscoveryManager","org.jivesoftware.smackx.ServiceDiscoveryManager","class",1
,"Roster Item Exchange","Send a entire roster","<div class=""subheader""> <h3>
 <a name=""riesendroster"">Send a entire roster</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> Sometimes it is useful to send a whole roster to another user. Smack provides a very easy way to send a complete roster to another XMPP client.</p> 
<b>Usage</b> 
<p> Create an instance of <i><b> 
   <clt fqn=""org.jivesoftware.smackx.RosterExchangeManager"" api=""RosterExchangeManager"" kind=""class"">
     RosterExchangeManager 
   </clt></b></i> and use the <b> 
  <clt fqn=""org.jivesoftware.smackx.RosterExchangeManager.send"" api=""RosterExchangeManager"" kind=""method"">
   #RosterExchangeManager.send(Roster, String)
  </clt></b> message to send a roster to a given user. The first parameter is the roster to send and the second parameter is the id of the user that will receive the roster entries.</p> 
<b>Example</b> 
<p> In this example we can see how user1 sends his roster to user2. </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Connect to the server and log in</font>
conn1 = new XMPPConnection(host);
conn1.login(server_user1, pass1);
<font color=""#3f7f5f"">// Create a new roster exchange manager on conn1</font>
RosterExchangeManager rosterExchangeManager = new RosterExchangeManager(conn1);
<font color=""#3f7f5f"">// Send user1's roster to user2</font>
rosterExchangeManager.send(conn1.getRoster(), user2);
</pre> 
</blockquote>","RosterExchangeManager","org.jivesoftware.smackx.RosterExchangeManager","class",1
,"Roster Item Exchange","Send a roster group","<div class=""subheader""> <h3>
 <a name=""riesendgroup"">Send a roster group</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> It is also possible to send a roster group to another XMPP client. A roster group groups a set of roster entries under a name.</p> 
<b>Usage</b> 
<p> Create an instance of <i><b> 
   <clt fqn=""org.jivesoftware.smackx.RosterExchangeManager"" api=""RosterExchangeManager"" kind=""class"">
     RosterExchangeManager 
   </clt></b></i> and use the <b> 
  <clt fqn=""org.jivesoftware.smackx.RosterExchangeManager.send"" api=""RosterExchangeManager"" kind=""method"">
   #RosterExchangeManager.send(RosterGroup, String)
  </clt></b> message to send a roster group to a given user. The first parameter is the roster group to send and the second parameter is the id of the user that will receive the roster entries.</p> 
<b>Example</b> 
<p> In this example we can see how user1 sends his roster groups to user2. </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Connect to the server and log in</font>
conn1 = new XMPPConnection(host);
conn1.login(server_user1, pass1);
<font color=""#3f7f5f"">// Create a new roster exchange manager on conn1</font>
RosterExchangeManager rosterExchangeManager = new RosterExchangeManager(conn1);
<font color=""#3f7f5f"">// Send user1's RosterGroups to user2</font>
for (Iterator it = conn1.getRoster().getGroups(); it.hasNext(); )
rosterExchangeManager.send((RosterGroup)it.next(), user2);
</pre> 
</blockquote>","RosterExchangeManager","org.jivesoftware.smackx.RosterExchangeManager","class",1
,"Roster Item Exchange","Send a roster entry","<div class=""subheader""> <h3>
 <a name=""riesendentry"">Send a roster entry</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> Sometimes you may need to send a single roster entry to another XMPP client. Smack also lets you send items at this granularity level.</p> 
<b>Usage</b> 
<p> Create an instance of <i><b> 
   <clt fqn=""org.jivesoftware.smackx.RosterExchangeManager"" api=""RosterExchangeManager"" kind=""class"">
     RosterExchangeManager 
   </clt></b></i> and use the <b> 
  <clt fqn=""org.jivesoftware.smackx.RosterExchangeManager.send"" api=""RosterExchangeManager"" kind=""method"">
   #RosterExchangeManager.send(RosterEntry, String)
  </clt></b> message to send a roster entry to a given user. The first parameter is the roster entry to send and the second parameter is the id of the user that will receive the roster entries.</p> 
<b>Example</b> 
<p> In this example we can see how user1 sends a roster entry to user2. </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Connect to the server and log in</font>
conn1 = new XMPPConnection(host);
conn1.login(server_user1, pass1);
<font color=""#3f7f5f"">// Create a new roster exchange manager on conn1</font>
RosterExchangeManager rosterExchangeManager = new RosterExchangeManager(conn1);
<font color=""#3f7f5f"">// Send a roster entry (any) to user2</font>
rosterExchangeManager1.send((RosterEntry)conn1.getRoster().getEntries().next(), user2);
</pre> 
</blockquote>","RosterExchangeManager","org.jivesoftware.smackx.RosterExchangeManager","class",1
,"Roster Item Exchange","Receive roster entries","<div class=""subheader""> <h3>
 <a name=""riercventry"">Receive roster entries</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> Since roster items are sent between XMPP clients, it is necessary to listen to possible roster entries receptions. Smack provides a mechanism that you can use to execute custom logic when roster entries are received.</p> 
<b>Usage</b> 
<ol> 
 <li>Create a class that implements the <i><b> 
    <clt fqn=""org.jivesoftware.smackx.RosterExchangeListener"" api=""RosterExchangeListener"" kind=""class"">
      RosterExchangeListener 
    </clt></b></i> interface.</li> 
 <li>Implement the method <b> 
   <clt fqn=""org.jivesoftware.smackx.RosterExchangeListener.entriesReceived"" api=""RosterExchangeListener"" kind=""method"">
    RosterExchangeListener.entriesReceived(String, Iterator)
   </clt></b> that will be called when new entries are received with custom logic.</li> 
 <li>Add the listener to the <i> 
   <clt fqn=""org.jivesoftware.smackx.RosterExchangeManager"" api=""RosterExchangeManager"" kind=""class"">
     RosterExchangeManager 
   </clt></i> that works on the desired <i> 
   <clt fqn=""org.jivesoftware.smack.Connection"" api=""Connection"" kind=""class"">
     Connection 
   </clt></i>.</li> 
</ol> 
<b>Example</b> 
<p> In this example we can see how user1 sends a roster entry to user2 and user2 adds the received entries to his roster. </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Connect to the server and log in the users</font>
conn1 = new XMPPConnection(host);
conn1.login(server_user1, pass1);
conn2 = new XMPPConnection(host);
conn2.login(server_user2, pass2);
final Roster user2_roster = conn2.getRoster();
<font color=""#3f7f5f"">// Create a RosterExchangeManager that will help user2 to listen and accept
the entries received</font>
RosterExchangeManager rosterExchangeManager2 = new RosterExchangeManager(conn2);
<font color=""#3f7f5f"">// Create a RosterExchangeListener that will iterate over the received roster entries</font>
RosterExchangeListener rosterExchangeListener = new RosterExchangeListener() {
public void entriesReceived(String from, Iterator remoteRosterEntries) {
while (remoteRosterEntries.hasNext()) {
try {
<font color=""#3f7f5f"">// Get the received entry</font>
RemoteRosterEntry remoteRosterEntry = (RemoteRosterEntry) remoteRosterEntries.next();
<font color=""#3f7f5f"">// Display the remote entry on the console</font>
System.out.println(remoteRosterEntry);
<font color=""#3f7f5f"">// Add the entry to the user2's roster</font>
user2_roster.createEntry(
remoteRosterEntry.getUser(),
remoteRosterEntry.getName(),
remoteRosterEntry.getGroupArrayNames());
}
catch (XMPPException e) {
e.printStackTrace();
}
}
}
};
<font color=""#3f7f5f"">// Add the RosterExchangeListener to the RosterExchangeManager that user2 is using</font>
rosterExchangeManager2.addRosterListener(rosterExchangeListener);
<font color=""#3f7f5f"">// Create a RosterExchangeManager that will help user1 to send his roster</font>
RosterExchangeManager rosterExchangeManager1 = new RosterExchangeManager(conn1);
<font color=""#3f7f5f"">// Send user1's roster to user2</font>
rosterExchangeManager1.send(conn1.getRoster(), user2);
</pre> 
</blockquote>","RosterExchangeListener","org.jivesoftware.smackx.RosterExchangeListener","class",1
,"Roster Item Exchange","Receive roster entries","<div class=""subheader""> <h3>
 <a name=""riercventry"">Receive roster entries</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> Since roster items are sent between XMPP clients, it is necessary to listen to possible roster entries receptions. Smack provides a mechanism that you can use to execute custom logic when roster entries are received.</p> 
<b>Usage</b> 
<ol> 
 <li>Create a class that implements the <i><b> 
    <clt fqn=""org.jivesoftware.smackx.RosterExchangeListener"" api=""RosterExchangeListener"" kind=""class"">
      RosterExchangeListener 
    </clt></b></i> interface.</li> 
 <li>Implement the method <b> 
   <clt fqn=""org.jivesoftware.smackx.RosterExchangeListener.entriesReceived"" api=""RosterExchangeListener"" kind=""method"">
    RosterExchangeListener.entriesReceived(String, Iterator)
   </clt></b> that will be called when new entries are received with custom logic.</li> 
 <li>Add the listener to the <i> 
   <clt fqn=""org.jivesoftware.smackx.RosterExchangeManager"" api=""RosterExchangeManager"" kind=""class"">
     RosterExchangeManager 
   </clt></i> that works on the desired <i> 
   <clt fqn=""org.jivesoftware.smack.Connection"" api=""Connection"" kind=""class"">
     Connection 
   </clt></i>.</li> 
</ol> 
<b>Example</b> 
<p> In this example we can see how user1 sends a roster entry to user2 and user2 adds the received entries to his roster. </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Connect to the server and log in the users</font>
conn1 = new XMPPConnection(host);
conn1.login(server_user1, pass1);
conn2 = new XMPPConnection(host);
conn2.login(server_user2, pass2);
final Roster user2_roster = conn2.getRoster();
<font color=""#3f7f5f"">// Create a RosterExchangeManager that will help user2 to listen and accept
the entries received</font>
RosterExchangeManager rosterExchangeManager2 = new RosterExchangeManager(conn2);
<font color=""#3f7f5f"">// Create a RosterExchangeListener that will iterate over the received roster entries</font>
RosterExchangeListener rosterExchangeListener = new RosterExchangeListener() {
public void entriesReceived(String from, Iterator remoteRosterEntries) {
while (remoteRosterEntries.hasNext()) {
try {
<font color=""#3f7f5f"">// Get the received entry</font>
RemoteRosterEntry remoteRosterEntry = (RemoteRosterEntry) remoteRosterEntries.next();
<font color=""#3f7f5f"">// Display the remote entry on the console</font>
System.out.println(remoteRosterEntry);
<font color=""#3f7f5f"">// Add the entry to the user2's roster</font>
user2_roster.createEntry(
remoteRosterEntry.getUser(),
remoteRosterEntry.getName(),
remoteRosterEntry.getGroupArrayNames());
}
catch (XMPPException e) {
e.printStackTrace();
}
}
}
};
<font color=""#3f7f5f"">// Add the RosterExchangeListener to the RosterExchangeManager that user2 is using</font>
rosterExchangeManager2.addRosterListener(rosterExchangeListener);
<font color=""#3f7f5f"">// Create a RosterExchangeManager that will help user1 to send his roster</font>
RosterExchangeManager rosterExchangeManager1 = new RosterExchangeManager(conn1);
<font color=""#3f7f5f"">// Send user1's roster to user2</font>
rosterExchangeManager1.send(conn1.getRoster(), user2);
</pre> 
</blockquote>","RosterExchangeManager","org.jivesoftware.smackx.RosterExchangeManager","class",0
,"Roster Item Exchange","Receive roster entries","<div class=""subheader""> <h3>
 <a name=""riercventry"">Receive roster entries</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> Since roster items are sent between XMPP clients, it is necessary to listen to possible roster entries receptions. Smack provides a mechanism that you can use to execute custom logic when roster entries are received.</p> 
<b>Usage</b> 
<ol> 
 <li>Create a class that implements the <i><b> 
    <clt fqn=""org.jivesoftware.smackx.RosterExchangeListener"" api=""RosterExchangeListener"" kind=""class"">
      RosterExchangeListener 
    </clt></b></i> interface.</li> 
 <li>Implement the method <b> 
   <clt fqn=""org.jivesoftware.smackx.RosterExchangeListener.entriesReceived"" api=""RosterExchangeListener"" kind=""method"">
    RosterExchangeListener.entriesReceived(String, Iterator)
   </clt></b> that will be called when new entries are received with custom logic.</li> 
 <li>Add the listener to the <i> 
   <clt fqn=""org.jivesoftware.smackx.RosterExchangeManager"" api=""RosterExchangeManager"" kind=""class"">
     RosterExchangeManager 
   </clt></i> that works on the desired <i> 
   <clt fqn=""org.jivesoftware.smack.Connection"" api=""Connection"" kind=""class"">
     Connection 
   </clt></i>.</li> 
</ol> 
<b>Example</b> 
<p> In this example we can see how user1 sends a roster entry to user2 and user2 adds the received entries to his roster. </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Connect to the server and log in the users</font>
conn1 = new XMPPConnection(host);
conn1.login(server_user1, pass1);
conn2 = new XMPPConnection(host);
conn2.login(server_user2, pass2);
final Roster user2_roster = conn2.getRoster();
<font color=""#3f7f5f"">// Create a RosterExchangeManager that will help user2 to listen and accept
the entries received</font>
RosterExchangeManager rosterExchangeManager2 = new RosterExchangeManager(conn2);
<font color=""#3f7f5f"">// Create a RosterExchangeListener that will iterate over the received roster entries</font>
RosterExchangeListener rosterExchangeListener = new RosterExchangeListener() {
public void entriesReceived(String from, Iterator remoteRosterEntries) {
while (remoteRosterEntries.hasNext()) {
try {
<font color=""#3f7f5f"">// Get the received entry</font>
RemoteRosterEntry remoteRosterEntry = (RemoteRosterEntry) remoteRosterEntries.next();
<font color=""#3f7f5f"">// Display the remote entry on the console</font>
System.out.println(remoteRosterEntry);
<font color=""#3f7f5f"">// Add the entry to the user2's roster</font>
user2_roster.createEntry(
remoteRosterEntry.getUser(),
remoteRosterEntry.getName(),
remoteRosterEntry.getGroupArrayNames());
}
catch (XMPPException e) {
e.printStackTrace();
}
}
}
};
<font color=""#3f7f5f"">// Add the RosterExchangeListener to the RosterExchangeManager that user2 is using</font>
rosterExchangeManager2.addRosterListener(rosterExchangeListener);
<font color=""#3f7f5f"">// Create a RosterExchangeManager that will help user1 to send his roster</font>
RosterExchangeManager rosterExchangeManager1 = new RosterExchangeManager(conn1);
<font color=""#3f7f5f"">// Send user1's roster to user2</font>
rosterExchangeManager1.send(conn1.getRoster(), user2);
</pre> 
</blockquote>","Connection","org.jivesoftware.smack.Connection","class",0
,"Roster and Presence","Roster and Presence","<div class=""header""><h3>
  Roster and Presence </h3>
</div> 
<p> The roster lets you keep track of the availability (&quot;presence&quot;) of other users. A roster also allows you to organize users into groups such as &quot;Friends&quot; and &quot;Co-workers&quot;. Other IM systems refer to the roster as the buddy list, contact list, etc.</p> 
<p> A <tt> 
  <clt fqn=""org.jivesoftware.smack.Roster"" api=""Roster"" kind=""class"">
    Roster 
  </clt></tt> instance is obtained using the <tt> 
  <clt fqn=""org.jivesoftware.smack.Connection.getRoster"" api=""Connection"" kind=""method"">
  Connection.getRoster()
  </clt></tt> method. </p>","Roster","org.jivesoftware.smack.Roster","class",1
,"Roster and Presence","Roster and Presence","<div class=""header""><h3>
  Roster and Presence </h3>
</div> 
<p> The roster lets you keep track of the availability (&quot;presence&quot;) of other users. A roster also allows you to organize users into groups such as &quot;Friends&quot; and &quot;Co-workers&quot;. Other IM systems refer to the roster as the buddy list, contact list, etc.</p> 
<p> A <tt> 
  <clt fqn=""org.jivesoftware.smack.Roster"" api=""Roster"" kind=""class"">
    Roster 
  </clt></tt> instance is obtained using the <tt> 
  <clt fqn=""org.jivesoftware.smack.Connection.getRoster"" api=""Connection"" kind=""method"">
  Connection.getRoster()
  </clt></tt> method. </p>","Connection","org.jivesoftware.smack.Connection","class",0
,"XHTML Messages","Compose an XHTML Message - part 2","<h3>Compose an XHTML Message - part 2</h3>
<p> Create an instance of <i><b> 
   <clt fqn=""org.jivesoftware.smackx.XHTMLText"" api=""XHTMLText"" kind=""class"">
     XHTMLText 
   </clt></b></i> specifying the style and language of the body. You can add several XHTML bodies to the message but each body should be for a different language. Once you have an XHTMLText you can start to append tags and text to it. In order to append tags there are several messages that you can use. For each XHTML defined tag there is a message that you can send. In order to add text you can send the message <b> 
  <clt fqn=""org.jivesoftware.smackx.XHTMLText.append"" api=""XHTMLText"" kind=""method"">
   #XHTMLText.append(String textToAppend)
  </clt></b>.</p> 
<p>After you have configured the XHTML text, the last step you have to do is to add the XHTML text to the message you want to send. If you decided to create the XHTML text by yourself, you will have to follow this last step too. In order to add the XHTML text to the message send the message <b> 
  <clt fqn=""org.jivesoftware.smackx.XHTMLManager.addBody"" api=""XHTMLManager"" kind=""method"">
   #XHTMLManager.addBody(Message message, String body)
  </clt></b> to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.XHTMLManager"" api=""XHTMLManager"" kind=""class"">
     XHTMLManager 
   </clt></b></i> class where <i>message</i> is the message that will receive the XHTML body and <i>body</i> is the string to add as an XHTML body to the message.</p>","XHTMLText","org.jivesoftware.smackx.XHTMLText","class",1
,"XHTML Messages","Compose an XHTML Message - part 2","<h3>Compose an XHTML Message - part 2</h3>
<p> Create an instance of <i><b> 
   <clt fqn=""org.jivesoftware.smackx.XHTMLText"" api=""XHTMLText"" kind=""class"">
     XHTMLText 
   </clt></b></i> specifying the style and language of the body. You can add several XHTML bodies to the message but each body should be for a different language. Once you have an XHTMLText you can start to append tags and text to it. In order to append tags there are several messages that you can use. For each XHTML defined tag there is a message that you can send. In order to add text you can send the message <b> 
  <clt fqn=""org.jivesoftware.smackx.XHTMLText.append"" api=""XHTMLText"" kind=""method"">
   #XHTMLText.append(String textToAppend)
  </clt></b>.</p> 
<p>After you have configured the XHTML text, the last step you have to do is to add the XHTML text to the message you want to send. If you decided to create the XHTML text by yourself, you will have to follow this last step too. In order to add the XHTML text to the message send the message <b> 
  <clt fqn=""org.jivesoftware.smackx.XHTMLManager.addBody"" api=""XHTMLManager"" kind=""method"">
   #XHTMLManager.addBody(Message message, String body)
  </clt></b> to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.XHTMLManager"" api=""XHTMLManager"" kind=""class"">
     XHTMLManager 
   </clt></b></i> class where <i>message</i> is the message that will receive the XHTML body and <i>body</i> is the string to add as an XHTML body to the message.</p>","XHTMLManager","org.jivesoftware.smackx.XHTMLManager","class",1
,"XHTML Messages","Send an XHTML Message","<div class=""subheader""> <h3>
 <a name=""xhtmlsend"">Send an XHTML Message</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> After you have composed an XHTML message you will want to send it. Once you have added the XHTML content to the message you want to send you are almost done. The last step is to send the message as you do with any other message.</p> 
<b>Usage</b> 
<p> An XHTML message is like any regular message, therefore to send the message you can follow the usual steps you do in order to send a message. For example, to send a message as part of a chat just use the message <b>#send(Message)</b> of <i><b> 
   <clt fqn=""org.jivesoftware.smack.Chat"" api=""Chat"" kind=""class"">
     Chat 
   </clt></b></i> or you can use the message <b>#send(Packet)</b> of <i><b> 
   <clt fqn=""org.jivesoftware.smack.Connection"" api=""Connection"" kind=""class"">
     Connection 
   </clt></b></i>.</p> 
<b>Example</b> 
<p> In this example we can see how to send a message with XHTML content as part of a chat. </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Create a message to send</font>
Message msg = chat.createMessage();
<font color=""#3f7f5f"">// Obtain the XHTML text to send from somewhere</font>
String xhtmlBody = getXHTMLTextToSend();
<font color=""#3f7f5f"">// Add the XHTML text to the message</font>
XHTMLManager.addBody(msg, xhtmlBody);
<font color=""#3f7f5f"">// Send the message that contains the XHTML</font>
chat.sendMessage(msg);
</pre> 
</blockquote>","Chat","org.jivesoftware.smack.Chat","class",0
,"XHTML Messages","Send an XHTML Message","<div class=""subheader""> <h3>
 <a name=""xhtmlsend"">Send an XHTML Message</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> After you have composed an XHTML message you will want to send it. Once you have added the XHTML content to the message you want to send you are almost done. The last step is to send the message as you do with any other message.</p> 
<b>Usage</b> 
<p> An XHTML message is like any regular message, therefore to send the message you can follow the usual steps you do in order to send a message. For example, to send a message as part of a chat just use the message <b>#send(Message)</b> of <i><b> 
   <clt fqn=""org.jivesoftware.smack.Chat"" api=""Chat"" kind=""class"">
     Chat 
   </clt></b></i> or you can use the message <b>#send(Packet)</b> of <i><b> 
   <clt fqn=""org.jivesoftware.smack.Connection"" api=""Connection"" kind=""class"">
     Connection 
   </clt></b></i>.</p> 
<b>Example</b> 
<p> In this example we can see how to send a message with XHTML content as part of a chat. </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Create a message to send</font>
Message msg = chat.createMessage();
<font color=""#3f7f5f"">// Obtain the XHTML text to send from somewhere</font>
String xhtmlBody = getXHTMLTextToSend();
<font color=""#3f7f5f"">// Add the XHTML text to the message</font>
XHTMLManager.addBody(msg, xhtmlBody);
<font color=""#3f7f5f"">// Send the message that contains the XHTML</font>
chat.sendMessage(msg);
</pre> 
</blockquote>","Connection","org.jivesoftware.smack.Connection","class",0
,"XHTML Messages","Receive an XHTML Message","<div class=""subheader""> <h3>
 <a name=""xhtmlreceive"">Receive an XHTML Message</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> It is also possible to obtain the XHTML content from a received message. Remember that the specification defines that a message may contain several XHTML bodies where each body should be for a different language.</p> 
<b>Usage</b> 
<p> To get the XHTML bodies of a given message just send the message <b> 
  <clt fqn=""org.jivesoftware.smackx.XHTMLManager.getBodies"" api=""XHTMLManager"" kind=""method"">
   #XHTMLManager.getBodies(Message)
  </clt></b> to the class <i><b> 
   <clt fqn=""org.jivesoftware.smackx.XHTMLManager"" api=""XHTMLManager"" kind=""class"">
     XHTMLManager 
   </clt></b></i>. The answer of this message will be an <i><b>Iterator</b></i> with the different XHTML bodies of the message or null if none.</p> 
<b>Example</b> 
<p> In this example we can see how to create a PacketListener that obtains the XHTML bodies of any received message. </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Create a listener for the chat and display any XHTML content</font>
PacketListener packetListener = new PacketListener() {
public void processPacket(Packet packet) {
Message message = (Message) packet;
<font color=""#3f7f5f"">// Obtain the XHTML bodies of the message</font>
Iterator it = XHTMLManager.getBodies(message);
if (it != null) {
<font color=""#3f7f5f"">// Display the bodies on the console</font>
while (it.hasNext()) {
String body = (String) it.next();
System.out.println(body);
}
}
};
chat.addMessageListener(packetListener);
</pre> 
</blockquote>","XHTMLManager","org.jivesoftware.smackx.XHTMLManager","class",1
,"XHTML Messages","Discover support for XHTML Messages","<div class=""subheader""> <h3>
 <a name=""xhtmldiscover"">Discover support for XHTML Messages</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> Before you start to send XHTML messages to a user you should discover if the user supports XHTML messages. There are two ways to achieve the discovery, explicitly and implicitly. Explicit is when you first try to discover if the user supports XHTML before sending any XHTML message. Implicit is when you send XHTML messages without first discovering if the conversation partner's client supports XHTML and depenging on the answer (normal message or XHTML message) you find out if the user supports XHTML messages or not. This section explains how to explicitly discover for XHTML support.</p> 
<b>Usage</b> 
<p> In order to discover if a remote user supports XHTML messages send <b> 
  <clt fqn=""org.jivesoftware.smackx.XHTMLManager.isServiceEnabled"" api=""XHTMLManager"" kind=""method"">
   #XHTMLManager.isServiceEnabled(Connection connection, String userID)
  </clt></b> to the class <i><b> 
   <clt fqn=""org.jivesoftware.smackx.XHTMLManager"" api=""XHTMLManager"" kind=""class"">
     XHTMLManager 
   </clt></b></i> where connection is the connection to use to perform the service discovery and userID is the user to check (A fully qualified xmpp ID, e.g. jdoe@example.com). This message will return true if the specified user handles XHTML messages.</p> 
<b>Example</b> 
<p> In this example we can see how to discover if a remote user supports XHTML Messages. </p> 
<blockquote> 
 <pre>      Message msg = chat.createMessage();
<font color=""#3f7f5f"">// Include a normal body in the message</font>
msg.setBody(getTextToSend());
<font color=""#3f7f5f"">// Check if the other user supports XHTML messages</font>
if (XHTMLManager.isServiceEnabled(connection, chat.getParticipant())) {
<font color=""#3f7f5f"">// Obtain the XHTML text to send from somewhere</font>
String xhtmlBody = getXHTMLTextToSend();
<font color=""#3f7f5f"">// Include an XHTML body in the message</font>
XHTMLManager.addBody(msg, xhtmlBody);
}
<font color=""#3f7f5f"">// Send the message</font>
chat.sendMessage(msg);
</pre> 
</blockquote>","XHTMLManager","org.jivesoftware.smackx.XHTMLManager","class",1
,"Multi User Chat","Create a new Room","<div class=""subheader""> <h3>
 <a name=""create"">Create a new Room</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> Allowed users may create new rooms. There are two types of rooms that you can create. <b>Instant rooms</b> which are available for immediate access and are automatically created based on some default configuration and <b>Reserved rooms</b> which are manually configured by the room creator before anyone is allowed to enter.</p> 
<b>Usage</b> 
<p> In order to create a room you will need to first create an instance of <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i>. The room name passed to the constructor will be the name of the room to create. The next step is to send <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.create"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.create(String nickname)
  </clt></b> to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> instance where nickname is the nickname to use when joining the room.</p> 
<p> Depending on the type of room that you want to create you will have to use different configuration forms. In order to create an Instant room just send <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.sendConfigurationForm"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.sendConfigurationForm(Form form)
  </clt></b> where form is an empty form. But if you want to create a Reserved room then you should first get the room's configuration form, complete the form and finally send it back to the server.</p>","MultiUserChat","org.jivesoftware.smackx.muc.MultiUserChat","class",1
,"Multi User Chat","Join a room","<div class=""subheader""> <h3>
 <a name=""join"">Join a room</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> Your usual first step in order to send messages to a room is to join the room. Multi User Chat allows to specify several parameter while joining a room. Basically you can control the amount of history to receive after joining the room as well as provide your nickname within the room and a password if the room is password protected.</p> 
<b>Usage</b> 
<p> In order to join a room you will need to first create an instance of <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i>. The room name passed to the constructor will be the name of the room to join. The next step is to send <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.join"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.join(...)
  </clt></b> to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> instance. But first you will have to decide which join message to send. If you want to just join the room without a password and without specifying the amount of history to receive then you could use <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.join"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.join(String nickname)
  </clt></b> where nickname if your nickname in the room. In case the room requires a password in order to join you could then use <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.join"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.join(String nickname, String password)
  </clt></b>. And finally, the most complete way to join a room is to send <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.join"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.join(String nickname, String password, DiscussionHistory history, long timeout)
  </clt></b> where nickname is your nickname in the room, , password is your password to join the room, history is an object that specifies the amount of history to receive and timeout is the milliseconds to wait for a response from the server.</p>","MultiUserChat","org.jivesoftware.smackx.muc.MultiUserChat","class",1
,"Multi User Chat","Manage room invitations","<div class=""subheader""> <h3>
 <a name=""invite"">Manage room invitations</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> It can be useful to invite another user to a room in which one is an occupant. Depending on the room's type the invitee could receive a password to use to join the room and/or be added to the member list if the room is of type members-only. Smack allows to send room invitations and let potential invitees to listening for room invitations and inviters to listen for invitees' rejections.</p> 
<b>Usage</b> 
<p> In order to invite another user to a room you must be already joined to the room. Once you are joined just send <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.invite"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.invite(String participant, String reason)
  </clt></b> to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> where participant is the user to invite to the room (e.g. hecate@shakespeare.lit) and reason is the reason why the user is being invited.</p> 
<p> If potential invitees want to listen for room invitations then the invitee must add an <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.InvitationListener"" api=""InvitationListener"" kind=""class"">
     InvitationListener 
   </clt></b></i> to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> class. Since the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.InvitationListener"" api=""InvitationListener"" kind=""class"">
     InvitationListener 
   </clt></b></i> is an <i>interface</i>, it is necessary to create a class that implements this <i>interface</i>. If an inviter wants to listen for room invitation rejections, just add an <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.InvitationRejectionListener"" api=""InvitationRejectionListener"" kind=""class"">
     InvitationRejectionListener 
   </clt></b></i> to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i>. <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.InvitationRejectionListener"" api=""InvitationRejectionListener"" kind=""class"">
     InvitationRejectionListener 
   </clt></b></i> is also an interface so you will need to create a class that implements this interface.</p>","MultiUserChat","org.jivesoftware.smackx.muc.MultiUserChat","class",1
,"Multi User Chat","Manage room invitations","<div class=""subheader""> <h3>
 <a name=""invite"">Manage room invitations</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> It can be useful to invite another user to a room in which one is an occupant. Depending on the room's type the invitee could receive a password to use to join the room and/or be added to the member list if the room is of type members-only. Smack allows to send room invitations and let potential invitees to listening for room invitations and inviters to listen for invitees' rejections.</p> 
<b>Usage</b> 
<p> In order to invite another user to a room you must be already joined to the room. Once you are joined just send <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.invite"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.invite(String participant, String reason)
  </clt></b> to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> where participant is the user to invite to the room (e.g. hecate@shakespeare.lit) and reason is the reason why the user is being invited.</p> 
<p> If potential invitees want to listen for room invitations then the invitee must add an <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.InvitationListener"" api=""InvitationListener"" kind=""class"">
     InvitationListener 
   </clt></b></i> to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> class. Since the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.InvitationListener"" api=""InvitationListener"" kind=""class"">
     InvitationListener 
   </clt></b></i> is an <i>interface</i>, it is necessary to create a class that implements this <i>interface</i>. If an inviter wants to listen for room invitation rejections, just add an <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.InvitationRejectionListener"" api=""InvitationRejectionListener"" kind=""class"">
     InvitationRejectionListener 
   </clt></b></i> to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i>. <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.InvitationRejectionListener"" api=""InvitationRejectionListener"" kind=""class"">
     InvitationRejectionListener 
   </clt></b></i> is also an interface so you will need to create a class that implements this interface.</p>","InvitationListener","org.jivesoftware.smackx.muc.InvitationListener","class",0
,"Multi User Chat","Manage room invitations","<div class=""subheader""> <h3>
 <a name=""invite"">Manage room invitations</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> It can be useful to invite another user to a room in which one is an occupant. Depending on the room's type the invitee could receive a password to use to join the room and/or be added to the member list if the room is of type members-only. Smack allows to send room invitations and let potential invitees to listening for room invitations and inviters to listen for invitees' rejections.</p> 
<b>Usage</b> 
<p> In order to invite another user to a room you must be already joined to the room. Once you are joined just send <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.invite"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.invite(String participant, String reason)
  </clt></b> to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> where participant is the user to invite to the room (e.g. hecate@shakespeare.lit) and reason is the reason why the user is being invited.</p> 
<p> If potential invitees want to listen for room invitations then the invitee must add an <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.InvitationListener"" api=""InvitationListener"" kind=""class"">
     InvitationListener 
   </clt></b></i> to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> class. Since the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.InvitationListener"" api=""InvitationListener"" kind=""class"">
     InvitationListener 
   </clt></b></i> is an <i>interface</i>, it is necessary to create a class that implements this <i>interface</i>. If an inviter wants to listen for room invitation rejections, just add an <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.InvitationRejectionListener"" api=""InvitationRejectionListener"" kind=""class"">
     InvitationRejectionListener 
   </clt></b></i> to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i>. <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.InvitationRejectionListener"" api=""InvitationRejectionListener"" kind=""class"">
     InvitationRejectionListener 
   </clt></b></i> is also an interface so you will need to create a class that implements this interface.</p>","InvitationRejectionListener","org.jivesoftware.smackx.muc.InvitationRejectionListener","class",0
,"Multi User Chat","Discover MUC support","<div class=""subheader""> <h3>
 <a name=""discomuc"">Discover MUC support</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> A user may want to discover if one of the user's contacts supports the Multi-User Chat protocol.</p> 
<b>Usage</b> 
<p> In order to discover if one of the user's contacts supports MUC just send <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.isServiceEnabled"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.isServiceEnabled(Connection connection, String user)
  </clt></b> to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> class where user is a fully qualified XMPP ID, e.g. jdoe@example.com. You will receive a boolean indicating whether the user supports MUC or not.</p> 
<b>Examples</b> 
<p> In this example we can see how to discover support of MUC: </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Discover whether user3@host.org supports MUC or not</font>
boolean supports = MultiUserChat.isServiceEnabled(conn, <font color=""#0000FF"">&quot;user3@host.org/Smack&quot;</font>);
</pre> 
</blockquote>","MultiUserChat","org.jivesoftware.smackx.muc.MultiUserChat","class",1
,"Multi User Chat","Discover joined rooms","<div class=""subheader""> <h3>
 <a name=""discojoin"">Discover joined rooms</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> A user may also want to query a contact regarding which rooms the contact is in.</p> 
<b>Usage</b> 
<p> In order to get the rooms where a user is in just send <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.getJoinedRooms"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.getJoinedRooms(Connection connection, String user)
  </clt></b> to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> class where user is a fully qualified XMPP ID, e.g. jdoe@example.com. You will get an Iterator of Strings as an answer where each String represents a room name.</p> 
<b>Examples</b> 
<p> In this example we can see how to get the rooms where a user is in: </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Get the rooms where user3@host.org has joined</font>
Iterator joinedRooms = MultiUserChat.getJoinedRooms(conn, <font color=""#0000FF"">&quot;user3@host.org/Smack&quot;</font>);
</pre> 
</blockquote>","MultiUserChat","org.jivesoftware.smackx.muc.MultiUserChat","class",1
,"Multi User Chat","Discover room information","<div class=""subheader""> <h3>
 <a name=""discoroom"">Discover room information</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> A user may need to discover information about a room without having to actually join the room. The server will provide information only for public rooms.</p> 
<b>Usage</b> 
<p> In order to discover information about a room just send <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.getRoomInfo"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.getRoomInfo(Connection connection, String room)
  </clt></b> to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> class where room is the XMPP ID of the room, e.g. roomName@conference.myserver. You will get a RoomInfo object that contains the discovered room information.</p> 
<b>Examples</b> 
<p> In this example we can see how to discover information about a room: </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Discover information about the room roomName@conference.myserver</font>
RoomInfo info = MultiUserChat.getRoomInfo(conn, <font color=""#0000FF"">&quot;roomName@conference.myserver&quot;</font>);
System.out.println(&quot;Number of occupants:&quot; + info.getOccupantsCount());
System.out.println(&quot;Room Subject:&quot; + info.getSubject());
</pre> 
</blockquote>","MultiUserChat","org.jivesoftware.smackx.muc.MultiUserChat","class",1
,"Multi User Chat","Start a private chat","<div class=""subheader""> <h3>
 <a name=""privchat"">Start a private chat</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> A room occupant may want to start a private chat with another room occupant even though they don't know the fully qualified XMPP ID (e.g. jdoe@example.com) of each other.</p> 
<b>Usage</b> 
<p> To create a private chat with another room occupant just send <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.createPrivateChat"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.createPrivateChat(String participant)
  </clt></b> to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> that you used to join the room. The parameter participant is the occupant unique room JID (e.g. 'darkcave@macbeth.shakespeare.lit/Paul'). You will receive a regular <i><b> 
   <clt fqn=""org.jivesoftware.smack.Chat"" api=""Chat"" kind=""class"">
     Chat 
   </clt></b></i> object that you can use to chat with the other room occupant.</p> 
<b>Examples</b> 
<p> In this example we can see how to start a private chat with another room occupant: </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Start a private chat with another participant</font>
Chat chat = muc2.createPrivateChat(<font color=""#0000FF"">&quot;myroom@conference.jabber.org/johndoe&quot;</font>);
chat.sendMessage(<font color=""#0000FF"">&quot;Hello there&quot;</font>);
</pre> 
</blockquote>","MultiUserChat","org.jivesoftware.smackx.muc.MultiUserChat","class",1
,"Multi User Chat","Start a private chat","<div class=""subheader""> <h3>
 <a name=""privchat"">Start a private chat</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> A room occupant may want to start a private chat with another room occupant even though they don't know the fully qualified XMPP ID (e.g. jdoe@example.com) of each other.</p> 
<b>Usage</b> 
<p> To create a private chat with another room occupant just send <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.createPrivateChat"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.createPrivateChat(String participant)
  </clt></b> to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> that you used to join the room. The parameter participant is the occupant unique room JID (e.g. 'darkcave@macbeth.shakespeare.lit/Paul'). You will receive a regular <i><b> 
   <clt fqn=""org.jivesoftware.smack.Chat"" api=""Chat"" kind=""class"">
     Chat 
   </clt></b></i> object that you can use to chat with the other room occupant.</p> 
<b>Examples</b> 
<p> In this example we can see how to start a private chat with another room occupant: </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Start a private chat with another participant</font>
Chat chat = muc2.createPrivateChat(<font color=""#0000FF"">&quot;myroom@conference.jabber.org/johndoe&quot;</font>);
chat.sendMessage(<font color=""#0000FF"">&quot;Hello there&quot;</font>);
</pre> 
</blockquote>","Chat","org.jivesoftware.smack.Chat","class",0
,"Multi User Chat","Manage changes on room subject","<div class=""subheader""> <h3>
 <a name=""subject"">Manage changes on room subject</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> A common feature of multi-user chat rooms is the ability to change the subject within the room. As a default, only users with a role of &quot;moderator&quot; are allowed to change the subject in a room. Although some rooms may be configured to allow a mere participant or even a visitor to change the subject.</p> 
<p> Every time the room's subject is changed you may want to be notified of the modification. The new subject could be used to display an in-room message.</p> 
<b>Usage</b> 
<p> In order to modify the room's subject just send <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.changeSubject"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.changeSubject(String subject)
  </clt></b> to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> that you used to join the room where subject is the new room's subject. On the other hand, if you want to be notified whenever the room's subject is modified you should add a <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.SubjectUpdatedListener"" api=""SubjectUpdatedListener"" kind=""class"">
     SubjectUpdatedListener 
   </clt></b></i> to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> by sending <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.addSubjectUpdatedListener"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.addSubjectUpdatedListener(SubjectUpdatedListener listener)
  </clt></b> to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i>. Since the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.SubjectUpdatedListener"" api=""SubjectUpdatedListener"" kind=""class"">
     SubjectUpdatedListener 
   </clt></b></i> is an <i>interface</i>, it is necessary to create a class that implements this <i>interface</i>.</p> 
<b>Examples</b> 
<p> In this example we can see how to change the room's subject and react whenever the room's subject is modified: </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// An occupant wants to be notified every time the room's subject is changed</font>
muc3.addSubjectUpdatedListener(new SubjectUpdatedListener() {
public void subjectUpdated(String subject, String from) {
....
}
});
<font color=""#3f7f5f"">// A room's owner changes the room's subject</font>
muc2.changeSubject(<font color=""#0000FF"">&quot;New Subject&quot;</font>);
</pre> 
</blockquote>","MultiUserChat","org.jivesoftware.smackx.muc.MultiUserChat","class",1
,"Multi User Chat","Manage changes on room subject","<div class=""subheader""> <h3>
 <a name=""subject"">Manage changes on room subject</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> A common feature of multi-user chat rooms is the ability to change the subject within the room. As a default, only users with a role of &quot;moderator&quot; are allowed to change the subject in a room. Although some rooms may be configured to allow a mere participant or even a visitor to change the subject.</p> 
<p> Every time the room's subject is changed you may want to be notified of the modification. The new subject could be used to display an in-room message.</p> 
<b>Usage</b> 
<p> In order to modify the room's subject just send <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.changeSubject"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.changeSubject(String subject)
  </clt></b> to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> that you used to join the room where subject is the new room's subject. On the other hand, if you want to be notified whenever the room's subject is modified you should add a <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.SubjectUpdatedListener"" api=""SubjectUpdatedListener"" kind=""class"">
     SubjectUpdatedListener 
   </clt></b></i> to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> by sending <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.addSubjectUpdatedListener"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.addSubjectUpdatedListener(SubjectUpdatedListener listener)
  </clt></b> to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i>. Since the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.SubjectUpdatedListener"" api=""SubjectUpdatedListener"" kind=""class"">
     SubjectUpdatedListener 
   </clt></b></i> is an <i>interface</i>, it is necessary to create a class that implements this <i>interface</i>.</p> 
<b>Examples</b> 
<p> In this example we can see how to change the room's subject and react whenever the room's subject is modified: </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// An occupant wants to be notified every time the room's subject is changed</font>
muc3.addSubjectUpdatedListener(new SubjectUpdatedListener() {
public void subjectUpdated(String subject, String from) {
....
}
});
<font color=""#3f7f5f"">// A room's owner changes the room's subject</font>
muc2.changeSubject(<font color=""#0000FF"">&quot;New Subject&quot;</font>);
</pre> 
</blockquote>","SubjectUpdatedListener","org.jivesoftware.smackx.muc.SubjectUpdatedListener","class",1
,"Multi User Chat","Manage role modifications - part 2","<h3>Manage role modifications - part 2</h3>
<b>Usage</b> 
<p> In order to grant voice (i.e. make someone a <i>participant</i>) just send the message <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.grantVoice"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.grantVoice(String nickname)
  </clt></b> to <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i>. Use <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.revokeVoice"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.revokeVoice(String nickname)
  </clt></b> to revoke the occupant's voice (i.e. make the occupant a <i>visitor</i>).</p> 
<p> In order to grant moderator privileges to a participant or visitor just send the message <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.grantModerator"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.grantModerator(String nickname)
  </clt></b> to <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i>. Use <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.revokeModerator"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.revokeModerator(String nickname)
  </clt></b> to revoke the moderator privilege from the occupant thus making the occupant a participant.</p> 
<p> Smack allows you to listen for role modification events. If you are interested in listening role modification events of any occupant then use the listener <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.ParticipantStatusListener"" api=""ParticipantStatusListener"" kind=""class"">
     ParticipantStatusListener 
   </clt></i></b>. But if you are interested in listening for your own role modification events, use the listener <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.UserStatusListener"" api=""UserStatusListener"" kind=""class"">
     UserStatusListener 
   </clt></i></b>. Both listeners should be added to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> by using <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.addParticipantStatusListener"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.addParticipantStatusListener(ParticipantStatusListener listener)
  </clt></b> or <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.addUserStatusListener"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.addUserStatusListener(UserStatusListener listener)
  </clt></b> respectively. These listeners include several notification events but you may be interested in just a few of them. Smack provides default implementations for these listeners avoiding you to implement all the interfaces' methods. The default implementations are <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.DefaultUserStatusListener"" api=""DefaultUserStatusListener"" kind=""class"">
     DefaultUserStatusListener 
   </clt></i></b> and <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.DefaultParticipantStatusListener"" api=""DefaultParticipantStatusListener"" kind=""class"">
     DefaultParticipantStatusListener 
   </clt></i></b>. Below you will find the sent messages to the listeners whenever an occupant's role has changed.</p>","MultiUserChat","org.jivesoftware.smackx.muc.MultiUserChat","class",1
,"Multi User Chat","Manage role modifications - part 2","<h3>Manage role modifications - part 2</h3>
<b>Usage</b> 
<p> In order to grant voice (i.e. make someone a <i>participant</i>) just send the message <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.grantVoice"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.grantVoice(String nickname)
  </clt></b> to <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i>. Use <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.revokeVoice"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.revokeVoice(String nickname)
  </clt></b> to revoke the occupant's voice (i.e. make the occupant a <i>visitor</i>).</p> 
<p> In order to grant moderator privileges to a participant or visitor just send the message <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.grantModerator"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.grantModerator(String nickname)
  </clt></b> to <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i>. Use <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.revokeModerator"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.revokeModerator(String nickname)
  </clt></b> to revoke the moderator privilege from the occupant thus making the occupant a participant.</p> 
<p> Smack allows you to listen for role modification events. If you are interested in listening role modification events of any occupant then use the listener <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.ParticipantStatusListener"" api=""ParticipantStatusListener"" kind=""class"">
     ParticipantStatusListener 
   </clt></i></b>. But if you are interested in listening for your own role modification events, use the listener <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.UserStatusListener"" api=""UserStatusListener"" kind=""class"">
     UserStatusListener 
   </clt></i></b>. Both listeners should be added to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> by using <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.addParticipantStatusListener"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.addParticipantStatusListener(ParticipantStatusListener listener)
  </clt></b> or <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.addUserStatusListener"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.addUserStatusListener(UserStatusListener listener)
  </clt></b> respectively. These listeners include several notification events but you may be interested in just a few of them. Smack provides default implementations for these listeners avoiding you to implement all the interfaces' methods. The default implementations are <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.DefaultUserStatusListener"" api=""DefaultUserStatusListener"" kind=""class"">
     DefaultUserStatusListener 
   </clt></i></b> and <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.DefaultParticipantStatusListener"" api=""DefaultParticipantStatusListener"" kind=""class"">
     DefaultParticipantStatusListener 
   </clt></i></b>. Below you will find the sent messages to the listeners whenever an occupant's role has changed.</p>","ParticipantStatusListener","org.jivesoftware.smackx.muc.ParticipantStatusListener","class",1
,"Multi User Chat","Manage role modifications - part 2","<h3>Manage role modifications - part 2</h3>
<b>Usage</b> 
<p> In order to grant voice (i.e. make someone a <i>participant</i>) just send the message <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.grantVoice"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.grantVoice(String nickname)
  </clt></b> to <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i>. Use <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.revokeVoice"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.revokeVoice(String nickname)
  </clt></b> to revoke the occupant's voice (i.e. make the occupant a <i>visitor</i>).</p> 
<p> In order to grant moderator privileges to a participant or visitor just send the message <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.grantModerator"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.grantModerator(String nickname)
  </clt></b> to <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i>. Use <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.revokeModerator"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.revokeModerator(String nickname)
  </clt></b> to revoke the moderator privilege from the occupant thus making the occupant a participant.</p> 
<p> Smack allows you to listen for role modification events. If you are interested in listening role modification events of any occupant then use the listener <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.ParticipantStatusListener"" api=""ParticipantStatusListener"" kind=""class"">
     ParticipantStatusListener 
   </clt></i></b>. But if you are interested in listening for your own role modification events, use the listener <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.UserStatusListener"" api=""UserStatusListener"" kind=""class"">
     UserStatusListener 
   </clt></i></b>. Both listeners should be added to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> by using <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.addParticipantStatusListener"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.addParticipantStatusListener(ParticipantStatusListener listener)
  </clt></b> or <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.addUserStatusListener"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.addUserStatusListener(UserStatusListener listener)
  </clt></b> respectively. These listeners include several notification events but you may be interested in just a few of them. Smack provides default implementations for these listeners avoiding you to implement all the interfaces' methods. The default implementations are <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.DefaultUserStatusListener"" api=""DefaultUserStatusListener"" kind=""class"">
     DefaultUserStatusListener 
   </clt></i></b> and <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.DefaultParticipantStatusListener"" api=""DefaultParticipantStatusListener"" kind=""class"">
     DefaultParticipantStatusListener 
   </clt></i></b>. Below you will find the sent messages to the listeners whenever an occupant's role has changed.</p>","UserStatusListener","org.jivesoftware.smackx.muc.UserStatusListener","class",1
,"Multi User Chat","Manage role modifications - part 2","<h3>Manage role modifications - part 2</h3>
<b>Usage</b> 
<p> In order to grant voice (i.e. make someone a <i>participant</i>) just send the message <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.grantVoice"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.grantVoice(String nickname)
  </clt></b> to <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i>. Use <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.revokeVoice"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.revokeVoice(String nickname)
  </clt></b> to revoke the occupant's voice (i.e. make the occupant a <i>visitor</i>).</p> 
<p> In order to grant moderator privileges to a participant or visitor just send the message <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.grantModerator"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.grantModerator(String nickname)
  </clt></b> to <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i>. Use <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.revokeModerator"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.revokeModerator(String nickname)
  </clt></b> to revoke the moderator privilege from the occupant thus making the occupant a participant.</p> 
<p> Smack allows you to listen for role modification events. If you are interested in listening role modification events of any occupant then use the listener <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.ParticipantStatusListener"" api=""ParticipantStatusListener"" kind=""class"">
     ParticipantStatusListener 
   </clt></i></b>. But if you are interested in listening for your own role modification events, use the listener <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.UserStatusListener"" api=""UserStatusListener"" kind=""class"">
     UserStatusListener 
   </clt></i></b>. Both listeners should be added to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> by using <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.addParticipantStatusListener"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.addParticipantStatusListener(ParticipantStatusListener listener)
  </clt></b> or <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.addUserStatusListener"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.addUserStatusListener(UserStatusListener listener)
  </clt></b> respectively. These listeners include several notification events but you may be interested in just a few of them. Smack provides default implementations for these listeners avoiding you to implement all the interfaces' methods. The default implementations are <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.DefaultUserStatusListener"" api=""DefaultUserStatusListener"" kind=""class"">
     DefaultUserStatusListener 
   </clt></i></b> and <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.DefaultParticipantStatusListener"" api=""DefaultParticipantStatusListener"" kind=""class"">
     DefaultParticipantStatusListener 
   </clt></i></b>. Below you will find the sent messages to the listeners whenever an occupant's role has changed.</p>","DefaultUserStatusListener","org.jivesoftware.smackx.muc.DefaultUserStatusListener","class",0
,"Multi User Chat","Manage role modifications - part 2","<h3>Manage role modifications - part 2</h3>
<b>Usage</b> 
<p> In order to grant voice (i.e. make someone a <i>participant</i>) just send the message <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.grantVoice"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.grantVoice(String nickname)
  </clt></b> to <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i>. Use <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.revokeVoice"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.revokeVoice(String nickname)
  </clt></b> to revoke the occupant's voice (i.e. make the occupant a <i>visitor</i>).</p> 
<p> In order to grant moderator privileges to a participant or visitor just send the message <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.grantModerator"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.grantModerator(String nickname)
  </clt></b> to <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i>. Use <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.revokeModerator"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.revokeModerator(String nickname)
  </clt></b> to revoke the moderator privilege from the occupant thus making the occupant a participant.</p> 
<p> Smack allows you to listen for role modification events. If you are interested in listening role modification events of any occupant then use the listener <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.ParticipantStatusListener"" api=""ParticipantStatusListener"" kind=""class"">
     ParticipantStatusListener 
   </clt></i></b>. But if you are interested in listening for your own role modification events, use the listener <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.UserStatusListener"" api=""UserStatusListener"" kind=""class"">
     UserStatusListener 
   </clt></i></b>. Both listeners should be added to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> by using <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.addParticipantStatusListener"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.addParticipantStatusListener(ParticipantStatusListener listener)
  </clt></b> or <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.addUserStatusListener"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.addUserStatusListener(UserStatusListener listener)
  </clt></b> respectively. These listeners include several notification events but you may be interested in just a few of them. Smack provides default implementations for these listeners avoiding you to implement all the interfaces' methods. The default implementations are <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.DefaultUserStatusListener"" api=""DefaultUserStatusListener"" kind=""class"">
     DefaultUserStatusListener 
   </clt></i></b> and <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.DefaultParticipantStatusListener"" api=""DefaultParticipantStatusListener"" kind=""class"">
     DefaultParticipantStatusListener 
   </clt></i></b>. Below you will find the sent messages to the listeners whenever an occupant's role has changed.</p>","DefaultParticipantStatusListener","org.jivesoftware.smackx.muc.DefaultParticipantStatusListener","class",0
,"Multi User Chat","Manage affiliation modifications - part 2","<h3>Manage affiliation modifications - part 2</h3>
<p> The member affiliation provides a way for a room owner or admin to specify a &quot;whitelist&quot; of users who are allowed to enter a members-only room. When a member enters a members-only room, his or her affiliation does not change, no matter what his or her role is. The member affiliation also provides a way for users to effectively register with an open room and thus be permanently associated with that room in some way (one result may be that the user's nickname is reserved in the room).</p> 
<p> An outcast is a user who has been banned from a room and who is not allowed to enter the room. Whenever a user's affiliation is changed Smack will trigger specific events.</p> 
<b>Usage</b> 
<p> In order to grant membership to a room, administrator privileges or owner priveliges just send <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.grantMembership"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.grantMembership(String jid)
  </clt></b>, <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.grantAdmin"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.grantAdmin(String jid)
  </clt></b> or <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.grantOwnership"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.grantOwnership(String jid)
  </clt></b> to <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> respectively. Use <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.revokeMembership"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.revokeMembership(String jid)
  </clt></b>, <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.revokeAdmin"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.revokeAdmin(String jid)
  </clt></b> or <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.revokeOwnership"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.revokeOwnership(String jid)
  </clt></b> to revoke the membership to a room, administrator privileges or owner priveliges respectively.</p>","MultiUserChat","org.jivesoftware.smackx.muc.MultiUserChat","class",1
,"Multi User Chat","Manage affiliation modifications - part 3","<h3>Manage affiliation modifications - part 3</h3>
<p> In order to ban a user from the room just send the message <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.banUser"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.banUser(String jid, String reason)
  </clt></b> to <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i>.</p> 
<p> Smack allows you to listen for affiliation modification events. If you are interested in listening affiliation modification events of any user then use the listener <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.ParticipantStatusListener"" api=""ParticipantStatusListener"" kind=""class"">
     ParticipantStatusListener 
   </clt></i></b>. But if you are interested in listening for your own affiliation modification events, use the listener <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.UserStatusListener"" api=""UserStatusListener"" kind=""class"">
     UserStatusListener 
   </clt></i></b>. Both listeners should be added to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> by using <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.addParticipantStatusListener"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.addParticipantStatusListener(ParticipantStatusListener listener)
  </clt></b> or <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.addUserStatusListener"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.addUserStatusListener(UserStatusListener listener)
  </clt></b> respectively. These listeners include several notification events but you may be interested in just a few of them. Smack provides default implementations for these listeners avoiding you to implement all the interfaces' methods. The default implementations are <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.DefaultUserStatusListener"" api=""DefaultUserStatusListener"" kind=""class"">
     DefaultUserStatusListener 
   </clt></i></b> and <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.DefaultParticipantStatusListener"" api=""DefaultParticipantStatusListener"" kind=""class"">
     DefaultParticipantStatusListener 
   </clt></i></b>. Below you will find the sent messages to the listeners whenever a user's affiliation has changed.</p>","MultiUserChat","org.jivesoftware.smackx.muc.MultiUserChat","class",1
,"Multi User Chat","Manage affiliation modifications - part 3","<h3>Manage affiliation modifications - part 3</h3>
<p> In order to ban a user from the room just send the message <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.banUser"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.banUser(String jid, String reason)
  </clt></b> to <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i>.</p> 
<p> Smack allows you to listen for affiliation modification events. If you are interested in listening affiliation modification events of any user then use the listener <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.ParticipantStatusListener"" api=""ParticipantStatusListener"" kind=""class"">
     ParticipantStatusListener 
   </clt></i></b>. But if you are interested in listening for your own affiliation modification events, use the listener <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.UserStatusListener"" api=""UserStatusListener"" kind=""class"">
     UserStatusListener 
   </clt></i></b>. Both listeners should be added to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> by using <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.addParticipantStatusListener"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.addParticipantStatusListener(ParticipantStatusListener listener)
  </clt></b> or <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.addUserStatusListener"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.addUserStatusListener(UserStatusListener listener)
  </clt></b> respectively. These listeners include several notification events but you may be interested in just a few of them. Smack provides default implementations for these listeners avoiding you to implement all the interfaces' methods. The default implementations are <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.DefaultUserStatusListener"" api=""DefaultUserStatusListener"" kind=""class"">
     DefaultUserStatusListener 
   </clt></i></b> and <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.DefaultParticipantStatusListener"" api=""DefaultParticipantStatusListener"" kind=""class"">
     DefaultParticipantStatusListener 
   </clt></i></b>. Below you will find the sent messages to the listeners whenever a user's affiliation has changed.</p>","ParticipantStatusListener","org.jivesoftware.smackx.muc.ParticipantStatusListener","class",1
,"Multi User Chat","Manage affiliation modifications - part 3","<h3>Manage affiliation modifications - part 3</h3>
<p> In order to ban a user from the room just send the message <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.banUser"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.banUser(String jid, String reason)
  </clt></b> to <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i>.</p> 
<p> Smack allows you to listen for affiliation modification events. If you are interested in listening affiliation modification events of any user then use the listener <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.ParticipantStatusListener"" api=""ParticipantStatusListener"" kind=""class"">
     ParticipantStatusListener 
   </clt></i></b>. But if you are interested in listening for your own affiliation modification events, use the listener <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.UserStatusListener"" api=""UserStatusListener"" kind=""class"">
     UserStatusListener 
   </clt></i></b>. Both listeners should be added to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> by using <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.addParticipantStatusListener"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.addParticipantStatusListener(ParticipantStatusListener listener)
  </clt></b> or <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.addUserStatusListener"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.addUserStatusListener(UserStatusListener listener)
  </clt></b> respectively. These listeners include several notification events but you may be interested in just a few of them. Smack provides default implementations for these listeners avoiding you to implement all the interfaces' methods. The default implementations are <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.DefaultUserStatusListener"" api=""DefaultUserStatusListener"" kind=""class"">
     DefaultUserStatusListener 
   </clt></i></b> and <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.DefaultParticipantStatusListener"" api=""DefaultParticipantStatusListener"" kind=""class"">
     DefaultParticipantStatusListener 
   </clt></i></b>. Below you will find the sent messages to the listeners whenever a user's affiliation has changed.</p>","UserStatusListener","org.jivesoftware.smackx.muc.UserStatusListener","class",1
,"Multi User Chat","Manage affiliation modifications - part 3","<h3>Manage affiliation modifications - part 3</h3>
<p> In order to ban a user from the room just send the message <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.banUser"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.banUser(String jid, String reason)
  </clt></b> to <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i>.</p> 
<p> Smack allows you to listen for affiliation modification events. If you are interested in listening affiliation modification events of any user then use the listener <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.ParticipantStatusListener"" api=""ParticipantStatusListener"" kind=""class"">
     ParticipantStatusListener 
   </clt></i></b>. But if you are interested in listening for your own affiliation modification events, use the listener <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.UserStatusListener"" api=""UserStatusListener"" kind=""class"">
     UserStatusListener 
   </clt></i></b>. Both listeners should be added to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> by using <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.addParticipantStatusListener"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.addParticipantStatusListener(ParticipantStatusListener listener)
  </clt></b> or <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.addUserStatusListener"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.addUserStatusListener(UserStatusListener listener)
  </clt></b> respectively. These listeners include several notification events but you may be interested in just a few of them. Smack provides default implementations for these listeners avoiding you to implement all the interfaces' methods. The default implementations are <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.DefaultUserStatusListener"" api=""DefaultUserStatusListener"" kind=""class"">
     DefaultUserStatusListener 
   </clt></i></b> and <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.DefaultParticipantStatusListener"" api=""DefaultParticipantStatusListener"" kind=""class"">
     DefaultParticipantStatusListener 
   </clt></i></b>. Below you will find the sent messages to the listeners whenever a user's affiliation has changed.</p>","DefaultUserStatusListener","org.jivesoftware.smackx.muc.DefaultUserStatusListener","class",0
,"Multi User Chat","Manage affiliation modifications - part 3","<h3>Manage affiliation modifications - part 3</h3>
<p> In order to ban a user from the room just send the message <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.banUser"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.banUser(String jid, String reason)
  </clt></b> to <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i>.</p> 
<p> Smack allows you to listen for affiliation modification events. If you are interested in listening affiliation modification events of any user then use the listener <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.ParticipantStatusListener"" api=""ParticipantStatusListener"" kind=""class"">
     ParticipantStatusListener 
   </clt></i></b>. But if you are interested in listening for your own affiliation modification events, use the listener <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.UserStatusListener"" api=""UserStatusListener"" kind=""class"">
     UserStatusListener 
   </clt></i></b>. Both listeners should be added to the <i><b> 
   <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat"" api=""MultiUserChat"" kind=""class"">
     MultiUserChat 
   </clt></b></i> by using <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.addParticipantStatusListener"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.addParticipantStatusListener(ParticipantStatusListener listener)
  </clt></b> or <b> 
  <clt fqn=""org.jivesoftware.smackx.muc.MultiUserChat.addUserStatusListener"" api=""MultiUserChat"" kind=""method"">
   MultiUserChat.addUserStatusListener(UserStatusListener listener)
  </clt></b> respectively. These listeners include several notification events but you may be interested in just a few of them. Smack provides default implementations for these listeners avoiding you to implement all the interfaces' methods. The default implementations are <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.DefaultUserStatusListener"" api=""DefaultUserStatusListener"" kind=""class"">
     DefaultUserStatusListener 
   </clt></i></b> and <b><i> 
   <clt fqn=""org.jivesoftware.smackx.muc.DefaultParticipantStatusListener"" api=""DefaultParticipantStatusListener"" kind=""class"">
     DefaultParticipantStatusListener 
   </clt></i></b>. Below you will find the sent messages to the listeners whenever a user's affiliation has changed.</p>","DefaultParticipantStatusListener","org.jivesoftware.smackx.muc.DefaultParticipantStatusListener","class",0
,"Messaging using Chats","Messaging using Chats","<div class=""header""><h3>
  Messaging using Chats</h3> 
</div> 
<p> Sending messages back and forth is at the core of instant messaging. Although individual messages can be sent and received as packets, it's generally easier to treat the string of messages as a chat using the <tt> 
  <clt fqn=""org.jivesoftware.smack.Chat"" api=""Chat"" kind=""class"">
    org.jivesoftware.smack.Chat 
  </clt></tt> class. </p>","Chat","org.jivesoftware.smack.Chat","class",0
,"Message Events","Requesting Event Notifications","<div class=""subheader""> <h3>
 <a name=""reqevnot"">Requesting Event Notifications</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> In order to receive event notifications for a given message you first have to specify which events are you interested in. Each message that you send has to request its own event notifications. Therefore, every message that you send as part of a chat should request its own event notifications.</p> 
<b>Usage</b> 
<p> The class <i> 
  <clt fqn=""org.jivesoftware.smackx.MessageEventManager"" api=""MessageEventManager"" kind=""class"">
    MessageEventManager 
  </clt></i> provides an easy way for requesting event notifications. All you have to do is specify the message that requires the event notifications and the events that you are interested in. </p> 
<p>Use the static method <i><b> 
   <clt fqn=""org.jivesoftware.smackx.MessageEventManager.addNotificationsRequests"" api=""MessageEventManager"" kind=""method"">
    MessageEventManager.MessageEventManager.addNotificationsRequests(Message message, boolean offline, boolean delivered, boolean displayed, boolean composing)
   </clt></b></i> for requesting event notifications. </p> 
<b>Example</b> 
<p> Below you can find an example that logs in a user to the server, creates a message, adds the requests for notifications and sends the message. </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Connect to the server and log in</font>
conn1 = new XMPPConnection(host);
conn1.login(server_user1, pass1);
<font color=""#3f7f5f"">// Create a chat with user2</font>
Chat chat1 = conn1.createChat(user2);
<font color=""#3f7f5f"">// Create a message to send</font>
Message msg = chat1.createMessage();
msg.setSubject(<font color=""#0000FF"">&quot;Any subject you want&quot;</font>);
msg.setBody(<font color=""#0000FF"">&quot;An interesting body comes here...&quot;</font>);
<font color=""#3f7f5f"">// Add to the message all the notifications requests (offline, delivered, displayed,</font>
<font color=""#3f7f5f"">// composing)</font>
MessageEventManager.addNotificationsRequests(msg, <font color=""#7f0055""><b>true</b></font>, <font color=""#7f0055""><b>true</b></font>, <font color=""#7f0055""><b>true</b></font>, <font color=""#7f0055""><b>true</b></font>);
<font color=""#3f7f5f"">// Send the message that contains the notifications request</font>
chat1.sendMessage(msg);
</pre> 
</blockquote>","MessageEventManager","org.jivesoftware.smackx.MessageEventManager","class",1
,"Message Events","Reacting to Event Notification Requests","<div class=""subheader""> <h3>
 <a name=""lstevnotreq"">Reacting to Event Notification Requests</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> You can receive notification requests for the following events: delivered, displayed, composing and offline. You <b>must</b> listen for these requests and react accordingly.</p> 
<b>Usage</b> 
<p> The general idea is to create a new <i> 
  <clt fqn=""org.jivesoftware.smackx.DefaultMessageEventRequestListener"" api=""DefaultMessageEventRequestListener"" kind=""class"">
    DefaultMessageEventRequestListener 
  </clt></i> that will listen to the event notifications requests and react with custom logic. Then you will have to add the listener to the <i> 
  <clt fqn=""org.jivesoftware.smackx.MessageEventManager"" api=""MessageEventManager"" kind=""class"">
    MessageEventManager 
  </clt></i> that works on the desired <i> 
  <clt fqn=""org.jivesoftware.smack.Connection"" api=""Connection"" kind=""class"">
    Connection 
  </clt></i>. </p> 
<p>Note that <i> 
  <clt fqn=""org.jivesoftware.smackx.DefaultMessageEventRequestListener"" api=""DefaultMessageEventRequestListener"" kind=""class"">
    DefaultMessageEventRequestListener 
  </clt></i> is a default implementation of the <i> 
  <clt fqn=""org.jivesoftware.smackx.MessageEventRequestListener"" api=""MessageEventRequestListener"" kind=""class"">
    MessageEventRequestListener 
  </clt></i> interface. The class <i> 
  <clt fqn=""org.jivesoftware.smackx.DefaultMessageEventRequestListener"" api=""DefaultMessageEventRequestListener"" kind=""class"">
    DefaultMessageEventRequestListener 
  </clt></i> automatically sends a delivered notification to the sender of the message if the sender has requested to be notified when the message is delivered. If you decide to create a new class that implements the <i> 
  <clt fqn=""org.jivesoftware.smackx.MessageEventRequestListener"" api=""MessageEventRequestListener"" kind=""class"">
    MessageEventRequestListener 
  </clt></i> interface, please remember to send the delivered notification.</p> 
<ul> 
 <li>To create a new <i> 
   <clt fqn=""org.jivesoftware.smackx.MessageEventManager"" api=""MessageEventManager"" kind=""class"">
     MessageEventManager 
   </clt></i> use the <i><b> 
    <clt fqn=""org.jivesoftware.smackx.MessageEventManager.MessageEventManager"" api=""MessageEventManager"" kind=""method"">
     MessageEventManager.MessageEventManager(Connection)
    </clt></b></i> constructor. </li> 
 <li>To create an event notification requests listener create a subclass of <i><b> 
    <clt fqn=""org.jivesoftware.smackx.DefaultMessageEventRequestListener"" api=""DefaultMessageEventRequestListener"" kind=""class"">
      DefaultMessageEventRequestListener 
    </clt></b></i> or create a class that implements the <i><b> 
    <clt fqn=""org.jivesoftware.smackx.MessageEventRequestListener"" api=""MessageEventRequestListener"" kind=""class"">
      MessageEventRequestListener 
    </clt></b></i> interface. </li> 
 <li>To add a listener to the messageEventManager use the MessageEventManager's message <i><b> 
    <clt fqn=""org.jivesoftware.smackx.MessageEventManager.addMessageEventRequestListener"" api=""MessageEventManager"" kind=""method"">
     MessageEventManager.addMessageEventRequestListener(MessageEventRequestListener)
    </clt></b></i>.</li> 
</ul>","DefaultMessageEventRequestListener","org.jivesoftware.smackx.DefaultMessageEventRequestListener","class",1
,"Message Events","Reacting to Event Notification Requests","<div class=""subheader""> <h3>
 <a name=""lstevnotreq"">Reacting to Event Notification Requests</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> You can receive notification requests for the following events: delivered, displayed, composing and offline. You <b>must</b> listen for these requests and react accordingly.</p> 
<b>Usage</b> 
<p> The general idea is to create a new <i> 
  <clt fqn=""org.jivesoftware.smackx.DefaultMessageEventRequestListener"" api=""DefaultMessageEventRequestListener"" kind=""class"">
    DefaultMessageEventRequestListener 
  </clt></i> that will listen to the event notifications requests and react with custom logic. Then you will have to add the listener to the <i> 
  <clt fqn=""org.jivesoftware.smackx.MessageEventManager"" api=""MessageEventManager"" kind=""class"">
    MessageEventManager 
  </clt></i> that works on the desired <i> 
  <clt fqn=""org.jivesoftware.smack.Connection"" api=""Connection"" kind=""class"">
    Connection 
  </clt></i>. </p> 
<p>Note that <i> 
  <clt fqn=""org.jivesoftware.smackx.DefaultMessageEventRequestListener"" api=""DefaultMessageEventRequestListener"" kind=""class"">
    DefaultMessageEventRequestListener 
  </clt></i> is a default implementation of the <i> 
  <clt fqn=""org.jivesoftware.smackx.MessageEventRequestListener"" api=""MessageEventRequestListener"" kind=""class"">
    MessageEventRequestListener 
  </clt></i> interface. The class <i> 
  <clt fqn=""org.jivesoftware.smackx.DefaultMessageEventRequestListener"" api=""DefaultMessageEventRequestListener"" kind=""class"">
    DefaultMessageEventRequestListener 
  </clt></i> automatically sends a delivered notification to the sender of the message if the sender has requested to be notified when the message is delivered. If you decide to create a new class that implements the <i> 
  <clt fqn=""org.jivesoftware.smackx.MessageEventRequestListener"" api=""MessageEventRequestListener"" kind=""class"">
    MessageEventRequestListener 
  </clt></i> interface, please remember to send the delivered notification.</p> 
<ul> 
 <li>To create a new <i> 
   <clt fqn=""org.jivesoftware.smackx.MessageEventManager"" api=""MessageEventManager"" kind=""class"">
     MessageEventManager 
   </clt></i> use the <i><b> 
    <clt fqn=""org.jivesoftware.smackx.MessageEventManager.MessageEventManager"" api=""MessageEventManager"" kind=""method"">
     MessageEventManager.MessageEventManager(Connection)
    </clt></b></i> constructor. </li> 
 <li>To create an event notification requests listener create a subclass of <i><b> 
    <clt fqn=""org.jivesoftware.smackx.DefaultMessageEventRequestListener"" api=""DefaultMessageEventRequestListener"" kind=""class"">
      DefaultMessageEventRequestListener 
    </clt></b></i> or create a class that implements the <i><b> 
    <clt fqn=""org.jivesoftware.smackx.MessageEventRequestListener"" api=""MessageEventRequestListener"" kind=""class"">
      MessageEventRequestListener 
    </clt></b></i> interface. </li> 
 <li>To add a listener to the messageEventManager use the MessageEventManager's message <i><b> 
    <clt fqn=""org.jivesoftware.smackx.MessageEventManager.addMessageEventRequestListener"" api=""MessageEventManager"" kind=""method"">
     MessageEventManager.addMessageEventRequestListener(MessageEventRequestListener)
    </clt></b></i>.</li> 
</ul>","MessageEventManager","org.jivesoftware.smackx.MessageEventManager","class",1
,"Message Events","Reacting to Event Notification Requests","<div class=""subheader""> <h3>
 <a name=""lstevnotreq"">Reacting to Event Notification Requests</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> You can receive notification requests for the following events: delivered, displayed, composing and offline. You <b>must</b> listen for these requests and react accordingly.</p> 
<b>Usage</b> 
<p> The general idea is to create a new <i> 
  <clt fqn=""org.jivesoftware.smackx.DefaultMessageEventRequestListener"" api=""DefaultMessageEventRequestListener"" kind=""class"">
    DefaultMessageEventRequestListener 
  </clt></i> that will listen to the event notifications requests and react with custom logic. Then you will have to add the listener to the <i> 
  <clt fqn=""org.jivesoftware.smackx.MessageEventManager"" api=""MessageEventManager"" kind=""class"">
    MessageEventManager 
  </clt></i> that works on the desired <i> 
  <clt fqn=""org.jivesoftware.smack.Connection"" api=""Connection"" kind=""class"">
    Connection 
  </clt></i>. </p> 
<p>Note that <i> 
  <clt fqn=""org.jivesoftware.smackx.DefaultMessageEventRequestListener"" api=""DefaultMessageEventRequestListener"" kind=""class"">
    DefaultMessageEventRequestListener 
  </clt></i> is a default implementation of the <i> 
  <clt fqn=""org.jivesoftware.smackx.MessageEventRequestListener"" api=""MessageEventRequestListener"" kind=""class"">
    MessageEventRequestListener 
  </clt></i> interface. The class <i> 
  <clt fqn=""org.jivesoftware.smackx.DefaultMessageEventRequestListener"" api=""DefaultMessageEventRequestListener"" kind=""class"">
    DefaultMessageEventRequestListener 
  </clt></i> automatically sends a delivered notification to the sender of the message if the sender has requested to be notified when the message is delivered. If you decide to create a new class that implements the <i> 
  <clt fqn=""org.jivesoftware.smackx.MessageEventRequestListener"" api=""MessageEventRequestListener"" kind=""class"">
    MessageEventRequestListener 
  </clt></i> interface, please remember to send the delivered notification.</p> 
<ul> 
 <li>To create a new <i> 
   <clt fqn=""org.jivesoftware.smackx.MessageEventManager"" api=""MessageEventManager"" kind=""class"">
     MessageEventManager 
   </clt></i> use the <i><b> 
    <clt fqn=""org.jivesoftware.smackx.MessageEventManager.MessageEventManager"" api=""MessageEventManager"" kind=""method"">
     MessageEventManager.MessageEventManager(Connection)
    </clt></b></i> constructor. </li> 
 <li>To create an event notification requests listener create a subclass of <i><b> 
    <clt fqn=""org.jivesoftware.smackx.DefaultMessageEventRequestListener"" api=""DefaultMessageEventRequestListener"" kind=""class"">
      DefaultMessageEventRequestListener 
    </clt></b></i> or create a class that implements the <i><b> 
    <clt fqn=""org.jivesoftware.smackx.MessageEventRequestListener"" api=""MessageEventRequestListener"" kind=""class"">
      MessageEventRequestListener 
    </clt></b></i> interface. </li> 
 <li>To add a listener to the messageEventManager use the MessageEventManager's message <i><b> 
    <clt fqn=""org.jivesoftware.smackx.MessageEventManager.addMessageEventRequestListener"" api=""MessageEventManager"" kind=""method"">
     MessageEventManager.addMessageEventRequestListener(MessageEventRequestListener)
    </clt></b></i>.</li> 
</ul>","Connection","org.jivesoftware.smack.Connection","class",0
,"Message Events","Reacting to Event Notification Requests","<div class=""subheader""> <h3>
 <a name=""lstevnotreq"">Reacting to Event Notification Requests</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> You can receive notification requests for the following events: delivered, displayed, composing and offline. You <b>must</b> listen for these requests and react accordingly.</p> 
<b>Usage</b> 
<p> The general idea is to create a new <i> 
  <clt fqn=""org.jivesoftware.smackx.DefaultMessageEventRequestListener"" api=""DefaultMessageEventRequestListener"" kind=""class"">
    DefaultMessageEventRequestListener 
  </clt></i> that will listen to the event notifications requests and react with custom logic. Then you will have to add the listener to the <i> 
  <clt fqn=""org.jivesoftware.smackx.MessageEventManager"" api=""MessageEventManager"" kind=""class"">
    MessageEventManager 
  </clt></i> that works on the desired <i> 
  <clt fqn=""org.jivesoftware.smack.Connection"" api=""Connection"" kind=""class"">
    Connection 
  </clt></i>. </p> 
<p>Note that <i> 
  <clt fqn=""org.jivesoftware.smackx.DefaultMessageEventRequestListener"" api=""DefaultMessageEventRequestListener"" kind=""class"">
    DefaultMessageEventRequestListener 
  </clt></i> is a default implementation of the <i> 
  <clt fqn=""org.jivesoftware.smackx.MessageEventRequestListener"" api=""MessageEventRequestListener"" kind=""class"">
    MessageEventRequestListener 
  </clt></i> interface. The class <i> 
  <clt fqn=""org.jivesoftware.smackx.DefaultMessageEventRequestListener"" api=""DefaultMessageEventRequestListener"" kind=""class"">
    DefaultMessageEventRequestListener 
  </clt></i> automatically sends a delivered notification to the sender of the message if the sender has requested to be notified when the message is delivered. If you decide to create a new class that implements the <i> 
  <clt fqn=""org.jivesoftware.smackx.MessageEventRequestListener"" api=""MessageEventRequestListener"" kind=""class"">
    MessageEventRequestListener 
  </clt></i> interface, please remember to send the delivered notification.</p> 
<ul> 
 <li>To create a new <i> 
   <clt fqn=""org.jivesoftware.smackx.MessageEventManager"" api=""MessageEventManager"" kind=""class"">
     MessageEventManager 
   </clt></i> use the <i><b> 
    <clt fqn=""org.jivesoftware.smackx.MessageEventManager.MessageEventManager"" api=""MessageEventManager"" kind=""method"">
     MessageEventManager.MessageEventManager(Connection)
    </clt></b></i> constructor. </li> 
 <li>To create an event notification requests listener create a subclass of <i><b> 
    <clt fqn=""org.jivesoftware.smackx.DefaultMessageEventRequestListener"" api=""DefaultMessageEventRequestListener"" kind=""class"">
      DefaultMessageEventRequestListener 
    </clt></b></i> or create a class that implements the <i><b> 
    <clt fqn=""org.jivesoftware.smackx.MessageEventRequestListener"" api=""MessageEventRequestListener"" kind=""class"">
      MessageEventRequestListener 
    </clt></b></i> interface. </li> 
 <li>To add a listener to the messageEventManager use the MessageEventManager's message <i><b> 
    <clt fqn=""org.jivesoftware.smackx.MessageEventManager.addMessageEventRequestListener"" api=""MessageEventManager"" kind=""method"">
     MessageEventManager.addMessageEventRequestListener(MessageEventRequestListener)
    </clt></b></i>.</li> 
</ul>","MessageEventRequestListener","org.jivesoftware.smackx.MessageEventRequestListener","class",0
,"Message Events","Reacting to Event Notification Requests - part 2","<h3>Reacting to Event Notification Requests - part 2</h3>
<b>Example</b> 
<p> Below you can find an example that connects two users to the server. One user will create a message, add the requests for notifications and will send the message to the other user. The other user will add a <i> 
  <clt fqn=""org.jivesoftware.smackx.DefaultMessageEventRequestListener"" api=""DefaultMessageEventRequestListener"" kind=""class"">
    DefaultMessageEventRequestListener 
  </clt></i> to a <i> 
  <clt fqn=""org.jivesoftware.smackx.MessageEventManager"" api=""MessageEventManager"" kind=""class"">
    MessageEventManager 
  </clt></i> that will listen and react to the event notification requested by the other user. </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Connect to the server and log in the users</font>
conn1 = new XMPPConnection(host);
conn1.login(server_user1, pass1);
conn2 = new XMPPConnection(host);
conn2.login(server_user2, pass2);
<font color=""#3f7f5f"">// User2 creates a MessageEventManager</font>
MessageEventManager messageEventManager = new MessageEventManager(conn2);
<font color=""#3f7f5f"">// User2 adds the listener that will react to the event notifications requests</font>
messageEventManager.addMessageEventRequestListener(new DefaultMessageEventRequestListener() {
public void deliveredNotificationRequested(
String from,
String packetID,
MessageEventManager messageEventManager) {
super.deliveredNotificationRequested(from, packetID, messageEventManager);
<font color=""#3f7f5f"">// DefaultMessageEventRequestListener automatically responds that the message was delivered when receives this request</font>
System.out.println(<font color=""#0000FF"">&quot;Delivered Notification Requested (&quot; + from + &quot;, &quot; + packetID + &quot;)&quot;</font>);
}
public void displayedNotificationRequested(
String from,
String packetID,
MessageEventManager messageEventManager) {
super.displayedNotificationRequested(from, packetID, messageEventManager);
<font color=""#3f7f5f"">// Send to the message's sender that the message was displayed</font>
messageEventManager.sendDisplayedNotification(from, packetID);
}
public void composingNotificationRequested(
String from,
String packetID,
MessageEventManager messageEventManager) {
super.composingNotificationRequested(from, packetID, messageEventManager);
<font color=""#3f7f5f"">// Send to the message's sender that the message's receiver is composing a reply</font>
messageEventManager.sendComposingNotification(from, packetID);
}
public void offlineNotificationRequested(
String from,
String packetID,
MessageEventManager messageEventManager) {
super.offlineNotificationRequested(from, packetID, messageEventManager);
<font color=""#3f7f5f"">// The XMPP server should take care of this request. Do nothing.</font>
System.out.println(<font color=""#0000FF"">&quot;Offline Notification Requested (&quot; + from + &quot;, &quot; + packetID + &quot;)&quot;</font>);
}
});
<font color=""#3f7f5f"">// User1 creates a chat with user2</font>
Chat chat1 = conn1.createChat(user2);
<font color=""#3f7f5f"">// User1 creates a message to send to user2</font>
Message msg = chat1.createMessage();
msg.setSubject(<font color=""#0000FF"">&quot;Any subject you want&quot;</font>);
msg.setBody(<font color=""#0000FF"">&quot;An interesting body comes here...&quot;</font>);
<font color=""#3f7f5f"">// User1 adds to the message all the notifications requests (offline, delivered, displayed,</font>
<font color=""#3f7f5f"">// composing)</font>
MessageEventManager.addNotificationsRequests(msg, <font color=""#7f0055""><b>true</b></font>, <font color=""#7f0055""><b>true</b></font>, <font color=""#7f0055""><b>true</b></font>, <font color=""#7f0055""><b>true</b></font>);
<font color=""#3f7f5f"">// User1 sends the message that contains the notifications request</font>
chat1.sendMessage(msg);
Thread.sleep(500);
<font color=""#3f7f5f"">// User2 sends to the message's sender that the message's receiver cancelled composing a reply</font>
messageEventManager.sendCancelledNotification(user1, msg.getPacketID());
</pre> 
</blockquote>","DefaultMessageEventRequestListener","org.jivesoftware.smackx.DefaultMessageEventRequestListener","class",0
,"Message Events","Reacting to Event Notification Requests - part 2","<h3>Reacting to Event Notification Requests - part 2</h3>
<b>Example</b> 
<p> Below you can find an example that connects two users to the server. One user will create a message, add the requests for notifications and will send the message to the other user. The other user will add a <i> 
  <clt fqn=""org.jivesoftware.smackx.DefaultMessageEventRequestListener"" api=""DefaultMessageEventRequestListener"" kind=""class"">
    DefaultMessageEventRequestListener 
  </clt></i> to a <i> 
  <clt fqn=""org.jivesoftware.smackx.MessageEventManager"" api=""MessageEventManager"" kind=""class"">
    MessageEventManager 
  </clt></i> that will listen and react to the event notification requested by the other user. </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Connect to the server and log in the users</font>
conn1 = new XMPPConnection(host);
conn1.login(server_user1, pass1);
conn2 = new XMPPConnection(host);
conn2.login(server_user2, pass2);
<font color=""#3f7f5f"">// User2 creates a MessageEventManager</font>
MessageEventManager messageEventManager = new MessageEventManager(conn2);
<font color=""#3f7f5f"">// User2 adds the listener that will react to the event notifications requests</font>
messageEventManager.addMessageEventRequestListener(new DefaultMessageEventRequestListener() {
public void deliveredNotificationRequested(
String from,
String packetID,
MessageEventManager messageEventManager) {
super.deliveredNotificationRequested(from, packetID, messageEventManager);
<font color=""#3f7f5f"">// DefaultMessageEventRequestListener automatically responds that the message was delivered when receives this request</font>
System.out.println(<font color=""#0000FF"">&quot;Delivered Notification Requested (&quot; + from + &quot;, &quot; + packetID + &quot;)&quot;</font>);
}
public void displayedNotificationRequested(
String from,
String packetID,
MessageEventManager messageEventManager) {
super.displayedNotificationRequested(from, packetID, messageEventManager);
<font color=""#3f7f5f"">// Send to the message's sender that the message was displayed</font>
messageEventManager.sendDisplayedNotification(from, packetID);
}
public void composingNotificationRequested(
String from,
String packetID,
MessageEventManager messageEventManager) {
super.composingNotificationRequested(from, packetID, messageEventManager);
<font color=""#3f7f5f"">// Send to the message's sender that the message's receiver is composing a reply</font>
messageEventManager.sendComposingNotification(from, packetID);
}
public void offlineNotificationRequested(
String from,
String packetID,
MessageEventManager messageEventManager) {
super.offlineNotificationRequested(from, packetID, messageEventManager);
<font color=""#3f7f5f"">// The XMPP server should take care of this request. Do nothing.</font>
System.out.println(<font color=""#0000FF"">&quot;Offline Notification Requested (&quot; + from + &quot;, &quot; + packetID + &quot;)&quot;</font>);
}
});
<font color=""#3f7f5f"">// User1 creates a chat with user2</font>
Chat chat1 = conn1.createChat(user2);
<font color=""#3f7f5f"">// User1 creates a message to send to user2</font>
Message msg = chat1.createMessage();
msg.setSubject(<font color=""#0000FF"">&quot;Any subject you want&quot;</font>);
msg.setBody(<font color=""#0000FF"">&quot;An interesting body comes here...&quot;</font>);
<font color=""#3f7f5f"">// User1 adds to the message all the notifications requests (offline, delivered, displayed,</font>
<font color=""#3f7f5f"">// composing)</font>
MessageEventManager.addNotificationsRequests(msg, <font color=""#7f0055""><b>true</b></font>, <font color=""#7f0055""><b>true</b></font>, <font color=""#7f0055""><b>true</b></font>, <font color=""#7f0055""><b>true</b></font>);
<font color=""#3f7f5f"">// User1 sends the message that contains the notifications request</font>
chat1.sendMessage(msg);
Thread.sleep(500);
<font color=""#3f7f5f"">// User2 sends to the message's sender that the message's receiver cancelled composing a reply</font>
messageEventManager.sendCancelledNotification(user1, msg.getPacketID());
</pre> 
</blockquote>","MessageEventManager","org.jivesoftware.smackx.MessageEventManager","class",0
,"Message Events","Reacting to Event Notifications","<div class=""subheader""> <h3>
 <a name=""lstevnot"">Reacting to Event Notifications</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> Once you have requested for event notifications you will start to receive notifications of events. You can receive notifications of the following events: delivered, displayed, composing, offline and cancelled. You will probably want to react to some or all of these events.</p> 
<b>Usage</b> 
<p> The general idea is to create a new <i> 
  <clt fqn=""org.jivesoftware.smackx.MessageEventNotificationListener"" api=""MessageEventNotificationListener"" kind=""class"">
    MessageEventNotificationListener 
  </clt></i> that will listen to the event notifications and react with custom logic. Then you will have to add the listener to the <i> 
  <clt fqn=""org.jivesoftware.smackx.MessageEventManager"" api=""MessageEventManager"" kind=""class"">
    MessageEventManager 
  </clt></i> that works on the desired <i> 
  <clt fqn=""org.jivesoftware.smack.Connection"" api=""Connection"" kind=""class"">
    Connection 
  </clt></i>. </p> 
<ul> 
 <li>To create a new <i> 
   <clt fqn=""org.jivesoftware.smackx.MessageEventManager"" api=""MessageEventManager"" kind=""class"">
     MessageEventManager 
   </clt></i> use the <i><b> 
    <clt fqn=""org.jivesoftware.smackx.MessageEventManager.MessageEventManager"" api=""MessageEventManager"" kind=""method"">
     MessageEventManager.MessageEventManager(Connection)
    </clt></b></i> constructor. </li> 
 <li>To create an event notifications listener create a class that implements the <i><b> 
    <clt fqn=""org.jivesoftware.smackx.MessageEventNotificationListener"" api=""MessageEventNotificationListener"" kind=""class"">
      MessageEventNotificationListener 
    </clt></b></i> interface. </li> 
 <li>To add a listener to the messageEventManager use the MessageEventManager's message <i><b> 
    <clt fqn=""org.jivesoftware.smackx.MessageEventManager.addMessageEventNotificationListener"" api=""MessageEventManager"" kind=""method"">
     MessageEventManager.addMessageEventNotificationListener(MessageEventNotificationListener)
    </clt></b></i>.</li> 
</ul> 
<b>Example</b> 
<p> Below you can find an example that logs in a user to the server, adds a <i> 
  <clt fqn=""org.jivesoftware.smackx.MessageEventNotificationListener"" api=""MessageEventNotificationListener"" kind=""class"">
    MessageEventNotificationListener 
  </clt></i> to a <i> 
  <clt fqn=""org.jivesoftware.smackx.MessageEventManager"" api=""MessageEventManager"" kind=""class"">
    MessageEventManager 
  </clt></i> that will listen and react to the event notifications, creates a message, adds the requests for notifications and sends the message. </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Connect to the server and log in</font>
conn1 = new XMPPConnection(host);
conn1.login(server_user1, pass1);
<font color=""#3f7f5f"">// Create a MessageEventManager</font>
MessageEventManager messageEventManager = new MessageEventManager(conn1);
<font color=""#3f7f5f"">// Add the listener that will react to the event notifications</font>
messageEventManager.addMessageEventNotificationListener(new MessageEventNotificationListener() {
public void deliveredNotification(String from, String packetID) {
System.out.println(<font color=""#0000FF"">&quot;The message has been delivered (&quot; + from + &quot;, &quot; + packetID + &quot;)&quot;</font>);
}
public void displayedNotification(String from, String packetID) {
System.out.println(<font color=""#0000FF"">&quot;The message has been displayed (&quot; + from + &quot;, &quot; + packetID + &quot;)&quot;</font>);
}
public void composingNotification(String from, String packetID) {
System.out.println(<font color=""#0000FF"">&quot;The message's receiver is composing a reply (&quot; + from + &quot;, &quot; + packetID + &quot;)&quot;</font>);
}
public void offlineNotification(String from, String packetID) {
System.out.println(<font color=""#0000FF"">&quot;The message's receiver is offline (&quot; + from + &quot;, &quot; + packetID + &quot;)&quot;</font>);
}
public void cancelledNotification(String from, String packetID) {
System.out.println(<font color=""#0000FF"">&quot;The message's receiver cancelled composing a reply (&quot; + from + &quot;, &quot; + packetID + &quot;)&quot;</font>);
}
});
<font color=""#3f7f5f"">// Create a chat with user2</font>
Chat chat1 = conn1.createChat(user2);
<font color=""#3f7f5f"">// Create a message to send</font>
Message msg = chat1.createMessage();
msg.setSubject(<font color=""#0000FF"">&quot;Any subject you want&quot;</font>);
msg.setBody(<font color=""#0000FF"">&quot;An interesting body comes here...&quot;</font>);
<font color=""#3f7f5f"">// Add to the message all the notifications requests (offline, delivered, displayed,</font>
<font color=""#3f7f5f"">// composing)</font>
MessageEventManager.addNotificationsRequests(msg, <font color=""#7f0055""><b>true</b></font>, <font color=""#7f0055""><b>true</b></font>, <font color=""#7f0055""><b>true</b></font>, <font color=""#7f0055""><b>true</b></font>);
<font color=""#3f7f5f"">// Send the message that contains the notifications request</font>
chat1.sendMessage(msg);
</pre> 
</blockquote>","MessageEventNotificationListener","org.jivesoftware.smackx.MessageEventNotificationListener","class",1
,"Message Events","Reacting to Event Notifications","<div class=""subheader""> <h3>
 <a name=""lstevnot"">Reacting to Event Notifications</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> Once you have requested for event notifications you will start to receive notifications of events. You can receive notifications of the following events: delivered, displayed, composing, offline and cancelled. You will probably want to react to some or all of these events.</p> 
<b>Usage</b> 
<p> The general idea is to create a new <i> 
  <clt fqn=""org.jivesoftware.smackx.MessageEventNotificationListener"" api=""MessageEventNotificationListener"" kind=""class"">
    MessageEventNotificationListener 
  </clt></i> that will listen to the event notifications and react with custom logic. Then you will have to add the listener to the <i> 
  <clt fqn=""org.jivesoftware.smackx.MessageEventManager"" api=""MessageEventManager"" kind=""class"">
    MessageEventManager 
  </clt></i> that works on the desired <i> 
  <clt fqn=""org.jivesoftware.smack.Connection"" api=""Connection"" kind=""class"">
    Connection 
  </clt></i>. </p> 
<ul> 
 <li>To create a new <i> 
   <clt fqn=""org.jivesoftware.smackx.MessageEventManager"" api=""MessageEventManager"" kind=""class"">
     MessageEventManager 
   </clt></i> use the <i><b> 
    <clt fqn=""org.jivesoftware.smackx.MessageEventManager.MessageEventManager"" api=""MessageEventManager"" kind=""method"">
     MessageEventManager.MessageEventManager(Connection)
    </clt></b></i> constructor. </li> 
 <li>To create an event notifications listener create a class that implements the <i><b> 
    <clt fqn=""org.jivesoftware.smackx.MessageEventNotificationListener"" api=""MessageEventNotificationListener"" kind=""class"">
      MessageEventNotificationListener 
    </clt></b></i> interface. </li> 
 <li>To add a listener to the messageEventManager use the MessageEventManager's message <i><b> 
    <clt fqn=""org.jivesoftware.smackx.MessageEventManager.addMessageEventNotificationListener"" api=""MessageEventManager"" kind=""method"">
     MessageEventManager.addMessageEventNotificationListener(MessageEventNotificationListener)
    </clt></b></i>.</li> 
</ul> 
<b>Example</b> 
<p> Below you can find an example that logs in a user to the server, adds a <i> 
  <clt fqn=""org.jivesoftware.smackx.MessageEventNotificationListener"" api=""MessageEventNotificationListener"" kind=""class"">
    MessageEventNotificationListener 
  </clt></i> to a <i> 
  <clt fqn=""org.jivesoftware.smackx.MessageEventManager"" api=""MessageEventManager"" kind=""class"">
    MessageEventManager 
  </clt></i> that will listen and react to the event notifications, creates a message, adds the requests for notifications and sends the message. </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Connect to the server and log in</font>
conn1 = new XMPPConnection(host);
conn1.login(server_user1, pass1);
<font color=""#3f7f5f"">// Create a MessageEventManager</font>
MessageEventManager messageEventManager = new MessageEventManager(conn1);
<font color=""#3f7f5f"">// Add the listener that will react to the event notifications</font>
messageEventManager.addMessageEventNotificationListener(new MessageEventNotificationListener() {
public void deliveredNotification(String from, String packetID) {
System.out.println(<font color=""#0000FF"">&quot;The message has been delivered (&quot; + from + &quot;, &quot; + packetID + &quot;)&quot;</font>);
}
public void displayedNotification(String from, String packetID) {
System.out.println(<font color=""#0000FF"">&quot;The message has been displayed (&quot; + from + &quot;, &quot; + packetID + &quot;)&quot;</font>);
}
public void composingNotification(String from, String packetID) {
System.out.println(<font color=""#0000FF"">&quot;The message's receiver is composing a reply (&quot; + from + &quot;, &quot; + packetID + &quot;)&quot;</font>);
}
public void offlineNotification(String from, String packetID) {
System.out.println(<font color=""#0000FF"">&quot;The message's receiver is offline (&quot; + from + &quot;, &quot; + packetID + &quot;)&quot;</font>);
}
public void cancelledNotification(String from, String packetID) {
System.out.println(<font color=""#0000FF"">&quot;The message's receiver cancelled composing a reply (&quot; + from + &quot;, &quot; + packetID + &quot;)&quot;</font>);
}
});
<font color=""#3f7f5f"">// Create a chat with user2</font>
Chat chat1 = conn1.createChat(user2);
<font color=""#3f7f5f"">// Create a message to send</font>
Message msg = chat1.createMessage();
msg.setSubject(<font color=""#0000FF"">&quot;Any subject you want&quot;</font>);
msg.setBody(<font color=""#0000FF"">&quot;An interesting body comes here...&quot;</font>);
<font color=""#3f7f5f"">// Add to the message all the notifications requests (offline, delivered, displayed,</font>
<font color=""#3f7f5f"">// composing)</font>
MessageEventManager.addNotificationsRequests(msg, <font color=""#7f0055""><b>true</b></font>, <font color=""#7f0055""><b>true</b></font>, <font color=""#7f0055""><b>true</b></font>, <font color=""#7f0055""><b>true</b></font>);
<font color=""#3f7f5f"">// Send the message that contains the notifications request</font>
chat1.sendMessage(msg);
</pre> 
</blockquote>","MessageEventManager","org.jivesoftware.smackx.MessageEventManager","class",1
,"Message Events","Reacting to Event Notifications","<div class=""subheader""> <h3>
 <a name=""lstevnot"">Reacting to Event Notifications</a> </h3>
</div> 
<p> <b>Description</b></p> 
<p> Once you have requested for event notifications you will start to receive notifications of events. You can receive notifications of the following events: delivered, displayed, composing, offline and cancelled. You will probably want to react to some or all of these events.</p> 
<b>Usage</b> 
<p> The general idea is to create a new <i> 
  <clt fqn=""org.jivesoftware.smackx.MessageEventNotificationListener"" api=""MessageEventNotificationListener"" kind=""class"">
    MessageEventNotificationListener 
  </clt></i> that will listen to the event notifications and react with custom logic. Then you will have to add the listener to the <i> 
  <clt fqn=""org.jivesoftware.smackx.MessageEventManager"" api=""MessageEventManager"" kind=""class"">
    MessageEventManager 
  </clt></i> that works on the desired <i> 
  <clt fqn=""org.jivesoftware.smack.Connection"" api=""Connection"" kind=""class"">
    Connection 
  </clt></i>. </p> 
<ul> 
 <li>To create a new <i> 
   <clt fqn=""org.jivesoftware.smackx.MessageEventManager"" api=""MessageEventManager"" kind=""class"">
     MessageEventManager 
   </clt></i> use the <i><b> 
    <clt fqn=""org.jivesoftware.smackx.MessageEventManager.MessageEventManager"" api=""MessageEventManager"" kind=""method"">
     MessageEventManager.MessageEventManager(Connection)
    </clt></b></i> constructor. </li> 
 <li>To create an event notifications listener create a class that implements the <i><b> 
    <clt fqn=""org.jivesoftware.smackx.MessageEventNotificationListener"" api=""MessageEventNotificationListener"" kind=""class"">
      MessageEventNotificationListener 
    </clt></b></i> interface. </li> 
 <li>To add a listener to the messageEventManager use the MessageEventManager's message <i><b> 
    <clt fqn=""org.jivesoftware.smackx.MessageEventManager.addMessageEventNotificationListener"" api=""MessageEventManager"" kind=""method"">
     MessageEventManager.addMessageEventNotificationListener(MessageEventNotificationListener)
    </clt></b></i>.</li> 
</ul> 
<b>Example</b> 
<p> Below you can find an example that logs in a user to the server, adds a <i> 
  <clt fqn=""org.jivesoftware.smackx.MessageEventNotificationListener"" api=""MessageEventNotificationListener"" kind=""class"">
    MessageEventNotificationListener 
  </clt></i> to a <i> 
  <clt fqn=""org.jivesoftware.smackx.MessageEventManager"" api=""MessageEventManager"" kind=""class"">
    MessageEventManager 
  </clt></i> that will listen and react to the event notifications, creates a message, adds the requests for notifications and sends the message. </p> 
<blockquote> 
 <pre>      <font color=""#3f7f5f"">// Connect to the server and log in</font>
conn1 = new XMPPConnection(host);
conn1.login(server_user1, pass1);
<font color=""#3f7f5f"">// Create a MessageEventManager</font>
MessageEventManager messageEventManager = new MessageEventManager(conn1);
<font color=""#3f7f5f"">// Add the listener that will react to the event notifications</font>
messageEventManager.addMessageEventNotificationListener(new MessageEventNotificationListener() {
public void deliveredNotification(String from, String packetID) {
System.out.println(<font color=""#0000FF"">&quot;The message has been delivered (&quot; + from + &quot;, &quot; + packetID + &quot;)&quot;</font>);
}
public void displayedNotification(String from, String packetID) {
System.out.println(<font color=""#0000FF"">&quot;The message has been displayed (&quot; + from + &quot;, &quot; + packetID + &quot;)&quot;</font>);
}
public void composingNotification(String from, String packetID) {
System.out.println(<font color=""#0000FF"">&quot;The message's receiver is composing a reply (&quot; + from + &quot;, &quot; + packetID + &quot;)&quot;</font>);
}
public void offlineNotification(String from, String packetID) {
System.out.println(<font color=""#0000FF"">&quot;The message's receiver is offline (&quot; + from + &quot;, &quot; + packetID + &quot;)&quot;</font>);
}
public void cancelledNotification(String from, String packetID) {
System.out.println(<font color=""#0000FF"">&quot;The message's receiver cancelled composing a reply (&quot; + from + &quot;, &quot; + packetID + &quot;)&quot;</font>);
}
});
<font color=""#3f7f5f"">// Create a chat with user2</font>
Chat chat1 = conn1.createChat(user2);
<font color=""#3f7f5f"">// Create a message to send</font>
Message msg = chat1.createMessage();
msg.setSubject(<font color=""#0000FF"">&quot;Any subject you want&quot;</font>);
msg.setBody(<font color=""#0000FF"">&quot;An interesting body comes here...&quot;</font>);
<font color=""#3f7f5f"">// Add to the message all the notifications requests (offline, delivered, displayed,</font>
<font color=""#3f7f5f"">// composing)</font>
MessageEventManager.addNotificationsRequests(msg, <font color=""#7f0055""><b>true</b></font>, <font color=""#7f0055""><b>true</b></font>, <font color=""#7f0055""><b>true</b></font>, <font color=""#7f0055""><b>true</b></font>);
<font color=""#3f7f5f"">// Send the message that contains the notifications request</font>
chat1.sendMessage(msg);
</pre> 
</blockquote>","Connection","org.jivesoftware.smack.Connection","class",0
