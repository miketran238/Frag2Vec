,"Java's 
<clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
  Stack 
</clt>Class","Java's Stack Class","<h1>Java's 
 <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
   Stack 
 </clt>Class</h1> 
<p> The <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    java.util.Stack 
  </clt></code> class deserves a little explanation on its own. In the text on the <a href=""list.html""><code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code></a> interface the <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code> class is listed as an implementation. The typical use of a <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code> is not as a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> though. </p> 
<p> A <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code> is a data structure where you add elements to the &quot;top&quot; of the stack, and also remove elements from the top again. This is also referred to as the &quot;Last In First Out (LIFO)&quot; principle. In contrast, a <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> uses a &quot;First In First Out (FIFO)&quot; principle. </p> 
<p> <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code>'s are really handy for some types of data processing, for instance if you are parsing an XML file using either <a href=""/java-xml/sax.html"">SAX</a> or <a href=""/java-xml/stax.html"">StAX</a>. For an example, see my <a href=""/java-xml/sax-example.html"">Java SAX Example</a> in my Java XML tutorial. </p> 
<p> Here is a <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code> usage example: </p> 
<pre class=""codeBox"">
Stack stack = new Stack();
stack.push(&quot;1&quot;);
stack.push(&quot;2&quot;);
stack.push(&quot;3&quot;);
//look at top object (&quot;3&quot;), without taking it off the stack.    
Object objTop = stack.peek();
Object obj3 = stack.pop(); //the string &quot;3&quot; is at the top of the stack.
Object obj2 = stack.pop(); //the string &quot;2&quot; is at the top of the stack.
Object obj1 = stack.pop(); //the string &quot;1&quot; is at the top of the stack.   
</pre> 
<p> The <code> 
  <clt fqn=""java.util.Stack.push"" api=""Stack"" kind=""method"">
    Stack.push() 
  </clt></code> method pushes an object onto the top of the <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code>. </p> 
<p> The <code> 
  <clt fqn=""java.util.Stack.peek"" api=""Stack"" kind=""method"">
    Stack.peek() 
  </clt></code> method returns the object at the top of the <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code>, but leaves the object on of the <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code>. </p> 
<p> The <code> 
  <clt fqn=""java.util.Stack.pop"" api=""Stack"" kind=""method"">
    Stack.pop() 
  </clt></code> method returns the object at the top of the <code>stack</code>, and removes the object from the <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code>. </p>","Stack","java.util.Stack","class",1
,"Java's 
<clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
  Stack 
</clt>Class","Java's Stack Class","<h1>Java's 
 <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
   Stack 
 </clt>Class</h1> 
<p> The <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    java.util.Stack 
  </clt></code> class deserves a little explanation on its own. In the text on the <a href=""list.html""><code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code></a> interface the <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code> class is listed as an implementation. The typical use of a <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code> is not as a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> though. </p> 
<p> A <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code> is a data structure where you add elements to the &quot;top&quot; of the stack, and also remove elements from the top again. This is also referred to as the &quot;Last In First Out (LIFO)&quot; principle. In contrast, a <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> uses a &quot;First In First Out (FIFO)&quot; principle. </p> 
<p> <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code>'s are really handy for some types of data processing, for instance if you are parsing an XML file using either <a href=""/java-xml/sax.html"">SAX</a> or <a href=""/java-xml/stax.html"">StAX</a>. For an example, see my <a href=""/java-xml/sax-example.html"">Java SAX Example</a> in my Java XML tutorial. </p> 
<p> Here is a <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code> usage example: </p> 
<pre class=""codeBox"">
Stack stack = new Stack();
stack.push(&quot;1&quot;);
stack.push(&quot;2&quot;);
stack.push(&quot;3&quot;);
//look at top object (&quot;3&quot;), without taking it off the stack.    
Object objTop = stack.peek();
Object obj3 = stack.pop(); //the string &quot;3&quot; is at the top of the stack.
Object obj2 = stack.pop(); //the string &quot;2&quot; is at the top of the stack.
Object obj1 = stack.pop(); //the string &quot;1&quot; is at the top of the stack.   
</pre> 
<p> The <code> 
  <clt fqn=""java.util.Stack.push"" api=""Stack"" kind=""method"">
    Stack.push() 
  </clt></code> method pushes an object onto the top of the <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code>. </p> 
<p> The <code> 
  <clt fqn=""java.util.Stack.peek"" api=""Stack"" kind=""method"">
    Stack.peek() 
  </clt></code> method returns the object at the top of the <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code>, but leaves the object on of the <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code>. </p> 
<p> The <code> 
  <clt fqn=""java.util.Stack.pop"" api=""Stack"" kind=""method"">
    Stack.pop() 
  </clt></code> method returns the object at the top of the <code>stack</code>, and removes the object from the <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code>. </p>","List","java.util.List","class",0
,"Java's 
<clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
  Stack 
</clt>Class","Java's Stack Class","<h1>Java's 
 <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
   Stack 
 </clt>Class</h1> 
<p> The <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    java.util.Stack 
  </clt></code> class deserves a little explanation on its own. In the text on the <a href=""list.html""><code> 
   <clt fqn=""java.util.List"" api=""List"" kind=""class"">
     List 
   </clt></code></a> interface the <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code> class is listed as an implementation. The typical use of a <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code> is not as a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> though. </p> 
<p> A <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code> is a data structure where you add elements to the &quot;top&quot; of the stack, and also remove elements from the top again. This is also referred to as the &quot;Last In First Out (LIFO)&quot; principle. In contrast, a <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> uses a &quot;First In First Out (FIFO)&quot; principle. </p> 
<p> <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code>'s are really handy for some types of data processing, for instance if you are parsing an XML file using either <a href=""/java-xml/sax.html"">SAX</a> or <a href=""/java-xml/stax.html"">StAX</a>. For an example, see my <a href=""/java-xml/sax-example.html"">Java SAX Example</a> in my Java XML tutorial. </p> 
<p> Here is a <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code> usage example: </p> 
<pre class=""codeBox"">
Stack stack = new Stack();
stack.push(&quot;1&quot;);
stack.push(&quot;2&quot;);
stack.push(&quot;3&quot;);
//look at top object (&quot;3&quot;), without taking it off the stack.    
Object objTop = stack.peek();
Object obj3 = stack.pop(); //the string &quot;3&quot; is at the top of the stack.
Object obj2 = stack.pop(); //the string &quot;2&quot; is at the top of the stack.
Object obj1 = stack.pop(); //the string &quot;1&quot; is at the top of the stack.   
</pre> 
<p> The <code> 
  <clt fqn=""java.util.Stack.push"" api=""Stack"" kind=""method"">
    Stack.push() 
  </clt></code> method pushes an object onto the top of the <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code>. </p> 
<p> The <code> 
  <clt fqn=""java.util.Stack.peek"" api=""Stack"" kind=""method"">
    Stack.peek() 
  </clt></code> method returns the object at the top of the <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code>, but leaves the object on of the <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code>. </p> 
<p> The <code> 
  <clt fqn=""java.util.Stack.pop"" api=""Stack"" kind=""method"">
    Stack.pop() 
  </clt></code> method returns the object at the top of the <code>stack</code>, and removes the object from the <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code>. </p>","Queue","java.util.Queue","class",0
,"Java's 
<clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
  Stack 
</clt>Class","Searching the Stack","<h2>Searching the Stack</h2> 
<p> You can search for an object on the stack to get it's index, using the <code> 
  <clt fqn=""java.util.Stack.search"" api=""Stack"" kind=""method"">
    Stack.search() 
  </clt></code> method. The object's <code>equals()</code> method is called on every object on the <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code> to determine if the searched-for object is present on the <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code>. The index you get is the index from the <b>top</b> of the <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code>, meaning the top element on the <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code> has index 1. </p> 
<p> Here is how you search a <code> 
  <clt fqn=""java.util.Stack"" api=""Stack"" kind=""class"">
    Stack 
  </clt></code> for an object: </p> 
<pre class=""codeBox"">
Stack stack = new Stack();
stack.push(&quot;1&quot;);
stack.push(&quot;2&quot;);
stack.push(&quot;3&quot;);
<b>int index = stack.search(&quot;3&quot;);</b>     //index = 3
</pre>","Stack","java.util.Stack","class",1
,"Java's 
<clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
  NavigableMap 
</clt>Interface","Java's NavigableMap Interface","<h1>Java's 
 <clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
   NavigableMap 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
    java.util.NavigableMap 
  </clt></code> interface is a subtype of the <a href=""sortedmap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     java.util.SortedMap 
   </clt></code></a> interface. It has a few extensions to the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> which makes it possible to navigate the map. I will take a closer look at these navigation methods in this text. </p> 
<p> The <code>java.util</code> package only has one implementation of the <code> 
  <clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
    NavigableMap 
  </clt></code> interface: <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    java.util.TreeMap 
  </clt></code>. There is an implementation in the <code>java.util.concurrent</code> package but that is outside the scope of this trail. </p> 
<p> Here is a list of the topics covered in this text: </p> 
<ol> 
 <li><a href=""#iterator"">descendingKeySet() and descendingMap()</a></li> 
 <li><a href=""#headmap"">headMap(), tailMap() and subMap()</a></li> 
 <li><a href=""#ceilingKey"">ceilingKey(), floorKey(), higherKey() and lowerKey()</a></li> 
 <li><a href=""#ceilingEntry"">ceilingEntry(), floorEntry(), higherEntry() and lowerEntry()</a></li> 
 <li><a href=""#pollFirst"">pollFirstEntry() and pollLastEntry()</a></li> 
 <li><a href=""#javaDoc"">More detail in the JavaDoc</a></li> 
</ol>","NavigableMap","java.util.NavigableMap","class",0
,"Java's 
<clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
  NavigableMap 
</clt>Interface","Java's NavigableMap Interface","<h1>Java's 
 <clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
   NavigableMap 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
    java.util.NavigableMap 
  </clt></code> interface is a subtype of the <a href=""sortedmap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     java.util.SortedMap 
   </clt></code></a> interface. It has a few extensions to the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> which makes it possible to navigate the map. I will take a closer look at these navigation methods in this text. </p> 
<p> The <code>java.util</code> package only has one implementation of the <code> 
  <clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
    NavigableMap 
  </clt></code> interface: <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    java.util.TreeMap 
  </clt></code>. There is an implementation in the <code>java.util.concurrent</code> package but that is outside the scope of this trail. </p> 
<p> Here is a list of the topics covered in this text: </p> 
<ol> 
 <li><a href=""#iterator"">descendingKeySet() and descendingMap()</a></li> 
 <li><a href=""#headmap"">headMap(), tailMap() and subMap()</a></li> 
 <li><a href=""#ceilingKey"">ceilingKey(), floorKey(), higherKey() and lowerKey()</a></li> 
 <li><a href=""#ceilingEntry"">ceilingEntry(), floorEntry(), higherEntry() and lowerEntry()</a></li> 
 <li><a href=""#pollFirst"">pollFirstEntry() and pollLastEntry()</a></li> 
 <li><a href=""#javaDoc"">More detail in the JavaDoc</a></li> 
</ol>","SortedMap","java.util.SortedMap","class",0
,"Java's 
<clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
  NavigableMap 
</clt>Interface","Java's NavigableMap Interface","<h1>Java's 
 <clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
   NavigableMap 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
    java.util.NavigableMap 
  </clt></code> interface is a subtype of the <a href=""sortedmap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     java.util.SortedMap 
   </clt></code></a> interface. It has a few extensions to the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> which makes it possible to navigate the map. I will take a closer look at these navigation methods in this text. </p> 
<p> The <code>java.util</code> package only has one implementation of the <code> 
  <clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
    NavigableMap 
  </clt></code> interface: <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    java.util.TreeMap 
  </clt></code>. There is an implementation in the <code>java.util.concurrent</code> package but that is outside the scope of this trail. </p> 
<p> Here is a list of the topics covered in this text: </p> 
<ol> 
 <li><a href=""#iterator"">descendingKeySet() and descendingMap()</a></li> 
 <li><a href=""#headmap"">headMap(), tailMap() and subMap()</a></li> 
 <li><a href=""#ceilingKey"">ceilingKey(), floorKey(), higherKey() and lowerKey()</a></li> 
 <li><a href=""#ceilingEntry"">ceilingEntry(), floorEntry(), higherEntry() and lowerEntry()</a></li> 
 <li><a href=""#pollFirst"">pollFirstEntry() and pollLastEntry()</a></li> 
 <li><a href=""#javaDoc"">More detail in the JavaDoc</a></li> 
</ol>","SortedSet","java.util.SortedSet","class",0
,"Java's 
<clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
  NavigableMap 
</clt>Interface","Java's NavigableMap Interface","<h1>Java's 
 <clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
   NavigableMap 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
    java.util.NavigableMap 
  </clt></code> interface is a subtype of the <a href=""sortedmap.html""><code> 
   <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
     java.util.SortedMap 
   </clt></code></a> interface. It has a few extensions to the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> which makes it possible to navigate the map. I will take a closer look at these navigation methods in this text. </p> 
<p> The <code>java.util</code> package only has one implementation of the <code> 
  <clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
    NavigableMap 
  </clt></code> interface: <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    java.util.TreeMap 
  </clt></code>. There is an implementation in the <code>java.util.concurrent</code> package but that is outside the scope of this trail. </p> 
<p> Here is a list of the topics covered in this text: </p> 
<ol> 
 <li><a href=""#iterator"">descendingKeySet() and descendingMap()</a></li> 
 <li><a href=""#headmap"">headMap(), tailMap() and subMap()</a></li> 
 <li><a href=""#ceilingKey"">ceilingKey(), floorKey(), higherKey() and lowerKey()</a></li> 
 <li><a href=""#ceilingEntry"">ceilingEntry(), floorEntry(), higherEntry() and lowerEntry()</a></li> 
 <li><a href=""#pollFirst"">pollFirstEntry() and pollLastEntry()</a></li> 
 <li><a href=""#javaDoc"">More detail in the JavaDoc</a></li> 
</ol>","TreeMap","java.util.TreeMap","class",0
,"Java's 
<clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
  NavigableMap 
</clt>Interface","descendingKeySet() and descendingMap()","<h2>descendingKeySet() and descendingMap()</h2> 
<p> The first interesting navigation methods are the <code> 
  <clt fqn=""java.util.NavigableMap.descendingKeySet"" api=""NavigableMap"" kind=""method"">
    NavigableMap.descendingKeySet() 
  </clt></code> and <code> 
  <clt fqn=""java.util.NavigableMap.descendingMap"" api=""NavigableMap"" kind=""method"">
    NavigableMap.descendingMap() 
  </clt></code> methods. </p> 
<p> The <code> 
  <clt fqn=""java.util.NavigableMap.descendingKeySet"" api=""NavigableMap"" kind=""method"">
    NavigableMap.descendingKeySet() 
  </clt></code> method returns a <code> 
  <clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
    NavigableSet 
  </clt></code> in which the order of the elements is reversed compared to the original key set. The returned &quot;view&quot; is backed by the original <code> 
  <clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
    NavigableSet 
  </clt></code> ket set, so changes to the descending set are also reflected in the original set. However, you should not remove elements directly from the key set. Use the <code> 
  <clt fqn=""java.util.Map.remove"" api=""Map"" kind=""method"">
    Map.Map.remove() 
  </clt></code> method instead. </p> 
<p> Here is a simple example: </p> 
<pre class=""codeBox"">
NavigableSet reverse = map.descendingKeySet();
</pre> 
<p> The <code> 
  <clt fqn=""java.util.NavigableMap.descendingMap"" api=""NavigableMap"" kind=""method"">
    NavigableMap.descendingMap() 
  </clt></code> method returns a <code> 
  <clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
    NavigableMap 
  </clt></code> which is a view of the original <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. The order of the elements in this view map is reverse of the order of the original map. Being a view of the original map, any changes to this view is also reflected in the original map. </p> 
<p> Here is a simple example: </p> 
<pre class=""codeBox"">
NavigableMap descending = map.descendingMap();
</pre>","NavigableMap","java.util.NavigableMap","class",1
,"Java's 
<clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
  NavigableMap 
</clt>Interface","descendingKeySet() and descendingMap()","<h2>descendingKeySet() and descendingMap()</h2> 
<p> The first interesting navigation methods are the <code> 
  <clt fqn=""java.util.NavigableMap.descendingKeySet"" api=""NavigableMap"" kind=""method"">
    NavigableMap.descendingKeySet() 
  </clt></code> and <code> 
  <clt fqn=""java.util.NavigableMap.descendingMap"" api=""NavigableMap"" kind=""method"">
    NavigableMap.descendingMap() 
  </clt></code> methods. </p> 
<p> The <code> 
  <clt fqn=""java.util.NavigableMap.descendingKeySet"" api=""NavigableMap"" kind=""method"">
    NavigableMap.descendingKeySet() 
  </clt></code> method returns a <code> 
  <clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
    NavigableSet 
  </clt></code> in which the order of the elements is reversed compared to the original key set. The returned &quot;view&quot; is backed by the original <code> 
  <clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
    NavigableSet 
  </clt></code> ket set, so changes to the descending set are also reflected in the original set. However, you should not remove elements directly from the key set. Use the <code> 
  <clt fqn=""java.util.Map.remove"" api=""Map"" kind=""method"">
    Map.Map.remove() 
  </clt></code> method instead. </p> 
<p> Here is a simple example: </p> 
<pre class=""codeBox"">
NavigableSet reverse = map.descendingKeySet();
</pre> 
<p> The <code> 
  <clt fqn=""java.util.NavigableMap.descendingMap"" api=""NavigableMap"" kind=""method"">
    NavigableMap.descendingMap() 
  </clt></code> method returns a <code> 
  <clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
    NavigableMap 
  </clt></code> which is a view of the original <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. The order of the elements in this view map is reverse of the order of the original map. Being a view of the original map, any changes to this view is also reflected in the original map. </p> 
<p> Here is a simple example: </p> 
<pre class=""codeBox"">
NavigableMap descending = map.descendingMap();
</pre>","NavigableSet","java.util.NavigableSet","class",1
,"Java's 
<clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
  NavigableMap 
</clt>Interface","descendingKeySet() and descendingMap()","<h2>descendingKeySet() and descendingMap()</h2> 
<p> The first interesting navigation methods are the <code> 
  <clt fqn=""java.util.NavigableMap.descendingKeySet"" api=""NavigableMap"" kind=""method"">
    NavigableMap.descendingKeySet() 
  </clt></code> and <code> 
  <clt fqn=""java.util.NavigableMap.descendingMap"" api=""NavigableMap"" kind=""method"">
    NavigableMap.descendingMap() 
  </clt></code> methods. </p> 
<p> The <code> 
  <clt fqn=""java.util.NavigableMap.descendingKeySet"" api=""NavigableMap"" kind=""method"">
    NavigableMap.descendingKeySet() 
  </clt></code> method returns a <code> 
  <clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
    NavigableSet 
  </clt></code> in which the order of the elements is reversed compared to the original key set. The returned &quot;view&quot; is backed by the original <code> 
  <clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
    NavigableSet 
  </clt></code> ket set, so changes to the descending set are also reflected in the original set. However, you should not remove elements directly from the key set. Use the <code> 
  <clt fqn=""java.util.Map.remove"" api=""Map"" kind=""method"">
    Map.Map.remove() 
  </clt></code> method instead. </p> 
<p> Here is a simple example: </p> 
<pre class=""codeBox"">
NavigableSet reverse = map.descendingKeySet();
</pre> 
<p> The <code> 
  <clt fqn=""java.util.NavigableMap.descendingMap"" api=""NavigableMap"" kind=""method"">
    NavigableMap.descendingMap() 
  </clt></code> method returns a <code> 
  <clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
    NavigableMap 
  </clt></code> which is a view of the original <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. The order of the elements in this view map is reverse of the order of the original map. Being a view of the original map, any changes to this view is also reflected in the original map. </p> 
<p> Here is a simple example: </p> 
<pre class=""codeBox"">
NavigableMap descending = map.descendingMap();
</pre>","Map","java.util.Map","class",0
,"Java's 
<clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
  NavigableMap 
</clt>Interface","headMap(), tailMap() and subMap()","<h2>headMap(), tailMap() and subMap()</h2> 
<p> The <code> 
  <clt fqn=""java.util.NavigableMap.headMap"" api=""NavigableMap"" kind=""method"">
    NavigableMap.headMap() 
  </clt></code> method returns a view of the original <code> 
  <clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
    NavigableMap 
  </clt></code> which only contains elements that are &quot;less than&quot; the given element. Here is an example: </p> 
<pre class=""codeBox"">
NavigableMap original = new TreeMap();
original.put(&quot;1&quot;, &quot;1&quot;);
original.put(&quot;2&quot;, &quot;2&quot;);
original.put(&quot;3&quot;, &quot;3&quot;);
//this headmap1 will contain &quot;1&quot; and &quot;2&quot;
SortedMap headmap1 = original.headMap(&quot;3&quot;);
//this headmap2 will contain &quot;1&quot;, &quot;2&quot;, and &quot;3&quot; because &quot;inclusive&quot;=true
NavigableMap headmap2 = original.headMap(&quot;3&quot;, true);
</pre> 
<p> The <code> 
  <clt fqn=""java.util.NavigableMap.tailMap"" api=""NavigableMap"" kind=""method"">
    NavigableMap.tailMap() 
  </clt></code> method works the same way, except it returns all elements that are <b>higher</b> than the given parameter element. </p> 
<p> The <code> 
  <clt fqn=""java.util.NavigableMap.subMap"" api=""NavigableMap"" kind=""method"">
    NavigableMap.subMap() 
  </clt></code> allows you to pass two parameters demarcating the boundaries of the view map to return. Here is an example: </p> 
<pre class=""codeBox"">
NavigableMap original = new TreeMap();
original.put(&quot;1&quot;, &quot;1&quot;);
original.add(&quot;2&quot;, &quot;2&quot;);
original.add(&quot;3&quot;, &quot;3&quot;);
original.add(&quot;4&quot;, &quot;4&quot;);
original.add(&quot;5&quot;, &quot;5&quot;);
//this submap1 will contain &quot;3&quot;, &quot;3&quot;
SortedMap    submap1  = original.subMap(&quot;2&quot;, &quot;4&quot;);
//this submap2 will contain (&quot;2&quot;, &quot;2&quot;) (&quot;3&quot;, &quot;3&quot;) and (&quot;4&quot;, &quot;4&quot;) because
//    fromInclusive=true, and toInclusive=true
NavigableMap submap2 = original.subMap(&quot;2&quot;, true, &quot;4&quot;, true);
</pre>","NavigableMap","java.util.NavigableMap","class",1
,"Java's 
<clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
  NavigableMap 
</clt>Interface","ceilingKey(), floorKey(), higherKey() and lowerKey()","<h2>ceilingKey(), floorKey(), higherKey() and lowerKey()</h2> 
<p> The <code> 
  <clt fqn=""java.util.NavigableMap.ceilingKey"" api=""NavigableMap"" kind=""method"">
    NavigableMap.ceilingKey() 
  </clt></code> method returns the least (smallest) key in this map that is greater than or equal to the element passed as parameter to the <code> 
  <clt fqn=""java.util.NavigableMap.ceilingKey"" api=""NavigableMap"" kind=""method"">
    NavigableMap.ceilingKey() 
  </clt></code> method. Here is an example: </p> 
<pre class=""codeBox"">
NavigableMap original = new TreeMap();
original.put(&quot;1&quot;, &quot;1&quot;);
original.put(&quot;2&quot;, &quot;2&quot;);
original.put(&quot;3&quot;, &quot;3&quot;);
//ceilingKey will be &quot;2&quot;.
Object ceilingKey = original.ceilingKey(&quot;2&quot;);
//floorKey will be &quot;2&quot;.
Object floorKey = original.floorKey(&quot;2&quot;);
</pre> 
<p> The <code> 
  <clt fqn=""java.util.NavigableMap.floorKey"" api=""NavigableMap"" kind=""method"">
    NavigableMap.floorKey() 
  </clt></code> method does the opposite of <code> 
  <clt fqn=""java.util.NavigableMap.ceilingKey"" api=""NavigableMap"" kind=""method"">
    NavigableMap.ceilingKey() 
  </clt></code> </p> 
<p> The <code> 
  <clt fqn=""java.util.NavigableMap.higherKey"" api=""NavigableMap"" kind=""method"">
    NavigableMap.higherKey() 
  </clt></code> method returns the least (smallest) element in this map that is greater than (not equal too) the element passed as parameter to the <code> 
  <clt fqn=""java.util.NavigableMap.higherKey"" api=""NavigableMap"" kind=""method"">
    NavigableMap.higherKey() 
  </clt></code> method. Here is an example: </p> 
<pre class=""codeBox"">
NavigableMap original = new TreeMap();
original.put(&quot;1&quot;, &quot;1&quot;);
original.put(&quot;2&quot;, &quot;2&quot;);
original.put(&quot;3&quot;, &quot;3&quot;);
//higherKey will be &quot;3&quot;.
Object higherKey = original.higherKey(&quot;2&quot;);
//lowerKey will be &quot;1&quot;
Object lowerKey = original.lowerKey(&quot;2&quot;);
</pre> 
<p> The <code> 
  <clt fqn=""java.util.NavigableMap.lowerKey"" api=""NavigableMap"" kind=""method"">
    NavigableMap.lowerKey() 
  </clt></code> method does the opposite of the <code> 
  <clt fqn=""java.util.NavigableMap.higherKey"" api=""NavigableMap"" kind=""method"">
    NavigableMap.higherKey() 
  </clt></code> method. </p>","NavigableMap","java.util.NavigableMap","class",1
,"Java's 
<clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
  NavigableMap 
</clt>Interface","celingEntry(), floorEntry(), higherEntry(), lowerEntry()","<h2>celingEntry(), floorEntry(), higherEntry(), lowerEntry()</h2> 
<p> The <code> 
  <clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
    NavigableMap 
  </clt></code> also has methods to get the entry for a given key, rather than the key itself. These methods behave like the <code> 
  <clt fqn=""java.util.NavigableMap.ceilingKey"" api=""NavigableMap"" kind=""method"">
    NavigableMap.ceilingKey() 
  </clt></code> etc. methods, except they return an <code> 
  <clt fqn=""java.util.Map.Entry"" api=""Entry"" kind=""class"">
    Map.Entry 
  </clt></code> instead of the key object itself. </p> 
<p> A <code> 
  <clt fqn=""java.util.Map.Entry"" api=""Entry"" kind=""class"">
    Map.Entry 
  </clt></code> maps a single key to a single value. </p> 
<p> Here is a simple example. For more details, check out the JavaDoc. </p> 
<pre class=""codeBox"">
NavigableMap original = new TreeMap();
original.put(&quot;1&quot;, &quot;1&quot;);
original.put(&quot;2&quot;, &quot;2&quot;);
original.put(&quot;3&quot;, &quot;3&quot;);
//higherEntry will be (&quot;3&quot;, &quot;3&quot;).
Map.Entry higherEntry = original.higherEntry(&quot;2&quot;);
//lowerEntry will be (&quot;1&quot;, &quot;1&quot;)
Map.Entry lowerEntry = original.lowerEntry(&quot;2&quot;);
</pre>","NavigableMap","java.util.NavigableMap","class",0
,"Java's 
<clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
  NavigableMap 
</clt>Interface","celingEntry(), floorEntry(), higherEntry(), lowerEntry()","<h2>celingEntry(), floorEntry(), higherEntry(), lowerEntry()</h2> 
<p> The <code> 
  <clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
    NavigableMap 
  </clt></code> also has methods to get the entry for a given key, rather than the key itself. These methods behave like the <code> 
  <clt fqn=""java.util.NavigableMap.ceilingKey"" api=""NavigableMap"" kind=""method"">
    NavigableMap.ceilingKey() 
  </clt></code> etc. methods, except they return an <code> 
  <clt fqn=""java.util.Map.Entry"" api=""Entry"" kind=""class"">
    Map.Entry 
  </clt></code> instead of the key object itself. </p> 
<p> A <code> 
  <clt fqn=""java.util.Map.Entry"" api=""Entry"" kind=""class"">
    Map.Entry 
  </clt></code> maps a single key to a single value. </p> 
<p> Here is a simple example. For more details, check out the JavaDoc. </p> 
<pre class=""codeBox"">
NavigableMap original = new TreeMap();
original.put(&quot;1&quot;, &quot;1&quot;);
original.put(&quot;2&quot;, &quot;2&quot;);
original.put(&quot;3&quot;, &quot;3&quot;);
//higherEntry will be (&quot;3&quot;, &quot;3&quot;).
Map.Entry higherEntry = original.higherEntry(&quot;2&quot;);
//lowerEntry will be (&quot;1&quot;, &quot;1&quot;)
Map.Entry lowerEntry = original.lowerEntry(&quot;2&quot;);
</pre>","Entry","java.util.Map.Entry","class",0
,"Java's 
<clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
  NavigableMap 
</clt>Interface","pollFirstEntry() and pollLastEntry()","<h2>pollFirstEntry() and pollLastEntry()</h2> 
<p> The <code> 
  <clt fqn=""java.util.NavigableMap.pollFirstEntry"" api=""NavigableMap"" kind=""method"">
    NavigableMap.pollFirstEntry() 
  </clt></code> method returns and removes the &quot;first&quot; entry (key + value) in the <code> 
  <clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
    NavigableMap 
  </clt></code> or null if the map is empty. The <code> 
  <clt fqn=""java.util.NavigableMap.pollLastEntry"" api=""NavigableMap"" kind=""method"">
    NavigableMap.pollLastEntry() 
  </clt></code> returns and removes the &quot;last&quot; element in the map or null if the map is empty. &quot;First&quot; means smallest element according to the sort order of the keys. &quot;Last&quot; means largest key according to the element sorting order of the map. </p> 
<p> Here are two examples: </p> 
<pre class=""codeBox"">
NavigableMap original = new TreeMap();
original.put(&quot;1&quot;, &quot;1&quot;);
original.put(&quot;2&quot;, &quot;2&quot;);
original.put(&quot;3&quot;, &quot;3&quot;);
//first is (&quot;1&quot;, &quot;1&quot;)
Map.Entry first = original.pollFirstEntry();
//last is (&quot;3&quot;, &quot;3&quot;)
Map.Entry last = original.pollLastEntry();
</pre>","NavigableMap","java.util.NavigableMap","class",1
,"Java's 
<clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
  NavigableMap 
</clt>Interface","More Detail in the JavaDoc","<h2>More Detail in the JavaDoc</h2> 
<p> There are still a few interesting methods left in the <code> 
  <clt fqn=""java.util.NavigableMap"" api=""NavigableMap"" kind=""class"">
    NavigableMap 
  </clt></code> interface that I have not covered here. For instance, the <code> 
  <clt fqn=""java.util.NavigableMap.firstEntry"" api=""NavigableMap"" kind=""method"">
    NavigableMap.firstEntry() 
  </clt></code> and <code> 
  <clt fqn=""java.util.NavigableMap.lastEntry"" api=""NavigableMap"" kind=""method"">
    NavigableMap.lastEntry() 
  </clt></code> methods. You can check out these last methods in the official JavaDoc. </p>","NavigableMap","java.util.NavigableMap","class",0
,"Java's 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Java's List Interface","<h1>Java's 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    java.util.List 
  </clt></code> interface is a subtype of the <a href=""collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     java.util.Collection 
   </clt></code></a> interface. It represents an ordered list of objects, meaning you can access the elements of a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> in a specific order, and by an index too. You can also add the same element more than once to a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>. </p> 
<p> Here is a list of the topics covered in this text: </p> 
<ol> 
 <li><a href=""#implementations"">List Implementations</a></li> 
 <li><a href=""#add"">Adding and Accessing Elements</a></li> 
 <li><a href=""#remove"">Removing Elements</a></li> 
 <li><a href=""#generics"">Generic Lists</a></li> 
 <li><a href=""#javadoc"">More Details in the JavaDoc</a></li> 
</ol>","List","java.util.List","class",0
,"Java's 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Java's List Interface","<h1>Java's 
 <clt fqn=""java.util.List"" api=""List"" kind=""class"">
   List 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    java.util.List 
  </clt></code> interface is a subtype of the <a href=""collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     java.util.Collection 
   </clt></code></a> interface. It represents an ordered list of objects, meaning you can access the elements of a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> in a specific order, and by an index too. You can also add the same element more than once to a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>. </p> 
<p> Here is a list of the topics covered in this text: </p> 
<ol> 
 <li><a href=""#implementations"">List Implementations</a></li> 
 <li><a href=""#add"">Adding and Accessing Elements</a></li> 
 <li><a href=""#remove"">Removing Elements</a></li> 
 <li><a href=""#generics"">Generic Lists</a></li> 
 <li><a href=""#javadoc"">More Details in the JavaDoc</a></li> 
</ol>","Collection","java.util.Collection","class",0
,"Java's 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","List Implementations","<h2>List Implementations</h2> 
<p> Being a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> subtype all methods in the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface are also available in the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> interface. </p> 
<p> Since <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> is an interface you need to instantiate a concrete implementation of the interface in order to use it. You can choose between the following <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> implementations in the Java Collections API: </p> 
<ul> 
 <li>java.util.ArrayList</li> 
 <li>java.util.LinkedList</li> 
 <li>java.util.Vector</li> 
 <li>java.util.Stack</li> 
</ul> 
<p> There are also <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> implementations in the <code>java.util.concurrent</code> package, but I will leave the concurrency utilities out of this tutorial. </p> 
<p> Here are a few examples of how to create a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> instance: </p> 
<pre class=""codeBox"">
List listA = new ArrayList();
List listB = new LinkedList();
List listC = new Vector();
List listD = new Stack();    
</pre>","Collection","java.util.Collection","class",0
,"Java's 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","List Implementations","<h2>List Implementations</h2> 
<p> Being a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> subtype all methods in the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface are also available in the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> interface. </p> 
<p> Since <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> is an interface you need to instantiate a concrete implementation of the interface in order to use it. You can choose between the following <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> implementations in the Java Collections API: </p> 
<ul> 
 <li>java.util.ArrayList</li> 
 <li>java.util.LinkedList</li> 
 <li>java.util.Vector</li> 
 <li>java.util.Stack</li> 
</ul> 
<p> There are also <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> implementations in the <code>java.util.concurrent</code> package, but I will leave the concurrency utilities out of this tutorial. </p> 
<p> Here are a few examples of how to create a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> instance: </p> 
<pre class=""codeBox"">
List listA = new ArrayList();
List listB = new LinkedList();
List listC = new Vector();
List listD = new Stack();    
</pre>","List","java.util.List","class",0
,"Java's 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Adding and Accessing Elements","<h2>Adding and Accessing Elements</h2> 
<p> To add elements to a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> you call its <code> 
  <clt fqn=""java.util.List.add"" api=""List"" kind=""method"">
    List.add() 
  </clt></code> method. This method is inherited from the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface. Here are a few examples: </p> 
<pre class=""codeBox"">
List listA = new ArrayList();
listA.add(&quot;element 1&quot;);
listA.add(&quot;element 2&quot;);
listA.add(&quot;element 3&quot;);
listA.add(0, &quot;element 0&quot;);
</pre> 
<p> The first three <code> 
  <clt fqn=""java.util.List.add"" api=""List"" kind=""method"">
    List.add() 
  </clt></code> calls add a <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> instance to the end of the list. The last <code> 
  <clt fqn=""java.util.List.add"" api=""List"" kind=""method"">
    List.add() 
  </clt></code> call adds a <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> at index 0, meaning at the beginning of the list. </p> 
<p> The order in which the elements are added to the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> is stored, so you can access the elements in the same order. You can do so using either the <code> 
  <clt fqn=""java.util.List.get"" api=""List"" kind=""method"">
    List.get(int index) 
  </clt></code> method, or via the <code> 
  <clt fqn=""java.util.Iterator"" api=""Iterator"" kind=""class"">
    Iterator 
  </clt></code> returned by the <code> 
  <clt fqn=""java.util.List.iterator"" api=""List"" kind=""method"">
    List.iterator() 
  </clt></code> method. Here is how: </p> 
<pre class=""codeBox"">
List listA = new ArrayList();
listA.add(&quot;element 0&quot;);
listA.add(&quot;element 1&quot;);
listA.add(&quot;element 2&quot;);
//access via index
String element0 = listA.get(0);
String element1 = listA.get(1);
String element3 = listA.get(2);
//access via Iterator
Iterator iterator = listA.iterator();
while(iterator.hasNext(){
String element = (String) iterator.next();
}
//access via new for-loop
for(Object object : listA) {
String element = (String) object;
}
</pre> 
<p> When iterating the list via its <code> 
  <clt fqn=""java.util.Iterator"" api=""Iterator"" kind=""class"">
    Iterator 
  </clt></code> or via the for-loop (which also uses the Iterator behind the scene), the elements are iterated in the same sequence they are stored in the list. </p>","List","java.util.List","class",1
,"Java's 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Adding and Accessing Elements","<h2>Adding and Accessing Elements</h2> 
<p> To add elements to a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> you call its <code> 
  <clt fqn=""java.util.List.add"" api=""List"" kind=""method"">
    List.add() 
  </clt></code> method. This method is inherited from the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface. Here are a few examples: </p> 
<pre class=""codeBox"">
List listA = new ArrayList();
listA.add(&quot;element 1&quot;);
listA.add(&quot;element 2&quot;);
listA.add(&quot;element 3&quot;);
listA.add(0, &quot;element 0&quot;);
</pre> 
<p> The first three <code> 
  <clt fqn=""java.util.List.add"" api=""List"" kind=""method"">
    List.add() 
  </clt></code> calls add a <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> instance to the end of the list. The last <code> 
  <clt fqn=""java.util.List.add"" api=""List"" kind=""method"">
    List.add() 
  </clt></code> call adds a <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> at index 0, meaning at the beginning of the list. </p> 
<p> The order in which the elements are added to the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> is stored, so you can access the elements in the same order. You can do so using either the <code> 
  <clt fqn=""java.util.List.get"" api=""List"" kind=""method"">
    List.get(int index) 
  </clt></code> method, or via the <code> 
  <clt fqn=""java.util.Iterator"" api=""Iterator"" kind=""class"">
    Iterator 
  </clt></code> returned by the <code> 
  <clt fqn=""java.util.List.iterator"" api=""List"" kind=""method"">
    List.iterator() 
  </clt></code> method. Here is how: </p> 
<pre class=""codeBox"">
List listA = new ArrayList();
listA.add(&quot;element 0&quot;);
listA.add(&quot;element 1&quot;);
listA.add(&quot;element 2&quot;);
//access via index
String element0 = listA.get(0);
String element1 = listA.get(1);
String element3 = listA.get(2);
//access via Iterator
Iterator iterator = listA.iterator();
while(iterator.hasNext(){
String element = (String) iterator.next();
}
//access via new for-loop
for(Object object : listA) {
String element = (String) object;
}
</pre> 
<p> When iterating the list via its <code> 
  <clt fqn=""java.util.Iterator"" api=""Iterator"" kind=""class"">
    Iterator 
  </clt></code> or via the for-loop (which also uses the Iterator behind the scene), the elements are iterated in the same sequence they are stored in the list. </p>","Collection","java.util.Collection","class",0
,"Java's 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Adding and Accessing Elements","<h2>Adding and Accessing Elements</h2> 
<p> To add elements to a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> you call its <code> 
  <clt fqn=""java.util.List.add"" api=""List"" kind=""method"">
    List.add() 
  </clt></code> method. This method is inherited from the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface. Here are a few examples: </p> 
<pre class=""codeBox"">
List listA = new ArrayList();
listA.add(&quot;element 1&quot;);
listA.add(&quot;element 2&quot;);
listA.add(&quot;element 3&quot;);
listA.add(0, &quot;element 0&quot;);
</pre> 
<p> The first three <code> 
  <clt fqn=""java.util.List.add"" api=""List"" kind=""method"">
    List.add() 
  </clt></code> calls add a <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> instance to the end of the list. The last <code> 
  <clt fqn=""java.util.List.add"" api=""List"" kind=""method"">
    List.add() 
  </clt></code> call adds a <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> at index 0, meaning at the beginning of the list. </p> 
<p> The order in which the elements are added to the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> is stored, so you can access the elements in the same order. You can do so using either the <code> 
  <clt fqn=""java.util.List.get"" api=""List"" kind=""method"">
    List.get(int index) 
  </clt></code> method, or via the <code> 
  <clt fqn=""java.util.Iterator"" api=""Iterator"" kind=""class"">
    Iterator 
  </clt></code> returned by the <code> 
  <clt fqn=""java.util.List.iterator"" api=""List"" kind=""method"">
    List.iterator() 
  </clt></code> method. Here is how: </p> 
<pre class=""codeBox"">
List listA = new ArrayList();
listA.add(&quot;element 0&quot;);
listA.add(&quot;element 1&quot;);
listA.add(&quot;element 2&quot;);
//access via index
String element0 = listA.get(0);
String element1 = listA.get(1);
String element3 = listA.get(2);
//access via Iterator
Iterator iterator = listA.iterator();
while(iterator.hasNext(){
String element = (String) iterator.next();
}
//access via new for-loop
for(Object object : listA) {
String element = (String) object;
}
</pre> 
<p> When iterating the list via its <code> 
  <clt fqn=""java.util.Iterator"" api=""Iterator"" kind=""class"">
    Iterator 
  </clt></code> or via the for-loop (which also uses the Iterator behind the scene), the elements are iterated in the same sequence they are stored in the list. </p>","String","java.lang.String","class",0
,"Java's 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Adding and Accessing Elements","<h2>Adding and Accessing Elements</h2> 
<p> To add elements to a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> you call its <code> 
  <clt fqn=""java.util.List.add"" api=""List"" kind=""method"">
    List.add() 
  </clt></code> method. This method is inherited from the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface. Here are a few examples: </p> 
<pre class=""codeBox"">
List listA = new ArrayList();
listA.add(&quot;element 1&quot;);
listA.add(&quot;element 2&quot;);
listA.add(&quot;element 3&quot;);
listA.add(0, &quot;element 0&quot;);
</pre> 
<p> The first three <code> 
  <clt fqn=""java.util.List.add"" api=""List"" kind=""method"">
    List.add() 
  </clt></code> calls add a <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> instance to the end of the list. The last <code> 
  <clt fqn=""java.util.List.add"" api=""List"" kind=""method"">
    List.add() 
  </clt></code> call adds a <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> at index 0, meaning at the beginning of the list. </p> 
<p> The order in which the elements are added to the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> is stored, so you can access the elements in the same order. You can do so using either the <code> 
  <clt fqn=""java.util.List.get"" api=""List"" kind=""method"">
    List.get(int index) 
  </clt></code> method, or via the <code> 
  <clt fqn=""java.util.Iterator"" api=""Iterator"" kind=""class"">
    Iterator 
  </clt></code> returned by the <code> 
  <clt fqn=""java.util.List.iterator"" api=""List"" kind=""method"">
    List.iterator() 
  </clt></code> method. Here is how: </p> 
<pre class=""codeBox"">
List listA = new ArrayList();
listA.add(&quot;element 0&quot;);
listA.add(&quot;element 1&quot;);
listA.add(&quot;element 2&quot;);
//access via index
String element0 = listA.get(0);
String element1 = listA.get(1);
String element3 = listA.get(2);
//access via Iterator
Iterator iterator = listA.iterator();
while(iterator.hasNext(){
String element = (String) iterator.next();
}
//access via new for-loop
for(Object object : listA) {
String element = (String) object;
}
</pre> 
<p> When iterating the list via its <code> 
  <clt fqn=""java.util.Iterator"" api=""Iterator"" kind=""class"">
    Iterator 
  </clt></code> or via the for-loop (which also uses the Iterator behind the scene), the elements are iterated in the same sequence they are stored in the list. </p>","Iterator","java.util.Iterator","class",0
,"Java's 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Removing Elements","<h2>Removing Elements</h2> 
<p> You can remove elements in two ways: </p> 
<ol> 
 <li>remove(Object element)</li> 
 <li>remove(int index)</li> 
</ol> 
<p> <code> 
  <clt fqn=""java.util.List.remove"" api=""List"" kind=""method"">
    List.remove(Object element) 
  </clt></code> removes that element in the list, if it is present. All subsequent elements in the list are then moved up in the list. Their index thus decreases by 1. </p> 
<p> <code> 
  <clt fqn=""java.util.List.remove"" api=""List"" kind=""method"">
    List.remove(int index) 
  </clt></code> removes the element at the given index. All subsequent elements in the list are then moved up in the list. Their index thus decreases by 1. </p>","List","java.util.List","class",1
,"Java's 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Generic Lists","<h2>Generic Lists</h2> 
<p> By default you can put any <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code> into a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>, but from Java 5, Java Generics makes it possible to limit the types of object you can insert into a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>. Here is an example: </p> 
<pre class=""codeBox"">
List&lt;MyObject&gt; list = new ArrayList&lt;MyObject&gt;();
</pre> 
<p> This <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> can now only have <code>MyObject</code> instances inserted into it. You can then access and iterate its elements without casting them. Here is how it looks: </p> 
<pre class=""codeBox"">
MyObject myObject = list.get(0);
for(MyObject anObject : list){
//do someting to anObject...   
}
</pre> 
<p> For more information about Java Generics, see the <a href=""/java-generics/index.html"">Java Generics Tutorial</a>. </p>","Object","java.lang.Object","class",0
,"Java's 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","Generic Lists","<h2>Generic Lists</h2> 
<p> By default you can put any <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code> into a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>, but from Java 5, Java Generics makes it possible to limit the types of object you can insert into a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>. Here is an example: </p> 
<pre class=""codeBox"">
List&lt;MyObject&gt; list = new ArrayList&lt;MyObject&gt;();
</pre> 
<p> This <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> can now only have <code>MyObject</code> instances inserted into it. You can then access and iterate its elements without casting them. Here is how it looks: </p> 
<pre class=""codeBox"">
MyObject myObject = list.get(0);
for(MyObject anObject : list){
//do someting to anObject...   
}
</pre> 
<p> For more information about Java Generics, see the <a href=""/java-generics/index.html"">Java Generics Tutorial</a>. </p>","List","java.util.List","class",0
,"Java's 
<clt fqn=""java.util.List"" api=""List"" kind=""class"">
  List 
</clt>Interface","More Details in the JavaDoc","<h2>More Details in the JavaDoc</h2> 
<p> There is a lot more you can do with a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>, but you will have to check out the JavaDoc for more details. This text focused on the two most common operations: Adding / removing elements, and iterating the elements. </p>","List","java.util.List","class",0
,"Java 
<clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
  Collections 
</clt>Overview","Java Collections Overview","<h1>Java 
 <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
   Collections 
 </clt>Overview</h1> 
<p> In order to understand and use the Java Collections API effectively it is useful to have an overview of the interfaces it contains. So, that is what I will provide here. </p> 
<p> There are two &quot;groups&quot; of interfaces: <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>'s and <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>'s. </p> 
<p> Here is a graphical overview of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface hierarchy: </p> 
<p> And here is a graphical overview of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface hierarchy: </p> 
<p> You can find links to explanations of most (if not all) of these interfaces and implementations in the sub-menu at the top right of this page. That top-menu exists on all pages in this trail. </p>","Collections","java.util.Collections","class",0
,"Java 
<clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
  Collections 
</clt>Overview","Java Collections Overview","<h1>Java 
 <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
   Collections 
 </clt>Overview</h1> 
<p> In order to understand and use the Java Collections API effectively it is useful to have an overview of the interfaces it contains. So, that is what I will provide here. </p> 
<p> There are two &quot;groups&quot; of interfaces: <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>'s and <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>'s. </p> 
<p> Here is a graphical overview of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface hierarchy: </p> 
<p> And here is a graphical overview of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface hierarchy: </p> 
<p> You can find links to explanations of most (if not all) of these interfaces and implementations in the sub-menu at the top right of this page. That top-menu exists on all pages in this trail. </p>","Collection","java.util.Collection","class",0
,"Java 
<clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
  Collections 
</clt>Overview","Java Collections Overview","<h1>Java 
 <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
   Collections 
 </clt>Overview</h1> 
<p> In order to understand and use the Java Collections API effectively it is useful to have an overview of the interfaces it contains. So, that is what I will provide here. </p> 
<p> There are two &quot;groups&quot; of interfaces: <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code>'s and <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>'s. </p> 
<p> Here is a graphical overview of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface hierarchy: </p> 
<p> And here is a graphical overview of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface hierarchy: </p> 
<p> You can find links to explanations of most (if not all) of these interfaces and implementations in the sub-menu at the top right of this page. That top-menu exists on all pages in this trail. </p>","Map","java.util.Map","class",0
,"Java's 
<clt fqn=""java.lang.Iterable"" api=""Iterable"" kind=""class"">
  Iterable 
</clt>Interface","Java's Iterable Interface","<h1>Java's 
 <clt fqn=""java.lang.Iterable"" api=""Iterable"" kind=""class"">
   Iterable 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.lang.Iterable"" api=""Iterable"" kind=""class"">
    Iterable 
  </clt></code> interface (<code> 
  <clt fqn=""java.lang.Iterable"" api=""Iterable"" kind=""class"">
    java.lang.Iterable 
  </clt></code>) is one of the root interfaces of the Java collection classes. The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface extends <code> 
  <clt fqn=""java.lang.Iterable"" api=""Iterable"" kind=""class"">
    Iterable 
  </clt></code>, so all subtypes of <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> also implement the <code> 
  <clt fqn=""java.lang.Iterable"" api=""Iterable"" kind=""class"">
    Iterable 
  </clt></code> interface. </p> 
<p> A class that implements the <code> 
  <clt fqn=""java.lang.Iterable"" api=""Iterable"" kind=""class"">
    Iterable 
  </clt></code> can be used with the new for-loop. Here is such an example: </p> 
<pre class=""codeBox"">
List list = new ArrayList();
for(Object o : list){
//do something o;    
}
</pre> 
<p> The <code> 
  <clt fqn=""java.lang.Iterable"" api=""Iterable"" kind=""class"">
    Iterable 
  </clt></code> interface has only one method: </p> 
<pre class=""codeBox"">
public interface Iterable&lt;T&gt; {
public Iterator&lt;T&gt; iterator();    
}
</pre> 
<p> How you implement this <code> 
  <clt fqn=""java.lang.Iterable"" api=""Iterable"" kind=""class"">
    Iterable 
  </clt></code> interface so that you can use it with the new for-loop, is explained in the text <a href=""/java-generics/implementing-iterable.html"">Implementing the Iterable Interface</a>, in my Java Generics tutorial. </p>","Iterable","java.lang.Iterable","class",1
,"Java's 
<clt fqn=""java.lang.Iterable"" api=""Iterable"" kind=""class"">
  Iterable 
</clt>Interface","Java's Iterable Interface","<h1>Java's 
 <clt fqn=""java.lang.Iterable"" api=""Iterable"" kind=""class"">
   Iterable 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.lang.Iterable"" api=""Iterable"" kind=""class"">
    Iterable 
  </clt></code> interface (<code> 
  <clt fqn=""java.lang.Iterable"" api=""Iterable"" kind=""class"">
    java.lang.Iterable 
  </clt></code>) is one of the root interfaces of the Java collection classes. The <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface extends <code> 
  <clt fqn=""java.lang.Iterable"" api=""Iterable"" kind=""class"">
    Iterable 
  </clt></code>, so all subtypes of <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> also implement the <code> 
  <clt fqn=""java.lang.Iterable"" api=""Iterable"" kind=""class"">
    Iterable 
  </clt></code> interface. </p> 
<p> A class that implements the <code> 
  <clt fqn=""java.lang.Iterable"" api=""Iterable"" kind=""class"">
    Iterable 
  </clt></code> can be used with the new for-loop. Here is such an example: </p> 
<pre class=""codeBox"">
List list = new ArrayList();
for(Object o : list){
//do something o;    
}
</pre> 
<p> The <code> 
  <clt fqn=""java.lang.Iterable"" api=""Iterable"" kind=""class"">
    Iterable 
  </clt></code> interface has only one method: </p> 
<pre class=""codeBox"">
public interface Iterable&lt;T&gt; {
public Iterator&lt;T&gt; iterator();    
}
</pre> 
<p> How you implement this <code> 
  <clt fqn=""java.lang.Iterable"" api=""Iterable"" kind=""class"">
    Iterable 
  </clt></code> interface so that you can use it with the new for-loop, is explained in the text <a href=""/java-generics/implementing-iterable.html"">Implementing the Iterable Interface</a>, in my Java Generics tutorial. </p>","Collection","java.util.Collection","class",0
,"Sorting Java Collections","Sorting Java Collections","<h1>Sorting Java Collections</h1> 
<p> You can sort <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> collections using the <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
    java.util.Collections.sort() 
  </clt></code> method. You can sort these two types of <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>'s. </p> 
<ol> 
 <li>List</li> 
 <li>LinkedList</li> 
</ol>","List","java.util.List","class",0
,"Sorting Java Collections","Sorting Java Collections","<h1>Sorting Java Collections</h1> 
<p> You can sort <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> collections using the <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
    java.util.Collections.sort() 
  </clt></code> method. You can sort these two types of <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>'s. </p> 
<ol> 
 <li>List</li> 
 <li>LinkedList</li> 
</ol>","Collections","java.util.Collections","class",0
,"Sorting Java Collections","Sorting Objects by their Natural Order","<h2>Sorting Objects by their Natural Order</h2> 
<p> To sort a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> you do this: </p> 
<pre class=""codeBox"">
List list = new ArrayList();
//add elements to the list
Collections.sort(list);
</pre> 
<p> When sorting a list like this the elements are ordered according to their &quot;natural order&quot;. For objects to have a natural order they must implement the interface <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    java.lang.Comparable 
  </clt></code>. In other words, the objects must be comparable to determine their order. Here is how the <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> interface looks: </p> 
<pre class=""codeBox"">
public interface Comparable&lt;T&gt; {
int compareTo(T o);
}
</pre> 
<p> The <code> 
  <clt fqn=""java.lang.Comparable.compareTo"" api=""Comparable"" kind=""method"">
    Comparable.compareTo() 
  </clt></code> method should compare this object to another object, return an <code>int</code> value. Here are the rules for that <code>int</code> value: </p> 
<ul> 
 <li>Return a <b>negative</b> value if this object is <b>smaller</b> than the other object</li> 
 <li>Return <b>0 (zero)</b> if this object is <b>equal</b> to the other object.</li> 
 <li>Return a <b>positive</b> value if this object is <b>larger</b> than the other object.</li> 
</ul> 
<p> There are a few more specific rules to obey in the implementation, but the above is the primary requirements. Check out the JavaDoc for the details. </p>","List","java.util.List","class",0
,"Sorting Java Collections","Sorting Objects by their Natural Order","<h2>Sorting Objects by their Natural Order</h2> 
<p> To sort a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> you do this: </p> 
<pre class=""codeBox"">
List list = new ArrayList();
//add elements to the list
Collections.sort(list);
</pre> 
<p> When sorting a list like this the elements are ordered according to their &quot;natural order&quot;. For objects to have a natural order they must implement the interface <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    java.lang.Comparable 
  </clt></code>. In other words, the objects must be comparable to determine their order. Here is how the <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code> interface looks: </p> 
<pre class=""codeBox"">
public interface Comparable&lt;T&gt; {
int compareTo(T o);
}
</pre> 
<p> The <code> 
  <clt fqn=""java.lang.Comparable.compareTo"" api=""Comparable"" kind=""method"">
    Comparable.compareTo() 
  </clt></code> method should compare this object to another object, return an <code>int</code> value. Here are the rules for that <code>int</code> value: </p> 
<ul> 
 <li>Return a <b>negative</b> value if this object is <b>smaller</b> than the other object</li> 
 <li>Return <b>0 (zero)</b> if this object is <b>equal</b> to the other object.</li> 
 <li>Return a <b>positive</b> value if this object is <b>larger</b> than the other object.</li> 
</ul> 
<p> There are a few more specific rules to obey in the implementation, but the above is the primary requirements. Check out the JavaDoc for the details. </p>","Comparable","java.lang.Comparable","class",1
,"Sorting Java Collections","Sorting Objects by their Natural Order - part 2","<h3>Sorting Objects by their Natural Order - part 2</h3> 
<p> Let's say you are sorting a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> elements. To sort them, each string is compared to the others according to some sorting algorithm (not interesting here). Each string compares itself to another string by alphabetic comparison. So, if a string is less than another string by alphabetic comparison it will return a negative number from the <code> 
  <clt fqn=""java.lang.Comparable.compareTo"" api=""Comparable"" kind=""method"">
    Comparable.compareTo() 
  </clt></code> method. </p> 
<p> When you implement the <code> 
  <clt fqn=""java.lang.Comparable.compareTo"" api=""Comparable"" kind=""method"">
    Comparable.compareTo() 
  </clt></code> method in your own classes you will have to decide how these objects should be compared to each other. For instance, <code>Employee</code> objects can be compared by their first name, last name, salary, start year or whatever else you think makes sense. </p>","List","java.util.List","class",0
,"Sorting Java Collections","Sorting Objects by their Natural Order - part 2","<h3>Sorting Objects by their Natural Order - part 2</h3> 
<p> Let's say you are sorting a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> elements. To sort them, each string is compared to the others according to some sorting algorithm (not interesting here). Each string compares itself to another string by alphabetic comparison. So, if a string is less than another string by alphabetic comparison it will return a negative number from the <code> 
  <clt fqn=""java.lang.Comparable.compareTo"" api=""Comparable"" kind=""method"">
    Comparable.compareTo() 
  </clt></code> method. </p> 
<p> When you implement the <code> 
  <clt fqn=""java.lang.Comparable.compareTo"" api=""Comparable"" kind=""method"">
    Comparable.compareTo() 
  </clt></code> method in your own classes you will have to decide how these objects should be compared to each other. For instance, <code>Employee</code> objects can be compared by their first name, last name, salary, start year or whatever else you think makes sense. </p>","String","java.lang.String","class",0
,"Sorting Java Collections","Sorting Objects by their Natural Order - part 2","<h3>Sorting Objects by their Natural Order - part 2</h3> 
<p> Let's say you are sorting a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> of <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> elements. To sort them, each string is compared to the others according to some sorting algorithm (not interesting here). Each string compares itself to another string by alphabetic comparison. So, if a string is less than another string by alphabetic comparison it will return a negative number from the <code> 
  <clt fqn=""java.lang.Comparable.compareTo"" api=""Comparable"" kind=""method"">
    Comparable.compareTo() 
  </clt></code> method. </p> 
<p> When you implement the <code> 
  <clt fqn=""java.lang.Comparable.compareTo"" api=""Comparable"" kind=""method"">
    Comparable.compareTo() 
  </clt></code> method in your own classes you will have to decide how these objects should be compared to each other. For instance, <code>Employee</code> objects can be compared by their first name, last name, salary, start year or whatever else you think makes sense. </p>","Comparable","java.lang.Comparable","class",1
,"Sorting Java Collections","Sorting Objects Using a Comparator","<h2>Sorting Objects Using a Comparator</h2> 
<p> Sometimes you may want to sort a list according to another order than their natural order. Perhaps the objects you are sorting do not even have a natural order. In that case you can use a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> instead. Here is how you sort a list using a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>: </p> 
<pre class=""codeBox"">
List list = new ArrayList();
//add elements to the list
Comparator comparator = new SomeComparator();
Collections.sort(list, comparator);
</pre> 
<p> Notice how the <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
    Collections.sort() 
  </clt></code> method now takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    java.util.Comparator 
  </clt></code> as parameter in addition to the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>. This <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> compares the elements in the list two by two. Here is how the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> interface looks: </p> 
<pre class=""codeBox"">
public interface Comparator&lt;T&gt; {
int compare(T object1, T object2);
}
</pre> 
<p> The <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
    Comparator.compare() 
  </clt></code> method compares two objects to each other and should: </p> 
<ul> 
 <li>Return a <b>negative</b> value if object1 is <b>smaller</b> than object2</li> 
 <li>Return <b>0 (zero)</b> if objec1 is <b>equal</b> to object2.</li> 
 <li>Return a <b>positive</b> value if object1 is <b>larger</b> than object2.</li> 
</ul> 
<p> There are a few more requirements to the implementation of the <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
    Comparator.compare() 
  </clt></code> method, but these are the primary requirements. Check out the JavaDoc for more specific details. </p>","Comparator","java.util.Comparator","class",1
,"Sorting Java Collections","Sorting Objects Using a Comparator","<h2>Sorting Objects Using a Comparator</h2> 
<p> Sometimes you may want to sort a list according to another order than their natural order. Perhaps the objects you are sorting do not even have a natural order. In that case you can use a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> instead. Here is how you sort a list using a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>: </p> 
<pre class=""codeBox"">
List list = new ArrayList();
//add elements to the list
Comparator comparator = new SomeComparator();
Collections.sort(list, comparator);
</pre> 
<p> Notice how the <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
    Collections.sort() 
  </clt></code> method now takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    java.util.Comparator 
  </clt></code> as parameter in addition to the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>. This <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> compares the elements in the list two by two. Here is how the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> interface looks: </p> 
<pre class=""codeBox"">
public interface Comparator&lt;T&gt; {
int compare(T object1, T object2);
}
</pre> 
<p> The <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
    Comparator.compare() 
  </clt></code> method compares two objects to each other and should: </p> 
<ul> 
 <li>Return a <b>negative</b> value if object1 is <b>smaller</b> than object2</li> 
 <li>Return <b>0 (zero)</b> if objec1 is <b>equal</b> to object2.</li> 
 <li>Return a <b>positive</b> value if object1 is <b>larger</b> than object2.</li> 
</ul> 
<p> There are a few more requirements to the implementation of the <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
    Comparator.compare() 
  </clt></code> method, but these are the primary requirements. Check out the JavaDoc for more specific details. </p>","Collections","java.util.Collections","class",0
,"Sorting Java Collections","Sorting Objects Using a Comparator","<h2>Sorting Objects Using a Comparator</h2> 
<p> Sometimes you may want to sort a list according to another order than their natural order. Perhaps the objects you are sorting do not even have a natural order. In that case you can use a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> instead. Here is how you sort a list using a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code>: </p> 
<pre class=""codeBox"">
List list = new ArrayList();
//add elements to the list
Comparator comparator = new SomeComparator();
Collections.sort(list, comparator);
</pre> 
<p> Notice how the <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
    Collections.sort() 
  </clt></code> method now takes a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    java.util.Comparator 
  </clt></code> as parameter in addition to the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>. This <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> compares the elements in the list two by two. Here is how the <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> interface looks: </p> 
<pre class=""codeBox"">
public interface Comparator&lt;T&gt; {
int compare(T object1, T object2);
}
</pre> 
<p> The <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
    Comparator.compare() 
  </clt></code> method compares two objects to each other and should: </p> 
<ul> 
 <li>Return a <b>negative</b> value if object1 is <b>smaller</b> than object2</li> 
 <li>Return <b>0 (zero)</b> if objec1 is <b>equal</b> to object2.</li> 
 <li>Return a <b>positive</b> value if object1 is <b>larger</b> than object2.</li> 
</ul> 
<p> There are a few more requirements to the implementation of the <code> 
  <clt fqn=""java.util.Comparator.compare"" api=""Comparator"" kind=""method"">
    Comparator.compare() 
  </clt></code> method, but these are the primary requirements. Check out the JavaDoc for more specific details. </p>","List","java.util.List","class",0
,"Sorting Java Collections","Sorting Objects Using a Comparator - part 2","<h3>Sorting Objects Using a Comparator - part 2</h3> 
<p> Here is an example <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> that compares two fictive Employee objects: </p> 
<pre class=""codeBox"">
public class MyComparator&lt;Employee&gt; implements Comparator&lt;Employee&gt; {
public int compare(Employee emp1, Employee emp2){
if(emp1.getSalary() &lt;  emp2.getSalary()) return -1;
if(emp1.getSalary() == emp2.getSalary()) return 0;
return 1;
}
}
</pre> 
<p> A shorter way to write the comparison would be like this: </p> 
<pre class=""codeBox"">
public class MyComparator&lt;Employee&gt; implements Comparator&lt;Employee&gt; {
public int compare(Employee emp1, Employee emp2){
return emp1.getSalary() - emp2.getSalary();
}
}
</pre> 
<p> By subtracting one salary from the other, the resulting value is automatically either negative, 0 or positive. Smart, right? </p> 
<p> If you want to compare objects by more than one factor, start by comparing by the first factor (e.g first name). Then, if the first factors are equal, compare by the second factor (e.g. last name, or salary) etc. </p>","Comparator","java.util.Comparator","class",0
,"Java's 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Java's Map Interface","<h1>Java's 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    java.util.Map 
  </clt></code> interface represents a mapping between a key and a value. The <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface is not a subtype of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface. Therefore it behaves a bit different from the rest of the collection types. </p> 
<p> Here is a list of the topics covered in this text: </p> 
<ol> 
 <li><a href=""#implementations"">Map Implementations</a></li> 
 <li><a href=""#add"">Adding and Accessing Elements</a></li> 
 <li><a href=""#remove"">Removing Elements</a></li> 
 <li><a href=""#generics"">Generic Maps</a></li> 
 <li><a href=""#javadoc"">More Details in the JavaDoc</a></li> 
</ol>","Map","java.util.Map","class",0
,"Java's 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Java's Map Interface","<h1>Java's 
 <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
   Map 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    java.util.Map 
  </clt></code> interface represents a mapping between a key and a value. The <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> interface is not a subtype of the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface. Therefore it behaves a bit different from the rest of the collection types. </p> 
<p> Here is a list of the topics covered in this text: </p> 
<ol> 
 <li><a href=""#implementations"">Map Implementations</a></li> 
 <li><a href=""#add"">Adding and Accessing Elements</a></li> 
 <li><a href=""#remove"">Removing Elements</a></li> 
 <li><a href=""#generics"">Generic Maps</a></li> 
 <li><a href=""#javadoc"">More Details in the JavaDoc</a></li> 
</ol>","Collection","java.util.Collection","class",0
,"Java's 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Map Implementations","<h2>Map Implementations</h2> 
<p> Since <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is an interface you need to instantiate a concrete implementation of the interface in order to use it. You can choose between the following <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations in the Java Collections API: </p> 
<ul> 
 <li>java.util.HashMap</li> 
 <li>java.util.Hashtable</li> 
 <li>java.util.EnumMap</li> 
 <li>java.util.IdentityHashMap</li> 
 <li>java.util.LinkedHashMap</li> 
 <li>java.util.Properties</li> 
 <li>java.util.TreeMap</li> 
 <li>java.util.WeakHashMap</li> 
</ul> 
<p> In my experience, the most commonly used <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations are <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> and <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>. </p> 
<p> Each of these <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations behaves a little differently with respect to the order of the elements when iterating the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, and the time (big O notation) it takes to insert and access elements in the maps. </p> 
<p> <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> maps a key and a value. It does not guarantee any order of the elements stored internally in the map. </p> 
<p> <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code> also maps a key and a value. Furthermore it guarantees the order in which keys or values are iterated - which is the sort order of the keys or values. Check out the JavaDoc for more details. </p> 
<p> Here are a few examples of how to create a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instance: </p> 
<pre class=""codeBox"">
Map mapA = new HashMap();
Map mapB = new TreeMap();
</pre>","Map","java.util.Map","class",1
,"Java's 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Map Implementations","<h2>Map Implementations</h2> 
<p> Since <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is an interface you need to instantiate a concrete implementation of the interface in order to use it. You can choose between the following <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations in the Java Collections API: </p> 
<ul> 
 <li>java.util.HashMap</li> 
 <li>java.util.Hashtable</li> 
 <li>java.util.EnumMap</li> 
 <li>java.util.IdentityHashMap</li> 
 <li>java.util.LinkedHashMap</li> 
 <li>java.util.Properties</li> 
 <li>java.util.TreeMap</li> 
 <li>java.util.WeakHashMap</li> 
</ul> 
<p> In my experience, the most commonly used <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations are <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> and <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>. </p> 
<p> Each of these <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations behaves a little differently with respect to the order of the elements when iterating the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, and the time (big O notation) it takes to insert and access elements in the maps. </p> 
<p> <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> maps a key and a value. It does not guarantee any order of the elements stored internally in the map. </p> 
<p> <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code> also maps a key and a value. Furthermore it guarantees the order in which keys or values are iterated - which is the sort order of the keys or values. Check out the JavaDoc for more details. </p> 
<p> Here are a few examples of how to create a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instance: </p> 
<pre class=""codeBox"">
Map mapA = new HashMap();
Map mapB = new TreeMap();
</pre>","HashMap","java.util.HashMap","class",1
,"Java's 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Map Implementations","<h2>Map Implementations</h2> 
<p> Since <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> is an interface you need to instantiate a concrete implementation of the interface in order to use it. You can choose between the following <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations in the Java Collections API: </p> 
<ul> 
 <li>java.util.HashMap</li> 
 <li>java.util.Hashtable</li> 
 <li>java.util.EnumMap</li> 
 <li>java.util.IdentityHashMap</li> 
 <li>java.util.LinkedHashMap</li> 
 <li>java.util.Properties</li> 
 <li>java.util.TreeMap</li> 
 <li>java.util.WeakHashMap</li> 
</ul> 
<p> In my experience, the most commonly used <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations are <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> and <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code>. </p> 
<p> Each of these <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> implementations behaves a little differently with respect to the order of the elements when iterating the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, and the time (big O notation) it takes to insert and access elements in the maps. </p> 
<p> <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> maps a key and a value. It does not guarantee any order of the elements stored internally in the map. </p> 
<p> <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code> also maps a key and a value. Furthermore it guarantees the order in which keys or values are iterated - which is the sort order of the keys or values. Check out the JavaDoc for more details. </p> 
<p> Here are a few examples of how to create a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> instance: </p> 
<pre class=""codeBox"">
Map mapA = new HashMap();
Map mapB = new TreeMap();
</pre>","TreeMap","java.util.TreeMap","class",1
,"Java's 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Adding and Accessing Elements","<h2>Adding and Accessing Elements</h2> 
<p> To add elements to a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> you call its <code> 
  <clt fqn=""java.util.Map.put"" api=""Map"" kind=""method"">
    Map.put() 
  </clt></code> method. Here are a few examples: </p> 
<pre class=""codeBox"">
Map mapA = new HashMap();
mapA.put(&quot;key1&quot;, &quot;element 1&quot;);
mapA.put(&quot;key2&quot;, &quot;element 2&quot;);
mapA.put(&quot;key3&quot;, &quot;element 3&quot;);
</pre> 
<p> The three <code> 
  <clt fqn=""java.util.Map.put"" api=""Map"" kind=""method"">
    Map.put() 
  </clt></code> calls maps a string value to a string key. You can then obtain the value using the key. To do that you use the <code> 
  <clt fqn=""java.util.Map.get"" api=""Map"" kind=""method"">
    Map.get() 
  </clt></code> method like this: </p> 
<pre class=""codeBox"">
String element1 = (String) mapA.get(&quot;key1&quot;);
</pre> 
<p> You can iterate either the keys or the values of a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. Here is how you do that: </p> 
<pre class=""codeBox"">
// key iterator
Iterator iterator = mapA.keySet().iterator();
// value iterator
Iterator iterator = mapA.values();
</pre> 
<p> Most often you iterate the keys of the <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> and then get the corresponding values during the iteration. Here is how it looks: </p> 
<pre class=""codeBox"">
Iterator iterator = mapA.keySet().iterator();
while(iterator.hasNext(){
Object key   = iterator.next();
Object value = mapA.get(key);
}
//access via new for-loop
for(Object key : mapA.keySet()) {
Object value = mapA.get(key);
}
</pre>","Map","java.util.Map","class",1
,"Java's 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Removing Elements","<h2>Removing Elements</h2> 
<p> You remove elements by calling the <code> 
  <clt fqn=""java.util.Map.remove"" api=""Map"" kind=""method"">
    Map.remove(Object key) 
  </clt></code> method. You thus remove the (key, value) pair matching the key. </p>","Map","java.util.Map","class",0
,"Java's 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Generic Maps","<h2>Generic Maps</h2> 
<p> By default you can put any <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code> into a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, but from Java 5, Java Generics makes it possible to limit the types of object you can use for both keys and values in a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. Here is an example: </p> 
<pre class=""codeBox"">
Map&lt;String, MyObject&gt; map = new HashSet&lt;String, MyObject&gt;();
</pre> 
<p> This <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> can now only accept <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> objects for keys, and <code>MyObject</code> instances for values. You can then access and iterate keys and values without casting them. Here is how it looks: </p> 
<pre class=""codeBox"">
for(MyObject anObject : map.values()){
//do someting to anObject...
}
for(String key : map.keySet()){
MyObject value = map.get(key);
//do something to value
}
</pre> 
<p> For more information about Java Generics, see the <a href=""/java-generics/index.html"">Java Generics Tutorial</a>. </p>","Object","java.lang.Object","class",0
,"Java's 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Generic Maps","<h2>Generic Maps</h2> 
<p> By default you can put any <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code> into a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, but from Java 5, Java Generics makes it possible to limit the types of object you can use for both keys and values in a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. Here is an example: </p> 
<pre class=""codeBox"">
Map&lt;String, MyObject&gt; map = new HashSet&lt;String, MyObject&gt;();
</pre> 
<p> This <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> can now only accept <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> objects for keys, and <code>MyObject</code> instances for values. You can then access and iterate keys and values without casting them. Here is how it looks: </p> 
<pre class=""codeBox"">
for(MyObject anObject : map.values()){
//do someting to anObject...
}
for(String key : map.keySet()){
MyObject value = map.get(key);
//do something to value
}
</pre> 
<p> For more information about Java Generics, see the <a href=""/java-generics/index.html"">Java Generics Tutorial</a>. </p>","Map","java.util.Map","class",0
,"Java's 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","Generic Maps","<h2>Generic Maps</h2> 
<p> By default you can put any <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code> into a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, but from Java 5, Java Generics makes it possible to limit the types of object you can use for both keys and values in a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>. Here is an example: </p> 
<pre class=""codeBox"">
Map&lt;String, MyObject&gt; map = new HashSet&lt;String, MyObject&gt;();
</pre> 
<p> This <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code> can now only accept <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> objects for keys, and <code>MyObject</code> instances for values. You can then access and iterate keys and values without casting them. Here is how it looks: </p> 
<pre class=""codeBox"">
for(MyObject anObject : map.values()){
//do someting to anObject...
}
for(String key : map.keySet()){
MyObject value = map.get(key);
//do something to value
}
</pre> 
<p> For more information about Java Generics, see the <a href=""/java-generics/index.html"">Java Generics Tutorial</a>. </p>","String","java.lang.String","class",0
,"Java's 
<clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
  Map 
</clt>Interface","More Details in the JavaDoc","<h2>More Details in the JavaDoc</h2> 
<p> There is more you can do with a <code> 
  <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
    Map 
  </clt></code>, but you will have to check out the JavaDoc for more details. This text focused on the two most common operations: Adding / removing elements, and iterating the keys and values. </p>","Map","java.util.Map","class",0
,"Java's 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Java's Set Interface","<h1>Java's 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    java.util.Set 
  </clt></code> interface is a subtype of the <a href=""collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     java.util.Collection 
   </clt></code></a> interface. It represents set of objects, meaning each element can only exists once in a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. </p> 
<div itemscope="""" itemtype=""http://schema.org/SiteNavigationElement""> 
 <p> Table of contents: </p> 
 <ul> 
  <li><a href=""#java-set-example"">Java Set Example</a></li> 
  <li><a href=""#implementations"">Set Implementations</a></li> 
  <li><a href=""#add"">Adding and Accessing Elements</a></li> 
  <li><a href=""#remove"">Removing Elements</a></li> 
  <li><a href=""#generics"">Generic Sets</a></li> 
  <li><a href=""#javadoc"">More Details in the JavaDoc</a></li> 
 </ul> 
</div>","Set","java.util.Set","class",0
,"Java's 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Java's Set Interface","<h1>Java's 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    java.util.Set 
  </clt></code> interface is a subtype of the <a href=""collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     java.util.Collection 
   </clt></code></a> interface. It represents set of objects, meaning each element can only exists once in a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. </p> 
<div itemscope="""" itemtype=""http://schema.org/SiteNavigationElement""> 
 <p> Table of contents: </p> 
 <ul> 
  <li><a href=""#java-set-example"">Java Set Example</a></li> 
  <li><a href=""#implementations"">Set Implementations</a></li> 
  <li><a href=""#add"">Adding and Accessing Elements</a></li> 
  <li><a href=""#remove"">Removing Elements</a></li> 
  <li><a href=""#generics"">Generic Sets</a></li> 
  <li><a href=""#javadoc"">More Details in the JavaDoc</a></li> 
 </ul> 
</div>","Collection","java.util.Collection","class",0
,"Java's 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Java Set Example","<h2>Java 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt>Example</h2> 
<p> Here is first a simple Java <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> example to give you a feel for how sets work: </p> 
<pre class=""codeBox"">
Set setA = new HashSet();
String element = &quot;element 1&quot;;
setA.add(element);
System.out.println( set.contains(element) );
</pre> 
<p> This example creates a <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> which is one of the classes in the Java APIs that implement the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> interface. Then it adds a string object to the set, and finally it checks if the set contains the element just added. </p>","Set","java.util.Set","class",1
,"Java's 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Java Set Example","<h2>Java 
 <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
   Set 
 </clt>Example</h2> 
<p> Here is first a simple Java <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> example to give you a feel for how sets work: </p> 
<pre class=""codeBox"">
Set setA = new HashSet();
String element = &quot;element 1&quot;;
setA.add(element);
System.out.println( set.contains(element) );
</pre> 
<p> This example creates a <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> which is one of the classes in the Java APIs that implement the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> interface. Then it adds a string object to the set, and finally it checks if the set contains the element just added. </p>","HashSet","java.util.HashSet","class",0
,"Java's 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Set Implementations","<h2>Set Implementations</h2> 
<p> Being a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> subtype all methods in the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface are also available in the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> interface. </p> 
<p> Since <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> is an interface you need to instantiate a concrete implementation of the interface in order to use it. You can choose between the following <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations in the Java Collections API: </p> 
<ul> 
 <li>java.util.EnumSet</li> 
 <li>java.util.HashSet</li> 
 <li>java.util.LinkedHashSet</li> 
 <li>java.util.TreeSet</li> 
</ul> 
<p> Each of these <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations behaves a little differently with respect to the order of the elements when iterating the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, and the time (big O notation) it takes to insert and access elements in the sets. </p> 
<p> <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> is backed by a <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code>. It makes no guarantees about the sequence of the elements when you iterate them. </p> 
<p> <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> differs from <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> by guaranteeing that the order of the elements during iteration is the same as the order they were inserted into the <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>. Reinserting an element that is already in the <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> does not change this order. </p>","Collection","java.util.Collection","class",0
,"Java's 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Set Implementations","<h2>Set Implementations</h2> 
<p> Being a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> subtype all methods in the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface are also available in the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> interface. </p> 
<p> Since <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> is an interface you need to instantiate a concrete implementation of the interface in order to use it. You can choose between the following <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations in the Java Collections API: </p> 
<ul> 
 <li>java.util.EnumSet</li> 
 <li>java.util.HashSet</li> 
 <li>java.util.LinkedHashSet</li> 
 <li>java.util.TreeSet</li> 
</ul> 
<p> Each of these <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations behaves a little differently with respect to the order of the elements when iterating the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, and the time (big O notation) it takes to insert and access elements in the sets. </p> 
<p> <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> is backed by a <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code>. It makes no guarantees about the sequence of the elements when you iterate them. </p> 
<p> <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> differs from <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> by guaranteeing that the order of the elements during iteration is the same as the order they were inserted into the <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>. Reinserting an element that is already in the <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> does not change this order. </p>","Set","java.util.Set","class",1
,"Java's 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Set Implementations","<h2>Set Implementations</h2> 
<p> Being a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> subtype all methods in the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface are also available in the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> interface. </p> 
<p> Since <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> is an interface you need to instantiate a concrete implementation of the interface in order to use it. You can choose between the following <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations in the Java Collections API: </p> 
<ul> 
 <li>java.util.EnumSet</li> 
 <li>java.util.HashSet</li> 
 <li>java.util.LinkedHashSet</li> 
 <li>java.util.TreeSet</li> 
</ul> 
<p> Each of these <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations behaves a little differently with respect to the order of the elements when iterating the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, and the time (big O notation) it takes to insert and access elements in the sets. </p> 
<p> <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> is backed by a <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code>. It makes no guarantees about the sequence of the elements when you iterate them. </p> 
<p> <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> differs from <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> by guaranteeing that the order of the elements during iteration is the same as the order they were inserted into the <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>. Reinserting an element that is already in the <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> does not change this order. </p>","HashSet","java.util.HashSet","class",1
,"Java's 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Set Implementations","<h2>Set Implementations</h2> 
<p> Being a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> subtype all methods in the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface are also available in the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> interface. </p> 
<p> Since <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> is an interface you need to instantiate a concrete implementation of the interface in order to use it. You can choose between the following <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations in the Java Collections API: </p> 
<ul> 
 <li>java.util.EnumSet</li> 
 <li>java.util.HashSet</li> 
 <li>java.util.LinkedHashSet</li> 
 <li>java.util.TreeSet</li> 
</ul> 
<p> Each of these <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations behaves a little differently with respect to the order of the elements when iterating the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, and the time (big O notation) it takes to insert and access elements in the sets. </p> 
<p> <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> is backed by a <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code>. It makes no guarantees about the sequence of the elements when you iterate them. </p> 
<p> <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> differs from <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> by guaranteeing that the order of the elements during iteration is the same as the order they were inserted into the <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>. Reinserting an element that is already in the <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> does not change this order. </p>","HashMap","java.util.HashMap","class",0
,"Java's 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Set Implementations","<h2>Set Implementations</h2> 
<p> Being a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> subtype all methods in the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface are also available in the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> interface. </p> 
<p> Since <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> is an interface you need to instantiate a concrete implementation of the interface in order to use it. You can choose between the following <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations in the Java Collections API: </p> 
<ul> 
 <li>java.util.EnumSet</li> 
 <li>java.util.HashSet</li> 
 <li>java.util.LinkedHashSet</li> 
 <li>java.util.TreeSet</li> 
</ul> 
<p> Each of these <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations behaves a little differently with respect to the order of the elements when iterating the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, and the time (big O notation) it takes to insert and access elements in the sets. </p> 
<p> <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> is backed by a <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code>. It makes no guarantees about the sequence of the elements when you iterate them. </p> 
<p> <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> differs from <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code> by guaranteeing that the order of the elements during iteration is the same as the order they were inserted into the <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code>. Reinserting an element that is already in the <code> 
  <clt fqn=""java.util.LinkedHashSet"" api=""LinkedHashSet"" kind=""class"">
    LinkedHashSet 
  </clt></code> does not change this order. </p>","LinkedHashSet","java.util.LinkedHashSet","class",1
,"Java's 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Set Implementations - part 2","<h3>Set Implementations - part 2</h3> 
<p> <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> also guarantees the order of the elements when iterated, but the order is the sorting order of the elements. In other words, the order in which the elements whould be sorted if you used a <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
    Collections.sort() 
  </clt></code> on a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> or array containing these elements. This order is determined either by their natural order (if they implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>), or by a specific <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> implementation. </p> 
<p> There are also <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations in the <code>java.util.concurrent</code> package, but I will leave the concurrency utilities out of this tutorial. </p> 
<p> Here are a few examples of how to create a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> instance: </p> 
<pre class=""codeBox"">
Set setA = new EnumSet();
Set setB = new HashSet();
Set setC = new LinkedHashSet();
Set setD = new TreeSet();
</pre>","TreeSet","java.util.TreeSet","class",1
,"Java's 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Set Implementations - part 2","<h3>Set Implementations - part 2</h3> 
<p> <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> also guarantees the order of the elements when iterated, but the order is the sorting order of the elements. In other words, the order in which the elements whould be sorted if you used a <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
    Collections.sort() 
  </clt></code> on a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> or array containing these elements. This order is determined either by their natural order (if they implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>), or by a specific <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> implementation. </p> 
<p> There are also <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations in the <code>java.util.concurrent</code> package, but I will leave the concurrency utilities out of this tutorial. </p> 
<p> Here are a few examples of how to create a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> instance: </p> 
<pre class=""codeBox"">
Set setA = new EnumSet();
Set setB = new HashSet();
Set setC = new LinkedHashSet();
Set setD = new TreeSet();
</pre>","Collections","java.util.Collections","class",0
,"Java's 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Set Implementations - part 2","<h3>Set Implementations - part 2</h3> 
<p> <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> also guarantees the order of the elements when iterated, but the order is the sorting order of the elements. In other words, the order in which the elements whould be sorted if you used a <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
    Collections.sort() 
  </clt></code> on a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> or array containing these elements. This order is determined either by their natural order (if they implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>), or by a specific <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> implementation. </p> 
<p> There are also <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations in the <code>java.util.concurrent</code> package, but I will leave the concurrency utilities out of this tutorial. </p> 
<p> Here are a few examples of how to create a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> instance: </p> 
<pre class=""codeBox"">
Set setA = new EnumSet();
Set setB = new HashSet();
Set setC = new LinkedHashSet();
Set setD = new TreeSet();
</pre>","List","java.util.List","class",0
,"Java's 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Set Implementations - part 2","<h3>Set Implementations - part 2</h3> 
<p> <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> also guarantees the order of the elements when iterated, but the order is the sorting order of the elements. In other words, the order in which the elements whould be sorted if you used a <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
    Collections.sort() 
  </clt></code> on a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> or array containing these elements. This order is determined either by their natural order (if they implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>), or by a specific <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> implementation. </p> 
<p> There are also <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations in the <code>java.util.concurrent</code> package, but I will leave the concurrency utilities out of this tutorial. </p> 
<p> Here are a few examples of how to create a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> instance: </p> 
<pre class=""codeBox"">
Set setA = new EnumSet();
Set setB = new HashSet();
Set setC = new LinkedHashSet();
Set setD = new TreeSet();
</pre>","Comparable","java.lang.Comparable","class",0
,"Java's 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Set Implementations - part 2","<h3>Set Implementations - part 2</h3> 
<p> <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> also guarantees the order of the elements when iterated, but the order is the sorting order of the elements. In other words, the order in which the elements whould be sorted if you used a <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
    Collections.sort() 
  </clt></code> on a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> or array containing these elements. This order is determined either by their natural order (if they implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>), or by a specific <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> implementation. </p> 
<p> There are also <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations in the <code>java.util.concurrent</code> package, but I will leave the concurrency utilities out of this tutorial. </p> 
<p> Here are a few examples of how to create a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> instance: </p> 
<pre class=""codeBox"">
Set setA = new EnumSet();
Set setB = new HashSet();
Set setC = new LinkedHashSet();
Set setD = new TreeSet();
</pre>","Comparator","java.util.Comparator","class",0
,"Java's 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Set Implementations - part 2","<h3>Set Implementations - part 2</h3> 
<p> <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> also guarantees the order of the elements when iterated, but the order is the sorting order of the elements. In other words, the order in which the elements whould be sorted if you used a <code> 
  <clt fqn=""java.util.Collections.sort"" api=""Collections"" kind=""method"">
    Collections.sort() 
  </clt></code> on a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> or array containing these elements. This order is determined either by their natural order (if they implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>), or by a specific <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> implementation. </p> 
<p> There are also <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementations in the <code>java.util.concurrent</code> package, but I will leave the concurrency utilities out of this tutorial. </p> 
<p> Here are a few examples of how to create a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> instance: </p> 
<pre class=""codeBox"">
Set setA = new EnumSet();
Set setB = new HashSet();
Set setC = new LinkedHashSet();
Set setD = new TreeSet();
</pre>","Set","java.util.Set","class",0
,"Java's 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Adding and Accessing Elements","<h2>Adding and Accessing Elements</h2> 
<p> To add elements to a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> you call its <code> 
  <clt fqn=""java.util.Set.add"" api=""Set"" kind=""method"">
    Set.add() 
  </clt></code> method. This method is inherited from the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface. Here are a few examples: </p> 
<pre class=""codeBox"">
Set setA = new HashSet();
setA.add(&quot;element 1&quot;);
setA.add(&quot;element 2&quot;);
setA.add(&quot;element 3&quot;);
</pre> 
<p> The three <code> 
  <clt fqn=""java.util.Set.add"" api=""Set"" kind=""method"">
    Set.add() 
  </clt></code> calls add a <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> instance to the set. </p> 
<p> When iterating the elements in the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> the order of the elements depends on what <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation you use, as mentioned earlier. Here is an iteration example: </p> 
<pre class=""codeBox"">
Set setA = new HashSet();
setA.add(&quot;element 0&quot;);
setA.add(&quot;element 1&quot;);
setA.add(&quot;element 2&quot;);
//access via Iterator
Iterator iterator = setA.iterator();
while(iterator.hasNext(){
String element = (String) iterator.next();
}
//access via new for-loop
for(Object object : setA) {
String element = (String) object;
}
</pre>","Set","java.util.Set","class",1
,"Java's 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Adding and Accessing Elements","<h2>Adding and Accessing Elements</h2> 
<p> To add elements to a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> you call its <code> 
  <clt fqn=""java.util.Set.add"" api=""Set"" kind=""method"">
    Set.add() 
  </clt></code> method. This method is inherited from the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface. Here are a few examples: </p> 
<pre class=""codeBox"">
Set setA = new HashSet();
setA.add(&quot;element 1&quot;);
setA.add(&quot;element 2&quot;);
setA.add(&quot;element 3&quot;);
</pre> 
<p> The three <code> 
  <clt fqn=""java.util.Set.add"" api=""Set"" kind=""method"">
    Set.add() 
  </clt></code> calls add a <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> instance to the set. </p> 
<p> When iterating the elements in the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> the order of the elements depends on what <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation you use, as mentioned earlier. Here is an iteration example: </p> 
<pre class=""codeBox"">
Set setA = new HashSet();
setA.add(&quot;element 0&quot;);
setA.add(&quot;element 1&quot;);
setA.add(&quot;element 2&quot;);
//access via Iterator
Iterator iterator = setA.iterator();
while(iterator.hasNext(){
String element = (String) iterator.next();
}
//access via new for-loop
for(Object object : setA) {
String element = (String) object;
}
</pre>","Collection","java.util.Collection","class",0
,"Java's 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Adding and Accessing Elements","<h2>Adding and Accessing Elements</h2> 
<p> To add elements to a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> you call its <code> 
  <clt fqn=""java.util.Set.add"" api=""Set"" kind=""method"">
    Set.add() 
  </clt></code> method. This method is inherited from the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface. Here are a few examples: </p> 
<pre class=""codeBox"">
Set setA = new HashSet();
setA.add(&quot;element 1&quot;);
setA.add(&quot;element 2&quot;);
setA.add(&quot;element 3&quot;);
</pre> 
<p> The three <code> 
  <clt fqn=""java.util.Set.add"" api=""Set"" kind=""method"">
    Set.add() 
  </clt></code> calls add a <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> instance to the set. </p> 
<p> When iterating the elements in the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> the order of the elements depends on what <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation you use, as mentioned earlier. Here is an iteration example: </p> 
<pre class=""codeBox"">
Set setA = new HashSet();
setA.add(&quot;element 0&quot;);
setA.add(&quot;element 1&quot;);
setA.add(&quot;element 2&quot;);
//access via Iterator
Iterator iterator = setA.iterator();
while(iterator.hasNext(){
String element = (String) iterator.next();
}
//access via new for-loop
for(Object object : setA) {
String element = (String) object;
}
</pre>","String","java.lang.String","class",0
,"Java's 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Removing Elements","<h2>Removing Elements</h2> 
<p> You remove elements by calling the <code> 
  <clt fqn=""java.util.Set.remove"" api=""Set"" kind=""method"">
    Set.remove(Object o) 
  </clt></code> method. There is no way to remove an object based on index in a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, since the order of the elements depends on the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> implementation. </p>","Set","java.util.Set","class",1
,"Java's 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Generic Sets","<h2>Generic Sets</h2> 
<p> By default you can put any <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code> into a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, but from Java 5, Java Generics makes it possible to limit the types of object you can insert into a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. Here is an example: </p> 
<pre class=""codeBox"">
Set&lt;MyObject&gt; set = new HashSet&lt;MyObject&gt;();
</pre> 
<p> This <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> can now only have <code>MyObject</code> instances inserted into it. You can then access and iterate its elements without casting them. Here is how it looks: </p> 
<pre class=""codeBox"">
for(MyObject anObject : set){
//do someting to anObject...
}
</pre> 
<p> For more information about Java Generics, see the <a href=""/java-generics/index.html"">Java Generics Tutorial</a>. </p>","Object","java.lang.Object","class",0
,"Java's 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","Generic Sets","<h2>Generic Sets</h2> 
<p> By default you can put any <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code> into a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, but from Java 5, Java Generics makes it possible to limit the types of object you can insert into a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>. Here is an example: </p> 
<pre class=""codeBox"">
Set&lt;MyObject&gt; set = new HashSet&lt;MyObject&gt;();
</pre> 
<p> This <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> can now only have <code>MyObject</code> instances inserted into it. You can then access and iterate its elements without casting them. Here is how it looks: </p> 
<pre class=""codeBox"">
for(MyObject anObject : set){
//do someting to anObject...
}
</pre> 
<p> For more information about Java Generics, see the <a href=""/java-generics/index.html"">Java Generics Tutorial</a>. </p>","Set","java.util.Set","class",0
,"Java's 
<clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
  Set 
</clt>Interface","More Details in the JavaDoc","<h2>More Details in the JavaDoc</h2> 
<p> There is a lot more you can do with a <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code>, but you will have to check out the JavaDoc for more details. This text focused on the two most common operations: Adding / removing elements, and iterating the elements. </p>","Set","java.util.Set","class",0
,"Java's 
<clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
  Queue 
</clt>Interface","Java's Queue Interface","<h1>Java's 
 <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    java.util.Queue 
  </clt></code> interface is a subtype of the <a href=""collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     java.util.Collection 
   </clt></code></a> interface. It represents an ordered list of objects just like a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>, but its intended use is slightly different. A queue is designed to have elements inserted at the end of the queue, and elements removed from the beginning of the queue. Just like a queue in a supermarket. </p> 
<p> Here is a list of the topics covered in this text: </p> 
<ol> 
 <li><a href=""#implementations"">Queue Implementations</a></li> 
 <li><a href=""#add"">Adding and Accessing Elements</a></li> 
 <li><a href=""#remove"">Removing Elements</a></li> 
 <li><a href=""#generics"">Generic Queues</a></li> 
 <li><a href=""#javadoc"">More Details in the JavaDoc</a></li> 
</ol>","Queue","java.util.Queue","class",0
,"Java's 
<clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
  Queue 
</clt>Interface","Java's Queue Interface","<h1>Java's 
 <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    java.util.Queue 
  </clt></code> interface is a subtype of the <a href=""collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     java.util.Collection 
   </clt></code></a> interface. It represents an ordered list of objects just like a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>, but its intended use is slightly different. A queue is designed to have elements inserted at the end of the queue, and elements removed from the beginning of the queue. Just like a queue in a supermarket. </p> 
<p> Here is a list of the topics covered in this text: </p> 
<ol> 
 <li><a href=""#implementations"">Queue Implementations</a></li> 
 <li><a href=""#add"">Adding and Accessing Elements</a></li> 
 <li><a href=""#remove"">Removing Elements</a></li> 
 <li><a href=""#generics"">Generic Queues</a></li> 
 <li><a href=""#javadoc"">More Details in the JavaDoc</a></li> 
</ol>","Collection","java.util.Collection","class",0
,"Java's 
<clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
  Queue 
</clt>Interface","Java's Queue Interface","<h1>Java's 
 <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
   Queue 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    java.util.Queue 
  </clt></code> interface is a subtype of the <a href=""collection.html""><code> 
   <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
     java.util.Collection 
   </clt></code></a> interface. It represents an ordered list of objects just like a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>, but its intended use is slightly different. A queue is designed to have elements inserted at the end of the queue, and elements removed from the beginning of the queue. Just like a queue in a supermarket. </p> 
<p> Here is a list of the topics covered in this text: </p> 
<ol> 
 <li><a href=""#implementations"">Queue Implementations</a></li> 
 <li><a href=""#add"">Adding and Accessing Elements</a></li> 
 <li><a href=""#remove"">Removing Elements</a></li> 
 <li><a href=""#generics"">Generic Queues</a></li> 
 <li><a href=""#javadoc"">More Details in the JavaDoc</a></li> 
</ol>","List","java.util.List","class",0
,"Java's 
<clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
  Queue 
</clt>Interface","Queue Implementations","<h2>Queue Implementations</h2> 
<p> Being a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> subtype all methods in the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface are also available in the <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> interface. </p> 
<p> Since <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> is an interface you need to instantiate a concrete implementation of the interface in order to use it. You can choose between the following <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> implementations in the Java Collections API: </p> 
<ul> 
 <li>java.util.LinkedList</li> 
 <li>java.util.PriorityQueue</li> 
</ul> 
<p> <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> is a pretty standard queue implementation. </p> 
<p> <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> stores its elements internally according to their natural order (if they implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>), or according to a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> passed to the <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code>. </p> 
<p> There are also <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> implementations in the <code>java.util.concurrent</code> package, but I will leave the concurrency utilities out of this tutorial. </p> 
<p> Here are a few examples of how to create a <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> instance: </p> 
<pre class=""codeBox"">
Queue queueA = new LinkedList();
Queue queueB = new PriorityQueue();
</pre>","Collection","java.util.Collection","class",0
,"Java's 
<clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
  Queue 
</clt>Interface","Queue Implementations","<h2>Queue Implementations</h2> 
<p> Being a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> subtype all methods in the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface are also available in the <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> interface. </p> 
<p> Since <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> is an interface you need to instantiate a concrete implementation of the interface in order to use it. You can choose between the following <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> implementations in the Java Collections API: </p> 
<ul> 
 <li>java.util.LinkedList</li> 
 <li>java.util.PriorityQueue</li> 
</ul> 
<p> <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> is a pretty standard queue implementation. </p> 
<p> <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> stores its elements internally according to their natural order (if they implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>), or according to a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> passed to the <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code>. </p> 
<p> There are also <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> implementations in the <code>java.util.concurrent</code> package, but I will leave the concurrency utilities out of this tutorial. </p> 
<p> Here are a few examples of how to create a <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> instance: </p> 
<pre class=""codeBox"">
Queue queueA = new LinkedList();
Queue queueB = new PriorityQueue();
</pre>","Queue","java.util.Queue","class",1
,"Java's 
<clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
  Queue 
</clt>Interface","Queue Implementations","<h2>Queue Implementations</h2> 
<p> Being a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> subtype all methods in the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface are also available in the <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> interface. </p> 
<p> Since <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> is an interface you need to instantiate a concrete implementation of the interface in order to use it. You can choose between the following <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> implementations in the Java Collections API: </p> 
<ul> 
 <li>java.util.LinkedList</li> 
 <li>java.util.PriorityQueue</li> 
</ul> 
<p> <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> is a pretty standard queue implementation. </p> 
<p> <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> stores its elements internally according to their natural order (if they implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>), or according to a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> passed to the <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code>. </p> 
<p> There are also <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> implementations in the <code>java.util.concurrent</code> package, but I will leave the concurrency utilities out of this tutorial. </p> 
<p> Here are a few examples of how to create a <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> instance: </p> 
<pre class=""codeBox"">
Queue queueA = new LinkedList();
Queue queueB = new PriorityQueue();
</pre>","LinkedList","java.util.LinkedList","class",0
,"Java's 
<clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
  Queue 
</clt>Interface","Queue Implementations","<h2>Queue Implementations</h2> 
<p> Being a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> subtype all methods in the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface are also available in the <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> interface. </p> 
<p> Since <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> is an interface you need to instantiate a concrete implementation of the interface in order to use it. You can choose between the following <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> implementations in the Java Collections API: </p> 
<ul> 
 <li>java.util.LinkedList</li> 
 <li>java.util.PriorityQueue</li> 
</ul> 
<p> <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> is a pretty standard queue implementation. </p> 
<p> <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> stores its elements internally according to their natural order (if they implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>), or according to a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> passed to the <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code>. </p> 
<p> There are also <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> implementations in the <code>java.util.concurrent</code> package, but I will leave the concurrency utilities out of this tutorial. </p> 
<p> Here are a few examples of how to create a <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> instance: </p> 
<pre class=""codeBox"">
Queue queueA = new LinkedList();
Queue queueB = new PriorityQueue();
</pre>","PriorityQueue","java.util.PriorityQueue","class",1
,"Java's 
<clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
  Queue 
</clt>Interface","Queue Implementations","<h2>Queue Implementations</h2> 
<p> Being a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> subtype all methods in the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface are also available in the <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> interface. </p> 
<p> Since <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> is an interface you need to instantiate a concrete implementation of the interface in order to use it. You can choose between the following <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> implementations in the Java Collections API: </p> 
<ul> 
 <li>java.util.LinkedList</li> 
 <li>java.util.PriorityQueue</li> 
</ul> 
<p> <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> is a pretty standard queue implementation. </p> 
<p> <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> stores its elements internally according to their natural order (if they implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>), or according to a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> passed to the <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code>. </p> 
<p> There are also <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> implementations in the <code>java.util.concurrent</code> package, but I will leave the concurrency utilities out of this tutorial. </p> 
<p> Here are a few examples of how to create a <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> instance: </p> 
<pre class=""codeBox"">
Queue queueA = new LinkedList();
Queue queueB = new PriorityQueue();
</pre>","Comparable","java.lang.Comparable","class",0
,"Java's 
<clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
  Queue 
</clt>Interface","Queue Implementations","<h2>Queue Implementations</h2> 
<p> Being a <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> subtype all methods in the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface are also available in the <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> interface. </p> 
<p> Since <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> is an interface you need to instantiate a concrete implementation of the interface in order to use it. You can choose between the following <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> implementations in the Java Collections API: </p> 
<ul> 
 <li>java.util.LinkedList</li> 
 <li>java.util.PriorityQueue</li> 
</ul> 
<p> <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> is a pretty standard queue implementation. </p> 
<p> <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code> stores its elements internally according to their natural order (if they implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    Comparable 
  </clt></code>), or according to a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> passed to the <code> 
  <clt fqn=""java.util.PriorityQueue"" api=""PriorityQueue"" kind=""class"">
    PriorityQueue 
  </clt></code>. </p> 
<p> There are also <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> implementations in the <code>java.util.concurrent</code> package, but I will leave the concurrency utilities out of this tutorial. </p> 
<p> Here are a few examples of how to create a <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> instance: </p> 
<pre class=""codeBox"">
Queue queueA = new LinkedList();
Queue queueB = new PriorityQueue();
</pre>","Comparator","java.util.Comparator","class",0
,"Java's 
<clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
  Queue 
</clt>Interface","Adding and Accessing Elements","<h2>Adding and Accessing Elements</h2> 
<p> To add elements to a <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> you call its <code> 
  <clt fqn=""java.util.Queue.add"" api=""Queue"" kind=""method"">
    Queue.add() 
  </clt></code> method. This method is inherited from the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface. Here are a few examples: </p> 
<pre class=""codeBox"">
Queue queueA = new LinkedList();
queueA.add(&quot;element 1&quot;);
queueA.add(&quot;element 2&quot;);
queueA.add(&quot;element 3&quot;);
</pre> 
<p> The order in which the elements added to the <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> are stored internally, depends on the implementation. The same is true for the order in which elements are retrieved from the queue. You should consult the JavaDoc's for more information about the specific <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> implementations. </p> 
<p> You can peek at the element at the head of the queue without taking the element out of the queue. This is done via the <code> 
  <clt fqn=""java.util.Queue.element"" api=""Queue"" kind=""method"">
    Queue.element() 
  </clt></code> method. Here is how that looks: </p> 
<pre class=""codeBox"">
Object firstElement = queueA.element();
</pre> 
<p> To take the first element out of the queue, you use the <code> 
  <clt fqn=""java.util.Queue.remove"" api=""Queue"" kind=""method"">
    Queue.remove() 
  </clt></code> method which is described later. </p> 
<p> You can also iterate all elements of a queue, instead of just processing one at a time. Here is how that looks: </p> 
<pre class=""codeBox"">
Queue queueA = new LinkedList();
queueA.add(&quot;element 0&quot;);
queueA.add(&quot;element 1&quot;);
queueA.add(&quot;element 2&quot;);
//access via Iterator
Iterator iterator = queueA.iterator();
while(iterator.hasNext(){
String element = (String) iterator.next();
}
//access via new for-loop
for(Object object : queueA) {
String element = (String) object;
}
</pre> 
<p> When iterating the queue via its <code> 
  <clt fqn=""java.util.Iterator"" api=""Iterator"" kind=""class"">
    Iterator 
  </clt></code> or via the for-loop (which also uses the Iterator behind the scene, the sequence in which the elements are iterated depends on the queue implementation. </p>","Queue","java.util.Queue","class",1
,"Java's 
<clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
  Queue 
</clt>Interface","Adding and Accessing Elements","<h2>Adding and Accessing Elements</h2> 
<p> To add elements to a <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> you call its <code> 
  <clt fqn=""java.util.Queue.add"" api=""Queue"" kind=""method"">
    Queue.add() 
  </clt></code> method. This method is inherited from the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface. Here are a few examples: </p> 
<pre class=""codeBox"">
Queue queueA = new LinkedList();
queueA.add(&quot;element 1&quot;);
queueA.add(&quot;element 2&quot;);
queueA.add(&quot;element 3&quot;);
</pre> 
<p> The order in which the elements added to the <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> are stored internally, depends on the implementation. The same is true for the order in which elements are retrieved from the queue. You should consult the JavaDoc's for more information about the specific <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> implementations. </p> 
<p> You can peek at the element at the head of the queue without taking the element out of the queue. This is done via the <code> 
  <clt fqn=""java.util.Queue.element"" api=""Queue"" kind=""method"">
    Queue.element() 
  </clt></code> method. Here is how that looks: </p> 
<pre class=""codeBox"">
Object firstElement = queueA.element();
</pre> 
<p> To take the first element out of the queue, you use the <code> 
  <clt fqn=""java.util.Queue.remove"" api=""Queue"" kind=""method"">
    Queue.remove() 
  </clt></code> method which is described later. </p> 
<p> You can also iterate all elements of a queue, instead of just processing one at a time. Here is how that looks: </p> 
<pre class=""codeBox"">
Queue queueA = new LinkedList();
queueA.add(&quot;element 0&quot;);
queueA.add(&quot;element 1&quot;);
queueA.add(&quot;element 2&quot;);
//access via Iterator
Iterator iterator = queueA.iterator();
while(iterator.hasNext(){
String element = (String) iterator.next();
}
//access via new for-loop
for(Object object : queueA) {
String element = (String) object;
}
</pre> 
<p> When iterating the queue via its <code> 
  <clt fqn=""java.util.Iterator"" api=""Iterator"" kind=""class"">
    Iterator 
  </clt></code> or via the for-loop (which also uses the Iterator behind the scene, the sequence in which the elements are iterated depends on the queue implementation. </p>","Collection","java.util.Collection","class",0
,"Java's 
<clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
  Queue 
</clt>Interface","Adding and Accessing Elements","<h2>Adding and Accessing Elements</h2> 
<p> To add elements to a <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> you call its <code> 
  <clt fqn=""java.util.Queue.add"" api=""Queue"" kind=""method"">
    Queue.add() 
  </clt></code> method. This method is inherited from the <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interface. Here are a few examples: </p> 
<pre class=""codeBox"">
Queue queueA = new LinkedList();
queueA.add(&quot;element 1&quot;);
queueA.add(&quot;element 2&quot;);
queueA.add(&quot;element 3&quot;);
</pre> 
<p> The order in which the elements added to the <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> are stored internally, depends on the implementation. The same is true for the order in which elements are retrieved from the queue. You should consult the JavaDoc's for more information about the specific <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> implementations. </p> 
<p> You can peek at the element at the head of the queue without taking the element out of the queue. This is done via the <code> 
  <clt fqn=""java.util.Queue.element"" api=""Queue"" kind=""method"">
    Queue.element() 
  </clt></code> method. Here is how that looks: </p> 
<pre class=""codeBox"">
Object firstElement = queueA.element();
</pre> 
<p> To take the first element out of the queue, you use the <code> 
  <clt fqn=""java.util.Queue.remove"" api=""Queue"" kind=""method"">
    Queue.remove() 
  </clt></code> method which is described later. </p> 
<p> You can also iterate all elements of a queue, instead of just processing one at a time. Here is how that looks: </p> 
<pre class=""codeBox"">
Queue queueA = new LinkedList();
queueA.add(&quot;element 0&quot;);
queueA.add(&quot;element 1&quot;);
queueA.add(&quot;element 2&quot;);
//access via Iterator
Iterator iterator = queueA.iterator();
while(iterator.hasNext(){
String element = (String) iterator.next();
}
//access via new for-loop
for(Object object : queueA) {
String element = (String) object;
}
</pre> 
<p> When iterating the queue via its <code> 
  <clt fqn=""java.util.Iterator"" api=""Iterator"" kind=""class"">
    Iterator 
  </clt></code> or via the for-loop (which also uses the Iterator behind the scene, the sequence in which the elements are iterated depends on the queue implementation. </p>","Iterator","java.util.Iterator","class",0
,"Java's 
<clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
  Queue 
</clt>Interface","Removing Elements","<h2>Removing Elements</h2> 
<p> To remove elements from a queue, you call the <code> 
  <clt fqn=""java.util.Queue.remove"" api=""Queue"" kind=""method"">
    Queue.remove() 
  </clt></code> method. This method removes the element at the head of the queue. In most <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> implementations the head and tail of the queue are at opposite ends. It is possible, however, to implement the <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> interface so that the head and tail of the queue is in the same end. In that case you would have a stack. </p> 
<p> Here is a remove example(); </p> 
<pre class=""codeBox"">
Object firstElement = queueA.remove();
</pre>","Queue","java.util.Queue","class",1
,"Java's 
<clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
  Queue 
</clt>Interface","Generic Queue","<h2>Generic Queue</h2> 
<p> By default you can put any <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code> into a <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code>, but from Java 5, Java Generics makes it possible to limit the types of object you can insert into a <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code>. Here is an example: </p> 
<pre class=""codeBox"">
Queue&lt;MyObject&gt; queue = new LinkedList&lt;MyObject&gt;();
</pre> 
<p> This <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> can now only have <code>MyObject</code> instances inserted into it. You can then access and iterate its elements without casting them. Here is how it looks: </p> 
<pre class=""codeBox"">
MyObject myObject = queue.remove();
for(MyObject anObject : queue){
//do someting to anObject...   
}
</pre> 
<p> For more information about Java Generics, see the <a href=""/java-generics/index.html"">Java Generics Tutorial</a>. </p>","Object","java.lang.Object","class",0
,"Java's 
<clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
  Queue 
</clt>Interface","Generic Queue","<h2>Generic Queue</h2> 
<p> By default you can put any <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code> into a <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code>, but from Java 5, Java Generics makes it possible to limit the types of object you can insert into a <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code>. Here is an example: </p> 
<pre class=""codeBox"">
Queue&lt;MyObject&gt; queue = new LinkedList&lt;MyObject&gt;();
</pre> 
<p> This <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> can now only have <code>MyObject</code> instances inserted into it. You can then access and iterate its elements without casting them. Here is how it looks: </p> 
<pre class=""codeBox"">
MyObject myObject = queue.remove();
for(MyObject anObject : queue){
//do someting to anObject...   
}
</pre> 
<p> For more information about Java Generics, see the <a href=""/java-generics/index.html"">Java Generics Tutorial</a>. </p>","Queue","java.util.Queue","class",0
,"Java's 
<clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
  Queue 
</clt>Interface","More Details in the JavaDoc","<h2>More Details in the JavaDoc</h2> 
<p> There is a lot more you can do with a <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code>, but you will have to check out the JavaDoc for more details. This text focused on the two most common operations: Adding / removing elements, and iterating the elements. </p>","Queue","java.util.Queue","class",0
,"Implementing hashCode() and equals()","equals()","<h2>equals()</h2> 
<p> <code>equals()</code> is used in most collections to determine if a collection contains a given element. For instance: </p> 
<pre class=""codeBox"">
List list = new ArrayList();
list.add(&quot;123&quot;);
<b>boolean contains123 = list.contains(&quot;123&quot;);</b>
</pre> 
<p> The <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> iterates all its elements and execute <code>&quot;123&quot;.equals(element)</code> to determine if the element is equal to the parameter object &quot;123&quot;. It is the <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String.equals() 
  </clt></code> implementation that determines if two strings are equal. </p> 
<p> The <code>equals()</code> method is also used when removing elements. For instance: </p> 
<pre class=""codeBox"">
List list = new ArrayList();
list.add(&quot;123&quot;);
<b>boolean removed = list.remove(&quot;123&quot;);</b>
</pre> 
<p> The <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> again iterates all its elements and execute <code>&quot;123&quot;.equals(element)</code> to determine if the element is equal to the parameter object &quot;123&quot;. The first element it finds that is equal to the given parameter &quot;123&quot; is removed. </p> 
<p> As you can see, a proper implementation of <code>.equals()</code> is essential for your own classes to work well with the Java Collection classes. So how do you implement <code>equals()</code> &quot;properly&quot;? </p>","ArrayList","java.util.ArrayList","class",0
,"Implementing hashCode() and equals()","equals()","<h2>equals()</h2> 
<p> <code>equals()</code> is used in most collections to determine if a collection contains a given element. For instance: </p> 
<pre class=""codeBox"">
List list = new ArrayList();
list.add(&quot;123&quot;);
<b>boolean contains123 = list.contains(&quot;123&quot;);</b>
</pre> 
<p> The <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> iterates all its elements and execute <code>&quot;123&quot;.equals(element)</code> to determine if the element is equal to the parameter object &quot;123&quot;. It is the <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String.equals() 
  </clt></code> implementation that determines if two strings are equal. </p> 
<p> The <code>equals()</code> method is also used when removing elements. For instance: </p> 
<pre class=""codeBox"">
List list = new ArrayList();
list.add(&quot;123&quot;);
<b>boolean removed = list.remove(&quot;123&quot;);</b>
</pre> 
<p> The <code> 
  <clt fqn=""java.util.ArrayList"" api=""ArrayList"" kind=""class"">
    ArrayList 
  </clt></code> again iterates all its elements and execute <code>&quot;123&quot;.equals(element)</code> to determine if the element is equal to the parameter object &quot;123&quot;. The first element it finds that is equal to the given parameter &quot;123&quot; is removed. </p> 
<p> As you can see, a proper implementation of <code>.equals()</code> is essential for your own classes to work well with the Java Collection classes. So how do you implement <code>equals()</code> &quot;properly&quot;? </p>","String","java.lang.String","class",0
,"Implementing hashCode() and equals()","hashCode()","<h2>hashCode()</h2> 
<p> The <code>hashCode()</code> method of objects is used when you insert them into a <code>HashTable</code>, <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> or <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>. If you do not know the theory of how a hashtable works internally, you can read about <a href=""http://en.wikipedia.org/wiki/Hashtable"" target=""_blank"">hastables on Wikipedia.org</a>. </p> 
<p> When inserting an object into a hastable you use a key. The hash code of this key is calculated, and used to determine where to <b>store</b> the object internally. When you need to lookup an object in a hashtable you also use a key. The hash code of this key is calculated and used to determine where to <b>search</b> for the object. </p> 
<p> The hash code only points to a certain &quot;area&quot; (or list, bucket etc) internally. Since different key objects could potentially have the same hash code, the hash code itself is no guarantee that the right key is found. The hashtable then iterates this area (all keys with the same hash code) and uses the key's <code>equals()</code> method to find the right key. Once the right key is found, the object stored for that key is returned. </p>","HashMap","java.util.HashMap","class",0
,"Implementing hashCode() and equals()","hashCode()","<h2>hashCode()</h2> 
<p> The <code>hashCode()</code> method of objects is used when you insert them into a <code>HashTable</code>, <code> 
  <clt fqn=""java.util.HashMap"" api=""HashMap"" kind=""class"">
    HashMap 
  </clt></code> or <code> 
  <clt fqn=""java.util.HashSet"" api=""HashSet"" kind=""class"">
    HashSet 
  </clt></code>. If you do not know the theory of how a hashtable works internally, you can read about <a href=""http://en.wikipedia.org/wiki/Hashtable"" target=""_blank"">hastables on Wikipedia.org</a>. </p> 
<p> When inserting an object into a hastable you use a key. The hash code of this key is calculated, and used to determine where to <b>store</b> the object internally. When you need to lookup an object in a hashtable you also use a key. The hash code of this key is calculated and used to determine where to <b>search</b> for the object. </p> 
<p> The hash code only points to a certain &quot;area&quot; (or list, bucket etc) internally. Since different key objects could potentially have the same hash code, the hash code itself is no guarantee that the right key is found. The hashtable then iterates this area (all keys with the same hash code) and uses the key's <code>equals()</code> method to find the right key. Once the right key is found, the object stored for that key is returned. </p>","HashSet","java.util.HashSet","class",0
,"Java 
<clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
  Collections 
</clt>Tutorial","Java Collections Tutorial","<h1>Java 
 <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
   Collections 
 </clt>Tutorial</h1> 
<p> The Java Collections API's provide Java developers with a set of classes and interfaces that makes it easier to handle collections of objects. In a sense Collection's works a bit like arrays, except their size can change dynamically, and they have more advanced behaviour than arrays. </p> 
<p> Rather than having to write your own collection classes, Java provides these ready-to-use collection classes for you. This tutorial will look closer at the Java Collection's, as they are also sometimes referred to, and more specifically the Java Collections available in Java 6. </p> 
<p> The purpose of this tutorial is to give you an overview of the Java Collection classes. Thus it will not describe each and every little detail of the Java Collection classes. But, once you have an overview of what is there, it is much easier to read the rest in the JavaDoc's afterwards. </p>","Collections","java.util.Collections","class",0
,"Java 
<clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
  Collections 
</clt>Tutorial","Java Collections and Generics","<h2>Java 
 <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
   Collections 
 </clt>and Generics</h2> 
<p> The fifth text in this Java Collections tutorial covers how to use Generics in Java Collections. Generics is very useful when working with Java's Collection classes. </p>","Collections","java.util.Collections","class",0
,"Java 
<clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
  Collections 
</clt>Tutorial","Java Collections and the equals() and hashCode() Methods","<h2>Java 
 <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
   Collections 
 </clt>and the equals() and hashCode() Methods</h2> 
<p> The last two texts in this Java Collections tutorial explains the central role the two <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    java.lang.Object 
  </clt></code> methods <code>equals()</code> and <code>hashCode()</code> play when using Java Collections. You should read this, if you plan to use Java Collections with your own classes, and thus need to implement <code>equals()</code> and <code>hashCode()</code>. </p>","Collections","java.util.Collections","class",0
,"Java 
<clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
  Collections 
</clt>Tutorial","Java Collections and the equals() and hashCode() Methods","<h2>Java 
 <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
   Collections 
 </clt>and the equals() and hashCode() Methods</h2> 
<p> The last two texts in this Java Collections tutorial explains the central role the two <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    java.lang.Object 
  </clt></code> methods <code>equals()</code> and <code>hashCode()</code> play when using Java Collections. You should read this, if you plan to use Java Collections with your own classes, and thus need to implement <code>equals()</code> and <code>hashCode()</code>. </p>","Object","java.lang.Object","class",0
,"Java's 
<clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
  Deque 
</clt>Interface","Java's Deque Interface","<h1>Java's 
 <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
   Deque 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    java.util.Deque 
  </clt></code> interface is a subtype of the <a href=""queue.html""><code> 
   <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
     java.util.Queue 
   </clt></code></a> interface. It represents a queue where you can insert and remove elements from both ends of the queue. Thus, &quot;Deque&quot; is short for &quot;Double Ended Queue&quot; and is pronounced &quot;deck&quot;, like a deck of cards. </p> 
<p> Here is a list of the topics covered in this text: </p> 
<ol> 
 <li><a href=""#implementations"">Deque Implementations</a></li> 
 <li><a href=""#add"">Adding and Accessing Elements</a></li> 
 <li><a href=""#remove"">Removing Elements</a></li> 
 <li><a href=""#generics"">Generic Deques</a></li> 
 <li><a href=""#javadoc"">More Details in the JavaDoc</a></li> 
</ol>","Deque","java.util.Deque","class",1
,"Java's 
<clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
  Deque 
</clt>Interface","Java's Deque Interface","<h1>Java's 
 <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
   Deque 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    java.util.Deque 
  </clt></code> interface is a subtype of the <a href=""queue.html""><code> 
   <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
     java.util.Queue 
   </clt></code></a> interface. It represents a queue where you can insert and remove elements from both ends of the queue. Thus, &quot;Deque&quot; is short for &quot;Double Ended Queue&quot; and is pronounced &quot;deck&quot;, like a deck of cards. </p> 
<p> Here is a list of the topics covered in this text: </p> 
<ol> 
 <li><a href=""#implementations"">Deque Implementations</a></li> 
 <li><a href=""#add"">Adding and Accessing Elements</a></li> 
 <li><a href=""#remove"">Removing Elements</a></li> 
 <li><a href=""#generics"">Generic Deques</a></li> 
 <li><a href=""#javadoc"">More Details in the JavaDoc</a></li> 
</ol>","Queue","java.util.Queue","class",0
,"Java's 
<clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
  Deque 
</clt>Interface","Deque Implementations","<h2>Deque Implementations</h2> 
<p> Being a <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> subtype all methods in the <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> and <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interfaces are also available in the <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> interface. </p> 
<p> Since <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> is an interface you need to instantiate a concrete implementation of the interface in order to use it. You can choose between the following <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> implementations in the Java Collections API: </p> 
<ul> 
 <li>java.util.ArrayDeque</li> 
 <li>java.util.LinkedList</li> 
</ul> 
<p> <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> is a pretty standard deque / queue implementation. </p> 
<p> <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> stores its elements internally in an array. If the number of elements exceeds the space in the array, a new array is allocated, and all elements moved over. In other words, the <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> grows as needed, even if it stores its elements in an array. </p> 
<p> There are also <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> implementations in the <code>java.util.concurrent</code> package, but I will leave the concurrency utilities out of this tutorial. </p> 
<p> Here are a few examples of how to create a <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> instance: </p> 
<pre class=""codeBox"">
Deque dequeA = new LinkedList();
Deque dequeB = new ArrayDeque();
</pre>","Queue","java.util.Queue","class",0
,"Java's 
<clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
  Deque 
</clt>Interface","Deque Implementations","<h2>Deque Implementations</h2> 
<p> Being a <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> subtype all methods in the <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> and <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interfaces are also available in the <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> interface. </p> 
<p> Since <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> is an interface you need to instantiate a concrete implementation of the interface in order to use it. You can choose between the following <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> implementations in the Java Collections API: </p> 
<ul> 
 <li>java.util.ArrayDeque</li> 
 <li>java.util.LinkedList</li> 
</ul> 
<p> <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> is a pretty standard deque / queue implementation. </p> 
<p> <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> stores its elements internally in an array. If the number of elements exceeds the space in the array, a new array is allocated, and all elements moved over. In other words, the <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> grows as needed, even if it stores its elements in an array. </p> 
<p> There are also <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> implementations in the <code>java.util.concurrent</code> package, but I will leave the concurrency utilities out of this tutorial. </p> 
<p> Here are a few examples of how to create a <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> instance: </p> 
<pre class=""codeBox"">
Deque dequeA = new LinkedList();
Deque dequeB = new ArrayDeque();
</pre>","Collection","java.util.Collection","class",0
,"Java's 
<clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
  Deque 
</clt>Interface","Deque Implementations","<h2>Deque Implementations</h2> 
<p> Being a <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> subtype all methods in the <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> and <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interfaces are also available in the <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> interface. </p> 
<p> Since <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> is an interface you need to instantiate a concrete implementation of the interface in order to use it. You can choose between the following <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> implementations in the Java Collections API: </p> 
<ul> 
 <li>java.util.ArrayDeque</li> 
 <li>java.util.LinkedList</li> 
</ul> 
<p> <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> is a pretty standard deque / queue implementation. </p> 
<p> <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> stores its elements internally in an array. If the number of elements exceeds the space in the array, a new array is allocated, and all elements moved over. In other words, the <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> grows as needed, even if it stores its elements in an array. </p> 
<p> There are also <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> implementations in the <code>java.util.concurrent</code> package, but I will leave the concurrency utilities out of this tutorial. </p> 
<p> Here are a few examples of how to create a <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> instance: </p> 
<pre class=""codeBox"">
Deque dequeA = new LinkedList();
Deque dequeB = new ArrayDeque();
</pre>","Deque","java.util.Deque","class",1
,"Java's 
<clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
  Deque 
</clt>Interface","Deque Implementations","<h2>Deque Implementations</h2> 
<p> Being a <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> subtype all methods in the <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> and <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interfaces are also available in the <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> interface. </p> 
<p> Since <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> is an interface you need to instantiate a concrete implementation of the interface in order to use it. You can choose between the following <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> implementations in the Java Collections API: </p> 
<ul> 
 <li>java.util.ArrayDeque</li> 
 <li>java.util.LinkedList</li> 
</ul> 
<p> <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> is a pretty standard deque / queue implementation. </p> 
<p> <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> stores its elements internally in an array. If the number of elements exceeds the space in the array, a new array is allocated, and all elements moved over. In other words, the <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> grows as needed, even if it stores its elements in an array. </p> 
<p> There are also <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> implementations in the <code>java.util.concurrent</code> package, but I will leave the concurrency utilities out of this tutorial. </p> 
<p> Here are a few examples of how to create a <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> instance: </p> 
<pre class=""codeBox"">
Deque dequeA = new LinkedList();
Deque dequeB = new ArrayDeque();
</pre>","LinkedList","java.util.LinkedList","class",0
,"Java's 
<clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
  Deque 
</clt>Interface","Deque Implementations","<h2>Deque Implementations</h2> 
<p> Being a <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> subtype all methods in the <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> and <code> 
  <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
    Collection 
  </clt></code> interfaces are also available in the <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> interface. </p> 
<p> Since <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> is an interface you need to instantiate a concrete implementation of the interface in order to use it. You can choose between the following <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> implementations in the Java Collections API: </p> 
<ul> 
 <li>java.util.ArrayDeque</li> 
 <li>java.util.LinkedList</li> 
</ul> 
<p> <code> 
  <clt fqn=""java.util.LinkedList"" api=""LinkedList"" kind=""class"">
    LinkedList 
  </clt></code> is a pretty standard deque / queue implementation. </p> 
<p> <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> stores its elements internally in an array. If the number of elements exceeds the space in the array, a new array is allocated, and all elements moved over. In other words, the <code> 
  <clt fqn=""java.util.ArrayDeque"" api=""ArrayDeque"" kind=""class"">
    ArrayDeque 
  </clt></code> grows as needed, even if it stores its elements in an array. </p> 
<p> There are also <code> 
  <clt fqn=""java.util.Queue"" api=""Queue"" kind=""class"">
    Queue 
  </clt></code> implementations in the <code>java.util.concurrent</code> package, but I will leave the concurrency utilities out of this tutorial. </p> 
<p> Here are a few examples of how to create a <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> instance: </p> 
<pre class=""codeBox"">
Deque dequeA = new LinkedList();
Deque dequeB = new ArrayDeque();
</pre>","ArrayDeque","java.util.ArrayDeque","class",1
,"Java's 
<clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
  Deque 
</clt>Interface","Adding and Accessing Elements","<h2>Adding and Accessing Elements</h2> 
<p> To add elements to the tail of a <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> you call its <code> 
  <clt fqn=""java.util.Deque.add"" api=""Deque"" kind=""method"">
    Deque.add() 
  </clt></code> method. You can also use the <code> 
  <clt fqn=""java.util.Deque.addFirst"" api=""Deque"" kind=""method"">
    Deque.addFirst() 
  </clt></code> and <code> 
  <clt fqn=""java.util.Deque.addLast"" api=""Deque"" kind=""method"">
    Deque.addLast() 
  </clt></code> methods, which add elements to the head and tail of the deque. </p> 
<pre class=""codeBox"">
Deque dequeA = new LinkedList();
dequeA.add     (&quot;element 1&quot;); //add element at tail
dequeA.addFirst(&quot;element 2&quot;); //add element at head
dequeA.addLast (&quot;element 3&quot;); //add element at tail
</pre> 
<p> The order in which the elements added to the <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> are stored internally, depends on the implementation. The two implementations mentioned earlier both store the elements in the order (first or last) in which they are inserted. </p> 
<p> You can peek at the element at the head of the queue without taking the element out of the queue. This is done via the <code> 
  <clt fqn=""java.util.Deque.element"" api=""Deque"" kind=""method"">
    Deque.element() 
  </clt></code> method. You can also use the <code> 
  <clt fqn=""java.util.Deque.getFirst"" api=""Deque"" kind=""method"">
    Deque.getFirst 
  </clt></code> and <code> 
  <clt fqn=""java.util.Deque.getLast"" api=""Deque"" kind=""method"">
    Deque.getLast() 
  </clt></code> methods, which return the first and last element in the <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code>. Here is how that looks: </p> 
<pre class=""codeBox"">
Object firstElement = dequeA.element();
Object firstElement = dequeA.getFirst();
Object lastElement  = dequeA.getLast();
</pre> 
<p> Taking elements from the deque is covered later. </p> 
<p> You can also iterate all elements of a deque, instead of just processing one at a time. Here is how that looks: </p> 
<pre class=""codeBox"">
Deque dequeA = new LinkedList();
dequeA.add(&quot;element 0&quot;);
dequeA.add(&quot;element 1&quot;);
dequeA.add(&quot;element 2&quot;);
//access via Iterator
Iterator iterator = dequeA.iterator();
while(iterator.hasNext(){
String element = (String) iterator.next();
}
//access via new for-loop
for(Object object : dequeA) {
String element = (String) object;
}
</pre> 
<p> When iterating the deque via its <code> 
  <clt fqn=""java.util.Iterator"" api=""Iterator"" kind=""class"">
    Iterator 
  </clt></code> or via the for-loop (which also uses the Iterator behind the scene, the sequence in which the elements are iterated depends on the deque implementation. </p>","Deque","java.util.Deque","class",1
,"Java's 
<clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
  Deque 
</clt>Interface","Adding and Accessing Elements","<h2>Adding and Accessing Elements</h2> 
<p> To add elements to the tail of a <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> you call its <code> 
  <clt fqn=""java.util.Deque.add"" api=""Deque"" kind=""method"">
    Deque.add() 
  </clt></code> method. You can also use the <code> 
  <clt fqn=""java.util.Deque.addFirst"" api=""Deque"" kind=""method"">
    Deque.addFirst() 
  </clt></code> and <code> 
  <clt fqn=""java.util.Deque.addLast"" api=""Deque"" kind=""method"">
    Deque.addLast() 
  </clt></code> methods, which add elements to the head and tail of the deque. </p> 
<pre class=""codeBox"">
Deque dequeA = new LinkedList();
dequeA.add     (&quot;element 1&quot;); //add element at tail
dequeA.addFirst(&quot;element 2&quot;); //add element at head
dequeA.addLast (&quot;element 3&quot;); //add element at tail
</pre> 
<p> The order in which the elements added to the <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> are stored internally, depends on the implementation. The two implementations mentioned earlier both store the elements in the order (first or last) in which they are inserted. </p> 
<p> You can peek at the element at the head of the queue without taking the element out of the queue. This is done via the <code> 
  <clt fqn=""java.util.Deque.element"" api=""Deque"" kind=""method"">
    Deque.element() 
  </clt></code> method. You can also use the <code> 
  <clt fqn=""java.util.Deque.getFirst"" api=""Deque"" kind=""method"">
    Deque.getFirst 
  </clt></code> and <code> 
  <clt fqn=""java.util.Deque.getLast"" api=""Deque"" kind=""method"">
    Deque.getLast() 
  </clt></code> methods, which return the first and last element in the <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code>. Here is how that looks: </p> 
<pre class=""codeBox"">
Object firstElement = dequeA.element();
Object firstElement = dequeA.getFirst();
Object lastElement  = dequeA.getLast();
</pre> 
<p> Taking elements from the deque is covered later. </p> 
<p> You can also iterate all elements of a deque, instead of just processing one at a time. Here is how that looks: </p> 
<pre class=""codeBox"">
Deque dequeA = new LinkedList();
dequeA.add(&quot;element 0&quot;);
dequeA.add(&quot;element 1&quot;);
dequeA.add(&quot;element 2&quot;);
//access via Iterator
Iterator iterator = dequeA.iterator();
while(iterator.hasNext(){
String element = (String) iterator.next();
}
//access via new for-loop
for(Object object : dequeA) {
String element = (String) object;
}
</pre> 
<p> When iterating the deque via its <code> 
  <clt fqn=""java.util.Iterator"" api=""Iterator"" kind=""class"">
    Iterator 
  </clt></code> or via the for-loop (which also uses the Iterator behind the scene, the sequence in which the elements are iterated depends on the deque implementation. </p>","Iterator","java.util.Iterator","class",0
,"Java's 
<clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
  Deque 
</clt>Interface","Removing Elements","<h2>Removing Elements</h2> 
<p> To remove elements from a deque, you call the <code> 
  <clt fqn=""java.util.Deque.remove"" api=""Deque"" kind=""method"">
    Deque.remove() 
  </clt></code>, <code> 
  <clt fqn=""java.util.Deque.removeFirst"" api=""Deque"" kind=""method"">
    Deque.removeFirst() 
  </clt></code> and <code> 
  <clt fqn=""java.util.Deque.removeLast"" api=""Deque"" kind=""method"">
    Deque.removeLast 
  </clt></code> methods. Here are a few examples: </p> 
<pre class=""codeBox"">
Object firstElement = dequeA.remove();
Object firstElement = dequeA.removeFirst();
Object lastElement  = dequeA.removeLast();
</pre>","Deque","java.util.Deque","class",0
,"Java's 
<clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
  Deque 
</clt>Interface","Generic Deque","<h2>Generic Deque</h2> 
<p> By default you can put any <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code> into a <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code>, but from Java 5, Java Generics makes it possible to limit the types of object you can insert into a <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code>. Here is an example: </p> 
<pre class=""codeBox"">
Deque&lt;MyObject&gt; deque = new LinkedList&lt;MyObject&gt;();
</pre> 
<p> This <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> can now only have <code>MyObject</code> instances inserted into it. You can then access and iterate its elements without casting them. Here is how it looks: </p> 
<pre class=""codeBox"">
MyObject myObject = deque.remove();
for(MyObject anObject : deque){
//do someting to anObject...   
}
</pre> 
<p> For more information about Java Generics, see the <a href=""/java-generics/index.html"">Java Generics Tutorial</a>. </p>","Object","java.lang.Object","class",0
,"Java's 
<clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
  Deque 
</clt>Interface","Generic Deque","<h2>Generic Deque</h2> 
<p> By default you can put any <code> 
  <clt fqn=""java.lang.Object"" api=""Object"" kind=""class"">
    Object 
  </clt></code> into a <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code>, but from Java 5, Java Generics makes it possible to limit the types of object you can insert into a <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code>. Here is an example: </p> 
<pre class=""codeBox"">
Deque&lt;MyObject&gt; deque = new LinkedList&lt;MyObject&gt;();
</pre> 
<p> This <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code> can now only have <code>MyObject</code> instances inserted into it. You can then access and iterate its elements without casting them. Here is how it looks: </p> 
<pre class=""codeBox"">
MyObject myObject = deque.remove();
for(MyObject anObject : deque){
//do someting to anObject...   
}
</pre> 
<p> For more information about Java Generics, see the <a href=""/java-generics/index.html"">Java Generics Tutorial</a>. </p>","Deque","java.util.Deque","class",0
,"Java's 
<clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
  Deque 
</clt>Interface","More Details in the JavaDoc","<h2>More Details in the JavaDoc</h2> 
<p> There is a lot more you can do with a <code> 
  <clt fqn=""java.util.Deque"" api=""Deque"" kind=""class"">
    Deque 
  </clt></code>, but you will have to check out the JavaDoc for more details. This text focused on the two most common operations: Adding / removing elements, and iterating the elements. </p>","Deque","java.util.Deque","class",0
,"Java's 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Interface","Java's Collection Interface","<h1>Java's 
 <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
   Collection 
 </clt>Interface</h1> 
<p> The Collection interface (java.util.Collection) is one of the root interfaces of the Java collection classes. Though you do not instantiate a Collection directly, but rather a subtype of Collection, you may often treat these subtypes uniformly as a Collection. In this text you will see how. </p> 
<p> Here is a list of the topics covered in this text: </p> 
<ol> 
 <li><a href=""#subtypes"">Collection Subtypes</a></li> 
 <li><a href=""#add"">Adding and Removing Elements</a></li> 
 <li><a href=""#contains"">Checking if a Collection Contains a Certain Element</a></li> 
 <li><a href=""#size"">Collection Size</a></li> 
 <li><a href=""#iterate"">Iterating a Collection</a></li> 
</ol>","Collection","java.util.Collection","class",0
,"Java's 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Interface","Adding and Removing Elements","<h2>Adding and Removing Elements</h2> 
<p> Regardless of what Collection subtype you are using there are a few standard methods to add and remove elements from a Collection. Adding and removing single elements is done like this: </p> 
<pre class=""codeBox"">
String     anElement  = &quot;an element&quot;;
Collection collection = new HashSet();
boolean didCollectionChange = collection.add(anElement);
boolean wasElementRemoved   = collection.remove(anElement);    
</pre> 
<p> <code> 
  <clt fqn=""java.util.Collection.add"" api=""Collection"" kind=""method"">
    Collection.add() 
  </clt></code> adds the given element to the collection, and returns true if the Collection changed as a result of calling the <code> 
  <clt fqn=""java.util.Collection.add"" api=""Collection"" kind=""method"">
    Collection.add() 
  </clt></code> method. A <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> for instance may not have changed. If the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> already contained that element, it is not added again. On the other hand, if you called <code> 
  <clt fqn=""java.util.Collection.add"" api=""Collection"" kind=""method"">
    Collection.add() 
  </clt></code> on a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> already contained that element, the element would then exist twice in the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>. </p> 
<p> <code> 
  <clt fqn=""java.util.Collection.remove"" api=""Collection"" kind=""method"">
    Collection.remove() 
  </clt></code> removes the given element and returns true if the removed element was present in the Collection, and was removed. If the element was not present, the <code> 
  <clt fqn=""java.util.Collection.remove"" api=""Collection"" kind=""method"">
    Collection.remove() 
  </clt></code> method returns false. </p>","Collection","java.util.Collection","class",1
,"Java's 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Interface","Adding and Removing Elements","<h2>Adding and Removing Elements</h2> 
<p> Regardless of what Collection subtype you are using there are a few standard methods to add and remove elements from a Collection. Adding and removing single elements is done like this: </p> 
<pre class=""codeBox"">
String     anElement  = &quot;an element&quot;;
Collection collection = new HashSet();
boolean didCollectionChange = collection.add(anElement);
boolean wasElementRemoved   = collection.remove(anElement);    
</pre> 
<p> <code> 
  <clt fqn=""java.util.Collection.add"" api=""Collection"" kind=""method"">
    Collection.add() 
  </clt></code> adds the given element to the collection, and returns true if the Collection changed as a result of calling the <code> 
  <clt fqn=""java.util.Collection.add"" api=""Collection"" kind=""method"">
    Collection.add() 
  </clt></code> method. A <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> for instance may not have changed. If the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> already contained that element, it is not added again. On the other hand, if you called <code> 
  <clt fqn=""java.util.Collection.add"" api=""Collection"" kind=""method"">
    Collection.add() 
  </clt></code> on a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> already contained that element, the element would then exist twice in the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>. </p> 
<p> <code> 
  <clt fqn=""java.util.Collection.remove"" api=""Collection"" kind=""method"">
    Collection.remove() 
  </clt></code> removes the given element and returns true if the removed element was present in the Collection, and was removed. If the element was not present, the <code> 
  <clt fqn=""java.util.Collection.remove"" api=""Collection"" kind=""method"">
    Collection.remove() 
  </clt></code> method returns false. </p>","Set","java.util.Set","class",0
,"Java's 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Interface","Adding and Removing Elements","<h2>Adding and Removing Elements</h2> 
<p> Regardless of what Collection subtype you are using there are a few standard methods to add and remove elements from a Collection. Adding and removing single elements is done like this: </p> 
<pre class=""codeBox"">
String     anElement  = &quot;an element&quot;;
Collection collection = new HashSet();
boolean didCollectionChange = collection.add(anElement);
boolean wasElementRemoved   = collection.remove(anElement);    
</pre> 
<p> <code> 
  <clt fqn=""java.util.Collection.add"" api=""Collection"" kind=""method"">
    Collection.add() 
  </clt></code> adds the given element to the collection, and returns true if the Collection changed as a result of calling the <code> 
  <clt fqn=""java.util.Collection.add"" api=""Collection"" kind=""method"">
    Collection.add() 
  </clt></code> method. A <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> for instance may not have changed. If the <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set 
  </clt></code> already contained that element, it is not added again. On the other hand, if you called <code> 
  <clt fqn=""java.util.Collection.add"" api=""Collection"" kind=""method"">
    Collection.add() 
  </clt></code> on a <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> and the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code> already contained that element, the element would then exist twice in the <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List 
  </clt></code>. </p> 
<p> <code> 
  <clt fqn=""java.util.Collection.remove"" api=""Collection"" kind=""method"">
    Collection.remove() 
  </clt></code> removes the given element and returns true if the removed element was present in the Collection, and was removed. If the element was not present, the <code> 
  <clt fqn=""java.util.Collection.remove"" api=""Collection"" kind=""method"">
    Collection.remove() 
  </clt></code> method returns false. </p>","List","java.util.List","class",0
,"Java's 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Interface","Adding and Removing Elements - part 2","<h3>Adding and Removing Elements - part 2</h3> 
<p> You can also add and remove collections of objects. Here are a few examples: </p> 
<pre class=""codeBox"">
Set  aSet  = ... // get Set  with elements from somewhere
List aList = ... // get List with elements from somewhere
Collection collection = new HashSet();
collection.addAll(aSet);    //returns boolean too, but ignored here.
collection.addAll(aList);   //returns boolean too, but ignored here.
collection.removeAll(aList);   //returns boolean too...
collection.retainAll(aSet);    //returns boolean too...
</pre> 
<p> <code> 
  <clt fqn=""java.util.Collection.addAll"" api=""Collection"" kind=""method"">
    Collection.addAll() 
  </clt></code> adds all elements found in the Collection passed as parameter to the method. The Collection object itself is not added. Only its elements. If you had called <code> 
  <clt fqn=""java.util.Collection.add"" api=""Collection"" kind=""method"">
    Collection.add() 
  </clt></code> with the Collection as parameter instead, the Collection object itself would have been added, not its elements. </p> 
<p>Exactly how thet <code> 
  <clt fqn=""java.util.Collection.addAll"" api=""Collection"" kind=""method"">
    Collection.addAll() 
  </clt></code> method behaves depends on the Collection subtype. Some Collection subtypes allows the same element to be added more than once, and others don't. </p> 
<p> <code> 
  <clt fqn=""java.util.Collection.removeAll"" api=""Collection"" kind=""method"">
    Collection.removeAll() 
  </clt></code> removes all elements found the Collection passed as parameter to the method. If the Collection parameter contains any elements not found the target collection, these are just ignored. </p> 
<p> <code> 
  <clt fqn=""java.util.Collection.retainAll"" api=""Collection"" kind=""method"">
    Collection.retainAll() 
  </clt></code> does the opposite of <code> 
  <clt fqn=""java.util.Collection.removeAll"" api=""Collection"" kind=""method"">
    Collection.removeAll() 
  </clt></code>. Instead of removing all the elements found in the parameter Collection, it keeps all these elements, and removes all other elements. Keep in mind, that only if the elements were already contained in the target collection, are they retained. Any new elements found in the parameter Collection which are not in the target collection, are not automatically added. They are just ignored. </p>","Collection","java.util.Collection","class",1
,"Java's 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Interface","Checking if a Collection Contains a Certain Element","<h2>Checking if a 
 <clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
   Collection 
 </clt>Contains a Certain Element</h2> 
<p> The Collection interface has two methods to check if a Collection contains one or more certain elements. These are the <code> 
  <clt fqn=""java.util.Collection.contains"" api=""Collection"" kind=""method"">
    Collection.contains() 
  </clt></code> and <code> 
  <clt fqn=""java.util.Collection.containsAll"" api=""Collection"" kind=""method"">
    Collection.containsAll() 
  </clt></code> methods. They are illustrated here: </p> 
<pre class=""codeBox"">
Collection collection   = new HashSet();
boolean containsElement = <b>collection.contains(&quot;an element&quot;);</b>
Collection elements     = new HashSet();
boolean containsAll     = <b>collection.containsAll(elements);</b>
</pre> 
<p> <code> 
  <clt fqn=""java.util.Collection.contains"" api=""Collection"" kind=""method"">
    Collection.contains() 
  </clt></code> returns true if the collection contains the element, and false if not. </p> 
<p> <code> 
  <clt fqn=""java.util.Collection.containsAll"" api=""Collection"" kind=""method"">
    Collection.containsAll() 
  </clt></code> returns true if the collection contains all the elements in the parameter collection, and false if not. </p>","Collection","java.util.Collection","class",1
,"Java's 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Interface","Collection Size","<h2>Collection Size</h2> 
<p> You can check the size of a collection using the <code> 
  <clt fqn=""java.util.Collection.size"" api=""Collection"" kind=""method"">
    Collection.size() 
  </clt></code> method. By &quot;size&quot; is meant the number of elements in the collection. Here is an example: </p> 
<pre class=""codeBox"">
int numberOfElements = collection.size();    
</pre>","Collection","java.util.Collection","class",0
,"Java's 
<clt fqn=""java.util.Collection"" api=""Collection"" kind=""class"">
  Collection 
</clt>Interface","Iterating a Collection","<h2>Iterating a Collection</h2> 
<p> You can iterate all elements of a collection. This is done by obtaining an <code> 
  <clt fqn=""java.util.Iterator"" api=""Iterator"" kind=""class"">
    Iterator 
  </clt></code> from the collection, and iterate through that. Here is how it looks: </p> 
<pre class=""codeBox"">
Collection collection = new HashSet();
//... add elements to the collection
Iterator iterator = collection.iterator();
while(iterator.hasNext()){
Object object = iterator.next();
//do something to object;    
}
</pre> 
<p> You can also use the new for-loop: </p> 
<pre class=""codeBox"">
Collection collection = new HashSet();
//... add elements to the collection
for(Object object : collection) {
//do something to object;
}
</pre>","Iterator","java.util.Iterator","class",0
,"Java's 
<clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
  SortedMap 
</clt>Interface","Java's SortedMap Interface","<h1>Java's 
 <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
   SortedMap 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    java.util.SortedMap 
  </clt></code> interface is a subtype of the <a href=""map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     java.util.Map 
   </clt></code></a> interface, with the addition that the elements stored in the map are sorted internally. </p> 
<p>The order of the sorting is either the natural sorting order of the elements (if they implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    java.lang.Comparable 
  </clt></code>), or the order determined by a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> that you can give to the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>. </p> 
<p> By default the elements are iterated in ascending order, starting with the &quot;smallest&quot; and moving towards the &quot;largest&quot;. But it is also possible to iterate the elements in descending order using the method <code> 
  <clt fqn=""java.util.TreeMap.descendingKeySet"" api=""TreeMap"" kind=""method"">
    TreeMap.descendingKeySet() 
  </clt></code>. </p> 
<p> The Java Collections API only has one implementation of the <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> interface - the <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    java.util.TreeMap 
  </clt></code> class. The <code>java.util.concurrent</code> package also has an implementation of this interface, but I will leave the concurrency utilities out of this trail. </p> 
<p> Here are two examples of how to create a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>: </p> 
<pre class=""codeBox"">
SortedMap mapA = new TreeMap();
Comparator comparator = new MyComparator();
SortedMap mapB = new TreeMap(comparator);
</pre>","SortedMap","java.util.SortedMap","class",1
,"Java's 
<clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
  SortedMap 
</clt>Interface","Java's SortedMap Interface","<h1>Java's 
 <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
   SortedMap 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    java.util.SortedMap 
  </clt></code> interface is a subtype of the <a href=""map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     java.util.Map 
   </clt></code></a> interface, with the addition that the elements stored in the map are sorted internally. </p> 
<p>The order of the sorting is either the natural sorting order of the elements (if they implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    java.lang.Comparable 
  </clt></code>), or the order determined by a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> that you can give to the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>. </p> 
<p> By default the elements are iterated in ascending order, starting with the &quot;smallest&quot; and moving towards the &quot;largest&quot;. But it is also possible to iterate the elements in descending order using the method <code> 
  <clt fqn=""java.util.TreeMap.descendingKeySet"" api=""TreeMap"" kind=""method"">
    TreeMap.descendingKeySet() 
  </clt></code>. </p> 
<p> The Java Collections API only has one implementation of the <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> interface - the <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    java.util.TreeMap 
  </clt></code> class. The <code>java.util.concurrent</code> package also has an implementation of this interface, but I will leave the concurrency utilities out of this trail. </p> 
<p> Here are two examples of how to create a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>: </p> 
<pre class=""codeBox"">
SortedMap mapA = new TreeMap();
Comparator comparator = new MyComparator();
SortedMap mapB = new TreeMap(comparator);
</pre>","Map","java.util.Map","class",0
,"Java's 
<clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
  SortedMap 
</clt>Interface","Java's SortedMap Interface","<h1>Java's 
 <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
   SortedMap 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    java.util.SortedMap 
  </clt></code> interface is a subtype of the <a href=""map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     java.util.Map 
   </clt></code></a> interface, with the addition that the elements stored in the map are sorted internally. </p> 
<p>The order of the sorting is either the natural sorting order of the elements (if they implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    java.lang.Comparable 
  </clt></code>), or the order determined by a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> that you can give to the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>. </p> 
<p> By default the elements are iterated in ascending order, starting with the &quot;smallest&quot; and moving towards the &quot;largest&quot;. But it is also possible to iterate the elements in descending order using the method <code> 
  <clt fqn=""java.util.TreeMap.descendingKeySet"" api=""TreeMap"" kind=""method"">
    TreeMap.descendingKeySet() 
  </clt></code>. </p> 
<p> The Java Collections API only has one implementation of the <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> interface - the <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    java.util.TreeMap 
  </clt></code> class. The <code>java.util.concurrent</code> package also has an implementation of this interface, but I will leave the concurrency utilities out of this trail. </p> 
<p> Here are two examples of how to create a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>: </p> 
<pre class=""codeBox"">
SortedMap mapA = new TreeMap();
Comparator comparator = new MyComparator();
SortedMap mapB = new TreeMap(comparator);
</pre>","Comparable","java.lang.Comparable","class",0
,"Java's 
<clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
  SortedMap 
</clt>Interface","Java's SortedMap Interface","<h1>Java's 
 <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
   SortedMap 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    java.util.SortedMap 
  </clt></code> interface is a subtype of the <a href=""map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     java.util.Map 
   </clt></code></a> interface, with the addition that the elements stored in the map are sorted internally. </p> 
<p>The order of the sorting is either the natural sorting order of the elements (if they implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    java.lang.Comparable 
  </clt></code>), or the order determined by a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> that you can give to the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>. </p> 
<p> By default the elements are iterated in ascending order, starting with the &quot;smallest&quot; and moving towards the &quot;largest&quot;. But it is also possible to iterate the elements in descending order using the method <code> 
  <clt fqn=""java.util.TreeMap.descendingKeySet"" api=""TreeMap"" kind=""method"">
    TreeMap.descendingKeySet() 
  </clt></code>. </p> 
<p> The Java Collections API only has one implementation of the <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> interface - the <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    java.util.TreeMap 
  </clt></code> class. The <code>java.util.concurrent</code> package also has an implementation of this interface, but I will leave the concurrency utilities out of this trail. </p> 
<p> Here are two examples of how to create a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>: </p> 
<pre class=""codeBox"">
SortedMap mapA = new TreeMap();
Comparator comparator = new MyComparator();
SortedMap mapB = new TreeMap(comparator);
</pre>","Comparator","java.util.Comparator","class",0
,"Java's 
<clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
  SortedMap 
</clt>Interface","Java's SortedMap Interface","<h1>Java's 
 <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
   SortedMap 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    java.util.SortedMap 
  </clt></code> interface is a subtype of the <a href=""map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     java.util.Map 
   </clt></code></a> interface, with the addition that the elements stored in the map are sorted internally. </p> 
<p>The order of the sorting is either the natural sorting order of the elements (if they implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    java.lang.Comparable 
  </clt></code>), or the order determined by a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> that you can give to the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>. </p> 
<p> By default the elements are iterated in ascending order, starting with the &quot;smallest&quot; and moving towards the &quot;largest&quot;. But it is also possible to iterate the elements in descending order using the method <code> 
  <clt fqn=""java.util.TreeMap.descendingKeySet"" api=""TreeMap"" kind=""method"">
    TreeMap.descendingKeySet() 
  </clt></code>. </p> 
<p> The Java Collections API only has one implementation of the <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> interface - the <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    java.util.TreeMap 
  </clt></code> class. The <code>java.util.concurrent</code> package also has an implementation of this interface, but I will leave the concurrency utilities out of this trail. </p> 
<p> Here are two examples of how to create a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>: </p> 
<pre class=""codeBox"">
SortedMap mapA = new TreeMap();
Comparator comparator = new MyComparator();
SortedMap mapB = new TreeMap(comparator);
</pre>","SortedSet","java.util.SortedSet","class",0
,"Java's 
<clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
  SortedMap 
</clt>Interface","Java's SortedMap Interface","<h1>Java's 
 <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
   SortedMap 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    java.util.SortedMap 
  </clt></code> interface is a subtype of the <a href=""map.html""><code> 
   <clt fqn=""java.util.Map"" api=""Map"" kind=""class"">
     java.util.Map 
   </clt></code></a> interface, with the addition that the elements stored in the map are sorted internally. </p> 
<p>The order of the sorting is either the natural sorting order of the elements (if they implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    java.lang.Comparable 
  </clt></code>), or the order determined by a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> that you can give to the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>. </p> 
<p> By default the elements are iterated in ascending order, starting with the &quot;smallest&quot; and moving towards the &quot;largest&quot;. But it is also possible to iterate the elements in descending order using the method <code> 
  <clt fqn=""java.util.TreeMap.descendingKeySet"" api=""TreeMap"" kind=""method"">
    TreeMap.descendingKeySet() 
  </clt></code>. </p> 
<p> The Java Collections API only has one implementation of the <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> interface - the <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    java.util.TreeMap 
  </clt></code> class. The <code>java.util.concurrent</code> package also has an implementation of this interface, but I will leave the concurrency utilities out of this trail. </p> 
<p> Here are two examples of how to create a <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code>: </p> 
<pre class=""codeBox"">
SortedMap mapA = new TreeMap();
Comparator comparator = new MyComparator();
SortedMap mapB = new TreeMap(comparator);
</pre>","TreeMap","java.util.TreeMap","class",0
,"Java's 
<clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
  SortedMap 
</clt>Interface","More Details in the JavaDoc","<h2>More Details in the JavaDoc</h2> 
<p> There is actually a lot more you can do with a <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code> that is not part of the <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> interface, like getting a descending key set etc. Check out the JavaDoc's for more detail about these features. </p>","TreeMap","java.util.TreeMap","class",0
,"Java's 
<clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
  SortedMap 
</clt>Interface","More Details in the JavaDoc","<h2>More Details in the JavaDoc</h2> 
<p> There is actually a lot more you can do with a <code> 
  <clt fqn=""java.util.TreeMap"" api=""TreeMap"" kind=""class"">
    TreeMap 
  </clt></code> that is not part of the <code> 
  <clt fqn=""java.util.SortedMap"" api=""SortedMap"" kind=""class"">
    SortedMap 
  </clt></code> interface, like getting a descending key set etc. Check out the JavaDoc's for more detail about these features. </p>","SortedMap","java.util.SortedMap","class",0
,"Java's 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","Java's SortedSet Interface","<h1>Java's 
 <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
   SortedSet 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    java.util.SortedSet 
  </clt></code> interface is a subtype of the <a href=""set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     java.util.Set 
   </clt></code></a> interface. It behaves like a normal set with the exception that the elements are sorted internally. This means that when you iterate the elements of a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> the elements are returned in the sorted order. </p> 
<p>The order of the sorting is either the natural sorting order of the elements (if they implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    java.lang.Comparable 
  </clt></code>), or the order determined by a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> that you can give to the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>. </p> 
<p> By default the elements are iterated in ascending order, starting with the &quot;smallest&quot; and moving towards the &quot;largest&quot;. But it is also possible to iterate the elements in descending order using the method <code> 
  <clt fqn=""java.util.TreeSet.descendingIterator"" api=""TreeSet"" kind=""method"">
    TreeSet.descendingIterator() 
  </clt></code>. </p> 
<p> The Java Collections API only has one implementation of the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface - the <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    java.util.TreeSet 
  </clt></code> class. The <code>java.util.concurrent</code> package also has an implementation of this interface, but I will leave the concurrency utilities out of this trail. </p> 
<p> Here are two examples of how to create a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>: </p> 
<pre class=""codeBox"">
SortedSet setA = new TreeSet();
Comparator comparator = new MyComparator();
SortedSet setB = new TreeSet(comparator);
</pre>","SortedSet","java.util.SortedSet","class",1
,"Java's 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","Java's SortedSet Interface","<h1>Java's 
 <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
   SortedSet 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    java.util.SortedSet 
  </clt></code> interface is a subtype of the <a href=""set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     java.util.Set 
   </clt></code></a> interface. It behaves like a normal set with the exception that the elements are sorted internally. This means that when you iterate the elements of a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> the elements are returned in the sorted order. </p> 
<p>The order of the sorting is either the natural sorting order of the elements (if they implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    java.lang.Comparable 
  </clt></code>), or the order determined by a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> that you can give to the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>. </p> 
<p> By default the elements are iterated in ascending order, starting with the &quot;smallest&quot; and moving towards the &quot;largest&quot;. But it is also possible to iterate the elements in descending order using the method <code> 
  <clt fqn=""java.util.TreeSet.descendingIterator"" api=""TreeSet"" kind=""method"">
    TreeSet.descendingIterator() 
  </clt></code>. </p> 
<p> The Java Collections API only has one implementation of the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface - the <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    java.util.TreeSet 
  </clt></code> class. The <code>java.util.concurrent</code> package also has an implementation of this interface, but I will leave the concurrency utilities out of this trail. </p> 
<p> Here are two examples of how to create a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>: </p> 
<pre class=""codeBox"">
SortedSet setA = new TreeSet();
Comparator comparator = new MyComparator();
SortedSet setB = new TreeSet(comparator);
</pre>","Set","java.util.Set","class",0
,"Java's 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","Java's SortedSet Interface","<h1>Java's 
 <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
   SortedSet 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    java.util.SortedSet 
  </clt></code> interface is a subtype of the <a href=""set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     java.util.Set 
   </clt></code></a> interface. It behaves like a normal set with the exception that the elements are sorted internally. This means that when you iterate the elements of a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> the elements are returned in the sorted order. </p> 
<p>The order of the sorting is either the natural sorting order of the elements (if they implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    java.lang.Comparable 
  </clt></code>), or the order determined by a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> that you can give to the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>. </p> 
<p> By default the elements are iterated in ascending order, starting with the &quot;smallest&quot; and moving towards the &quot;largest&quot;. But it is also possible to iterate the elements in descending order using the method <code> 
  <clt fqn=""java.util.TreeSet.descendingIterator"" api=""TreeSet"" kind=""method"">
    TreeSet.descendingIterator() 
  </clt></code>. </p> 
<p> The Java Collections API only has one implementation of the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface - the <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    java.util.TreeSet 
  </clt></code> class. The <code>java.util.concurrent</code> package also has an implementation of this interface, but I will leave the concurrency utilities out of this trail. </p> 
<p> Here are two examples of how to create a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>: </p> 
<pre class=""codeBox"">
SortedSet setA = new TreeSet();
Comparator comparator = new MyComparator();
SortedSet setB = new TreeSet(comparator);
</pre>","Comparable","java.lang.Comparable","class",0
,"Java's 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","Java's SortedSet Interface","<h1>Java's 
 <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
   SortedSet 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    java.util.SortedSet 
  </clt></code> interface is a subtype of the <a href=""set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     java.util.Set 
   </clt></code></a> interface. It behaves like a normal set with the exception that the elements are sorted internally. This means that when you iterate the elements of a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> the elements are returned in the sorted order. </p> 
<p>The order of the sorting is either the natural sorting order of the elements (if they implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    java.lang.Comparable 
  </clt></code>), or the order determined by a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> that you can give to the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>. </p> 
<p> By default the elements are iterated in ascending order, starting with the &quot;smallest&quot; and moving towards the &quot;largest&quot;. But it is also possible to iterate the elements in descending order using the method <code> 
  <clt fqn=""java.util.TreeSet.descendingIterator"" api=""TreeSet"" kind=""method"">
    TreeSet.descendingIterator() 
  </clt></code>. </p> 
<p> The Java Collections API only has one implementation of the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface - the <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    java.util.TreeSet 
  </clt></code> class. The <code>java.util.concurrent</code> package also has an implementation of this interface, but I will leave the concurrency utilities out of this trail. </p> 
<p> Here are two examples of how to create a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>: </p> 
<pre class=""codeBox"">
SortedSet setA = new TreeSet();
Comparator comparator = new MyComparator();
SortedSet setB = new TreeSet(comparator);
</pre>","Comparator","java.util.Comparator","class",0
,"Java's 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","Java's SortedSet Interface","<h1>Java's 
 <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
   SortedSet 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    java.util.SortedSet 
  </clt></code> interface is a subtype of the <a href=""set.html""><code> 
   <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
     java.util.Set 
   </clt></code></a> interface. It behaves like a normal set with the exception that the elements are sorted internally. This means that when you iterate the elements of a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> the elements are returned in the sorted order. </p> 
<p>The order of the sorting is either the natural sorting order of the elements (if they implement <code> 
  <clt fqn=""java.lang.Comparable"" api=""Comparable"" kind=""class"">
    java.lang.Comparable 
  </clt></code>), or the order determined by a <code> 
  <clt fqn=""java.util.Comparator"" api=""Comparator"" kind=""class"">
    Comparator 
  </clt></code> that you can give to the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>. </p> 
<p> By default the elements are iterated in ascending order, starting with the &quot;smallest&quot; and moving towards the &quot;largest&quot;. But it is also possible to iterate the elements in descending order using the method <code> 
  <clt fqn=""java.util.TreeSet.descendingIterator"" api=""TreeSet"" kind=""method"">
    TreeSet.descendingIterator() 
  </clt></code>. </p> 
<p> The Java Collections API only has one implementation of the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface - the <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    java.util.TreeSet 
  </clt></code> class. The <code>java.util.concurrent</code> package also has an implementation of this interface, but I will leave the concurrency utilities out of this trail. </p> 
<p> Here are two examples of how to create a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>: </p> 
<pre class=""codeBox"">
SortedSet setA = new TreeSet();
Comparator comparator = new MyComparator();
SortedSet setB = new TreeSet(comparator);
</pre>","TreeSet","java.util.TreeSet","class",1
,"Java's 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","More Details in the JavaDoc","<h2>More Details in the JavaDoc</h2> 
<p> There is actually a lot more you can do with a <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> that is not part of the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface, like getting the highest and lowest element, splitting the set into subsets based on two values etc. Check out the JavaDoc if you need any of these more special features. </p>","TreeSet","java.util.TreeSet","class",0
,"Java's 
<clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
  SortedSet 
</clt>Interface","More Details in the JavaDoc","<h2>More Details in the JavaDoc</h2> 
<p> There is actually a lot more you can do with a <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    TreeSet 
  </clt></code> that is not part of the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> interface, like getting the highest and lowest element, splitting the set into subsets based on two values etc. Check out the JavaDoc if you need any of these more special features. </p>","SortedSet","java.util.SortedSet","class",0
,"Java's 
<clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
  NavigableSet 
</clt>Interface","Java's NavigableSet Interface","<h1>Java's 
 <clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
   NavigableSet 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
    java.util.NavigableSet 
  </clt></code> interface is a subtype of the <a href=""set.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     java.util.SortedSet 
   </clt></code></a> interface. It behaves like a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> with the exception you have navigation methods available in addition to the sorting mechanisms of the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>. In this text I will look closer at some of these navigation methods. </p> 
<p> In Java 6 there is only one implementation of the <code> 
  <clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
    NavigableSet 
  </clt></code> interface in the <code>java.util</code> package: <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    java.util.TreeSet 
  </clt></code> There is an implementation in the <code>java.util.concurrent</code> package but that is outside the scope of this trail. </p> 
<p> Here is a list of the topics covered in this text: </p> 
<ol> 
 <li><a href=""#iterator"">descendingIterator() and descendingSet()</a></li> 
 <li><a href=""#headset"">headSet(), tailSet() and subSet()</a></li> 
 <li><a href=""#ceiling"">ceiling(), floor(), higher() and lower()</a></li> 
 <li><a href=""#pollFirst"">pollFirst() and pollLast()</a></li> 
</ol>","NavigableSet","java.util.NavigableSet","class",0
,"Java's 
<clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
  NavigableSet 
</clt>Interface","Java's NavigableSet Interface","<h1>Java's 
 <clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
   NavigableSet 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
    java.util.NavigableSet 
  </clt></code> interface is a subtype of the <a href=""set.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     java.util.SortedSet 
   </clt></code></a> interface. It behaves like a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> with the exception you have navigation methods available in addition to the sorting mechanisms of the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>. In this text I will look closer at some of these navigation methods. </p> 
<p> In Java 6 there is only one implementation of the <code> 
  <clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
    NavigableSet 
  </clt></code> interface in the <code>java.util</code> package: <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    java.util.TreeSet 
  </clt></code> There is an implementation in the <code>java.util.concurrent</code> package but that is outside the scope of this trail. </p> 
<p> Here is a list of the topics covered in this text: </p> 
<ol> 
 <li><a href=""#iterator"">descendingIterator() and descendingSet()</a></li> 
 <li><a href=""#headset"">headSet(), tailSet() and subSet()</a></li> 
 <li><a href=""#ceiling"">ceiling(), floor(), higher() and lower()</a></li> 
 <li><a href=""#pollFirst"">pollFirst() and pollLast()</a></li> 
</ol>","SortedSet","java.util.SortedSet","class",0
,"Java's 
<clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
  NavigableSet 
</clt>Interface","Java's NavigableSet Interface","<h1>Java's 
 <clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
   NavigableSet 
 </clt>Interface</h1> 
<p> The <code> 
  <clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
    java.util.NavigableSet 
  </clt></code> interface is a subtype of the <a href=""set.html""><code> 
   <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
     java.util.SortedSet 
   </clt></code></a> interface. It behaves like a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code> with the exception you have navigation methods available in addition to the sorting mechanisms of the <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>. In this text I will look closer at some of these navigation methods. </p> 
<p> In Java 6 there is only one implementation of the <code> 
  <clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
    NavigableSet 
  </clt></code> interface in the <code>java.util</code> package: <code> 
  <clt fqn=""java.util.TreeSet"" api=""TreeSet"" kind=""class"">
    java.util.TreeSet 
  </clt></code> There is an implementation in the <code>java.util.concurrent</code> package but that is outside the scope of this trail. </p> 
<p> Here is a list of the topics covered in this text: </p> 
<ol> 
 <li><a href=""#iterator"">descendingIterator() and descendingSet()</a></li> 
 <li><a href=""#headset"">headSet(), tailSet() and subSet()</a></li> 
 <li><a href=""#ceiling"">ceiling(), floor(), higher() and lower()</a></li> 
 <li><a href=""#pollFirst"">pollFirst() and pollLast()</a></li> 
</ol>","TreeSet","java.util.TreeSet","class",0
,"Java's 
<clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
  NavigableSet 
</clt>Interface","descendingIterator() and descendingSet()","<h2>descendingIterator() and descendingSet()</h2> 
<p> The first interesting navigation methods are the <code> 
  <clt fqn=""java.util.NavigableSet.descendingIterator"" api=""NavigableSet"" kind=""method"">
    NavigableSet.descendingIterator() 
  </clt></code> and <code> 
  <clt fqn=""java.util.NavigableSet.descendingSet"" api=""NavigableSet"" kind=""method"">
    NavigableSet.descendingSet() 
  </clt></code> methods. </p> 
<p> The <code> 
  <clt fqn=""java.util.NavigableSet.descendingSet"" api=""NavigableSet"" kind=""method"">
    NavigableSet.descendingSet() 
  </clt></code> method returns a <code> 
  <clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
    NavigableSet 
  </clt></code> in which the order of the elements is reversed compared to this one. The returned &quot;view&quot; is backed by the original <code> 
  <clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
    NavigableSet 
  </clt></code>, so changes to the descending set are also reflected in the original set. </p> 
<p> Here is a simple example: </p> 
<pre class=""codeBox"">
NavigableSet reverse = original.descendingSet();
</pre> 
<p> The <code> 
  <clt fqn=""java.util.NavigableSet.descendingIterator"" api=""NavigableSet"" kind=""method"">
    NavigableSet.descendingIterator() 
  </clt></code> method allows you to iterate the elements of the <code> 
  <clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
    NavigableSet 
  </clt></code> (which is also a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>) in reverse order, without changing the order of the elements internally. </p> 
<pre class=""codeBox"">
Iterator reverse = original.descendingIterator();    
</pre>","NavigableSet","java.util.NavigableSet","class",1
,"Java's 
<clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
  NavigableSet 
</clt>Interface","descendingIterator() and descendingSet()","<h2>descendingIterator() and descendingSet()</h2> 
<p> The first interesting navigation methods are the <code> 
  <clt fqn=""java.util.NavigableSet.descendingIterator"" api=""NavigableSet"" kind=""method"">
    NavigableSet.descendingIterator() 
  </clt></code> and <code> 
  <clt fqn=""java.util.NavigableSet.descendingSet"" api=""NavigableSet"" kind=""method"">
    NavigableSet.descendingSet() 
  </clt></code> methods. </p> 
<p> The <code> 
  <clt fqn=""java.util.NavigableSet.descendingSet"" api=""NavigableSet"" kind=""method"">
    NavigableSet.descendingSet() 
  </clt></code> method returns a <code> 
  <clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
    NavigableSet 
  </clt></code> in which the order of the elements is reversed compared to this one. The returned &quot;view&quot; is backed by the original <code> 
  <clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
    NavigableSet 
  </clt></code>, so changes to the descending set are also reflected in the original set. </p> 
<p> Here is a simple example: </p> 
<pre class=""codeBox"">
NavigableSet reverse = original.descendingSet();
</pre> 
<p> The <code> 
  <clt fqn=""java.util.NavigableSet.descendingIterator"" api=""NavigableSet"" kind=""method"">
    NavigableSet.descendingIterator() 
  </clt></code> method allows you to iterate the elements of the <code> 
  <clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
    NavigableSet 
  </clt></code> (which is also a <code> 
  <clt fqn=""java.util.SortedSet"" api=""SortedSet"" kind=""class"">
    SortedSet 
  </clt></code>) in reverse order, without changing the order of the elements internally. </p> 
<pre class=""codeBox"">
Iterator reverse = original.descendingIterator();    
</pre>","SortedSet","java.util.SortedSet","class",0
,"Java's 
<clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
  NavigableSet 
</clt>Interface","headSet(), tailSet() and subSet()","<h2>headSet(), tailSet() and subSet()</h2> 
<p> The <code> 
  <clt fqn=""java.util.NavigableSet.headSet"" api=""NavigableSet"" kind=""method"">
    NavigableSet.headSet() 
  </clt></code> method returns a view of the original <code> 
  <clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
    NavigableSet 
  </clt></code> which only contains elements that are &quot;less than&quot; the given element. Here is an example: </p> 
<pre class=""codeBox"">
NavigableSet original = new TreeSet();
original.add(&quot;1&quot;);
original.add(&quot;2&quot;);
original.add(&quot;3&quot;);
//this headset will contain &quot;1&quot; and &quot;2&quot;
SortedSet headset = original.headSet(&quot;3&quot;);
//this headset will contain &quot;1&quot;, &quot;2&quot;, and &quot;3&quot; because &quot;inclusive&quot;=true
NavigableSet headset = original.headSet(&quot;3&quot;, true);
</pre> 
<p> The <code> 
  <clt fqn=""java.util.NavigableSet.tailSet"" api=""NavigableSet"" kind=""method"">
    NavigableSet.tailSet() 
  </clt></code> method works the same way, except it returns all elements that are <b>higher</b> than the given parameter element. </p> 
<p> The <code> 
  <clt fqn=""java.util.NavigableSet.subSet"" api=""NavigableSet"" kind=""method"">
    NavigableSet.subSet() 
  </clt></code> allows you to pass two parameters demarcating the boundaries of the view set to return. The elements matching the first boundary is included, where as elements matching the last boundary are not. Here is an example: </p> 
<pre class=""codeBox"">
NavigableSet original = new TreeSet();
original.add(&quot;1&quot;);
original.add(&quot;2&quot;);
original.add(&quot;3&quot;);
original.add(&quot;4&quot;);
original.add(&quot;5&quot;);
//this subset will contain &quot;2&quot; and &quot;3&quot;
SortedSet    subset  = original.subSet(&quot;2&quot;, &quot;4&quot;);
//this subset will contain &quot;2&quot;, &quot;3&quot; and &quot;4&quot; because
//    fromInclusive=true, and toInclusive=true 
NavigableSet subset = original.subSet(&quot;2&quot;, true, &quot;4&quot;, true);
</pre>","NavigableSet","java.util.NavigableSet","class",1
,"Java's 
<clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
  NavigableSet 
</clt>Interface","ceiling(), floor(), higher(), and lower()","<h2>ceiling(), floor(), higher(), and lower()</h2> 
<p> The <code> 
  <clt fqn=""java.util.NavigableSet.ceiling"" api=""NavigableSet"" kind=""method"">
    NavigableSet.ceiling() 
  </clt></code> method returns the least (smallest) element in this set that is greater than or equal to the element passed as parameter to the <code> 
  <clt fqn=""java.util.NavigableSet.ceiling"" api=""NavigableSet"" kind=""method"">
    NavigableSet.ceiling() 
  </clt></code> method. Here is an example: </p> 
<pre class=""codeBox"">
NavigableSet original = new TreeSet();
original.add(&quot;1&quot;);
original.add(&quot;2&quot;);
original.add(&quot;3&quot;);
//ceiling will be &quot;2&quot;.
Object ceiling = original.ceiling(&quot;2&quot;);
//floor will be &quot;2&quot;.
Object floor = original.floor(&quot;2&quot;);
</pre> 
<p> The <code> 
  <clt fqn=""java.util.NavigableSet.floor"" api=""NavigableSet"" kind=""method"">
    NavigableSet.floor() 
  </clt></code> method does the opposite of <code> 
  <clt fqn=""java.util.NavigableSet.ceiling"" api=""NavigableSet"" kind=""method"">
    NavigableSet.ceiling() 
  </clt></code> </p> 
<p> The <code> 
  <clt fqn=""java.util.NavigableSet.higher"" api=""NavigableSet"" kind=""method"">
    NavigableSet.higher() 
  </clt></code> method returns the least (smallest) element in this set that is greater than (not equal too) the element passed as parameter to the <code> 
  <clt fqn=""java.util.NavigableSet.higher"" api=""NavigableSet"" kind=""method"">
    NavigableSet.higher() 
  </clt></code> method. Here is an example: </p> 
<pre class=""codeBox"">
NavigableSet original = new TreeSet();
original.add(&quot;1&quot;);
original.add(&quot;2&quot;);
original.add(&quot;3&quot;);
//higher will be &quot;3&quot;.
Object higher = original.higher(&quot;2&quot;);
//lower will be &quot;1&quot;
Object lower = original.lower(&quot;2&quot;);
</pre> 
<p> The <code> 
  <clt fqn=""java.util.NavigableSet.lower"" api=""NavigableSet"" kind=""method"">
    NavigableSet.lower() 
  </clt></code> method does the opposite of the <code> 
  <clt fqn=""java.util.NavigableSet.higher"" api=""NavigableSet"" kind=""method"">
    NavigableSet.higher() 
  </clt></code> method. </p>","NavigableSet","java.util.NavigableSet","class",1
,"Java's 
<clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
  NavigableSet 
</clt>Interface","pollFirst() and pollLast()","<h2>pollFirst() and pollLast()</h2> 
<p> The <code> 
  <clt fqn=""java.util.NavigableSet.pollFirst"" api=""NavigableSet"" kind=""method"">
    NavigableSet.pollFirst() 
  </clt></code> method returns and removes the &quot;first&quot; element in the <code> 
  <clt fqn=""java.util.NavigableSet"" api=""NavigableSet"" kind=""class"">
    NavigableSet 
  </clt></code> or null if the set is empty. The <code> 
  <clt fqn=""java.util.NavigableSet.pollLast"" api=""NavigableSet"" kind=""method"">
    NavigableSet.pollLast() 
  </clt></code> returns and removes the &quot;last&quot; element in the set or null if the set is empty. &quot;First&quot; means smallest element according to the sort order of the set. &quot;Last&quot; means largest according to teh element sorting order of the set. </p> 
<p> Here are two examples: </p> 
<pre class=""codeBox"">
NavigableSet original = new TreeSet();
original.add(&quot;1&quot;);
original.add(&quot;2&quot;);
original.add(&quot;3&quot;);
//first is &quot;1&quot;
Object first = original.pollFirst();
//last is &quot;3&quot;
Object last = original.pollLast();
</pre>","NavigableSet","java.util.NavigableSet","class",1
,"Generic 
<clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
  Collections 
</clt>in Java","Generic Collections in Java","<h1>Generic 
 <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
   Collections 
 </clt>in Java</h1> 
<p> It is possible to generify the various Collection and Map types and subtypes in the Java collection API. This text will not cover generics in detail. Java Generics is covered in my <a href=""/java-generics/index.html"">Java Generics tutorial</a>. </p> 
<p> The Collection interface can be generified like this: </p> 
<pre class=""codeBox"">
Collection&lt;String&gt; stringCollection = new HashSet&lt;String&gt;();
</pre> 
<p> This <code>stringCollection</code> can now only contain <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> instances. If you try to add anything else, or cast the elements in the collection to any other type than <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code>, the compiler will complain. </p> 
<p> Actually, it is possible to insert other objects than String objects, if you cheat a little (or is just plain stupid), but this is not recommended. </p> 
<p> You can iterate the above collection using the new for-loop, like this: </p> 
<pre class=""codeBox"">
Collection&lt;String&gt; stringCollection = new HashSet&lt;String&gt;();
for(String stringElement : stringCollection) {
//do something with each stringElement    
}
</pre> 
<p> You can do the same thing with <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List's 
  </clt></code>, <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set's 
  </clt></code> etc. </p> 
<p> I won't get into much more detail about generic collections here. Like I said in the beginning, I have a separate Java Generics tutorial. Additionally, more generic examples will be shown in the texts on the specific collection types. </p>","Collections","java.util.Collections","class",0
,"Generic 
<clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
  Collections 
</clt>in Java","Generic Collections in Java","<h1>Generic 
 <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
   Collections 
 </clt>in Java</h1> 
<p> It is possible to generify the various Collection and Map types and subtypes in the Java collection API. This text will not cover generics in detail. Java Generics is covered in my <a href=""/java-generics/index.html"">Java Generics tutorial</a>. </p> 
<p> The Collection interface can be generified like this: </p> 
<pre class=""codeBox"">
Collection&lt;String&gt; stringCollection = new HashSet&lt;String&gt;();
</pre> 
<p> This <code>stringCollection</code> can now only contain <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> instances. If you try to add anything else, or cast the elements in the collection to any other type than <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code>, the compiler will complain. </p> 
<p> Actually, it is possible to insert other objects than String objects, if you cheat a little (or is just plain stupid), but this is not recommended. </p> 
<p> You can iterate the above collection using the new for-loop, like this: </p> 
<pre class=""codeBox"">
Collection&lt;String&gt; stringCollection = new HashSet&lt;String&gt;();
for(String stringElement : stringCollection) {
//do something with each stringElement    
}
</pre> 
<p> You can do the same thing with <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List's 
  </clt></code>, <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set's 
  </clt></code> etc. </p> 
<p> I won't get into much more detail about generic collections here. Like I said in the beginning, I have a separate Java Generics tutorial. Additionally, more generic examples will be shown in the texts on the specific collection types. </p>","String","java.lang.String","class",0
,"Generic 
<clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
  Collections 
</clt>in Java","Generic Collections in Java","<h1>Generic 
 <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
   Collections 
 </clt>in Java</h1> 
<p> It is possible to generify the various Collection and Map types and subtypes in the Java collection API. This text will not cover generics in detail. Java Generics is covered in my <a href=""/java-generics/index.html"">Java Generics tutorial</a>. </p> 
<p> The Collection interface can be generified like this: </p> 
<pre class=""codeBox"">
Collection&lt;String&gt; stringCollection = new HashSet&lt;String&gt;();
</pre> 
<p> This <code>stringCollection</code> can now only contain <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> instances. If you try to add anything else, or cast the elements in the collection to any other type than <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code>, the compiler will complain. </p> 
<p> Actually, it is possible to insert other objects than String objects, if you cheat a little (or is just plain stupid), but this is not recommended. </p> 
<p> You can iterate the above collection using the new for-loop, like this: </p> 
<pre class=""codeBox"">
Collection&lt;String&gt; stringCollection = new HashSet&lt;String&gt;();
for(String stringElement : stringCollection) {
//do something with each stringElement    
}
</pre> 
<p> You can do the same thing with <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List's 
  </clt></code>, <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set's 
  </clt></code> etc. </p> 
<p> I won't get into much more detail about generic collections here. Like I said in the beginning, I have a separate Java Generics tutorial. Additionally, more generic examples will be shown in the texts on the specific collection types. </p>","List","java.util.List","class",0
,"Generic 
<clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
  Collections 
</clt>in Java","Generic Collections in Java","<h1>Generic 
 <clt fqn=""java.util.Collections"" api=""Collections"" kind=""class"">
   Collections 
 </clt>in Java</h1> 
<p> It is possible to generify the various Collection and Map types and subtypes in the Java collection API. This text will not cover generics in detail. Java Generics is covered in my <a href=""/java-generics/index.html"">Java Generics tutorial</a>. </p> 
<p> The Collection interface can be generified like this: </p> 
<pre class=""codeBox"">
Collection&lt;String&gt; stringCollection = new HashSet&lt;String&gt;();
</pre> 
<p> This <code>stringCollection</code> can now only contain <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code> instances. If you try to add anything else, or cast the elements in the collection to any other type than <code> 
  <clt fqn=""java.lang.String"" api=""String"" kind=""class"">
    String 
  </clt></code>, the compiler will complain. </p> 
<p> Actually, it is possible to insert other objects than String objects, if you cheat a little (or is just plain stupid), but this is not recommended. </p> 
<p> You can iterate the above collection using the new for-loop, like this: </p> 
<pre class=""codeBox"">
Collection&lt;String&gt; stringCollection = new HashSet&lt;String&gt;();
for(String stringElement : stringCollection) {
//do something with each stringElement    
}
</pre> 
<p> You can do the same thing with <code> 
  <clt fqn=""java.util.List"" api=""List"" kind=""class"">
    List's 
  </clt></code>, <code> 
  <clt fqn=""java.util.Set"" api=""Set"" kind=""class"">
    Set's 
  </clt></code> etc. </p> 
<p> I won't get into much more detail about generic collections here. Like I said in the beginning, I have a separate Java Generics tutorial. Additionally, more generic examples will be shown in the texts on the specific collection types. </p>","Set","java.util.Set","class",0
