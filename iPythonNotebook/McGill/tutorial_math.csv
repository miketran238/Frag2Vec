,"4 Numerical Analysis","4.3 Root-finding","<h3>4.3 Root-finding</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateDifferentiableSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateDifferentiableSolver"" api=""UnivariateDifferentiableSolver"" kind=""class"">
    UnivariateDifferentiableSolver 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PolynomialSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PolynomialSolver"" api=""PolynomialSolver"" kind=""class"">
    PolynomialSolver 
  </clt></a> provide means to find roots of <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a>, <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiable.html"">differentiable univariate real-valued functions</a>, and <a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a> respectively. A root is the value where the function takes the value 0. Commons-Math includes implementations of the several root-finding algorithms: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""5""><font size=""+2"">Root solvers</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>Function type</td> 
   <td>Convergence</td> 
   <td>Needs initial bracketing</td> 
   <td>Bracket side selection</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BisectionSolver.html"">Bisection</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BrentSolver.html"">Brent-Dekker</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketingNthOrderBrentSolver.html"">bracketing n<sup>th</sup> order Brent</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>variable order, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/IllinoisSolver.html"">Illinois Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/LaguerreSolver.html"">Laguerre's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a></td> 
   <td>cubic for simple root, linear for multiple root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver.html"">Muller's Method</a> using bracketing to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to roots</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver2.html"">Muller's Method</a> using modulus to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/NewtonRaphsonSolver.html"">Newton-Raphson's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html"">differentiable univariate real-valued functions</a></td> 
   <td>quadratic, non-guaranteed</td> 
   <td>no</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PegasusSolver.html"">Pegasus Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RegulaFalsiSolver.html"">Regula Falsi (false position) Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RiddersSolver.html"">Ridder's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/SecantSolver.html"">Secant Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, non-guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
 </tbody> 
</table>","UnivariateSolver","org.apache.commons.math3.analysis.solvers.UnivariateSolver","class",0
,"4 Numerical Analysis","4.3 Root-finding","<h3>4.3 Root-finding</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateDifferentiableSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateDifferentiableSolver"" api=""UnivariateDifferentiableSolver"" kind=""class"">
    UnivariateDifferentiableSolver 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PolynomialSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PolynomialSolver"" api=""PolynomialSolver"" kind=""class"">
    PolynomialSolver 
  </clt></a> provide means to find roots of <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a>, <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiable.html"">differentiable univariate real-valued functions</a>, and <a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a> respectively. A root is the value where the function takes the value 0. Commons-Math includes implementations of the several root-finding algorithms: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""5""><font size=""+2"">Root solvers</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>Function type</td> 
   <td>Convergence</td> 
   <td>Needs initial bracketing</td> 
   <td>Bracket side selection</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BisectionSolver.html"">Bisection</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BrentSolver.html"">Brent-Dekker</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketingNthOrderBrentSolver.html"">bracketing n<sup>th</sup> order Brent</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>variable order, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/IllinoisSolver.html"">Illinois Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/LaguerreSolver.html"">Laguerre's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a></td> 
   <td>cubic for simple root, linear for multiple root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver.html"">Muller's Method</a> using bracketing to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to roots</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver2.html"">Muller's Method</a> using modulus to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/NewtonRaphsonSolver.html"">Newton-Raphson's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html"">differentiable univariate real-valued functions</a></td> 
   <td>quadratic, non-guaranteed</td> 
   <td>no</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PegasusSolver.html"">Pegasus Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RegulaFalsiSolver.html"">Regula Falsi (false position) Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RiddersSolver.html"">Ridder's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/SecantSolver.html"">Secant Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, non-guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
 </tbody> 
</table>","UnivariateDifferentiableSolver","org.apache.commons.math3.analysis.solvers.UnivariateDifferentiableSolver","class",0
,"4 Numerical Analysis","4.3 Root-finding","<h3>4.3 Root-finding</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/UnivariateDifferentiableSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateDifferentiableSolver"" api=""UnivariateDifferentiableSolver"" kind=""class"">
    UnivariateDifferentiableSolver 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PolynomialSolver.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PolynomialSolver"" api=""PolynomialSolver"" kind=""class"">
    PolynomialSolver 
  </clt></a> provide means to find roots of <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a>, <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiable.html"">differentiable univariate real-valued functions</a>, and <a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a> respectively. A root is the value where the function takes the value 0. Commons-Math includes implementations of the several root-finding algorithms: </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""5""><font size=""+2"">Root solvers</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>Function type</td> 
   <td>Convergence</td> 
   <td>Needs initial bracketing</td> 
   <td>Bracket side selection</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BisectionSolver.html"">Bisection</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BrentSolver.html"">Brent-Dekker</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketingNthOrderBrentSolver.html"">bracketing n<sup>th</sup> order Brent</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>variable order, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/IllinoisSolver.html"">Illinois Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/LaguerreSolver.html"">Laguerre's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html"">polynomial functions</a></td> 
   <td>cubic for simple root, linear for multiple root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver.html"">Muller's Method</a> using bracketing to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to roots</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/MullerSolver2.html"">Muller's Method</a> using modulus to deal with real-valued functions</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>quadratic close to root</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/NewtonRaphsonSolver.html"">Newton-Raphson's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html"">differentiable univariate real-valued functions</a></td> 
   <td>quadratic, non-guaranteed</td> 
   <td>no</td> 
   <td>no</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/PegasusSolver.html"">Pegasus Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RegulaFalsiSolver.html"">Regula Falsi (false position) Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>linear, guaranteed</td> 
   <td>yes</td> 
   <td>yes</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/RiddersSolver.html"">Ridder's Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/solvers/SecantSolver.html"">Secant Method</a></td> 
   <td><a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html"">univariate real-valued functions</a></td> 
   <td>super-linear, non-guaranteed</td> 
   <td>yes</td> 
   <td>no</td> 
  </tr> 
 </tbody> 
</table>","PolynomialSolver","org.apache.commons.math3.analysis.solvers.PolynomialSolver","class",0
,"4 Numerical Analysis","4.3 Root-finding - part 4","<h3>4.3 Root-finding - part 4</h3>
<p> In order to use the root-finding features, first a solver object must be created by calling its constructor, often providing relative and absolute accuracy. Using a solver object, roots of functions are easily found using the <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver.solve"" api=""BracketingNthOrderBrentSolver"" kind=""unknown"">
   BracketingNthOrderBrentSolver.solve
  </clt></tt> methods. These methods takes a maximum iteration count <tt>maxEval</tt>, a function <tt>f</tt>, and either two domain values, <tt>min</tt> and <tt>max</tt>, or a <tt>startValue</tt> as parameters. If the maximal number of iterations count is exceeded, non-convergence is assumed and a <tt> 
  <clt fqn=""org.apache.commons.math3.exception.ConvergenceException"" api=""ConvergenceException"" kind=""class"">
    ConvergenceException 
  </clt></tt> exception is thrown. A suggested value is 100, which should be plenty, given that a bisection algorithm can't get any more accurate after 52 iterations because of the number of mantissa bits in a double precision floating point number. If a number of ill-conditioned problems is to be solved, this number can be decreased in order to avoid wasting time. <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketedUnivariateSolver.html"">Bracketed solvers</a> also take an <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/AllowedSolution.html"">allowed solution</a> enum parameter to specify which side of the final convergence interval should be selected as the root. It can be <tt>ANY_SIDE</tt>, <tt>LEFT_SIDE</tt>, <tt>RIGHT_SIDE</tt>, <tt>BELOW_SIDE</tt> or <tt>ABOVE_SIDE</tt>. Left and right are used to specify the root along the function parameter axis while below and above refer to the function value axis. The solve methods compute a value <tt>c</tt> such that: </p> 
<ul> 
 <li><tt>f(c) = 0.0</tt> (see &quot;function value accuracy&quot;)</li> 
 <li><tt>min &lt;= c &lt;= max</tt> (except for the secant method, which may find a solution outside the interval)</li> 
</ul>","BracketingNthOrderBrentSolver","org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver","class",1
,"4 Numerical Analysis","4.3 Root-finding - part 4","<h3>4.3 Root-finding - part 4</h3>
<p> In order to use the root-finding features, first a solver object must be created by calling its constructor, often providing relative and absolute accuracy. Using a solver object, roots of functions are easily found using the <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver.solve"" api=""BracketingNthOrderBrentSolver"" kind=""unknown"">
   BracketingNthOrderBrentSolver.solve
  </clt></tt> methods. These methods takes a maximum iteration count <tt>maxEval</tt>, a function <tt>f</tt>, and either two domain values, <tt>min</tt> and <tt>max</tt>, or a <tt>startValue</tt> as parameters. If the maximal number of iterations count is exceeded, non-convergence is assumed and a <tt> 
  <clt fqn=""org.apache.commons.math3.exception.ConvergenceException"" api=""ConvergenceException"" kind=""class"">
    ConvergenceException 
  </clt></tt> exception is thrown. A suggested value is 100, which should be plenty, given that a bisection algorithm can't get any more accurate after 52 iterations because of the number of mantissa bits in a double precision floating point number. If a number of ill-conditioned problems is to be solved, this number can be decreased in order to avoid wasting time. <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/BracketedUnivariateSolver.html"">Bracketed solvers</a> also take an <a href=""../apidocs/org/apache/commons/math3/analysis/solvers/AllowedSolution.html"">allowed solution</a> enum parameter to specify which side of the final convergence interval should be selected as the root. It can be <tt>ANY_SIDE</tt>, <tt>LEFT_SIDE</tt>, <tt>RIGHT_SIDE</tt>, <tt>BELOW_SIDE</tt> or <tt>ABOVE_SIDE</tt>. Left and right are used to specify the root along the function parameter axis while below and above refer to the function value axis. The solve methods compute a value <tt>c</tt> such that: </p> 
<ul> 
 <li><tt>f(c) = 0.0</tt> (see &quot;function value accuracy&quot;)</li> 
 <li><tt>min &lt;= c &lt;= max</tt> (except for the secant method, which may find a solution outside the interval)</li> 
</ul>","ConvergenceException","org.apache.commons.math3.exception.ConvergenceException","class",1
,"4 Numerical Analysis","4.3 Root-finding - part 5","<h3>4.3 Root-finding - part 5</h3>
<p> Typical usage: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
final int    maxOrder         = 5;
UnivariateSolver solver   = new BracketingNthOrderBrentSolver(relativeAccuracy, absoluteAccuracy, maxOrder);
double c = solver.solve(100, function, 1.0, 5.0, AllowedSolution.LEFT_SIDE);</pre> 
</div> 
<p> Force bracketing, by refining a base solution found by a non-bracketing solver: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
UnivariateSolver nonBracketing = new BrentSolver(relativeAccuracy, absoluteAccuracy);
double baseRoot = nonBracketing.solve(100, function, 1.0, 5.0);
double c = UnivariateSolverUtils.forceSide(100, function,
                                           new PegasusSolver(relativeAccuracy, absoluteAccuracy),
                                           baseRoot, 1.0, 5.0, AllowedSolution.LEFT_SIDE);
</pre> 
</div> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BrentSolver"" api=""BrentSolver"" kind=""class"">
    BrentSolver 
  </clt></tt> uses the Brent-Dekker algorithm which is fast and robust. If there are multiple roots in the interval, or there is a large domain of indeterminacy, the algorithm will converge to a random root in the interval without indication that there are problems. Interestingly, the examined text book implementations all disagree in details of the convergence criteria. Also each implementation had problems for one of the test cases, so the expressions had to be fudged further. Don't expect to get exactly the same root values as for other implementations of this algorithm. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver"" api=""BracketingNthOrderBrentSolver"" kind=""class"">
    BracketingNthOrderBrentSolver 
  </clt></tt> uses an extension of the Brent-Dekker algorithm which uses inverse n<sup>th</sup> order polynomial interpolation instead of inverse quadratic interpolation, and which allows selection of the side of the convergence interval for result bracketing. This is now the recommended algorithm for most users since it has the largest order, doesn't require derivatives, has guaranteed convergence and allows result bracket selection. </p>","BrentSolver","org.apache.commons.math3.analysis.solvers.BrentSolver","class",1
,"4 Numerical Analysis","4.3 Root-finding - part 5","<h3>4.3 Root-finding - part 5</h3>
<p> Typical usage: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
final int    maxOrder         = 5;
UnivariateSolver solver   = new BracketingNthOrderBrentSolver(relativeAccuracy, absoluteAccuracy, maxOrder);
double c = solver.solve(100, function, 1.0, 5.0, AllowedSolution.LEFT_SIDE);</pre> 
</div> 
<p> Force bracketing, by refining a base solution found by a non-bracketing solver: </p> 
<div class=""source""> 
 <pre>UnivariateFunction function = // some user defined function object
final double relativeAccuracy = 1.0e-12;
final double absoluteAccuracy = 1.0e-8;
UnivariateSolver nonBracketing = new BrentSolver(relativeAccuracy, absoluteAccuracy);
double baseRoot = nonBracketing.solve(100, function, 1.0, 5.0);
double c = UnivariateSolverUtils.forceSide(100, function,
                                           new PegasusSolver(relativeAccuracy, absoluteAccuracy),
                                           baseRoot, 1.0, 5.0, AllowedSolution.LEFT_SIDE);
</pre> 
</div> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BrentSolver"" api=""BrentSolver"" kind=""class"">
    BrentSolver 
  </clt></tt> uses the Brent-Dekker algorithm which is fast and robust. If there are multiple roots in the interval, or there is a large domain of indeterminacy, the algorithm will converge to a random root in the interval without indication that there are problems. Interestingly, the examined text book implementations all disagree in details of the convergence criteria. Also each implementation had problems for one of the test cases, so the expressions had to be fudged further. Don't expect to get exactly the same root values as for other implementations of this algorithm. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver"" api=""BracketingNthOrderBrentSolver"" kind=""class"">
    BracketingNthOrderBrentSolver 
  </clt></tt> uses an extension of the Brent-Dekker algorithm which uses inverse n<sup>th</sup> order polynomial interpolation instead of inverse quadratic interpolation, and which allows selection of the side of the convergence interval for result bracketing. This is now the recommended algorithm for most users since it has the largest order, doesn't require derivatives, has guaranteed convergence and allows result bracket selection. </p>","BracketingNthOrderBrentSolver","org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver","class",1
,"4 Numerical Analysis","4.3 Root-finding - part 6","<h3>4.3 Root-finding - part 6</h3>
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.SecantSolver"" api=""SecantSolver"" kind=""class"">
    SecantSolver 
  </clt></tt> uses a straightforward secant algorithm which does not bracket the search and therefore does not guarantee convergence. It may be faster than Brent on some well-behaved functions. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.RegulaFalsiSolver"" api=""RegulaFalsiSolver"" kind=""class"">
    RegulaFalsiSolver 
  </clt></tt> is variation of secant preserving bracketing, but then it may be slow, as one end point of the search interval will become fixed after and only the other end point will converge to the root, hence resulting in a search interval size that does not decrease to zero. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.IllinoisSolver"" api=""IllinoisSolver"" kind=""class"">
    IllinoisSolver 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PegasusSolver"" api=""PegasusSolver"" kind=""class"">
    PegasusSolver 
  </clt></tt> are well-known variations of regula falsi that fix the problem of stuck end points by slightly weighting one endpoint to balance the interval at next iteration. Pegasus is often faster than Illinois. Pegasus may be the algorithm of choice for selecting a specific side of the convergence interval. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BisectionSolver"" api=""BisectionSolver"" kind=""class"">
    BisectionSolver 
  </clt></tt> is included for completeness and for establishing a fall back in cases of emergency. The algorithm is simple, most likely bug free and guaranteed to converge even in very adverse circumstances which might cause other algorithms to malfunction. The drawback is of course that it is also guaranteed to be slow. </p>","SecantSolver","org.apache.commons.math3.analysis.solvers.SecantSolver","class",1
,"4 Numerical Analysis","4.3 Root-finding - part 6","<h3>4.3 Root-finding - part 6</h3>
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.SecantSolver"" api=""SecantSolver"" kind=""class"">
    SecantSolver 
  </clt></tt> uses a straightforward secant algorithm which does not bracket the search and therefore does not guarantee convergence. It may be faster than Brent on some well-behaved functions. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.RegulaFalsiSolver"" api=""RegulaFalsiSolver"" kind=""class"">
    RegulaFalsiSolver 
  </clt></tt> is variation of secant preserving bracketing, but then it may be slow, as one end point of the search interval will become fixed after and only the other end point will converge to the root, hence resulting in a search interval size that does not decrease to zero. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.IllinoisSolver"" api=""IllinoisSolver"" kind=""class"">
    IllinoisSolver 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PegasusSolver"" api=""PegasusSolver"" kind=""class"">
    PegasusSolver 
  </clt></tt> are well-known variations of regula falsi that fix the problem of stuck end points by slightly weighting one endpoint to balance the interval at next iteration. Pegasus is often faster than Illinois. Pegasus may be the algorithm of choice for selecting a specific side of the convergence interval. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BisectionSolver"" api=""BisectionSolver"" kind=""class"">
    BisectionSolver 
  </clt></tt> is included for completeness and for establishing a fall back in cases of emergency. The algorithm is simple, most likely bug free and guaranteed to converge even in very adverse circumstances which might cause other algorithms to malfunction. The drawback is of course that it is also guaranteed to be slow. </p>","RegulaFalsiSolver","org.apache.commons.math3.analysis.solvers.RegulaFalsiSolver","class",1
,"4 Numerical Analysis","4.3 Root-finding - part 6","<h3>4.3 Root-finding - part 6</h3>
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.SecantSolver"" api=""SecantSolver"" kind=""class"">
    SecantSolver 
  </clt></tt> uses a straightforward secant algorithm which does not bracket the search and therefore does not guarantee convergence. It may be faster than Brent on some well-behaved functions. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.RegulaFalsiSolver"" api=""RegulaFalsiSolver"" kind=""class"">
    RegulaFalsiSolver 
  </clt></tt> is variation of secant preserving bracketing, but then it may be slow, as one end point of the search interval will become fixed after and only the other end point will converge to the root, hence resulting in a search interval size that does not decrease to zero. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.IllinoisSolver"" api=""IllinoisSolver"" kind=""class"">
    IllinoisSolver 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PegasusSolver"" api=""PegasusSolver"" kind=""class"">
    PegasusSolver 
  </clt></tt> are well-known variations of regula falsi that fix the problem of stuck end points by slightly weighting one endpoint to balance the interval at next iteration. Pegasus is often faster than Illinois. Pegasus may be the algorithm of choice for selecting a specific side of the convergence interval. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BisectionSolver"" api=""BisectionSolver"" kind=""class"">
    BisectionSolver 
  </clt></tt> is included for completeness and for establishing a fall back in cases of emergency. The algorithm is simple, most likely bug free and guaranteed to converge even in very adverse circumstances which might cause other algorithms to malfunction. The drawback is of course that it is also guaranteed to be slow. </p>","IllinoisSolver","org.apache.commons.math3.analysis.solvers.IllinoisSolver","class",1
,"4 Numerical Analysis","4.3 Root-finding - part 6","<h3>4.3 Root-finding - part 6</h3>
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.SecantSolver"" api=""SecantSolver"" kind=""class"">
    SecantSolver 
  </clt></tt> uses a straightforward secant algorithm which does not bracket the search and therefore does not guarantee convergence. It may be faster than Brent on some well-behaved functions. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.RegulaFalsiSolver"" api=""RegulaFalsiSolver"" kind=""class"">
    RegulaFalsiSolver 
  </clt></tt> is variation of secant preserving bracketing, but then it may be slow, as one end point of the search interval will become fixed after and only the other end point will converge to the root, hence resulting in a search interval size that does not decrease to zero. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.IllinoisSolver"" api=""IllinoisSolver"" kind=""class"">
    IllinoisSolver 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PegasusSolver"" api=""PegasusSolver"" kind=""class"">
    PegasusSolver 
  </clt></tt> are well-known variations of regula falsi that fix the problem of stuck end points by slightly weighting one endpoint to balance the interval at next iteration. Pegasus is often faster than Illinois. Pegasus may be the algorithm of choice for selecting a specific side of the convergence interval. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BisectionSolver"" api=""BisectionSolver"" kind=""class"">
    BisectionSolver 
  </clt></tt> is included for completeness and for establishing a fall back in cases of emergency. The algorithm is simple, most likely bug free and guaranteed to converge even in very adverse circumstances which might cause other algorithms to malfunction. The drawback is of course that it is also guaranteed to be slow. </p>","PegasusSolver","org.apache.commons.math3.analysis.solvers.PegasusSolver","class",1
,"4 Numerical Analysis","4.3 Root-finding - part 6","<h3>4.3 Root-finding - part 6</h3>
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.SecantSolver"" api=""SecantSolver"" kind=""class"">
    SecantSolver 
  </clt></tt> uses a straightforward secant algorithm which does not bracket the search and therefore does not guarantee convergence. It may be faster than Brent on some well-behaved functions. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.RegulaFalsiSolver"" api=""RegulaFalsiSolver"" kind=""class"">
    RegulaFalsiSolver 
  </clt></tt> is variation of secant preserving bracketing, but then it may be slow, as one end point of the search interval will become fixed after and only the other end point will converge to the root, hence resulting in a search interval size that does not decrease to zero. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.IllinoisSolver"" api=""IllinoisSolver"" kind=""class"">
    IllinoisSolver 
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.PegasusSolver"" api=""PegasusSolver"" kind=""class"">
    PegasusSolver 
  </clt></tt> are well-known variations of regula falsi that fix the problem of stuck end points by slightly weighting one endpoint to balance the interval at next iteration. Pegasus is often faster than Illinois. Pegasus may be the algorithm of choice for selecting a specific side of the convergence interval. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.BisectionSolver"" api=""BisectionSolver"" kind=""class"">
    BisectionSolver 
  </clt></tt> is included for completeness and for establishing a fall back in cases of emergency. The algorithm is simple, most likely bug free and guaranteed to converge even in very adverse circumstances which might cause other algorithms to malfunction. The drawback is of course that it is also guaranteed to be slow. </p>","BisectionSolver","org.apache.commons.math3.analysis.solvers.BisectionSolver","class",1
,"4 Numerical Analysis","4.3 Root-finding - part 7","<h3>4.3 Root-finding - part 7</h3>
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.solvers.UnivariateSolver"" api=""UnivariateSolver"" kind=""class"">
    UnivariateSolver 
  </clt></tt> interface exposes many properties to control the convergence of a solver. The accuracy properties are set at solver instance creation and cannot be changed afterwards, there are only getters to retriveve their values, no setters are available. </p> 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Property</th> 
   <th>Purpose</th> 
  </tr> 
  <tr class=""b""> 
   <td>Absolute accuracy</td> 
   <td> The Absolute Accuracy is (estimated) maximal difference between the computed root and the true root of the function. This is what most people think of as &quot;accuracy&quot; intuitively. The default value is chosen as a sane value for most real world problems, for roots in the range from -100 to +100. For accurate computation of roots near zero, in the range form -0.0001 to +0.0001, the value may be decreased. For computing roots much larger in absolute value than 100, the default absolute accuracy may never be reached because the given relative accuracy is reached first. </td> 
  </tr> 
  <tr class=""a""> 
   <td>Relative accuracy</td> 
   <td> The Relative Accuracy is the maximal difference between the computed root and the true root, divided by the maximum of the absolute values of the numbers. This accuracy measurement is better suited for numerical calculations with computers, due to the way floating point numbers are represented. The default value is chosen so that algorithms will get a result even for roots with large absolute values, even while it may be impossible to reach the given absolute accuracy. </td> 
  </tr> 
  <tr class=""b""> 
   <td>Function value accuracy</td> 
   <td> This value is used by some algorithms in order to prevent numerical instabilities. If the function is evaluated to an absolute value smaller than the Function Value Accuracy, the algorithms assume they hit a root and return the value immediately. The default value is a &quot;very small value&quot;. If the goal is to get a near zero function value rather than an accurate root, computation may be sped up by setting this value appropriately. </td> 
  </tr> 
 </tbody> 
</table>","UnivariateSolver","org.apache.commons.math3.analysis.solvers.UnivariateSolver","class",1
,"4 Numerical Analysis","4.4 Interpolation","<h3>4.4 Interpolation</h3> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/UnivariateInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.UnivariateInterpolator"" api=""UnivariateInterpolator"" kind=""class"">
    UnivariateInterpolator 
  </clt></a> is used to find a univariate real-valued function <tt>f</tt> which for a given set of ordered pairs (<tt>x<sub>i</sub></tt>,<tt>y<sub>i</sub></tt>) yields <tt>f(x<sub>i</sub>)=y<sub>i</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.UnivariateFunction"" api=""UnivariateFunction"" kind=""class"">
    UnivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including point not belonging to the original set. Currently, only an interpolator for generating natural cubic splines and a polynomial interpolator are available. There is no interpolator factory, mainly because the interpolation algorithm is more determined by the kind of the interpolated function rather than the set of points to interpolate. There aren't currently any accuracy controls either, as interpolation accuracy is in general determined by the algorithm. </p> 
<p>Typical usage:</p> 
<div class=""source""> 
 <pre>double x[] = { 0.0, 1.0, 2.0 };
double y[] = { 1.0, -1.0, 2.0);
UnivariateInterpolator interpolator = new SplineInterpolator();
UnivariateFunction function = interpolator.interpolate(x, y);
double interpolationX = 0.5;
double interpolatedY = function.evaluate(x);
System.out println(&quot;f(&quot; + interpolationX + &quot;) = &quot; + interpolatedY);</pre> 
</div> 
<p> A natural cubic spline is a function consisting of a polynomial of third degree for each subinterval determined by the x-coordinates of the interpolated points. A function interpolating <tt>N</tt> value pairs consists of <tt>N-1</tt> polynomials. The function is continuous, smooth and can be differentiated twice. The second derivative is continuous but not smooth. The x values passed to the interpolator must be ordered in ascending order. It is not valid to evaluate the function for values outside the range <tt>x<sub>0</sub></tt>..<tt>x<sub>N</sub></tt>. </p>","UnivariateInterpolator","org.apache.commons.math3.analysis.interpolation.UnivariateInterpolator","class",0
,"4 Numerical Analysis","4.4 Interpolation","<h3>4.4 Interpolation</h3> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/UnivariateInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.UnivariateInterpolator"" api=""UnivariateInterpolator"" kind=""class"">
    UnivariateInterpolator 
  </clt></a> is used to find a univariate real-valued function <tt>f</tt> which for a given set of ordered pairs (<tt>x<sub>i</sub></tt>,<tt>y<sub>i</sub></tt>) yields <tt>f(x<sub>i</sub>)=y<sub>i</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.UnivariateFunction"" api=""UnivariateFunction"" kind=""class"">
    UnivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including point not belonging to the original set. Currently, only an interpolator for generating natural cubic splines and a polynomial interpolator are available. There is no interpolator factory, mainly because the interpolation algorithm is more determined by the kind of the interpolated function rather than the set of points to interpolate. There aren't currently any accuracy controls either, as interpolation accuracy is in general determined by the algorithm. </p> 
<p>Typical usage:</p> 
<div class=""source""> 
 <pre>double x[] = { 0.0, 1.0, 2.0 };
double y[] = { 1.0, -1.0, 2.0);
UnivariateInterpolator interpolator = new SplineInterpolator();
UnivariateFunction function = interpolator.interpolate(x, y);
double interpolationX = 0.5;
double interpolatedY = function.evaluate(x);
System.out println(&quot;f(&quot; + interpolationX + &quot;) = &quot; + interpolatedY);</pre> 
</div> 
<p> A natural cubic spline is a function consisting of a polynomial of third degree for each subinterval determined by the x-coordinates of the interpolated points. A function interpolating <tt>N</tt> value pairs consists of <tt>N-1</tt> polynomials. The function is continuous, smooth and can be differentiated twice. The second derivative is continuous but not smooth. The x values passed to the interpolator must be ordered in ascending order. It is not valid to evaluate the function for values outside the range <tt>x<sub>0</sub></tt>..<tt>x<sub>N</sub></tt>. </p>","UnivariateFunction","org.apache.commons.math3.analysis.UnivariateFunction","class",0
,"4 Numerical Analysis","4.4 Interpolation - part 3","<h3>4.4 Interpolation - part 3</h3>
<p> Microsphere interpolation is a robust multidimensional interpolation algorithm. It has been described in William Dudziak's <a class=""externalLink"" href=""http://www.dudziak.com/microsphere.pdf"">MS thesis</a>. </p> 
<p> <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Hermite_interpolation"">Hermite interpolation</a> is an interpolation method that can use derivatives in addition to function values at sample points. The <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/HermiteInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.HermiteInterpolator"" api=""HermiteInterpolator"" kind=""class"">
    HermiteInterpolator 
  </clt></a> class implements this method for vector-valued functions. The sampling points can have any spacing (there are no requirements for a regular grid) and some points may provide derivatives while others don't provide them (or provide derivatives to a smaller order). Points are added one at a time, as shown in the following example: </p> 
<div class=""source""> 
 <pre>HermiteInterpolator interpolator = new HermiteInterpolator;
// at x = 0, we provide both value and first derivative
interpolator.addSamplePoint(0.0, new double[] { 1.0 }, new double[] { 2.0 });
// at x = 1, we provide only function value
interpolator.addSamplePoint(1.0, new double[] { 4.0 });
// at x = 2, we provide both value and first derivative
interpolator.addSamplePoint(2.0, new double[] { 5.0 }, new double[] { 2.0 });
// should print &quot;value at x = 0.5: 2.5625&quot;
System.out.println(&quot;value at x = 0.5: &quot; + interpolator.value(0.5)[0]);
// should print &quot;derivative at x = 0.5: 3.5&quot;
System.out.println(&quot;derivative at x = 0.5: &quot; + interpolator.derivative(0.5)[0]);
// should print &quot;interpolation polynomial: 1 + 2 x + 4 x^2 - 4 x^3 + x^4&quot;
System.out.println(&quot;interpolation polynomial: &quot; + interpolator.getPolynomials()[0]);</pre> 
</div> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BivariateGridInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.BivariateGridInterpolator"" api=""BivariateGridInterpolator"" kind=""class"">
    BivariateGridInterpolator 
  </clt></a> is used to find a bivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>f<sub>ij</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>)=f<sub>ij</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/BivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.BivariateFunction"" api=""BivariateFunction"" kind=""class"">
    BivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt> and <tt>y<sub>j</sub></tt> must be sorted in increasing order in order to define a two-dimensional grid. </p>","HermiteInterpolator","org.apache.commons.math3.analysis.interpolation.HermiteInterpolator","class",1
,"4 Numerical Analysis","4.4 Interpolation - part 3","<h3>4.4 Interpolation - part 3</h3>
<p> Microsphere interpolation is a robust multidimensional interpolation algorithm. It has been described in William Dudziak's <a class=""externalLink"" href=""http://www.dudziak.com/microsphere.pdf"">MS thesis</a>. </p> 
<p> <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Hermite_interpolation"">Hermite interpolation</a> is an interpolation method that can use derivatives in addition to function values at sample points. The <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/HermiteInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.HermiteInterpolator"" api=""HermiteInterpolator"" kind=""class"">
    HermiteInterpolator 
  </clt></a> class implements this method for vector-valued functions. The sampling points can have any spacing (there are no requirements for a regular grid) and some points may provide derivatives while others don't provide them (or provide derivatives to a smaller order). Points are added one at a time, as shown in the following example: </p> 
<div class=""source""> 
 <pre>HermiteInterpolator interpolator = new HermiteInterpolator;
// at x = 0, we provide both value and first derivative
interpolator.addSamplePoint(0.0, new double[] { 1.0 }, new double[] { 2.0 });
// at x = 1, we provide only function value
interpolator.addSamplePoint(1.0, new double[] { 4.0 });
// at x = 2, we provide both value and first derivative
interpolator.addSamplePoint(2.0, new double[] { 5.0 }, new double[] { 2.0 });
// should print &quot;value at x = 0.5: 2.5625&quot;
System.out.println(&quot;value at x = 0.5: &quot; + interpolator.value(0.5)[0]);
// should print &quot;derivative at x = 0.5: 3.5&quot;
System.out.println(&quot;derivative at x = 0.5: &quot; + interpolator.derivative(0.5)[0]);
// should print &quot;interpolation polynomial: 1 + 2 x + 4 x^2 - 4 x^3 + x^4&quot;
System.out.println(&quot;interpolation polynomial: &quot; + interpolator.getPolynomials()[0]);</pre> 
</div> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BivariateGridInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.BivariateGridInterpolator"" api=""BivariateGridInterpolator"" kind=""class"">
    BivariateGridInterpolator 
  </clt></a> is used to find a bivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>f<sub>ij</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>)=f<sub>ij</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/BivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.BivariateFunction"" api=""BivariateFunction"" kind=""class"">
    BivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt> and <tt>y<sub>j</sub></tt> must be sorted in increasing order in order to define a two-dimensional grid. </p>","BivariateGridInterpolator","org.apache.commons.math3.analysis.interpolation.BivariateGridInterpolator","class",1
,"4 Numerical Analysis","4.4 Interpolation - part 3","<h3>4.4 Interpolation - part 3</h3>
<p> Microsphere interpolation is a robust multidimensional interpolation algorithm. It has been described in William Dudziak's <a class=""externalLink"" href=""http://www.dudziak.com/microsphere.pdf"">MS thesis</a>. </p> 
<p> <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Hermite_interpolation"">Hermite interpolation</a> is an interpolation method that can use derivatives in addition to function values at sample points. The <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/HermiteInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.HermiteInterpolator"" api=""HermiteInterpolator"" kind=""class"">
    HermiteInterpolator 
  </clt></a> class implements this method for vector-valued functions. The sampling points can have any spacing (there are no requirements for a regular grid) and some points may provide derivatives while others don't provide them (or provide derivatives to a smaller order). Points are added one at a time, as shown in the following example: </p> 
<div class=""source""> 
 <pre>HermiteInterpolator interpolator = new HermiteInterpolator;
// at x = 0, we provide both value and first derivative
interpolator.addSamplePoint(0.0, new double[] { 1.0 }, new double[] { 2.0 });
// at x = 1, we provide only function value
interpolator.addSamplePoint(1.0, new double[] { 4.0 });
// at x = 2, we provide both value and first derivative
interpolator.addSamplePoint(2.0, new double[] { 5.0 }, new double[] { 2.0 });
// should print &quot;value at x = 0.5: 2.5625&quot;
System.out.println(&quot;value at x = 0.5: &quot; + interpolator.value(0.5)[0]);
// should print &quot;derivative at x = 0.5: 3.5&quot;
System.out.println(&quot;derivative at x = 0.5: &quot; + interpolator.derivative(0.5)[0]);
// should print &quot;interpolation polynomial: 1 + 2 x + 4 x^2 - 4 x^3 + x^4&quot;
System.out.println(&quot;interpolation polynomial: &quot; + interpolator.getPolynomials()[0]);</pre> 
</div> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BivariateGridInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.BivariateGridInterpolator"" api=""BivariateGridInterpolator"" kind=""class"">
    BivariateGridInterpolator 
  </clt></a> is used to find a bivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>f<sub>ij</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>)=f<sub>ij</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/BivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.BivariateFunction"" api=""BivariateFunction"" kind=""class"">
    BivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt> and <tt>y<sub>j</sub></tt> must be sorted in increasing order in order to define a two-dimensional grid. </p>","BivariateFunction","org.apache.commons.math3.analysis.BivariateFunction","class",0
,"4 Numerical Analysis","4.4 Interpolation - part 4","<h3>4.4 Interpolation - part 4</h3>
<p> In <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Bicubic_interpolation"">bicubic interpolation</a>, the interpolation function is a 3rd-degree polynomial of two variables. The coefficients are computed from the function values sampled on a grid, as well as the values of the partial derivatives of the function at those grid points. From two-dimensional data sampled on a grid, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.BicubicSplineInterpolator"" api=""BicubicSplineInterpolator"" kind=""class"">
    BicubicSplineInterpolator 
  </clt></a> computes a <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolatingFunction.html""> bicubic interpolating function</a>. Prior to computing an interpolating function, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.SmoothingPolynomialBicubicSplineInterpolator"" api=""SmoothingPolynomialBicubicSplineInterpolator"" kind=""class"">
    SmoothingPolynomialBicubicSplineInterpolator 
  </clt></a> class performs smoothing of the data by computing the polynomial that best fits each of the one-dimensional curves along each of the coordinate axes. </p> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TrivariateGridInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.TrivariateGridInterpolator"" api=""TrivariateGridInterpolator"" kind=""class"">
    TrivariateGridInterpolator 
  </clt></a> is used to find a trivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>z<sub>k</sub></tt>, <tt>f<sub>ijk</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>,z<sub>k</sub>)=f<sub>ijk</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/TrivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.TrivariateFunction"" api=""TrivariateFunction"" kind=""class"">
    TrivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt>, <tt>y<sub>j</sub></tt> and <tt>z<sub>k</sub></tt> must be sorted in increasing order in order to define a three-dimensional grid. </p>","BicubicSplineInterpolator","org.apache.commons.math3.analysis.interpolation.BicubicSplineInterpolator","class",1
,"4 Numerical Analysis","4.4 Interpolation - part 4","<h3>4.4 Interpolation - part 4</h3>
<p> In <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Bicubic_interpolation"">bicubic interpolation</a>, the interpolation function is a 3rd-degree polynomial of two variables. The coefficients are computed from the function values sampled on a grid, as well as the values of the partial derivatives of the function at those grid points. From two-dimensional data sampled on a grid, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.BicubicSplineInterpolator"" api=""BicubicSplineInterpolator"" kind=""class"">
    BicubicSplineInterpolator 
  </clt></a> computes a <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolatingFunction.html""> bicubic interpolating function</a>. Prior to computing an interpolating function, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.SmoothingPolynomialBicubicSplineInterpolator"" api=""SmoothingPolynomialBicubicSplineInterpolator"" kind=""class"">
    SmoothingPolynomialBicubicSplineInterpolator 
  </clt></a> class performs smoothing of the data by computing the polynomial that best fits each of the one-dimensional curves along each of the coordinate axes. </p> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TrivariateGridInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.TrivariateGridInterpolator"" api=""TrivariateGridInterpolator"" kind=""class"">
    TrivariateGridInterpolator 
  </clt></a> is used to find a trivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>z<sub>k</sub></tt>, <tt>f<sub>ijk</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>,z<sub>k</sub>)=f<sub>ijk</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/TrivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.TrivariateFunction"" api=""TrivariateFunction"" kind=""class"">
    TrivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt>, <tt>y<sub>j</sub></tt> and <tt>z<sub>k</sub></tt> must be sorted in increasing order in order to define a three-dimensional grid. </p>","SmoothingPolynomialBicubicSplineInterpolator","org.apache.commons.math3.analysis.interpolation.SmoothingPolynomialBicubicSplineInterpolator","class",1
,"4 Numerical Analysis","4.4 Interpolation - part 4","<h3>4.4 Interpolation - part 4</h3>
<p> In <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Bicubic_interpolation"">bicubic interpolation</a>, the interpolation function is a 3rd-degree polynomial of two variables. The coefficients are computed from the function values sampled on a grid, as well as the values of the partial derivatives of the function at those grid points. From two-dimensional data sampled on a grid, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.BicubicSplineInterpolator"" api=""BicubicSplineInterpolator"" kind=""class"">
    BicubicSplineInterpolator 
  </clt></a> computes a <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolatingFunction.html""> bicubic interpolating function</a>. Prior to computing an interpolating function, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.SmoothingPolynomialBicubicSplineInterpolator"" api=""SmoothingPolynomialBicubicSplineInterpolator"" kind=""class"">
    SmoothingPolynomialBicubicSplineInterpolator 
  </clt></a> class performs smoothing of the data by computing the polynomial that best fits each of the one-dimensional curves along each of the coordinate axes. </p> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TrivariateGridInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.TrivariateGridInterpolator"" api=""TrivariateGridInterpolator"" kind=""class"">
    TrivariateGridInterpolator 
  </clt></a> is used to find a trivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>z<sub>k</sub></tt>, <tt>f<sub>ijk</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>,z<sub>k</sub>)=f<sub>ijk</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/TrivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.TrivariateFunction"" api=""TrivariateFunction"" kind=""class"">
    TrivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt>, <tt>y<sub>j</sub></tt> and <tt>z<sub>k</sub></tt> must be sorted in increasing order in order to define a three-dimensional grid. </p>","TrivariateGridInterpolator","org.apache.commons.math3.analysis.interpolation.TrivariateGridInterpolator","class",1
,"4 Numerical Analysis","4.4 Interpolation - part 4","<h3>4.4 Interpolation - part 4</h3>
<p> In <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Bicubic_interpolation"">bicubic interpolation</a>, the interpolation function is a 3rd-degree polynomial of two variables. The coefficients are computed from the function values sampled on a grid, as well as the values of the partial derivatives of the function at those grid points. From two-dimensional data sampled on a grid, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.BicubicSplineInterpolator"" api=""BicubicSplineInterpolator"" kind=""class"">
    BicubicSplineInterpolator 
  </clt></a> computes a <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/BicubicSplineInterpolatingFunction.html""> bicubic interpolating function</a>. Prior to computing an interpolating function, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/SmoothingPolynomialBicubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.SmoothingPolynomialBicubicSplineInterpolator"" api=""SmoothingPolynomialBicubicSplineInterpolator"" kind=""class"">
    SmoothingPolynomialBicubicSplineInterpolator 
  </clt></a> class performs smoothing of the data by computing the polynomial that best fits each of the one-dimensional curves along each of the coordinate axes. </p> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TrivariateGridInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.TrivariateGridInterpolator"" api=""TrivariateGridInterpolator"" kind=""class"">
    TrivariateGridInterpolator 
  </clt></a> is used to find a trivariate real-valued function <tt>f</tt> which for a given set of tuples (<tt>x<sub>i</sub></tt>,<tt>y<sub>j</sub></tt>,<tt>z<sub>k</sub></tt>, <tt>f<sub>ijk</sub></tt>) yields <tt>f(x<sub>i</sub>,y<sub>j</sub>,z<sub>k</sub>)=f<sub>ijk</sub></tt> to the best accuracy possible. The result is provided as an object implementing the <a href=""../apidocs/org/apache/commons/math3/analysis/TrivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.TrivariateFunction"" api=""TrivariateFunction"" kind=""class"">
    TrivariateFunction 
  </clt></a> interface. It can therefore be evaluated at any point, including a point not belonging to the original set. The arrays <tt>x<sub>i</sub></tt>, <tt>y<sub>j</sub></tt> and <tt>z<sub>k</sub></tt> must be sorted in increasing order in order to define a three-dimensional grid. </p>","TrivariateFunction","org.apache.commons.math3.analysis.TrivariateFunction","class",0
,"4 Numerical Analysis","4.4 Interpolation - part 5","<h3>4.4 Interpolation - part 5</h3>
<p> In <a class=""externalLink"" href=""http://en.wikipedia.org/wiki/Tricubic_interpolation"">tricubic interpolation</a>, the interpolation function is a 3rd-degree polynomial of three variables. The coefficients are computed from the function values sampled on a grid, as well as the values of the partial derivatives of the function at those grid points. From three-dimensional data sampled on a grid, the <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.interpolation.TricubicSplineInterpolator"" api=""TricubicSplineInterpolator"" kind=""class"">
    TricubicSplineInterpolator 
  </clt></a> computes a <a href=""../apidocs/org/apache/commons/math3/analysis/interpolation/TricubicSplineInterpolatingFunction.html""> tricubic interpolating function</a>. </p>","TricubicSplineInterpolator","org.apache.commons.math3.analysis.interpolation.TricubicSplineInterpolator","class",1
,"4 Numerical Analysis","4.5 Integration","<h3>4.5 Integration</h3> 
<p> A <a href=""../apidocs/org/apache/commons/math3/analysis/integration/UnivariateIntegrator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.integration.UnivariateIntegrator"" api=""UnivariateIntegrator"" kind=""class"">
    UnivariateIntegrator 
  </clt></a> provides the means to numerically integrate <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> univariate real-valued functions</a>. Commons-Math includes implementations of the following integration algorithms: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/analysis/integration/RombergIntegrator.html""> Romberg's method</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/analysis/integration/SimpsonIntegrator.html""> Simpson's method</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/analysis/integration/TrapezoidIntegrator.html""> trapezoid method</a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/analysis/integration/LegendreGaussIntegrator.html""> Legendre-Gauss method</a></li> 
</ul>","UnivariateIntegrator","org.apache.commons.math3.analysis.integration.UnivariateIntegrator","class",0
,"4 Numerical Analysis","4.6 Polynomials","<h3>4.6 Polynomials</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/package-summary.html""> org.apache.commons.math3.analysis.polynomials</a> package provides real coefficients polynomials. </p> 
<p> The <a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.polynomials.PolynomialFunction"" api=""PolynomialFunction"" kind=""class"">
    PolynomialFunction 
  </clt></a> class is the most general one, using traditional coefficients arrays. The <a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialsUtils.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.polynomials.PolynomialsUtils"" api=""PolynomialsUtils"" kind=""class"">
    PolynomialsUtils 
  </clt></a> utility class provides static factory methods to build Chebyshev, Hermite, Jacobi, Laguerre and Legendre polynomials. Coefficients are computed using exact fractions so these factory methods can build polynomials up to any degree. </p>","PolynomialFunction","org.apache.commons.math3.analysis.polynomials.PolynomialFunction","class",0
,"4 Numerical Analysis","4.6 Polynomials","<h3>4.6 Polynomials</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/package-summary.html""> org.apache.commons.math3.analysis.polynomials</a> package provides real coefficients polynomials. </p> 
<p> The <a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.polynomials.PolynomialFunction"" api=""PolynomialFunction"" kind=""class"">
    PolynomialFunction 
  </clt></a> class is the most general one, using traditional coefficients arrays. The <a href=""../apidocs/org/apache/commons/math3/analysis/polynomials/PolynomialsUtils.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.polynomials.PolynomialsUtils"" api=""PolynomialsUtils"" kind=""class"">
    PolynomialsUtils 
  </clt></a> utility class provides static factory methods to build Chebyshev, Hermite, Jacobi, Laguerre and Legendre polynomials. Coefficients are computed using exact fractions so these factory methods can build polynomials up to any degree. </p>","PolynomialsUtils","org.apache.commons.math3.analysis.polynomials.PolynomialsUtils","class",1
,"4 Numerical Analysis","4.7 Differentiation","<h3>4.7 Differentiation</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/package-summary.html""> org.apache.commons.math3.analysis.differentiation</a> package provides a general-purpose differentiation framework. </p> 
<p> The core class is <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> which holds the value and the differentials of a function. This class handles some arbitrary number of free parameters and arbitrary derivation order. It is used both as the input and the output type for the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction"" api=""UnivariateDifferentiableFunction"" kind=""class"">
    UnivariateDifferentiableFunction 
  </clt></a> interface. Any differentiable function should implement this interface. </p> 
<p> The main idea behind the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> class is that it can be used almost as a number (i.e. it can be added, multiplied, its square root can be extracted or its cosine computed... However, in addition to computed the value itself when doing these computations, the partial derivatives are also computed alongside. This is an extension of what is sometimes called Rall's numbers. This extension is described in Dan Kalman's paper <a class=""externalLink"" href=""http://www.math.american.edu/People/kalman/pdffiles/mmgautodiff.pdf"">Doubly Recursive Multivariate Automatic Differentiation</a>, Mathematics Magazine, vol. 75, no. 3, June 2002. Rall's numbers only hold the first derivative with respect to one free parameter whereas Dan Kalman's derivative structures hold all partial derivatives up to any specified order, with respect to any number of free parameters. Rall's numbers therefore can be seen as derivative structures for order one derivative and one free parameter, and primitive real numbers can be seen as derivative structures with zero order derivative and no free parameters. </p>","DerivativeStructure","org.apache.commons.math3.analysis.differentiation.DerivativeStructure","class",1
,"4 Numerical Analysis","4.7 Differentiation","<h3>4.7 Differentiation</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/package-summary.html""> org.apache.commons.math3.analysis.differentiation</a> package provides a general-purpose differentiation framework. </p> 
<p> The core class is <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> which holds the value and the differentials of a function. This class handles some arbitrary number of free parameters and arbitrary derivation order. It is used both as the input and the output type for the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction"" api=""UnivariateDifferentiableFunction"" kind=""class"">
    UnivariateDifferentiableFunction 
  </clt></a> interface. Any differentiable function should implement this interface. </p> 
<p> The main idea behind the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> class is that it can be used almost as a number (i.e. it can be added, multiplied, its square root can be extracted or its cosine computed... However, in addition to computed the value itself when doing these computations, the partial derivatives are also computed alongside. This is an extension of what is sometimes called Rall's numbers. This extension is described in Dan Kalman's paper <a class=""externalLink"" href=""http://www.math.american.edu/People/kalman/pdffiles/mmgautodiff.pdf"">Doubly Recursive Multivariate Automatic Differentiation</a>, Mathematics Magazine, vol. 75, no. 3, June 2002. Rall's numbers only hold the first derivative with respect to one free parameter whereas Dan Kalman's derivative structures hold all partial derivatives up to any specified order, with respect to any number of free parameters. Rall's numbers therefore can be seen as derivative structures for order one derivative and one free parameter, and primitive real numbers can be seen as derivative structures with zero order derivative and no free parameters. </p>","UnivariateDifferentiableFunction","org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction","class",0
,"4 Numerical Analysis","4.7 Differentiation - part 2","<h3>4.7 Differentiation - part 2</h3>
<p> The workflow of computation of a derivatives of an expression <tt>y=f(x)</tt> is the following one. First we configure an input parameter <tt>x</tt> of type <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> so it will drive the function to compute all derivatives up to order 3 for example. Then we compute <tt>y=f(x)</tt> normally by passing this parameter to the f function.At the end, we extract from <tt>y</tt> the value and the derivatives we want. As we have specified 3<sup>rd</sup> order when we built <tt>x</tt>, we can retrieve the derivatives up to 3<sup>rd</sup> order from <tt>y</tt>. The following example shows that (the 0 parameter in the DerivativeStructure constructor will be explained in the next paragraph): </p> 
<div class=""source""> 
 <pre>int params = 1;
int order = 3;
double xRealValue = 2.5;
DerivativeStructure x = new DerivativeStructure(params, order, 0, xRealValue);
DerivativeStructure y = f(x);
System.out.println(&quot;y    = &quot; + y.getValue();
System.out.println(&quot;y'   = &quot; + y.getPartialDerivative(1);
System.out.println(&quot;y''  = &quot; + y.getPartialDerivative(2);
System.out.println(&quot;y''' = &quot; + y.getPartialDerivative(3);</pre> 
</div>","DerivativeStructure","org.apache.commons.math3.analysis.differentiation.DerivativeStructure","class",1
,"4 Numerical Analysis","4.7 Differentiation - part 4","<h3>4.7 Differentiation - part 4</h3>
<p> When we compute <tt>y</tt> from this setting, what we really do is chain <tt>f</tt> after the identity function, so the net result is that the derivatives are computed with respect to the indexed free parameters (i.e. only free parameter number 0 here since there is only one free parameter) of the identity function x. Going one step further, if we compute <tt>z = g(y)</tt>, we will also compute <tt>z</tt> as a function of the initial free parameter. The very important consequence is that if we call <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure.getPartialDerivative"" api=""DerivativeStructure"" kind=""method"">
   z.DerivativeStructure.getPartialDerivative(1)
  </clt></tt>, we will not get the first derivative of <tt>g</tt> with respect to <tt>y</tt>, but with respect to the free parameter <tt>p0</tt>: the derivatives of g and f <i>will</i> be chained together automatically, without user intervention. </p> 
<p> This design choice is a very classical one in many algorithmic differentiation frameworks, either based on operator overloading (like the one we implemented here) or based on code generation. It implies the user has to <i>bootstrap</i> the system by providing initial derivatives, and this is essentially done by setting up identity function, i.e. functions that represent the variables themselves and have only unit first derivative. </p>","DerivativeStructure","org.apache.commons.math3.analysis.differentiation.DerivativeStructure","class",1
,"4 Numerical Analysis","4.7 Differentiation - part 5","<h3>4.7 Differentiation - part 5</h3>
<p> This design also allow a very interesting feature which can be explained with the following example. Suppose we have a two arguments function <tt>f</tt> and a one argument function <tt>g</tt>. If we compute <tt>g(f(x, y))</tt> with <tt>x</tt> and <tt>y</tt> be two variables, we want to be able to compute the partial derivatives <tt>dg/dx</tt>, <tt>dg/dy</tt>, <tt>d2g/dx2</tt> <tt>d2g/dxdy</tt> <tt>d2g/dy2</tt>. This does make sense since we combined the two functions, and it does make sense despite g is a one argument function only. In order to do this, we simply set up <tt>x</tt> as an identity function of an implicit free parameter <tt>p0</tt> and <tt>y</tt> as an identity function of a different implicit free parameter <tt>p1</tt> and compute everything directly. In order to be able to combine everything, however, both <tt>x</tt> and <tt>y</tt> must be built with the appropriate dimensions, so they will both be declared to handle two free parameters, but <tt>x</tt> will depend only on parameter 0 while <tt>y</tt> will depend on parameter 1. Here is how we do this (note that <tt> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure.getPartialDerivative"" api=""DerivativeStructure"" kind=""class"">
   DerivativeStructure.getPartialDerivative
  </clt></tt> is a variable arguments method which take as arguments the derivation order with respect to all free parameters, i.e. the first argument is derivation order with respect to free parameter 0 and the second argument is derivation order with respect to free parameter 1): </p>","DerivativeStructure","org.apache.commons.math3.analysis.differentiation.DerivativeStructure","class",0
,"4 Numerical Analysis","4.7 Differentiation - part 6","<h3>4.7 Differentiation - part 6</h3>
<div class=""source""> 
 <pre>int params = 2;
int order = 2;
double xRealValue =  2.5;
double yRealValue = -1.3;
DerivativeStructure x = new DerivativeStructure(params, order, 0, xRealValue);
DerivativeStructure y = new DerivativeStructure(params, order, 1, yRealValue);
DerivativeStructure f = DerivativeStructure.hypot(x, y);
DerivativeStructure g = f.log();
System.out.println(&quot;g        = &quot; + g.getValue();
System.out.println(&quot;dg/dx    = &quot; + g.getPartialDerivative(1, 0);
System.out.println(&quot;dg/dy    = &quot; + g.getPartialDerivative(0, 1);
System.out.println(&quot;d2g/dx2  = &quot; + g.getPartialDerivative(2, 0);
System.out.println(&quot;d2g/dxdy = &quot; + g.getPartialDerivative(1, 1);
System.out.println(&quot;d2g/dy2  = &quot; + g.getPartialDerivative(0, 2);</pre> 
</div> 
<p> There are several ways a user can create an implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction"" api=""UnivariateDifferentiableFunction"" kind=""class"">
    UnivariateDifferentiableFunction 
  </clt></a> interface. The first method is to simply write it directly using the appropriate methods from <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> to compute addition, subtraction, sine, cosine... This is often quite straigthforward and there is no need to remember the rules for differentiation: the user code only represent the function itself, the differentials will be computed automatically under the hood. The second method is to write a classical <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.UnivariateFunction"" api=""UnivariateFunction"" kind=""class"">
    UnivariateFunction 
  </clt></a> and to pass it to an existing implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"" api=""UnivariateFunctionDifferentiator"" kind=""class"">
    UnivariateFunctionDifferentiator 
  </clt></a> interface to retrieve a differentiated version of the same function. The first method is more suited to small functions for which user already control all the underlying code. The second method is more suited to either large functions that would be cumbersome to write using the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> API, or functions for which user does not have control to the full underlying code (for example functions that call external libraries). </p>","UnivariateDifferentiableFunction","org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction","class",1
,"4 Numerical Analysis","4.7 Differentiation - part 6","<h3>4.7 Differentiation - part 6</h3>
<div class=""source""> 
 <pre>int params = 2;
int order = 2;
double xRealValue =  2.5;
double yRealValue = -1.3;
DerivativeStructure x = new DerivativeStructure(params, order, 0, xRealValue);
DerivativeStructure y = new DerivativeStructure(params, order, 1, yRealValue);
DerivativeStructure f = DerivativeStructure.hypot(x, y);
DerivativeStructure g = f.log();
System.out.println(&quot;g        = &quot; + g.getValue();
System.out.println(&quot;dg/dx    = &quot; + g.getPartialDerivative(1, 0);
System.out.println(&quot;dg/dy    = &quot; + g.getPartialDerivative(0, 1);
System.out.println(&quot;d2g/dx2  = &quot; + g.getPartialDerivative(2, 0);
System.out.println(&quot;d2g/dxdy = &quot; + g.getPartialDerivative(1, 1);
System.out.println(&quot;d2g/dy2  = &quot; + g.getPartialDerivative(0, 2);</pre> 
</div> 
<p> There are several ways a user can create an implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction"" api=""UnivariateDifferentiableFunction"" kind=""class"">
    UnivariateDifferentiableFunction 
  </clt></a> interface. The first method is to simply write it directly using the appropriate methods from <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> to compute addition, subtraction, sine, cosine... This is often quite straigthforward and there is no need to remember the rules for differentiation: the user code only represent the function itself, the differentials will be computed automatically under the hood. The second method is to write a classical <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.UnivariateFunction"" api=""UnivariateFunction"" kind=""class"">
    UnivariateFunction 
  </clt></a> and to pass it to an existing implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"" api=""UnivariateFunctionDifferentiator"" kind=""class"">
    UnivariateFunctionDifferentiator 
  </clt></a> interface to retrieve a differentiated version of the same function. The first method is more suited to small functions for which user already control all the underlying code. The second method is more suited to either large functions that would be cumbersome to write using the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> API, or functions for which user does not have control to the full underlying code (for example functions that call external libraries). </p>","DerivativeStructure","org.apache.commons.math3.analysis.differentiation.DerivativeStructure","class",0
,"4 Numerical Analysis","4.7 Differentiation - part 6","<h3>4.7 Differentiation - part 6</h3>
<div class=""source""> 
 <pre>int params = 2;
int order = 2;
double xRealValue =  2.5;
double yRealValue = -1.3;
DerivativeStructure x = new DerivativeStructure(params, order, 0, xRealValue);
DerivativeStructure y = new DerivativeStructure(params, order, 1, yRealValue);
DerivativeStructure f = DerivativeStructure.hypot(x, y);
DerivativeStructure g = f.log();
System.out.println(&quot;g        = &quot; + g.getValue();
System.out.println(&quot;dg/dx    = &quot; + g.getPartialDerivative(1, 0);
System.out.println(&quot;dg/dy    = &quot; + g.getPartialDerivative(0, 1);
System.out.println(&quot;d2g/dx2  = &quot; + g.getPartialDerivative(2, 0);
System.out.println(&quot;d2g/dxdy = &quot; + g.getPartialDerivative(1, 1);
System.out.println(&quot;d2g/dy2  = &quot; + g.getPartialDerivative(0, 2);</pre> 
</div> 
<p> There are several ways a user can create an implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction"" api=""UnivariateDifferentiableFunction"" kind=""class"">
    UnivariateDifferentiableFunction 
  </clt></a> interface. The first method is to simply write it directly using the appropriate methods from <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> to compute addition, subtraction, sine, cosine... This is often quite straigthforward and there is no need to remember the rules for differentiation: the user code only represent the function itself, the differentials will be computed automatically under the hood. The second method is to write a classical <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.UnivariateFunction"" api=""UnivariateFunction"" kind=""class"">
    UnivariateFunction 
  </clt></a> and to pass it to an existing implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"" api=""UnivariateFunctionDifferentiator"" kind=""class"">
    UnivariateFunctionDifferentiator 
  </clt></a> interface to retrieve a differentiated version of the same function. The first method is more suited to small functions for which user already control all the underlying code. The second method is more suited to either large functions that would be cumbersome to write using the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> API, or functions for which user does not have control to the full underlying code (for example functions that call external libraries). </p>","UnivariateFunction","org.apache.commons.math3.analysis.UnivariateFunction","class",0
,"4 Numerical Analysis","4.7 Differentiation - part 6","<h3>4.7 Differentiation - part 6</h3>
<div class=""source""> 
 <pre>int params = 2;
int order = 2;
double xRealValue =  2.5;
double yRealValue = -1.3;
DerivativeStructure x = new DerivativeStructure(params, order, 0, xRealValue);
DerivativeStructure y = new DerivativeStructure(params, order, 1, yRealValue);
DerivativeStructure f = DerivativeStructure.hypot(x, y);
DerivativeStructure g = f.log();
System.out.println(&quot;g        = &quot; + g.getValue();
System.out.println(&quot;dg/dx    = &quot; + g.getPartialDerivative(1, 0);
System.out.println(&quot;dg/dy    = &quot; + g.getPartialDerivative(0, 1);
System.out.println(&quot;d2g/dx2  = &quot; + g.getPartialDerivative(2, 0);
System.out.println(&quot;d2g/dxdy = &quot; + g.getPartialDerivative(1, 1);
System.out.println(&quot;d2g/dy2  = &quot; + g.getPartialDerivative(0, 2);</pre> 
</div> 
<p> There are several ways a user can create an implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateDifferentiableFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateDifferentiableFunction"" api=""UnivariateDifferentiableFunction"" kind=""class"">
    UnivariateDifferentiableFunction 
  </clt></a> interface. The first method is to simply write it directly using the appropriate methods from <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> to compute addition, subtraction, sine, cosine... This is often quite straigthforward and there is no need to remember the rules for differentiation: the user code only represent the function itself, the differentials will be computed automatically under the hood. The second method is to write a classical <a href=""../apidocs/org/apache/commons/math3/analysis/UnivariateFunction.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.UnivariateFunction"" api=""UnivariateFunction"" kind=""class"">
    UnivariateFunction 
  </clt></a> and to pass it to an existing implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"" api=""UnivariateFunctionDifferentiator"" kind=""class"">
    UnivariateFunctionDifferentiator 
  </clt></a> interface to retrieve a differentiated version of the same function. The first method is more suited to small functions for which user already control all the underlying code. The second method is more suited to either large functions that would be cumbersome to write using the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.DerivativeStructure"" api=""DerivativeStructure"" kind=""class"">
    DerivativeStructure 
  </clt></a> API, or functions for which user does not have control to the full underlying code (for example functions that call external libraries). </p>","UnivariateFunctionDifferentiator","org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator","class",0
,"4 Numerical Analysis","4.7 Differentiation - part 7","<h3>4.7 Differentiation - part 7</h3>
<p> Apache Commons Math provides one implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"" api=""UnivariateFunctionDifferentiator"" kind=""class"">
    UnivariateFunctionDifferentiator 
  </clt></a> interface: <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/FiniteDifferencesDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.FiniteDifferencesDifferentiator"" api=""FiniteDifferencesDifferentiator"" kind=""class"">
    FiniteDifferencesDifferentiator 
  </clt></a>. This class creates a wrapper that will call the user-provided function on a grid sample and will use finite differences to compute the derivatives. It takes care of boundaries if the variable is not defined on the whole real line. It is possible to use more points than strictly required by the derivation order (for example one can specify an 8-points scheme to compute first derivative only). However, one must be aware that tuning the parameters for finite differences is highly problem-dependent. Choosing the wrong step size or the wrong number of sampling points can lead to huge errors. Finite differences are also not well suited to compute high order derivatives. </p> 
<p> Another implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"" api=""UnivariateFunctionDifferentiator"" kind=""class"">
    UnivariateFunctionDifferentiator 
  </clt></a> interface is under development in the related project <a class=""externalLink"" href=""http://commons.apache.org/sandbox/nabla/"">Apache Commons Nabla</a>. This implementation uses automatic code analysis and generation at binary level. However, at time of writing (end 2012), this project is not yet suitable for production use. </p>","UnivariateFunctionDifferentiator","org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator","class",1
,"4 Numerical Analysis","4.7 Differentiation - part 7","<h3>4.7 Differentiation - part 7</h3>
<p> Apache Commons Math provides one implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"" api=""UnivariateFunctionDifferentiator"" kind=""class"">
    UnivariateFunctionDifferentiator 
  </clt></a> interface: <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/FiniteDifferencesDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.FiniteDifferencesDifferentiator"" api=""FiniteDifferencesDifferentiator"" kind=""class"">
    FiniteDifferencesDifferentiator 
  </clt></a>. This class creates a wrapper that will call the user-provided function on a grid sample and will use finite differences to compute the derivatives. It takes care of boundaries if the variable is not defined on the whole real line. It is possible to use more points than strictly required by the derivation order (for example one can specify an 8-points scheme to compute first derivative only). However, one must be aware that tuning the parameters for finite differences is highly problem-dependent. Choosing the wrong step size or the wrong number of sampling points can lead to huge errors. Finite differences are also not well suited to compute high order derivatives. </p> 
<p> Another implementation of the <a href=""../apidocs/org/apache/commons/math3/analysis/differentiation/UnivariateFunctionDifferentiator.html""> 
  <clt fqn=""org.apache.commons.math3.analysis.differentiation.UnivariateFunctionDifferentiator"" api=""UnivariateFunctionDifferentiator"" kind=""class"">
    UnivariateFunctionDifferentiator 
  </clt></a> interface is under development in the related project <a class=""externalLink"" href=""http://commons.apache.org/sandbox/nabla/"">Apache Commons Nabla</a>. This implementation uses automatic code analysis and generation at binary level. However, at time of writing (end 2012), this project is not yet suitable for production use. </p>","FiniteDifferencesDifferentiator","org.apache.commons.math3.analysis.differentiation.FiniteDifferencesDifferentiator","class",1
,"7 
<clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""class"">
  Complex 
</clt> Numbers","7.2 Complex Numbers","<h3>7.2 
 <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""class"">
   Complex 
 </clt> Numbers</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/complex/Complex.html""> 
  <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""unknown"">
    Complex 
  </clt></a> provides a complex number type that forms the basis for the complex functionality found in commons-math. </p> 
<p> Complex functions and arithmetic operations are implemented in commons-math by applying standard computational formulas and following the rules for <tt>java.lang.Double</tt> arithmetic in handling infinite and <tt> 
  <clt fqn=""org.apache.commons.math3.complex.Complex.NaN"" api=""NaN"" kind=""class"">
    NaN 
  </clt></tt> values. No attempt is made to comply with ANSII/IEC C99x Annex G or any other standard for Complex arithmetic. See the class and method javadocs for the <a href=""../apidocs/org/apache/commons/math3/complex/Complex.html""> 
  <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""unknown"">
    Complex 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/complex/ComplexUtils.html""> 
  <clt fqn=""org.apache.commons.math3.complex.ComplexUtils"" api=""ComplexUtils"" kind=""class"">
    ComplexUtils 
  </clt></a> classes for details on computing formulas. </p> 
<p> To create a complex number, simply call the constructor passing in two floating-point arguments, the first being the real part of the complex number and the second being the imaginary part: </p> 
<div class=""source""> 
 <pre>Complex c = new Complex(1.0, 3.0); // 1 + 3i</pre> 
</div> 
<p> Complex numbers may also be created from polar representations using the <tt> 
  <clt fqn=""org.apache.commons.math3.complex.ComplexUtils.polar2Complex"" api=""ComplexUtils"" kind=""unknown"">
   ComplexUtils.polar2Complex
  </clt></tt> method in <tt> 
  <clt fqn=""org.apache.commons.math3.complex.ComplexUtils"" api=""ComplexUtils"" kind=""class"">
    ComplexUtils 
  </clt></tt>. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""unknown"">
    Complex 
  </clt></tt> class provides basic unary and binary complex number operations. These operations provide the means to add, subtract, multiply and divide complex numbers along with other complex number functions similar to the real number functions found in <tt>java.math.BigDecimal</tt>: </p> 
<div class=""source""> 
 <pre>Complex lhs = new Complex(1.0, 3.0);
Complex rhs = new Complex(2.0, 5.0);

Complex answer = lhs.add(rhs);       // add two complex numbers
        answer = lhs.subtract(rhs);  // subtract two complex numbers
        answer = lhs.abs();          // absolute value
        answer = lhs.conjugate(rhs); // complex conjugate</pre> 
</div>","Complex","org.apache.commons.math3.complex.Complex","class",1
,"7 
<clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""class"">
  Complex 
</clt> Numbers","7.2 Complex Numbers","<h3>7.2 
 <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""class"">
   Complex 
 </clt> Numbers</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/complex/Complex.html""> 
  <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""unknown"">
    Complex 
  </clt></a> provides a complex number type that forms the basis for the complex functionality found in commons-math. </p> 
<p> Complex functions and arithmetic operations are implemented in commons-math by applying standard computational formulas and following the rules for <tt>java.lang.Double</tt> arithmetic in handling infinite and <tt> 
  <clt fqn=""org.apache.commons.math3.complex.Complex.NaN"" api=""NaN"" kind=""class"">
    NaN 
  </clt></tt> values. No attempt is made to comply with ANSII/IEC C99x Annex G or any other standard for Complex arithmetic. See the class and method javadocs for the <a href=""../apidocs/org/apache/commons/math3/complex/Complex.html""> 
  <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""unknown"">
    Complex 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/complex/ComplexUtils.html""> 
  <clt fqn=""org.apache.commons.math3.complex.ComplexUtils"" api=""ComplexUtils"" kind=""class"">
    ComplexUtils 
  </clt></a> classes for details on computing formulas. </p> 
<p> To create a complex number, simply call the constructor passing in two floating-point arguments, the first being the real part of the complex number and the second being the imaginary part: </p> 
<div class=""source""> 
 <pre>Complex c = new Complex(1.0, 3.0); // 1 + 3i</pre> 
</div> 
<p> Complex numbers may also be created from polar representations using the <tt> 
  <clt fqn=""org.apache.commons.math3.complex.ComplexUtils.polar2Complex"" api=""ComplexUtils"" kind=""unknown"">
   ComplexUtils.polar2Complex
  </clt></tt> method in <tt> 
  <clt fqn=""org.apache.commons.math3.complex.ComplexUtils"" api=""ComplexUtils"" kind=""class"">
    ComplexUtils 
  </clt></tt>. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""unknown"">
    Complex 
  </clt></tt> class provides basic unary and binary complex number operations. These operations provide the means to add, subtract, multiply and divide complex numbers along with other complex number functions similar to the real number functions found in <tt>java.math.BigDecimal</tt>: </p> 
<div class=""source""> 
 <pre>Complex lhs = new Complex(1.0, 3.0);
Complex rhs = new Complex(2.0, 5.0);

Complex answer = lhs.add(rhs);       // add two complex numbers
        answer = lhs.subtract(rhs);  // subtract two complex numbers
        answer = lhs.abs();          // absolute value
        answer = lhs.conjugate(rhs); // complex conjugate</pre> 
</div>","NaN","org.apache.commons.math3.complex.Complex","class",0
,"7 
<clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""class"">
  Complex 
</clt> Numbers","7.2 Complex Numbers","<h3>7.2 
 <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""class"">
   Complex 
 </clt> Numbers</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/complex/Complex.html""> 
  <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""unknown"">
    Complex 
  </clt></a> provides a complex number type that forms the basis for the complex functionality found in commons-math. </p> 
<p> Complex functions and arithmetic operations are implemented in commons-math by applying standard computational formulas and following the rules for <tt>java.lang.Double</tt> arithmetic in handling infinite and <tt> 
  <clt fqn=""org.apache.commons.math3.complex.Complex.NaN"" api=""NaN"" kind=""class"">
    NaN 
  </clt></tt> values. No attempt is made to comply with ANSII/IEC C99x Annex G or any other standard for Complex arithmetic. See the class and method javadocs for the <a href=""../apidocs/org/apache/commons/math3/complex/Complex.html""> 
  <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""unknown"">
    Complex 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/complex/ComplexUtils.html""> 
  <clt fqn=""org.apache.commons.math3.complex.ComplexUtils"" api=""ComplexUtils"" kind=""class"">
    ComplexUtils 
  </clt></a> classes for details on computing formulas. </p> 
<p> To create a complex number, simply call the constructor passing in two floating-point arguments, the first being the real part of the complex number and the second being the imaginary part: </p> 
<div class=""source""> 
 <pre>Complex c = new Complex(1.0, 3.0); // 1 + 3i</pre> 
</div> 
<p> Complex numbers may also be created from polar representations using the <tt> 
  <clt fqn=""org.apache.commons.math3.complex.ComplexUtils.polar2Complex"" api=""ComplexUtils"" kind=""unknown"">
   ComplexUtils.polar2Complex
  </clt></tt> method in <tt> 
  <clt fqn=""org.apache.commons.math3.complex.ComplexUtils"" api=""ComplexUtils"" kind=""class"">
    ComplexUtils 
  </clt></tt>. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""unknown"">
    Complex 
  </clt></tt> class provides basic unary and binary complex number operations. These operations provide the means to add, subtract, multiply and divide complex numbers along with other complex number functions similar to the real number functions found in <tt>java.math.BigDecimal</tt>: </p> 
<div class=""source""> 
 <pre>Complex lhs = new Complex(1.0, 3.0);
Complex rhs = new Complex(2.0, 5.0);

Complex answer = lhs.add(rhs);       // add two complex numbers
        answer = lhs.subtract(rhs);  // subtract two complex numbers
        answer = lhs.abs();          // absolute value
        answer = lhs.conjugate(rhs); // complex conjugate</pre> 
</div>","ComplexUtils","org.apache.commons.math3.complex.ComplexUtils","class",0
,"7 
<clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""class"">
  Complex 
</clt> Numbers","7.3 Complex Transcendental Functions","<h3>7.3 
 <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""class"">
   Complex 
 </clt> Transcendental Functions</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/complex/Complex.html""> 
  <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""unknown"">
    Complex 
  </clt></a> also provides implementations of serveral transcendental functions involving complex number arguments. Prior to version 1.2, these functions were provided by <a href=""../apidocs/org/apache/commons/math3/complex/ComplexUtils.html""> 
  <clt fqn=""org.apache.commons.math3.complex.ComplexUtils"" api=""ComplexUtils"" kind=""class"">
    ComplexUtils 
  </clt></a> in a way similar to the real number functions found in <tt>java.lang.Math</tt>, but this has been deprecated. These operations provide the means to compute the log, sine, tangent, and other complex values : </p> 
<div class=""source""> 
 <pre>Complex first  = new Complex(1.0, 3.0);
Complex second = new Complex(2.0, 5.0);

Complex answer = first.log();        // natural logarithm.
        answer = first.cos();        // cosine
        answer = first.pow(second);  // first raised to the power of second</pre> 
</div>","Complex","org.apache.commons.math3.complex.Complex","class",1
,"7 
<clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""class"">
  Complex 
</clt> Numbers","7.3 Complex Transcendental Functions","<h3>7.3 
 <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""class"">
   Complex 
 </clt> Transcendental Functions</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/complex/Complex.html""> 
  <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""unknown"">
    Complex 
  </clt></a> also provides implementations of serveral transcendental functions involving complex number arguments. Prior to version 1.2, these functions were provided by <a href=""../apidocs/org/apache/commons/math3/complex/ComplexUtils.html""> 
  <clt fqn=""org.apache.commons.math3.complex.ComplexUtils"" api=""ComplexUtils"" kind=""class"">
    ComplexUtils 
  </clt></a> in a way similar to the real number functions found in <tt>java.lang.Math</tt>, but this has been deprecated. These operations provide the means to compute the log, sine, tangent, and other complex values : </p> 
<div class=""source""> 
 <pre>Complex first  = new Complex(1.0, 3.0);
Complex second = new Complex(2.0, 5.0);

Complex answer = first.log();        // natural logarithm.
        answer = first.cos();        // cosine
        answer = first.pow(second);  // first raised to the power of second</pre> 
</div>","ComplexUtils","org.apache.commons.math3.complex.ComplexUtils","class",0
,"7 
<clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""class"">
  Complex 
</clt> Numbers","7.4 Complex Formatting and Parsing","<h3>7.4 
 <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""class"">
   Complex 
 </clt> Formatting and Parsing</h3> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""unknown"">
    Complex 
  </clt></tt> instances can be converted to and from strings using the<a href=""../apidocs/org/apache/commons/math3/complex/ComplexFormat.html""> 
  <clt fqn=""org.apache.commons.math3.complex.ComplexFormat"" api=""ComplexFormat"" kind=""class"">
    ComplexFormat 
  </clt></a> class. <tt> 
  <clt fqn=""org.apache.commons.math3.complex.ComplexFormat"" api=""ComplexFormat"" kind=""class"">
    ComplexFormat 
  </clt></tt> is a <tt>java.text.Format</tt> extension and, as such, is used like other formatting objects (e.g. <tt>java.text.SimpleDateFormat</tt>): </p> 
<div class=""source""> 
 <pre>ComplexFormat format = new ComplexFormat(); // default format
Complex c = new Complex(1.1111, 2.2222);
String s = format.format(c); // s contains &quot;1.11 + 2.22i&quot;</pre> 
</div> 
<p> To customize the formatting output, one or two <tt>java.text.NumberFormat</tt> instances can be used to construct a <tt> 
  <clt fqn=""org.apache.commons.math3.complex.ComplexFormat"" api=""ComplexFormat"" kind=""class"">
    ComplexFormat 
  </clt></tt>. These number formats control the formatting of the real and imaginary values of the complex number: </p> 
<div class=""source""> 
 <pre>NumberFormat nf = NumberFormat.getInstance();
nf.setMinimumFractionDigits(3);
nf.setMaximumFractionDigits(3);

// create complex format with custom number format
// when one number format is used, both real and
// imaginary parts are formatted the same
ComplexFormat cf = new ComplexFormat(nf);
Complex c = new Complex(1.11, 2.2222);
String s = format.format(c); // s contains &quot;1.110 + 2.222i&quot;

NumberFormat nf2 = NumberFormat.getInstance();
nf.setMinimumFractionDigits(1);
nf.setMaximumFractionDigits(1);

// create complex format with custom number formats
cf = new ComplexFormat(nf, nf2);
s = format.format(c); // s contains &quot;1.110 + 2.2i&quot;</pre> 
</div> 
<p> Another formatting customization provided by <tt> 
  <clt fqn=""org.apache.commons.math3.complex.ComplexFormat"" api=""ComplexFormat"" kind=""class"">
    ComplexFormat 
  </clt></tt> is the text used for the imaginary designation. By default, the imaginary notation is &quot;i&quot; but, it can be manipulated using the <tt>setImaginaryCharacter</tt> method. </p> 
<p> Formatting inverse operation, parsing, can also be performed by <tt> 
  <clt fqn=""org.apache.commons.math3.complex.ComplexFormat"" api=""ComplexFormat"" kind=""class"">
    ComplexFormat 
  </clt></tt>. Parse a complex number from a string, simply call the <tt> 
  <clt fqn=""org.apache.commons.math3.complex.ComplexFormat.parse"" api=""ComplexFormat"" kind=""unknown"">
   ComplexFormat.parse
  </clt></tt> method: </p> 
<div class=""source""> 
 <pre>ComplexFormat cf = new ComplexFormat();
Complex c = cf.parse(&quot;1.110 + 2.222i&quot;);</pre> 
</div>","Complex","org.apache.commons.math3.complex.Complex","class",1
,"7 
<clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""class"">
  Complex 
</clt> Numbers","7.4 Complex Formatting and Parsing","<h3>7.4 
 <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""class"">
   Complex 
 </clt> Formatting and Parsing</h3> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""unknown"">
    Complex 
  </clt></tt> instances can be converted to and from strings using the<a href=""../apidocs/org/apache/commons/math3/complex/ComplexFormat.html""> 
  <clt fqn=""org.apache.commons.math3.complex.ComplexFormat"" api=""ComplexFormat"" kind=""class"">
    ComplexFormat 
  </clt></a> class. <tt> 
  <clt fqn=""org.apache.commons.math3.complex.ComplexFormat"" api=""ComplexFormat"" kind=""class"">
    ComplexFormat 
  </clt></tt> is a <tt>java.text.Format</tt> extension and, as such, is used like other formatting objects (e.g. <tt>java.text.SimpleDateFormat</tt>): </p> 
<div class=""source""> 
 <pre>ComplexFormat format = new ComplexFormat(); // default format
Complex c = new Complex(1.1111, 2.2222);
String s = format.format(c); // s contains &quot;1.11 + 2.22i&quot;</pre> 
</div> 
<p> To customize the formatting output, one or two <tt>java.text.NumberFormat</tt> instances can be used to construct a <tt> 
  <clt fqn=""org.apache.commons.math3.complex.ComplexFormat"" api=""ComplexFormat"" kind=""class"">
    ComplexFormat 
  </clt></tt>. These number formats control the formatting of the real and imaginary values of the complex number: </p> 
<div class=""source""> 
 <pre>NumberFormat nf = NumberFormat.getInstance();
nf.setMinimumFractionDigits(3);
nf.setMaximumFractionDigits(3);

// create complex format with custom number format
// when one number format is used, both real and
// imaginary parts are formatted the same
ComplexFormat cf = new ComplexFormat(nf);
Complex c = new Complex(1.11, 2.2222);
String s = format.format(c); // s contains &quot;1.110 + 2.222i&quot;

NumberFormat nf2 = NumberFormat.getInstance();
nf.setMinimumFractionDigits(1);
nf.setMaximumFractionDigits(1);

// create complex format with custom number formats
cf = new ComplexFormat(nf, nf2);
s = format.format(c); // s contains &quot;1.110 + 2.2i&quot;</pre> 
</div> 
<p> Another formatting customization provided by <tt> 
  <clt fqn=""org.apache.commons.math3.complex.ComplexFormat"" api=""ComplexFormat"" kind=""class"">
    ComplexFormat 
  </clt></tt> is the text used for the imaginary designation. By default, the imaginary notation is &quot;i&quot; but, it can be manipulated using the <tt>setImaginaryCharacter</tt> method. </p> 
<p> Formatting inverse operation, parsing, can also be performed by <tt> 
  <clt fqn=""org.apache.commons.math3.complex.ComplexFormat"" api=""ComplexFormat"" kind=""class"">
    ComplexFormat 
  </clt></tt>. Parse a complex number from a string, simply call the <tt> 
  <clt fqn=""org.apache.commons.math3.complex.ComplexFormat.parse"" api=""ComplexFormat"" kind=""unknown"">
   ComplexFormat.parse
  </clt></tt> method: </p> 
<div class=""source""> 
 <pre>ComplexFormat cf = new ComplexFormat();
Complex c = cf.parse(&quot;1.110 + 2.222i&quot;);</pre> 
</div>","ComplexFormat","org.apache.commons.math3.complex.ComplexFormat","class",1
,"8 Probability Distributions","8.2 Distribution Framework","<h3>8.2 Distribution Framework</h3> 
<p> The distribution framework provides the means to compute probability density function (PDF) probabilities and cumulative distribution function (CDF) probabilities for common probability distributions. Along with the direct computation of PDF and CDF probabilities, the framework also allows for the computation of inverse PDF and inverse CDF values. </p> 
<p> Using a distribution object, PDF and CDF probabilities are easily computed using the <tt> 
  <clt fqn=""org.apache.commons.math3.distribution.AbstractIntegerDistribution.cumulativeProbability"" api=""AbstractIntegerDistribution"" kind=""class"">
   AbstractIntegerDistribution.cumulativeProbability
  </clt></tt> methods. For a distribution <tt>X</tt>, and a domain value, <tt>x</tt>, <tt> 
  <clt fqn=""org.apache.commons.math3.distribution.AbstractIntegerDistribution.cumulativeProbability"" api=""AbstractIntegerDistribution"" kind=""class"">
   AbstractIntegerDistribution.cumulativeProbability
  </clt></tt> computes <tt>P(X &lt;= x)</tt> (i.e. the lower tail probability of <tt>X</tt>). </p> 
<div class=""source""> 
 <pre>TDistribution t = new TDistribution(29);
double lowerTail = t.cumulativeProbability(-2.656);     // P(T &lt;= -2.656)
double upperTail = 1.0 - t.cumulativeProbability(2.75); // P(T &gt;= 2.75)</pre> 
</div> 
<p> The inverse PDF and CDF values are just as easily computed using the <tt> 
  <clt fqn=""org.apache.commons.math3.distribution.AbstractIntegerDistribution.inverseCumulativeProbability"" api=""AbstractIntegerDistribution"" kind=""class"">
   AbstractIntegerDistribution.inverseCumulativeProbability
  </clt></tt> methods. For a distribution <tt>X</tt>, and a probability, <tt>p</tt>, <tt> 
  <clt fqn=""org.apache.commons.math3.distribution.AbstractIntegerDistribution.inverseCumulativeProbability"" api=""AbstractIntegerDistribution"" kind=""class"">
   AbstractIntegerDistribution.inverseCumulativeProbability
  </clt></tt> computes the domain value <tt>x</tt>, such that: </p> 
<ul> 
 <li><tt>P(X &lt;= x) = p</tt>, for continuous distributions</li> 
 <li><tt>P(X &lt;= x) &lt;= p</tt>, for discrete distributions</li> 
</ul>","AbstractIntegerDistribution","org.apache.commons.math3.distribution.AbstractIntegerDistribution","class",1
,"8 Probability Distributions","8.3 User Defined Distributions","<h3>8.3 User Defined Distributions</h3> 
<p> Since there are numerous distributions and Commons-Math only directly supports a handful, it may be necessary to extend the distribution framework to satisfy individual needs. It is recommended that the <a href=""../apidocs/org/apache/commons/math3/distribution/Distribution.html"">Distribution</a>, <a href=""../apidocs/org/apache/commons/math3/distribution/ContinuousDistribution.html""> ContinuousDistribution</a>, <a href=""../apidocs/org/apache/commons/math3/distribution/DiscreteDistribution.html""> DiscreteDistribution</a>, and <a href=""../apidocs/org/apache/commons/math3/distribution/IntegerDistribution.html""> 
  <clt fqn=""org.apache.commons.math3.distribution.IntegerDistribution"" api=""IntegerDistribution"" kind=""class"">
    IntegerDistribution 
  </clt></a> interfaces serve as base types for any extension. These serve as the basis for all the distributions directly supported by Commons-Math and using those interfaces for implementation purposes will ensure any extension is compatible with the remainder of Commons-Math. To aid in implementing a distribution extension, the <a href=""../apidocs/org/apache/commons/math3/distribution/AbstractDistribution.html""> AbstractDistribution</a>, <a href=""../apidocs/org/apache/commons/math3/distribution/AbstractContinuousDistribution.html""> AbstractContinuousDistribution</a>, and <a href=""../apidocs/org/apache/commons/math3/distribution/AbstractIntegerDistribution.html""> 
  <clt fqn=""org.apache.commons.math3.distribution.AbstractIntegerDistribution"" api=""AbstractIntegerDistribution"" kind=""class"">
    AbstractIntegerDistribution 
  </clt></a> provide implementation building blocks and offer basic distribution functionality. By extending these abstract classes directly, much of the repetitive distribution implementation is already developed and should save time and effort in developing user-defined distributions. </p>","IntegerDistribution","org.apache.commons.math3.distribution.IntegerDistribution","class",0
,"8 Probability Distributions","8.3 User Defined Distributions","<h3>8.3 User Defined Distributions</h3> 
<p> Since there are numerous distributions and Commons-Math only directly supports a handful, it may be necessary to extend the distribution framework to satisfy individual needs. It is recommended that the <a href=""../apidocs/org/apache/commons/math3/distribution/Distribution.html"">Distribution</a>, <a href=""../apidocs/org/apache/commons/math3/distribution/ContinuousDistribution.html""> ContinuousDistribution</a>, <a href=""../apidocs/org/apache/commons/math3/distribution/DiscreteDistribution.html""> DiscreteDistribution</a>, and <a href=""../apidocs/org/apache/commons/math3/distribution/IntegerDistribution.html""> 
  <clt fqn=""org.apache.commons.math3.distribution.IntegerDistribution"" api=""IntegerDistribution"" kind=""class"">
    IntegerDistribution 
  </clt></a> interfaces serve as base types for any extension. These serve as the basis for all the distributions directly supported by Commons-Math and using those interfaces for implementation purposes will ensure any extension is compatible with the remainder of Commons-Math. To aid in implementing a distribution extension, the <a href=""../apidocs/org/apache/commons/math3/distribution/AbstractDistribution.html""> AbstractDistribution</a>, <a href=""../apidocs/org/apache/commons/math3/distribution/AbstractContinuousDistribution.html""> AbstractContinuousDistribution</a>, and <a href=""../apidocs/org/apache/commons/math3/distribution/AbstractIntegerDistribution.html""> 
  <clt fqn=""org.apache.commons.math3.distribution.AbstractIntegerDistribution"" api=""AbstractIntegerDistribution"" kind=""class"">
    AbstractIntegerDistribution 
  </clt></a> provide implementation building blocks and offer basic distribution functionality. By extending these abstract classes directly, much of the repetitive distribution implementation is already developed and should save time and effort in developing user-defined distributions. </p>","AbstractIntegerDistribution","org.apache.commons.math3.distribution.AbstractIntegerDistribution","class",0
,"16 Exceptions","16.3 Hierarchies","<h3>16.3 Hierarchies</h3> 
<p> The exceptions defined by Commons Math follow the Java standard hierarchies: </p> 
<ul> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/IllegalArgumentException.html""> <tt>IllegalArgumentException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathIllegalArgumentException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathIllegalArgumentException"" api=""MathIllegalArgumentException"" kind=""class"">
      MathIllegalArgumentException 
    </clt></tt></a> is thrown when some input parameter fails a precondition check. </li> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/IllegalStateException.html""> <tt>IllegalStateException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathIllegalStateException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathIllegalStateException"" api=""MathIllegalStateException"" kind=""class"">
      MathIllegalStateException 
    </clt></tt></a> is thrown when some inconsistency has been detected. </li> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/MathArithmeticException.html""> <tt>ArithmeticException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathArithmeticException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathArithmeticException"" api=""MathArithmeticException"" kind=""class"">
      MathArithmeticException 
    </clt></tt></a> is thrown when conditions such as &quot;division by zero&quot; or &quot;overflow&quot; are encountered. </li> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/MathUnsupportedOperationException.html""> <tt>UnsupportedOperationException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathUnsupportedOperationException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathUnsupportedOperationException"" api=""MathUnsupportedOperationException"" kind=""class"">
      MathUnsupportedOperationException 
    </clt></tt></a> indicates that a feature is missing or does not make sense in the given context. </li> 
</ul> 
<p> In all of the above exception hierarchies, several subclasses can exist, each conveying a specific underlying cause of the problem. </p>","MathIllegalArgumentException","org.apache.commons.math3.exception.MathIllegalArgumentException","class",0
,"16 Exceptions","16.3 Hierarchies","<h3>16.3 Hierarchies</h3> 
<p> The exceptions defined by Commons Math follow the Java standard hierarchies: </p> 
<ul> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/IllegalArgumentException.html""> <tt>IllegalArgumentException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathIllegalArgumentException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathIllegalArgumentException"" api=""MathIllegalArgumentException"" kind=""class"">
      MathIllegalArgumentException 
    </clt></tt></a> is thrown when some input parameter fails a precondition check. </li> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/IllegalStateException.html""> <tt>IllegalStateException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathIllegalStateException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathIllegalStateException"" api=""MathIllegalStateException"" kind=""class"">
      MathIllegalStateException 
    </clt></tt></a> is thrown when some inconsistency has been detected. </li> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/MathArithmeticException.html""> <tt>ArithmeticException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathArithmeticException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathArithmeticException"" api=""MathArithmeticException"" kind=""class"">
      MathArithmeticException 
    </clt></tt></a> is thrown when conditions such as &quot;division by zero&quot; or &quot;overflow&quot; are encountered. </li> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/MathUnsupportedOperationException.html""> <tt>UnsupportedOperationException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathUnsupportedOperationException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathUnsupportedOperationException"" api=""MathUnsupportedOperationException"" kind=""class"">
      MathUnsupportedOperationException 
    </clt></tt></a> indicates that a feature is missing or does not make sense in the given context. </li> 
</ul> 
<p> In all of the above exception hierarchies, several subclasses can exist, each conveying a specific underlying cause of the problem. </p>","MathIllegalStateException","org.apache.commons.math3.exception.MathIllegalStateException","class",0
,"16 Exceptions","16.3 Hierarchies","<h3>16.3 Hierarchies</h3> 
<p> The exceptions defined by Commons Math follow the Java standard hierarchies: </p> 
<ul> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/IllegalArgumentException.html""> <tt>IllegalArgumentException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathIllegalArgumentException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathIllegalArgumentException"" api=""MathIllegalArgumentException"" kind=""class"">
      MathIllegalArgumentException 
    </clt></tt></a> is thrown when some input parameter fails a precondition check. </li> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/IllegalStateException.html""> <tt>IllegalStateException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathIllegalStateException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathIllegalStateException"" api=""MathIllegalStateException"" kind=""class"">
      MathIllegalStateException 
    </clt></tt></a> is thrown when some inconsistency has been detected. </li> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/MathArithmeticException.html""> <tt>ArithmeticException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathArithmeticException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathArithmeticException"" api=""MathArithmeticException"" kind=""class"">
      MathArithmeticException 
    </clt></tt></a> is thrown when conditions such as &quot;division by zero&quot; or &quot;overflow&quot; are encountered. </li> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/MathUnsupportedOperationException.html""> <tt>UnsupportedOperationException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathUnsupportedOperationException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathUnsupportedOperationException"" api=""MathUnsupportedOperationException"" kind=""class"">
      MathUnsupportedOperationException 
    </clt></tt></a> indicates that a feature is missing or does not make sense in the given context. </li> 
</ul> 
<p> In all of the above exception hierarchies, several subclasses can exist, each conveying a specific underlying cause of the problem. </p>","MathArithmeticException","org.apache.commons.math3.exception.MathArithmeticException","class",0
,"16 Exceptions","16.3 Hierarchies","<h3>16.3 Hierarchies</h3> 
<p> The exceptions defined by Commons Math follow the Java standard hierarchies: </p> 
<ul> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/IllegalArgumentException.html""> <tt>IllegalArgumentException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathIllegalArgumentException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathIllegalArgumentException"" api=""MathIllegalArgumentException"" kind=""class"">
      MathIllegalArgumentException 
    </clt></tt></a> is thrown when some input parameter fails a precondition check. </li> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/IllegalStateException.html""> <tt>IllegalStateException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathIllegalStateException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathIllegalStateException"" api=""MathIllegalStateException"" kind=""class"">
      MathIllegalStateException 
    </clt></tt></a> is thrown when some inconsistency has been detected. </li> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/MathArithmeticException.html""> <tt>ArithmeticException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathArithmeticException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathArithmeticException"" api=""MathArithmeticException"" kind=""class"">
      MathArithmeticException 
    </clt></tt></a> is thrown when conditions such as &quot;division by zero&quot; or &quot;overflow&quot; are encountered. </li> 
 <li> <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/MathUnsupportedOperationException.html""> <tt>UnsupportedOperationException</tt></a>: A <a href=""../apidocs/org/apache/commons/math3/exception/MathUnsupportedOperationException.html""> <tt> 
    <clt fqn=""org.apache.commons.math3.exception.MathUnsupportedOperationException"" api=""MathUnsupportedOperationException"" kind=""class"">
      MathUnsupportedOperationException 
    </clt></tt></a> indicates that a feature is missing or does not make sense in the given context. </li> 
</ul> 
<p> In all of the above exception hierarchies, several subclasses can exist, each conveying a specific underlying cause of the problem. </p>","MathUnsupportedOperationException","org.apache.commons.math3.exception.MathUnsupportedOperationException","class",0
,"16 Exceptions","16.4 Features","<h3>16.4 Features</h3> 
<ul> 
 <li>Localization <p> The detailed error messages (i.e. the string returned by the <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/Throwable.html#getLocalizedMessage()""> 
    <clt fqn=""org.apache.commons.math3.exception.util.ExceptionContext.getLocalizedMessage"" api=""ExceptionContext"" kind=""class"">
     ExceptionContext.getLocalizedMessage
    </clt></a> method) can be localized. However, besides the American/English default, French is the only language for which a translation resource is available. </p> </li> 
 <li>Exception &quot;context&quot; <p> Every exception generated by Commons Math implements the <a href=""../apidocs/org/apache/commons/math3/exception/util/ExceptionContextProvider.html""> 
    <clt fqn=""org.apache.commons.math3.exception.util.ExceptionContextProvider"" api=""ExceptionContextProvider"" kind=""class"">
      ExceptionContextProvider 
    </clt></a> interface. A call to the <a href=""../apidocs/org/apache/commons/math3/exception/util/ExceptionContextProvider.html#getContext""> 
    <clt fqn=""org.apache.commons.math3.exception.util.ExceptionContextProvider.getContext"" api=""ExceptionContextProvider"" kind=""class"">
     ExceptionContextProvider.getContext
    </clt></a> method will return the <a href=""../apidocs/org/apache/commons/math3/exception/util/ExceptionContext.html""> 
    <clt fqn=""org.apache.commons.math3.exception.util.ExceptionContext"" api=""ExceptionContext"" kind=""class"">
      ExceptionContext 
    </clt></a> instance stored in the exception, which the user can further customize by adding messages and/or any object. </p> </li> 
</ul>","ExceptionContext","org.apache.commons.math3.exception.util.ExceptionContext","class",1
,"16 Exceptions","16.4 Features","<h3>16.4 Features</h3> 
<ul> 
 <li>Localization <p> The detailed error messages (i.e. the string returned by the <a class=""externalLink"" href=""http://docs.oracle.com/javase/6/docs/api/java/lang/Throwable.html#getLocalizedMessage()""> 
    <clt fqn=""org.apache.commons.math3.exception.util.ExceptionContext.getLocalizedMessage"" api=""ExceptionContext"" kind=""class"">
     ExceptionContext.getLocalizedMessage
    </clt></a> method) can be localized. However, besides the American/English default, French is the only language for which a translation resource is available. </p> </li> 
 <li>Exception &quot;context&quot; <p> Every exception generated by Commons Math implements the <a href=""../apidocs/org/apache/commons/math3/exception/util/ExceptionContextProvider.html""> 
    <clt fqn=""org.apache.commons.math3.exception.util.ExceptionContextProvider"" api=""ExceptionContextProvider"" kind=""class"">
      ExceptionContextProvider 
    </clt></a> interface. A call to the <a href=""../apidocs/org/apache/commons/math3/exception/util/ExceptionContextProvider.html#getContext""> 
    <clt fqn=""org.apache.commons.math3.exception.util.ExceptionContextProvider.getContext"" api=""ExceptionContextProvider"" kind=""class"">
     ExceptionContextProvider.getContext
    </clt></a> method will return the <a href=""../apidocs/org/apache/commons/math3/exception/util/ExceptionContext.html""> 
    <clt fqn=""org.apache.commons.math3.exception.util.ExceptionContext"" api=""ExceptionContext"" kind=""class"">
      ExceptionContext 
    </clt></a> instance stored in the exception, which the user can further customize by adding messages and/or any object. </p> </li> 
</ul>","ExceptionContextProvider","org.apache.commons.math3.exception.util.ExceptionContextProvider","class",0
,"15 Filters","15.2 Kalman Filter","<h3>15.2 Kalman Filter</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/filter/KalmanFilter.html""> 
  <clt fqn=""org.apache.commons.math3.filter.KalmanFilter"" api=""KalmanFilter"" kind=""class"">
    KalmanFilter 
  </clt></a> provides a discrete-time filter to estimate a stochastic linear process.</p> 
<p>A Kalman filter is initialized with a <a href=""../apidocs/org/apache/commons/math3/filter/ProcessModel.html""> 
  <clt fqn=""org.apache.commons.math3.filter.ProcessModel"" api=""ProcessModel"" kind=""class"">
    ProcessModel 
  </clt></a> and a <a href=""../apidocs/org/apache/commons/math3/filter/MeasurementModel.html""> 
  <clt fqn=""org.apache.commons.math3.filter.MeasurementModel"" api=""MeasurementModel"" kind=""class"">
    MeasurementModel 
  </clt></a>, which contain the corresponding transformation and noise covariance matrices. The parameter names used in the respective models correspond to the following names commonly used in the mathematical literature: </p> 
<ul> 
 <li>A - state transition matrix</li> 
 <li>B - control input matrix</li> 
 <li>H - measurement matrix</li> 
 <li>Q - process noise covariance matrix</li> 
 <li>R - measurement noise covariance matrix</li> 
 <li>P - error covariance matrix</li> 
</ul> 
<dt>
  Initialization 
</dt> 
<dd>
  The following code will create a Kalman filter using the provided DefaultMeasurementModel and DefaultProcessModel classes. To support dynamically changing process and measurement noises, simply implement your own models. 
 <div class=""source""> 
  <pre>
// A = [ 1 ]
RealMatrix A = new Array2DRowRealMatrix(new double[] { 1d });
// no control input
RealMatrix B = null;
// H = [ 1 ]
RealMatrix H = new Array2DRowRealMatrix(new double[] { 1d });
// Q = [ 0 ]
RealMatrix Q = new Array2DRowRealMatrix(new double[] { 0 });
// R = [ 0 ]
RealMatrix R = new Array2DRowRealMatrix(new double[] { 0 });

ProcessModel pm
   = new DefaultProcessModel(A, B, Q, new ArrayRealVector(new double[] { 0 }), null);
MeasurementModel mm = new DefaultMeasurementModel(H, R);
KalmanFilter filter = new KalmanFilter(pm, mm);
 			</pre> 
 </div> 
</dd> 
<dt>
  Iteration 
</dt> 
<dd>
  The following code illustrates how to perform the predict/correct cycle: 
 <div class=""source""> 
  <pre>
for (;;) {
   // predict the state estimate one time-step ahead
   // optionally provide some control input
   filter.predict();

   // obtain measurement vector z
   RealVector z = getMeasurement();

   // correct the state estimate with the latest measurement
   filter.correct(z);
   
   double[] stateEstimate = filter.getStateEstimation();
   // do something with it
}
		  </pre> 
 </div> 
</dd> 
<dt>
  Constant Voltage Example 
</dt> 
<dd>
  The following example creates a Kalman filter for a static process: a system with a constant voltage as internal state. We observe this process with an artificially imposed measurement noise of 0.1V and assume an internal process noise of 1e-5V. 
 <div class=""source""> 
  <pre>
double constantVoltage = 10d;
double measurementNoise = 0.1d;
double processNoise = 1e-5d;

// A = [ 1 ]
RealMatrix A = new Array2DRowRealMatrix(new double[] { 1d });
// B = null
RealMatrix B = null;
// H = [ 1 ]
RealMatrix H = new Array2DRowRealMatrix(new double[] { 1d });
// x = [ 10 ]
RealVector x = new ArrayRealVector(new double[] { constantVoltage });
// Q = [ 1e-5 ]
RealMatrix Q = new Array2DRowRealMatrix(new double[] { processNoise });
// P = [ 1 ]
RealMatrix P0 = new Array2DRowRealMatrix(new double[] { 1d });
// R = [ 0.1 ]
RealMatrix R = new Array2DRowRealMatrix(new double[] { measurementNoise });

ProcessModel pm = new DefaultProcessModel(A, B, Q, x, P0);
MeasurementModel mm = new DefaultMeasurementModel(H, R);
KalmanFilter filter = new KalmanFilter(pm, mm);  

// process and measurement noise vectors
RealVector pNoise = new ArrayRealVector(1);
RealVector mNoise = new ArrayRealVector(1);

RandomGenerator rand = new JDKRandomGenerator();
// iterate 60 steps
for (int i = 0; i &lt; 60; i++) {
    filter.predict();

    // simulate the process
    pNoise.setEntry(0, processNoise * rand.nextGaussian());

    // x = A * x + p_noise
    x = A.operate(x).add(pNoise);

    // simulate the measurement
    mNoise.setEntry(0, measurementNoise * rand.nextGaussian());

    // z = H * x + m_noise
    RealVector z = H.operate(x).add(mNoise);

    filter.correct(z);

    double voltage = filter.getStateEstimation()[0];
}
          </pre> 
 </div> 
</dd>","KalmanFilter","org.apache.commons.math3.filter.KalmanFilter","class",1
,"15 Filters","15.2 Kalman Filter","<h3>15.2 Kalman Filter</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/filter/KalmanFilter.html""> 
  <clt fqn=""org.apache.commons.math3.filter.KalmanFilter"" api=""KalmanFilter"" kind=""class"">
    KalmanFilter 
  </clt></a> provides a discrete-time filter to estimate a stochastic linear process.</p> 
<p>A Kalman filter is initialized with a <a href=""../apidocs/org/apache/commons/math3/filter/ProcessModel.html""> 
  <clt fqn=""org.apache.commons.math3.filter.ProcessModel"" api=""ProcessModel"" kind=""class"">
    ProcessModel 
  </clt></a> and a <a href=""../apidocs/org/apache/commons/math3/filter/MeasurementModel.html""> 
  <clt fqn=""org.apache.commons.math3.filter.MeasurementModel"" api=""MeasurementModel"" kind=""class"">
    MeasurementModel 
  </clt></a>, which contain the corresponding transformation and noise covariance matrices. The parameter names used in the respective models correspond to the following names commonly used in the mathematical literature: </p> 
<ul> 
 <li>A - state transition matrix</li> 
 <li>B - control input matrix</li> 
 <li>H - measurement matrix</li> 
 <li>Q - process noise covariance matrix</li> 
 <li>R - measurement noise covariance matrix</li> 
 <li>P - error covariance matrix</li> 
</ul> 
<dt>
  Initialization 
</dt> 
<dd>
  The following code will create a Kalman filter using the provided DefaultMeasurementModel and DefaultProcessModel classes. To support dynamically changing process and measurement noises, simply implement your own models. 
 <div class=""source""> 
  <pre>
// A = [ 1 ]
RealMatrix A = new Array2DRowRealMatrix(new double[] { 1d });
// no control input
RealMatrix B = null;
// H = [ 1 ]
RealMatrix H = new Array2DRowRealMatrix(new double[] { 1d });
// Q = [ 0 ]
RealMatrix Q = new Array2DRowRealMatrix(new double[] { 0 });
// R = [ 0 ]
RealMatrix R = new Array2DRowRealMatrix(new double[] { 0 });

ProcessModel pm
   = new DefaultProcessModel(A, B, Q, new ArrayRealVector(new double[] { 0 }), null);
MeasurementModel mm = new DefaultMeasurementModel(H, R);
KalmanFilter filter = new KalmanFilter(pm, mm);
 			</pre> 
 </div> 
</dd> 
<dt>
  Iteration 
</dt> 
<dd>
  The following code illustrates how to perform the predict/correct cycle: 
 <div class=""source""> 
  <pre>
for (;;) {
   // predict the state estimate one time-step ahead
   // optionally provide some control input
   filter.predict();

   // obtain measurement vector z
   RealVector z = getMeasurement();

   // correct the state estimate with the latest measurement
   filter.correct(z);
   
   double[] stateEstimate = filter.getStateEstimation();
   // do something with it
}
		  </pre> 
 </div> 
</dd> 
<dt>
  Constant Voltage Example 
</dt> 
<dd>
  The following example creates a Kalman filter for a static process: a system with a constant voltage as internal state. We observe this process with an artificially imposed measurement noise of 0.1V and assume an internal process noise of 1e-5V. 
 <div class=""source""> 
  <pre>
double constantVoltage = 10d;
double measurementNoise = 0.1d;
double processNoise = 1e-5d;

// A = [ 1 ]
RealMatrix A = new Array2DRowRealMatrix(new double[] { 1d });
// B = null
RealMatrix B = null;
// H = [ 1 ]
RealMatrix H = new Array2DRowRealMatrix(new double[] { 1d });
// x = [ 10 ]
RealVector x = new ArrayRealVector(new double[] { constantVoltage });
// Q = [ 1e-5 ]
RealMatrix Q = new Array2DRowRealMatrix(new double[] { processNoise });
// P = [ 1 ]
RealMatrix P0 = new Array2DRowRealMatrix(new double[] { 1d });
// R = [ 0.1 ]
RealMatrix R = new Array2DRowRealMatrix(new double[] { measurementNoise });

ProcessModel pm = new DefaultProcessModel(A, B, Q, x, P0);
MeasurementModel mm = new DefaultMeasurementModel(H, R);
KalmanFilter filter = new KalmanFilter(pm, mm);  

// process and measurement noise vectors
RealVector pNoise = new ArrayRealVector(1);
RealVector mNoise = new ArrayRealVector(1);

RandomGenerator rand = new JDKRandomGenerator();
// iterate 60 steps
for (int i = 0; i &lt; 60; i++) {
    filter.predict();

    // simulate the process
    pNoise.setEntry(0, processNoise * rand.nextGaussian());

    // x = A * x + p_noise
    x = A.operate(x).add(pNoise);

    // simulate the measurement
    mNoise.setEntry(0, measurementNoise * rand.nextGaussian());

    // z = H * x + m_noise
    RealVector z = H.operate(x).add(mNoise);

    filter.correct(z);

    double voltage = filter.getStateEstimation()[0];
}
          </pre> 
 </div> 
</dd>","ProcessModel","org.apache.commons.math3.filter.ProcessModel","class",1
,"15 Filters","15.2 Kalman Filter","<h3>15.2 Kalman Filter</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/filter/KalmanFilter.html""> 
  <clt fqn=""org.apache.commons.math3.filter.KalmanFilter"" api=""KalmanFilter"" kind=""class"">
    KalmanFilter 
  </clt></a> provides a discrete-time filter to estimate a stochastic linear process.</p> 
<p>A Kalman filter is initialized with a <a href=""../apidocs/org/apache/commons/math3/filter/ProcessModel.html""> 
  <clt fqn=""org.apache.commons.math3.filter.ProcessModel"" api=""ProcessModel"" kind=""class"">
    ProcessModel 
  </clt></a> and a <a href=""../apidocs/org/apache/commons/math3/filter/MeasurementModel.html""> 
  <clt fqn=""org.apache.commons.math3.filter.MeasurementModel"" api=""MeasurementModel"" kind=""class"">
    MeasurementModel 
  </clt></a>, which contain the corresponding transformation and noise covariance matrices. The parameter names used in the respective models correspond to the following names commonly used in the mathematical literature: </p> 
<ul> 
 <li>A - state transition matrix</li> 
 <li>B - control input matrix</li> 
 <li>H - measurement matrix</li> 
 <li>Q - process noise covariance matrix</li> 
 <li>R - measurement noise covariance matrix</li> 
 <li>P - error covariance matrix</li> 
</ul> 
<dt>
  Initialization 
</dt> 
<dd>
  The following code will create a Kalman filter using the provided DefaultMeasurementModel and DefaultProcessModel classes. To support dynamically changing process and measurement noises, simply implement your own models. 
 <div class=""source""> 
  <pre>
// A = [ 1 ]
RealMatrix A = new Array2DRowRealMatrix(new double[] { 1d });
// no control input
RealMatrix B = null;
// H = [ 1 ]
RealMatrix H = new Array2DRowRealMatrix(new double[] { 1d });
// Q = [ 0 ]
RealMatrix Q = new Array2DRowRealMatrix(new double[] { 0 });
// R = [ 0 ]
RealMatrix R = new Array2DRowRealMatrix(new double[] { 0 });

ProcessModel pm
   = new DefaultProcessModel(A, B, Q, new ArrayRealVector(new double[] { 0 }), null);
MeasurementModel mm = new DefaultMeasurementModel(H, R);
KalmanFilter filter = new KalmanFilter(pm, mm);
 			</pre> 
 </div> 
</dd> 
<dt>
  Iteration 
</dt> 
<dd>
  The following code illustrates how to perform the predict/correct cycle: 
 <div class=""source""> 
  <pre>
for (;;) {
   // predict the state estimate one time-step ahead
   // optionally provide some control input
   filter.predict();

   // obtain measurement vector z
   RealVector z = getMeasurement();

   // correct the state estimate with the latest measurement
   filter.correct(z);
   
   double[] stateEstimate = filter.getStateEstimation();
   // do something with it
}
		  </pre> 
 </div> 
</dd> 
<dt>
  Constant Voltage Example 
</dt> 
<dd>
  The following example creates a Kalman filter for a static process: a system with a constant voltage as internal state. We observe this process with an artificially imposed measurement noise of 0.1V and assume an internal process noise of 1e-5V. 
 <div class=""source""> 
  <pre>
double constantVoltage = 10d;
double measurementNoise = 0.1d;
double processNoise = 1e-5d;

// A = [ 1 ]
RealMatrix A = new Array2DRowRealMatrix(new double[] { 1d });
// B = null
RealMatrix B = null;
// H = [ 1 ]
RealMatrix H = new Array2DRowRealMatrix(new double[] { 1d });
// x = [ 10 ]
RealVector x = new ArrayRealVector(new double[] { constantVoltage });
// Q = [ 1e-5 ]
RealMatrix Q = new Array2DRowRealMatrix(new double[] { processNoise });
// P = [ 1 ]
RealMatrix P0 = new Array2DRowRealMatrix(new double[] { 1d });
// R = [ 0.1 ]
RealMatrix R = new Array2DRowRealMatrix(new double[] { measurementNoise });

ProcessModel pm = new DefaultProcessModel(A, B, Q, x, P0);
MeasurementModel mm = new DefaultMeasurementModel(H, R);
KalmanFilter filter = new KalmanFilter(pm, mm);  

// process and measurement noise vectors
RealVector pNoise = new ArrayRealVector(1);
RealVector mNoise = new ArrayRealVector(1);

RandomGenerator rand = new JDKRandomGenerator();
// iterate 60 steps
for (int i = 0; i &lt; 60; i++) {
    filter.predict();

    // simulate the process
    pNoise.setEntry(0, processNoise * rand.nextGaussian());

    // x = A * x + p_noise
    x = A.operate(x).add(pNoise);

    // simulate the measurement
    mNoise.setEntry(0, measurementNoise * rand.nextGaussian());

    // z = H * x + m_noise
    RealVector z = H.operate(x).add(mNoise);

    filter.correct(z);

    double voltage = filter.getStateEstimation()[0];
}
          </pre> 
 </div> 
</dd>","MeasurementModel","org.apache.commons.math3.filter.MeasurementModel","class",1
,"9 Fractions","9.2 Fraction Numbers","<h3>9.2 
 <clt fqn=""org.apache.commons.math3.fraction.Fraction"" api=""Fraction"" kind=""class"">
   Fraction 
 </clt> Numbers</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/fraction/Fraction.html""> 
  <clt fqn=""org.apache.commons.math3.fraction.Fraction"" api=""Fraction"" kind=""unknown"">
    Fraction 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/fraction/BigFraction.html""> 
  <clt fqn=""org.apache.commons.math3.fraction.BigFraction"" api=""BigFraction"" kind=""class"">
    BigFraction 
  </clt></a> provide fraction number type that forms the basis for the fraction functionality found in Commons-Math. The former one can be used for fractions whose numerators and denominators are small enough to fit in an int (taking care of intermediate values) while the second class should be used when there is a risk the numerator and denominator grow very large. </p> 
<p> A fraction number, can be built from two integer arguments representing numerator and denominator or from a double which will be approximated: </p> 
<div class=""source""> 
 <pre>Fraction f = new Fraction(1, 3); // 1 / 3
Fraction g = new Fraction(0.25); // 1 / 4</pre> 
</div> 
<p> Of special note with fraction construction, when a fraction is created it is always reduced to lowest terms. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.fraction.Fraction"" api=""Fraction"" kind=""unknown"">
    Fraction 
  </clt></tt> class provides many unary and binary fraction operations. These operations provide the means to add, subtract, multiple and, divide fractions along with other functions similar to the real number functions found in <tt>java.math.BigDecimal</tt>: </p> 
<div class=""source""> 
 <pre>Fraction lhs = new Fraction(1, 3);
Fraction rhs = new Fraction(2, 5);

Fraction answer = lhs.add(rhs);     // add two fractions
        answer = lhs.subtract(rhs); // subtract two fractions
        answer = lhs.abs();         // absolute value
        answer = lhs.reciprocal();  // reciprocal of lhs</pre> 
</div> 
<p> Like fraction construction, for each of the fraction functions, the resulting fraction is reduced to lowest terms. </p>","Fraction","org.apache.commons.math3.fraction.Fraction","class",1
,"9 Fractions","9.2 Fraction Numbers","<h3>9.2 
 <clt fqn=""org.apache.commons.math3.fraction.Fraction"" api=""Fraction"" kind=""class"">
   Fraction 
 </clt> Numbers</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/fraction/Fraction.html""> 
  <clt fqn=""org.apache.commons.math3.fraction.Fraction"" api=""Fraction"" kind=""unknown"">
    Fraction 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/fraction/BigFraction.html""> 
  <clt fqn=""org.apache.commons.math3.fraction.BigFraction"" api=""BigFraction"" kind=""class"">
    BigFraction 
  </clt></a> provide fraction number type that forms the basis for the fraction functionality found in Commons-Math. The former one can be used for fractions whose numerators and denominators are small enough to fit in an int (taking care of intermediate values) while the second class should be used when there is a risk the numerator and denominator grow very large. </p> 
<p> A fraction number, can be built from two integer arguments representing numerator and denominator or from a double which will be approximated: </p> 
<div class=""source""> 
 <pre>Fraction f = new Fraction(1, 3); // 1 / 3
Fraction g = new Fraction(0.25); // 1 / 4</pre> 
</div> 
<p> Of special note with fraction construction, when a fraction is created it is always reduced to lowest terms. </p> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.fraction.Fraction"" api=""Fraction"" kind=""unknown"">
    Fraction 
  </clt></tt> class provides many unary and binary fraction operations. These operations provide the means to add, subtract, multiple and, divide fractions along with other functions similar to the real number functions found in <tt>java.math.BigDecimal</tt>: </p> 
<div class=""source""> 
 <pre>Fraction lhs = new Fraction(1, 3);
Fraction rhs = new Fraction(2, 5);

Fraction answer = lhs.add(rhs);     // add two fractions
        answer = lhs.subtract(rhs); // subtract two fractions
        answer = lhs.abs();         // absolute value
        answer = lhs.reciprocal();  // reciprocal of lhs</pre> 
</div> 
<p> Like fraction construction, for each of the fraction functions, the resulting fraction is reduced to lowest terms. </p>","BigFraction","org.apache.commons.math3.fraction.BigFraction","class",1
,"9 Fractions","9.3 Fraction Formatting and Parsing","<h3>9.3 
 <clt fqn=""org.apache.commons.math3.fraction.Fraction"" api=""Fraction"" kind=""class"">
   Fraction 
 </clt> Formatting and Parsing</h3> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.fraction.Fraction"" api=""Fraction"" kind=""unknown"">
    Fraction 
  </clt></tt> instances can be converted to and from strings using the<a href=""../apidocs/org/apache/commons/math3/fraction/FractionFormat.html""> 
  <clt fqn=""org.apache.commons.math3.fraction.FractionFormat"" api=""FractionFormat"" kind=""class"">
    FractionFormat 
  </clt></a> class. <tt> 
  <clt fqn=""org.apache.commons.math3.fraction.FractionFormat"" api=""FractionFormat"" kind=""class"">
    FractionFormat 
  </clt></tt> is a <tt>java.text.Format</tt> extension and, as such, is used like other formatting objects (e.g. <tt>java.text.SimpleDateFormat</tt>): </p> 
<div class=""source""> 
 <pre>FractionFormat format = new FractionFormat(); // default format
Fraction f = new Fraction(2, 4);
String s = format.format(f); // s contains &quot;1 / 2&quot;, note the reduced fraction</pre> 
</div> 
<p> To customize the formatting output, one or two <tt>java.text.NumberFormat</tt> instances can be used to construct a <tt> 
  <clt fqn=""org.apache.commons.math3.fraction.FractionFormat"" api=""FractionFormat"" kind=""class"">
    FractionFormat 
  </clt></tt>. These number formats control the formatting of the numerator and denominator of the fraction: </p> 
<div class=""source""> 
 <pre>NumberFormat nf = NumberFormat.getInstance(Locale.FRANCE);
// create fraction format with custom number format
// when one number format is used, both numerator and
// denominator are formatted the same
FractionFormat format = new FractionFormat(nf);
Fraction f = new Fraction(2000, 3333);
String s = format.format(c); // s contains &quot;2.000 / 3.333&quot;

NumberFormat nf2 = NumberFormat.getInstance(Locale.US);
// create fraction format with custom number formats
format = new FractionFormat(nf, nf2);
s = format.format(f); // s contains &quot;2.000 / 3,333&quot;</pre> 
</div> 
<p> Formatting's inverse operation, parsing, can also be performed by <tt> 
  <clt fqn=""org.apache.commons.math3.fraction.FractionFormat"" api=""FractionFormat"" kind=""class"">
    FractionFormat 
  </clt></tt>. To parse a fraction from a string, simply call the <tt> 
  <clt fqn=""org.apache.commons.math3.fraction.FractionFormat.parse"" api=""FractionFormat"" kind=""unknown"">
   FractionFormat.parse
  </clt></tt> method: </p> 
<div class=""source""> 
 <pre>FractionFormat ff = new FractionFormat();
Fraction f = ff.parse(&quot;-10 / 21&quot;);</pre> 
</div>","Fraction","org.apache.commons.math3.fraction.Fraction","class",1
,"9 Fractions","9.3 Fraction Formatting and Parsing","<h3>9.3 
 <clt fqn=""org.apache.commons.math3.fraction.Fraction"" api=""Fraction"" kind=""class"">
   Fraction 
 </clt> Formatting and Parsing</h3> 
<p> <tt> 
  <clt fqn=""org.apache.commons.math3.fraction.Fraction"" api=""Fraction"" kind=""unknown"">
    Fraction 
  </clt></tt> instances can be converted to and from strings using the<a href=""../apidocs/org/apache/commons/math3/fraction/FractionFormat.html""> 
  <clt fqn=""org.apache.commons.math3.fraction.FractionFormat"" api=""FractionFormat"" kind=""class"">
    FractionFormat 
  </clt></a> class. <tt> 
  <clt fqn=""org.apache.commons.math3.fraction.FractionFormat"" api=""FractionFormat"" kind=""class"">
    FractionFormat 
  </clt></tt> is a <tt>java.text.Format</tt> extension and, as such, is used like other formatting objects (e.g. <tt>java.text.SimpleDateFormat</tt>): </p> 
<div class=""source""> 
 <pre>FractionFormat format = new FractionFormat(); // default format
Fraction f = new Fraction(2, 4);
String s = format.format(f); // s contains &quot;1 / 2&quot;, note the reduced fraction</pre> 
</div> 
<p> To customize the formatting output, one or two <tt>java.text.NumberFormat</tt> instances can be used to construct a <tt> 
  <clt fqn=""org.apache.commons.math3.fraction.FractionFormat"" api=""FractionFormat"" kind=""class"">
    FractionFormat 
  </clt></tt>. These number formats control the formatting of the numerator and denominator of the fraction: </p> 
<div class=""source""> 
 <pre>NumberFormat nf = NumberFormat.getInstance(Locale.FRANCE);
// create fraction format with custom number format
// when one number format is used, both numerator and
// denominator are formatted the same
FractionFormat format = new FractionFormat(nf);
Fraction f = new Fraction(2000, 3333);
String s = format.format(c); // s contains &quot;2.000 / 3.333&quot;

NumberFormat nf2 = NumberFormat.getInstance(Locale.US);
// create fraction format with custom number formats
format = new FractionFormat(nf, nf2);
s = format.format(f); // s contains &quot;2.000 / 3,333&quot;</pre> 
</div> 
<p> Formatting's inverse operation, parsing, can also be performed by <tt> 
  <clt fqn=""org.apache.commons.math3.fraction.FractionFormat"" api=""FractionFormat"" kind=""class"">
    FractionFormat 
  </clt></tt>. To parse a fraction from a string, simply call the <tt> 
  <clt fqn=""org.apache.commons.math3.fraction.FractionFormat.parse"" api=""FractionFormat"" kind=""unknown"">
   FractionFormat.parse
  </clt></tt> method: </p> 
<div class=""source""> 
 <pre>FractionFormat ff = new FractionFormat();
Fraction f = ff.parse(&quot;-10 / 21&quot;);</pre> 
</div>","FractionFormat","org.apache.commons.math3.fraction.FractionFormat","class",1
,"14 Genetic Algorithms","14.2 GA Framework","<h3>14.2 GA Framework</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/genetics/GeneticAlgorithm.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm"" api=""GeneticAlgorithm"" kind=""class"">
    GeneticAlgorithm 
  </clt></a> provides an execution framework for Genetic Algorithms (GA). <a href=""../apidocs/org/apache/commons/math3/genetics/Population.html""> Populations,</a> consisting of <a href=""../apidocs/org/apache/commons/math3/genetics/Chromosome.html""> Chromosomes</a> are evolved by the <tt> 
  <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm"" api=""GeneticAlgorithm"" kind=""class"">
    GeneticAlgorithm 
  </clt></tt> until a <a href=""../apidocs/org/apache/commons/math3/genetics/StoppingCondition.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.StoppingCondition"" api=""StoppingCondition"" kind=""class"">
    StoppingCondition 
  </clt></a> is reached. Evolution is determined by <a href=""../apidocs/org/apache/commons/math3/genetics/SelectionPolicy.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.SelectionPolicy"" api=""SelectionPolicy"" kind=""class"">
    SelectionPolicy 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/genetics/MutationPolicy.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.MutationPolicy"" api=""MutationPolicy"" kind=""class"">
    MutationPolicy 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/genetics/Fitness.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.Fitness"" api=""Fitness"" kind=""unknown"">
    Fitness 
  </clt></a>. </p> 
<p> The GA itself is implemented by the <tt> 
  <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm.evolve"" api=""GeneticAlgorithm"" kind=""unknown"">
   GeneticAlgorithm.evolve
  </clt></tt> method of the <tt> 
  <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm"" api=""GeneticAlgorithm"" kind=""class"">
    GeneticAlgorithm 
  </clt></tt> class, which looks like this: </p> 
<div class=""source""> 
 <pre>public Population evolve(Population initial, StoppingCondition condition) {
    Population current = initial;
    while (!condition.isSatisfied(current)) {
        current = nextGeneration(current);
    }
    return current;
}
          </pre> 
</div> The 
<tt> 
 <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm.nextGeneration"" api=""GeneticAlgorithm"" kind=""class"">
  GeneticAlgorithm.nextGeneration
 </clt></tt> method implements the following algorithm: 
<ol style=""list-style-type: decimal""> 
 <li>Get nextGeneration population to fill from <tt>current</tt> generation, using its nextGeneration method</li> 
 <li>Loop until new generation is filled:</li> 
 <ul> 
  <li>Apply configured <tt> 
    <clt fqn=""org.apache.commons.math3.genetics.SelectionPolicy"" api=""SelectionPolicy"" kind=""class"">
      SelectionPolicy 
    </clt></tt> to select a pair of parents from <tt>current</tt></li> 
  <li>With probability = <a href=""../apidocs/org/apache/commons/math3/genetics/GeneticAlgorithm.html#getCrossoverRate""> 
    <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm.getCrossoverRate"" api=""GeneticAlgorithm"" kind=""method"">
     GeneticAlgorithm.getCrossoverRate()
    </clt></a>, apply configured <tt> 
    <clt fqn=""org.apache.commons.math3.genetics.CrossoverPolicy"" api=""CrossoverPolicy"" kind=""class"">
      CrossoverPolicy 
    </clt></tt> to parents</li> 
  <li>With probability = <a href=""../apidocs/org/apache/commons/math3/genetics/GeneticAlgorithm.html#getMutationRate""> 
    <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm.getMutationRate"" api=""GeneticAlgorithm"" kind=""method"">
     GeneticAlgorithm.getMutationRate()
    </clt></a>, apply configured <tt> 
    <clt fqn=""org.apache.commons.math3.genetics.MutationPolicy"" api=""MutationPolicy"" kind=""class"">
      MutationPolicy 
    </clt></tt> to each of the offspring</li> 
  <li>Add offspring individually to nextGeneration, space permitting</li> 
 </ul> 
 <li>Return nextGeneration</li> 
</ol>","GeneticAlgorithm","org.apache.commons.math3.genetics.GeneticAlgorithm","class",1
,"14 Genetic Algorithms","14.2 GA Framework","<h3>14.2 GA Framework</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/genetics/GeneticAlgorithm.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm"" api=""GeneticAlgorithm"" kind=""class"">
    GeneticAlgorithm 
  </clt></a> provides an execution framework for Genetic Algorithms (GA). <a href=""../apidocs/org/apache/commons/math3/genetics/Population.html""> Populations,</a> consisting of <a href=""../apidocs/org/apache/commons/math3/genetics/Chromosome.html""> Chromosomes</a> are evolved by the <tt> 
  <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm"" api=""GeneticAlgorithm"" kind=""class"">
    GeneticAlgorithm 
  </clt></tt> until a <a href=""../apidocs/org/apache/commons/math3/genetics/StoppingCondition.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.StoppingCondition"" api=""StoppingCondition"" kind=""class"">
    StoppingCondition 
  </clt></a> is reached. Evolution is determined by <a href=""../apidocs/org/apache/commons/math3/genetics/SelectionPolicy.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.SelectionPolicy"" api=""SelectionPolicy"" kind=""class"">
    SelectionPolicy 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/genetics/MutationPolicy.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.MutationPolicy"" api=""MutationPolicy"" kind=""class"">
    MutationPolicy 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/genetics/Fitness.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.Fitness"" api=""Fitness"" kind=""unknown"">
    Fitness 
  </clt></a>. </p> 
<p> The GA itself is implemented by the <tt> 
  <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm.evolve"" api=""GeneticAlgorithm"" kind=""unknown"">
   GeneticAlgorithm.evolve
  </clt></tt> method of the <tt> 
  <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm"" api=""GeneticAlgorithm"" kind=""class"">
    GeneticAlgorithm 
  </clt></tt> class, which looks like this: </p> 
<div class=""source""> 
 <pre>public Population evolve(Population initial, StoppingCondition condition) {
    Population current = initial;
    while (!condition.isSatisfied(current)) {
        current = nextGeneration(current);
    }
    return current;
}
          </pre> 
</div> The 
<tt> 
 <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm.nextGeneration"" api=""GeneticAlgorithm"" kind=""class"">
  GeneticAlgorithm.nextGeneration
 </clt></tt> method implements the following algorithm: 
<ol style=""list-style-type: decimal""> 
 <li>Get nextGeneration population to fill from <tt>current</tt> generation, using its nextGeneration method</li> 
 <li>Loop until new generation is filled:</li> 
 <ul> 
  <li>Apply configured <tt> 
    <clt fqn=""org.apache.commons.math3.genetics.SelectionPolicy"" api=""SelectionPolicy"" kind=""class"">
      SelectionPolicy 
    </clt></tt> to select a pair of parents from <tt>current</tt></li> 
  <li>With probability = <a href=""../apidocs/org/apache/commons/math3/genetics/GeneticAlgorithm.html#getCrossoverRate""> 
    <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm.getCrossoverRate"" api=""GeneticAlgorithm"" kind=""method"">
     GeneticAlgorithm.getCrossoverRate()
    </clt></a>, apply configured <tt> 
    <clt fqn=""org.apache.commons.math3.genetics.CrossoverPolicy"" api=""CrossoverPolicy"" kind=""class"">
      CrossoverPolicy 
    </clt></tt> to parents</li> 
  <li>With probability = <a href=""../apidocs/org/apache/commons/math3/genetics/GeneticAlgorithm.html#getMutationRate""> 
    <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm.getMutationRate"" api=""GeneticAlgorithm"" kind=""method"">
     GeneticAlgorithm.getMutationRate()
    </clt></a>, apply configured <tt> 
    <clt fqn=""org.apache.commons.math3.genetics.MutationPolicy"" api=""MutationPolicy"" kind=""class"">
      MutationPolicy 
    </clt></tt> to each of the offspring</li> 
  <li>Add offspring individually to nextGeneration, space permitting</li> 
 </ul> 
 <li>Return nextGeneration</li> 
</ol>","StoppingCondition","org.apache.commons.math3.genetics.StoppingCondition","class",0
,"14 Genetic Algorithms","14.2 GA Framework","<h3>14.2 GA Framework</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/genetics/GeneticAlgorithm.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm"" api=""GeneticAlgorithm"" kind=""class"">
    GeneticAlgorithm 
  </clt></a> provides an execution framework for Genetic Algorithms (GA). <a href=""../apidocs/org/apache/commons/math3/genetics/Population.html""> Populations,</a> consisting of <a href=""../apidocs/org/apache/commons/math3/genetics/Chromosome.html""> Chromosomes</a> are evolved by the <tt> 
  <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm"" api=""GeneticAlgorithm"" kind=""class"">
    GeneticAlgorithm 
  </clt></tt> until a <a href=""../apidocs/org/apache/commons/math3/genetics/StoppingCondition.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.StoppingCondition"" api=""StoppingCondition"" kind=""class"">
    StoppingCondition 
  </clt></a> is reached. Evolution is determined by <a href=""../apidocs/org/apache/commons/math3/genetics/SelectionPolicy.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.SelectionPolicy"" api=""SelectionPolicy"" kind=""class"">
    SelectionPolicy 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/genetics/MutationPolicy.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.MutationPolicy"" api=""MutationPolicy"" kind=""class"">
    MutationPolicy 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/genetics/Fitness.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.Fitness"" api=""Fitness"" kind=""unknown"">
    Fitness 
  </clt></a>. </p> 
<p> The GA itself is implemented by the <tt> 
  <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm.evolve"" api=""GeneticAlgorithm"" kind=""unknown"">
   GeneticAlgorithm.evolve
  </clt></tt> method of the <tt> 
  <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm"" api=""GeneticAlgorithm"" kind=""class"">
    GeneticAlgorithm 
  </clt></tt> class, which looks like this: </p> 
<div class=""source""> 
 <pre>public Population evolve(Population initial, StoppingCondition condition) {
    Population current = initial;
    while (!condition.isSatisfied(current)) {
        current = nextGeneration(current);
    }
    return current;
}
          </pre> 
</div> The 
<tt> 
 <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm.nextGeneration"" api=""GeneticAlgorithm"" kind=""class"">
  GeneticAlgorithm.nextGeneration
 </clt></tt> method implements the following algorithm: 
<ol style=""list-style-type: decimal""> 
 <li>Get nextGeneration population to fill from <tt>current</tt> generation, using its nextGeneration method</li> 
 <li>Loop until new generation is filled:</li> 
 <ul> 
  <li>Apply configured <tt> 
    <clt fqn=""org.apache.commons.math3.genetics.SelectionPolicy"" api=""SelectionPolicy"" kind=""class"">
      SelectionPolicy 
    </clt></tt> to select a pair of parents from <tt>current</tt></li> 
  <li>With probability = <a href=""../apidocs/org/apache/commons/math3/genetics/GeneticAlgorithm.html#getCrossoverRate""> 
    <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm.getCrossoverRate"" api=""GeneticAlgorithm"" kind=""method"">
     GeneticAlgorithm.getCrossoverRate()
    </clt></a>, apply configured <tt> 
    <clt fqn=""org.apache.commons.math3.genetics.CrossoverPolicy"" api=""CrossoverPolicy"" kind=""class"">
      CrossoverPolicy 
    </clt></tt> to parents</li> 
  <li>With probability = <a href=""../apidocs/org/apache/commons/math3/genetics/GeneticAlgorithm.html#getMutationRate""> 
    <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm.getMutationRate"" api=""GeneticAlgorithm"" kind=""method"">
     GeneticAlgorithm.getMutationRate()
    </clt></a>, apply configured <tt> 
    <clt fqn=""org.apache.commons.math3.genetics.MutationPolicy"" api=""MutationPolicy"" kind=""class"">
      MutationPolicy 
    </clt></tt> to each of the offspring</li> 
  <li>Add offspring individually to nextGeneration, space permitting</li> 
 </ul> 
 <li>Return nextGeneration</li> 
</ol>","SelectionPolicy","org.apache.commons.math3.genetics.SelectionPolicy","class",0
,"14 Genetic Algorithms","14.2 GA Framework","<h3>14.2 GA Framework</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/genetics/GeneticAlgorithm.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm"" api=""GeneticAlgorithm"" kind=""class"">
    GeneticAlgorithm 
  </clt></a> provides an execution framework for Genetic Algorithms (GA). <a href=""../apidocs/org/apache/commons/math3/genetics/Population.html""> Populations,</a> consisting of <a href=""../apidocs/org/apache/commons/math3/genetics/Chromosome.html""> Chromosomes</a> are evolved by the <tt> 
  <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm"" api=""GeneticAlgorithm"" kind=""class"">
    GeneticAlgorithm 
  </clt></tt> until a <a href=""../apidocs/org/apache/commons/math3/genetics/StoppingCondition.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.StoppingCondition"" api=""StoppingCondition"" kind=""class"">
    StoppingCondition 
  </clt></a> is reached. Evolution is determined by <a href=""../apidocs/org/apache/commons/math3/genetics/SelectionPolicy.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.SelectionPolicy"" api=""SelectionPolicy"" kind=""class"">
    SelectionPolicy 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/genetics/MutationPolicy.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.MutationPolicy"" api=""MutationPolicy"" kind=""class"">
    MutationPolicy 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/genetics/Fitness.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.Fitness"" api=""Fitness"" kind=""unknown"">
    Fitness 
  </clt></a>. </p> 
<p> The GA itself is implemented by the <tt> 
  <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm.evolve"" api=""GeneticAlgorithm"" kind=""unknown"">
   GeneticAlgorithm.evolve
  </clt></tt> method of the <tt> 
  <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm"" api=""GeneticAlgorithm"" kind=""class"">
    GeneticAlgorithm 
  </clt></tt> class, which looks like this: </p> 
<div class=""source""> 
 <pre>public Population evolve(Population initial, StoppingCondition condition) {
    Population current = initial;
    while (!condition.isSatisfied(current)) {
        current = nextGeneration(current);
    }
    return current;
}
          </pre> 
</div> The 
<tt> 
 <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm.nextGeneration"" api=""GeneticAlgorithm"" kind=""class"">
  GeneticAlgorithm.nextGeneration
 </clt></tt> method implements the following algorithm: 
<ol style=""list-style-type: decimal""> 
 <li>Get nextGeneration population to fill from <tt>current</tt> generation, using its nextGeneration method</li> 
 <li>Loop until new generation is filled:</li> 
 <ul> 
  <li>Apply configured <tt> 
    <clt fqn=""org.apache.commons.math3.genetics.SelectionPolicy"" api=""SelectionPolicy"" kind=""class"">
      SelectionPolicy 
    </clt></tt> to select a pair of parents from <tt>current</tt></li> 
  <li>With probability = <a href=""../apidocs/org/apache/commons/math3/genetics/GeneticAlgorithm.html#getCrossoverRate""> 
    <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm.getCrossoverRate"" api=""GeneticAlgorithm"" kind=""method"">
     GeneticAlgorithm.getCrossoverRate()
    </clt></a>, apply configured <tt> 
    <clt fqn=""org.apache.commons.math3.genetics.CrossoverPolicy"" api=""CrossoverPolicy"" kind=""class"">
      CrossoverPolicy 
    </clt></tt> to parents</li> 
  <li>With probability = <a href=""../apidocs/org/apache/commons/math3/genetics/GeneticAlgorithm.html#getMutationRate""> 
    <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm.getMutationRate"" api=""GeneticAlgorithm"" kind=""method"">
     GeneticAlgorithm.getMutationRate()
    </clt></a>, apply configured <tt> 
    <clt fqn=""org.apache.commons.math3.genetics.MutationPolicy"" api=""MutationPolicy"" kind=""class"">
      MutationPolicy 
    </clt></tt> to each of the offspring</li> 
  <li>Add offspring individually to nextGeneration, space permitting</li> 
 </ul> 
 <li>Return nextGeneration</li> 
</ol>","MutationPolicy","org.apache.commons.math3.genetics.MutationPolicy","class",0
,"14 Genetic Algorithms","14.2 GA Framework","<h3>14.2 GA Framework</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/genetics/GeneticAlgorithm.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm"" api=""GeneticAlgorithm"" kind=""class"">
    GeneticAlgorithm 
  </clt></a> provides an execution framework for Genetic Algorithms (GA). <a href=""../apidocs/org/apache/commons/math3/genetics/Population.html""> Populations,</a> consisting of <a href=""../apidocs/org/apache/commons/math3/genetics/Chromosome.html""> Chromosomes</a> are evolved by the <tt> 
  <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm"" api=""GeneticAlgorithm"" kind=""class"">
    GeneticAlgorithm 
  </clt></tt> until a <a href=""../apidocs/org/apache/commons/math3/genetics/StoppingCondition.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.StoppingCondition"" api=""StoppingCondition"" kind=""class"">
    StoppingCondition 
  </clt></a> is reached. Evolution is determined by <a href=""../apidocs/org/apache/commons/math3/genetics/SelectionPolicy.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.SelectionPolicy"" api=""SelectionPolicy"" kind=""class"">
    SelectionPolicy 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/genetics/MutationPolicy.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.MutationPolicy"" api=""MutationPolicy"" kind=""class"">
    MutationPolicy 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/genetics/Fitness.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.Fitness"" api=""Fitness"" kind=""unknown"">
    Fitness 
  </clt></a>. </p> 
<p> The GA itself is implemented by the <tt> 
  <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm.evolve"" api=""GeneticAlgorithm"" kind=""unknown"">
   GeneticAlgorithm.evolve
  </clt></tt> method of the <tt> 
  <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm"" api=""GeneticAlgorithm"" kind=""class"">
    GeneticAlgorithm 
  </clt></tt> class, which looks like this: </p> 
<div class=""source""> 
 <pre>public Population evolve(Population initial, StoppingCondition condition) {
    Population current = initial;
    while (!condition.isSatisfied(current)) {
        current = nextGeneration(current);
    }
    return current;
}
          </pre> 
</div> The 
<tt> 
 <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm.nextGeneration"" api=""GeneticAlgorithm"" kind=""class"">
  GeneticAlgorithm.nextGeneration
 </clt></tt> method implements the following algorithm: 
<ol style=""list-style-type: decimal""> 
 <li>Get nextGeneration population to fill from <tt>current</tt> generation, using its nextGeneration method</li> 
 <li>Loop until new generation is filled:</li> 
 <ul> 
  <li>Apply configured <tt> 
    <clt fqn=""org.apache.commons.math3.genetics.SelectionPolicy"" api=""SelectionPolicy"" kind=""class"">
      SelectionPolicy 
    </clt></tt> to select a pair of parents from <tt>current</tt></li> 
  <li>With probability = <a href=""../apidocs/org/apache/commons/math3/genetics/GeneticAlgorithm.html#getCrossoverRate""> 
    <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm.getCrossoverRate"" api=""GeneticAlgorithm"" kind=""method"">
     GeneticAlgorithm.getCrossoverRate()
    </clt></a>, apply configured <tt> 
    <clt fqn=""org.apache.commons.math3.genetics.CrossoverPolicy"" api=""CrossoverPolicy"" kind=""class"">
      CrossoverPolicy 
    </clt></tt> to parents</li> 
  <li>With probability = <a href=""../apidocs/org/apache/commons/math3/genetics/GeneticAlgorithm.html#getMutationRate""> 
    <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm.getMutationRate"" api=""GeneticAlgorithm"" kind=""method"">
     GeneticAlgorithm.getMutationRate()
    </clt></a>, apply configured <tt> 
    <clt fqn=""org.apache.commons.math3.genetics.MutationPolicy"" api=""MutationPolicy"" kind=""class"">
      MutationPolicy 
    </clt></tt> to each of the offspring</li> 
  <li>Add offspring individually to nextGeneration, space permitting</li> 
 </ul> 
 <li>Return nextGeneration</li> 
</ol>","Fitness","org.apache.commons.math3.genetics.Fitness","class",0
,"14 Genetic Algorithms","14.2 GA Framework","<h3>14.2 GA Framework</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/genetics/GeneticAlgorithm.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm"" api=""GeneticAlgorithm"" kind=""class"">
    GeneticAlgorithm 
  </clt></a> provides an execution framework for Genetic Algorithms (GA). <a href=""../apidocs/org/apache/commons/math3/genetics/Population.html""> Populations,</a> consisting of <a href=""../apidocs/org/apache/commons/math3/genetics/Chromosome.html""> Chromosomes</a> are evolved by the <tt> 
  <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm"" api=""GeneticAlgorithm"" kind=""class"">
    GeneticAlgorithm 
  </clt></tt> until a <a href=""../apidocs/org/apache/commons/math3/genetics/StoppingCondition.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.StoppingCondition"" api=""StoppingCondition"" kind=""class"">
    StoppingCondition 
  </clt></a> is reached. Evolution is determined by <a href=""../apidocs/org/apache/commons/math3/genetics/SelectionPolicy.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.SelectionPolicy"" api=""SelectionPolicy"" kind=""class"">
    SelectionPolicy 
  </clt></a>, <a href=""../apidocs/org/apache/commons/math3/genetics/MutationPolicy.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.MutationPolicy"" api=""MutationPolicy"" kind=""class"">
    MutationPolicy 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/genetics/Fitness.html""> 
  <clt fqn=""org.apache.commons.math3.genetics.Fitness"" api=""Fitness"" kind=""unknown"">
    Fitness 
  </clt></a>. </p> 
<p> The GA itself is implemented by the <tt> 
  <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm.evolve"" api=""GeneticAlgorithm"" kind=""unknown"">
   GeneticAlgorithm.evolve
  </clt></tt> method of the <tt> 
  <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm"" api=""GeneticAlgorithm"" kind=""class"">
    GeneticAlgorithm 
  </clt></tt> class, which looks like this: </p> 
<div class=""source""> 
 <pre>public Population evolve(Population initial, StoppingCondition condition) {
    Population current = initial;
    while (!condition.isSatisfied(current)) {
        current = nextGeneration(current);
    }
    return current;
}
          </pre> 
</div> The 
<tt> 
 <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm.nextGeneration"" api=""GeneticAlgorithm"" kind=""class"">
  GeneticAlgorithm.nextGeneration
 </clt></tt> method implements the following algorithm: 
<ol style=""list-style-type: decimal""> 
 <li>Get nextGeneration population to fill from <tt>current</tt> generation, using its nextGeneration method</li> 
 <li>Loop until new generation is filled:</li> 
 <ul> 
  <li>Apply configured <tt> 
    <clt fqn=""org.apache.commons.math3.genetics.SelectionPolicy"" api=""SelectionPolicy"" kind=""class"">
      SelectionPolicy 
    </clt></tt> to select a pair of parents from <tt>current</tt></li> 
  <li>With probability = <a href=""../apidocs/org/apache/commons/math3/genetics/GeneticAlgorithm.html#getCrossoverRate""> 
    <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm.getCrossoverRate"" api=""GeneticAlgorithm"" kind=""method"">
     GeneticAlgorithm.getCrossoverRate()
    </clt></a>, apply configured <tt> 
    <clt fqn=""org.apache.commons.math3.genetics.CrossoverPolicy"" api=""CrossoverPolicy"" kind=""class"">
      CrossoverPolicy 
    </clt></tt> to parents</li> 
  <li>With probability = <a href=""../apidocs/org/apache/commons/math3/genetics/GeneticAlgorithm.html#getMutationRate""> 
    <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm.getMutationRate"" api=""GeneticAlgorithm"" kind=""method"">
     GeneticAlgorithm.getMutationRate()
    </clt></a>, apply configured <tt> 
    <clt fqn=""org.apache.commons.math3.genetics.MutationPolicy"" api=""MutationPolicy"" kind=""class"">
      MutationPolicy 
    </clt></tt> to each of the offspring</li> 
  <li>Add offspring individually to nextGeneration, space permitting</li> 
 </ul> 
 <li>Return nextGeneration</li> 
</ol>","CrossoverPolicy","org.apache.commons.math3.genetics.CrossoverPolicy","class",0
,"14 Genetic Algorithms","14.3 Implementation","<h3>14.3 Implementation</h3> 
<p> Here is an example GA execution: </p> 
<div class=""source""> 
 <pre>
// initialize a new genetic algorithm
GeneticAlgorithm ga = new GeneticAlgorithm(
    new OnePointCrossover&lt;Integer&gt;(),
    1,
    new RandomKeyMutation(),
    0.10,
    new TournamentSelection(TOURNAMENT_ARITY)
);
        
// initial population
Population initial = getInitialPopulation();
        
// stopping condition
StoppingCondition stopCond = new FixedGenerationCount(NUM_GENERATIONS);
        
// run the algorithm
Population finalPopulation = ga.evolve(initial, stopCond);
        
// best chromosome from the final population
Chromosome bestFinal = finalPopulation.getFittestChromosome();
        </pre> 
</div> The arguments to the 
<tt> 
 <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm"" api=""GeneticAlgorithm"" kind=""class"">
   GeneticAlgorithm 
 </clt></tt> constructor above are: 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Parameter</th> 
   <th>value in example</th> 
   <th>meaning</th> 
  </tr> 
  <tr class=""b""> 
   <td>crossoverPolicy</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/genetics/OnePointCrossover.html""> 
     <clt fqn=""org.apache.commons.math3.genetics.OnePointCrossover"" api=""OnePointCrossover"" kind=""class"">
       OnePointCrossover 
     </clt></a></td> 
   <td>A random crossover point is selected and the first part from each parent is copied to the corresponding child, and the second parts are copied crosswise.</td> 
  </tr> 
  <tr class=""a""> 
   <td>crossoverRate</td> 
   <td>1</td> 
   <td>Always apply crossover</td> 
  </tr> 
  <tr class=""b""> 
   <td>mutationPolicy</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/genetics/RandomKeyMutation.html""> 
     <clt fqn=""org.apache.commons.math3.genetics.RandomKeyMutation"" api=""RandomKeyMutation"" kind=""class"">
       RandomKeyMutation 
     </clt></a></td> 
   <td>Changes a randomly chosen element of the array representation to a random value uniformly distributed in [0,1].</td> 
  </tr> 
  <tr class=""a""> 
   <td>mutationRate</td> 
   <td>.1</td> 
   <td>Apply mutation with probability 0.1 - that is, 10% of the time.</td> 
  </tr> 
  <tr class=""b""> 
   <td>selectionPolicy</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/genetics/TournamentSelection.html""> 
     <clt fqn=""org.apache.commons.math3.genetics.TournamentSelection"" api=""TournamentSelection"" kind=""class"">
       TournamentSelection 
     </clt></a></td> 
   <td>Each of the two selected chromosomes is selected based on an n-ary tournament -- this is done by drawing n random chromosomes without replacement from the population, and then selecting the fittest chromosome among them.</td> 
  </tr> 
 </tbody> 
</table> The algorithm starts with an 
<tt>initial</tt> population of 
<tt>Chromosomes.</tt> and executes until the specified 
<a href=""../apidocs/org/apache/commons/math3/genetics/StoppingCondition.html""> 
 <clt fqn=""org.apache.commons.math3.genetics.StoppingCondition"" api=""StoppingCondition"" kind=""class"">
   StoppingCondition 
 </clt></a> is reached. In the example above, a 
<a href=""../apidocs/org/apache/commons/math3/genetics/FixedGenerationCount.html""> 
 <clt fqn=""org.apache.commons.math3.genetics.FixedGenerationCount"" api=""FixedGenerationCount"" kind=""class"">
   FixedGenerationCount 
 </clt></a> stopping condition is used, which means the algorithm proceeds through a fixed number of generations.","GeneticAlgorithm","org.apache.commons.math3.genetics.GeneticAlgorithm","class",1
,"14 Genetic Algorithms","14.3 Implementation","<h3>14.3 Implementation</h3> 
<p> Here is an example GA execution: </p> 
<div class=""source""> 
 <pre>
// initialize a new genetic algorithm
GeneticAlgorithm ga = new GeneticAlgorithm(
    new OnePointCrossover&lt;Integer&gt;(),
    1,
    new RandomKeyMutation(),
    0.10,
    new TournamentSelection(TOURNAMENT_ARITY)
);
        
// initial population
Population initial = getInitialPopulation();
        
// stopping condition
StoppingCondition stopCond = new FixedGenerationCount(NUM_GENERATIONS);
        
// run the algorithm
Population finalPopulation = ga.evolve(initial, stopCond);
        
// best chromosome from the final population
Chromosome bestFinal = finalPopulation.getFittestChromosome();
        </pre> 
</div> The arguments to the 
<tt> 
 <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm"" api=""GeneticAlgorithm"" kind=""class"">
   GeneticAlgorithm 
 </clt></tt> constructor above are: 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Parameter</th> 
   <th>value in example</th> 
   <th>meaning</th> 
  </tr> 
  <tr class=""b""> 
   <td>crossoverPolicy</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/genetics/OnePointCrossover.html""> 
     <clt fqn=""org.apache.commons.math3.genetics.OnePointCrossover"" api=""OnePointCrossover"" kind=""class"">
       OnePointCrossover 
     </clt></a></td> 
   <td>A random crossover point is selected and the first part from each parent is copied to the corresponding child, and the second parts are copied crosswise.</td> 
  </tr> 
  <tr class=""a""> 
   <td>crossoverRate</td> 
   <td>1</td> 
   <td>Always apply crossover</td> 
  </tr> 
  <tr class=""b""> 
   <td>mutationPolicy</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/genetics/RandomKeyMutation.html""> 
     <clt fqn=""org.apache.commons.math3.genetics.RandomKeyMutation"" api=""RandomKeyMutation"" kind=""class"">
       RandomKeyMutation 
     </clt></a></td> 
   <td>Changes a randomly chosen element of the array representation to a random value uniformly distributed in [0,1].</td> 
  </tr> 
  <tr class=""a""> 
   <td>mutationRate</td> 
   <td>.1</td> 
   <td>Apply mutation with probability 0.1 - that is, 10% of the time.</td> 
  </tr> 
  <tr class=""b""> 
   <td>selectionPolicy</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/genetics/TournamentSelection.html""> 
     <clt fqn=""org.apache.commons.math3.genetics.TournamentSelection"" api=""TournamentSelection"" kind=""class"">
       TournamentSelection 
     </clt></a></td> 
   <td>Each of the two selected chromosomes is selected based on an n-ary tournament -- this is done by drawing n random chromosomes without replacement from the population, and then selecting the fittest chromosome among them.</td> 
  </tr> 
 </tbody> 
</table> The algorithm starts with an 
<tt>initial</tt> population of 
<tt>Chromosomes.</tt> and executes until the specified 
<a href=""../apidocs/org/apache/commons/math3/genetics/StoppingCondition.html""> 
 <clt fqn=""org.apache.commons.math3.genetics.StoppingCondition"" api=""StoppingCondition"" kind=""class"">
   StoppingCondition 
 </clt></a> is reached. In the example above, a 
<a href=""../apidocs/org/apache/commons/math3/genetics/FixedGenerationCount.html""> 
 <clt fqn=""org.apache.commons.math3.genetics.FixedGenerationCount"" api=""FixedGenerationCount"" kind=""class"">
   FixedGenerationCount 
 </clt></a> stopping condition is used, which means the algorithm proceeds through a fixed number of generations.","OnePointCrossover","org.apache.commons.math3.genetics.OnePointCrossover","class",1
,"14 Genetic Algorithms","14.3 Implementation","<h3>14.3 Implementation</h3> 
<p> Here is an example GA execution: </p> 
<div class=""source""> 
 <pre>
// initialize a new genetic algorithm
GeneticAlgorithm ga = new GeneticAlgorithm(
    new OnePointCrossover&lt;Integer&gt;(),
    1,
    new RandomKeyMutation(),
    0.10,
    new TournamentSelection(TOURNAMENT_ARITY)
);
        
// initial population
Population initial = getInitialPopulation();
        
// stopping condition
StoppingCondition stopCond = new FixedGenerationCount(NUM_GENERATIONS);
        
// run the algorithm
Population finalPopulation = ga.evolve(initial, stopCond);
        
// best chromosome from the final population
Chromosome bestFinal = finalPopulation.getFittestChromosome();
        </pre> 
</div> The arguments to the 
<tt> 
 <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm"" api=""GeneticAlgorithm"" kind=""class"">
   GeneticAlgorithm 
 </clt></tt> constructor above are: 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Parameter</th> 
   <th>value in example</th> 
   <th>meaning</th> 
  </tr> 
  <tr class=""b""> 
   <td>crossoverPolicy</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/genetics/OnePointCrossover.html""> 
     <clt fqn=""org.apache.commons.math3.genetics.OnePointCrossover"" api=""OnePointCrossover"" kind=""class"">
       OnePointCrossover 
     </clt></a></td> 
   <td>A random crossover point is selected and the first part from each parent is copied to the corresponding child, and the second parts are copied crosswise.</td> 
  </tr> 
  <tr class=""a""> 
   <td>crossoverRate</td> 
   <td>1</td> 
   <td>Always apply crossover</td> 
  </tr> 
  <tr class=""b""> 
   <td>mutationPolicy</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/genetics/RandomKeyMutation.html""> 
     <clt fqn=""org.apache.commons.math3.genetics.RandomKeyMutation"" api=""RandomKeyMutation"" kind=""class"">
       RandomKeyMutation 
     </clt></a></td> 
   <td>Changes a randomly chosen element of the array representation to a random value uniformly distributed in [0,1].</td> 
  </tr> 
  <tr class=""a""> 
   <td>mutationRate</td> 
   <td>.1</td> 
   <td>Apply mutation with probability 0.1 - that is, 10% of the time.</td> 
  </tr> 
  <tr class=""b""> 
   <td>selectionPolicy</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/genetics/TournamentSelection.html""> 
     <clt fqn=""org.apache.commons.math3.genetics.TournamentSelection"" api=""TournamentSelection"" kind=""class"">
       TournamentSelection 
     </clt></a></td> 
   <td>Each of the two selected chromosomes is selected based on an n-ary tournament -- this is done by drawing n random chromosomes without replacement from the population, and then selecting the fittest chromosome among them.</td> 
  </tr> 
 </tbody> 
</table> The algorithm starts with an 
<tt>initial</tt> population of 
<tt>Chromosomes.</tt> and executes until the specified 
<a href=""../apidocs/org/apache/commons/math3/genetics/StoppingCondition.html""> 
 <clt fqn=""org.apache.commons.math3.genetics.StoppingCondition"" api=""StoppingCondition"" kind=""class"">
   StoppingCondition 
 </clt></a> is reached. In the example above, a 
<a href=""../apidocs/org/apache/commons/math3/genetics/FixedGenerationCount.html""> 
 <clt fqn=""org.apache.commons.math3.genetics.FixedGenerationCount"" api=""FixedGenerationCount"" kind=""class"">
   FixedGenerationCount 
 </clt></a> stopping condition is used, which means the algorithm proceeds through a fixed number of generations.","RandomKeyMutation","org.apache.commons.math3.genetics.RandomKeyMutation","class",1
,"14 Genetic Algorithms","14.3 Implementation","<h3>14.3 Implementation</h3> 
<p> Here is an example GA execution: </p> 
<div class=""source""> 
 <pre>
// initialize a new genetic algorithm
GeneticAlgorithm ga = new GeneticAlgorithm(
    new OnePointCrossover&lt;Integer&gt;(),
    1,
    new RandomKeyMutation(),
    0.10,
    new TournamentSelection(TOURNAMENT_ARITY)
);
        
// initial population
Population initial = getInitialPopulation();
        
// stopping condition
StoppingCondition stopCond = new FixedGenerationCount(NUM_GENERATIONS);
        
// run the algorithm
Population finalPopulation = ga.evolve(initial, stopCond);
        
// best chromosome from the final population
Chromosome bestFinal = finalPopulation.getFittestChromosome();
        </pre> 
</div> The arguments to the 
<tt> 
 <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm"" api=""GeneticAlgorithm"" kind=""class"">
   GeneticAlgorithm 
 </clt></tt> constructor above are: 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Parameter</th> 
   <th>value in example</th> 
   <th>meaning</th> 
  </tr> 
  <tr class=""b""> 
   <td>crossoverPolicy</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/genetics/OnePointCrossover.html""> 
     <clt fqn=""org.apache.commons.math3.genetics.OnePointCrossover"" api=""OnePointCrossover"" kind=""class"">
       OnePointCrossover 
     </clt></a></td> 
   <td>A random crossover point is selected and the first part from each parent is copied to the corresponding child, and the second parts are copied crosswise.</td> 
  </tr> 
  <tr class=""a""> 
   <td>crossoverRate</td> 
   <td>1</td> 
   <td>Always apply crossover</td> 
  </tr> 
  <tr class=""b""> 
   <td>mutationPolicy</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/genetics/RandomKeyMutation.html""> 
     <clt fqn=""org.apache.commons.math3.genetics.RandomKeyMutation"" api=""RandomKeyMutation"" kind=""class"">
       RandomKeyMutation 
     </clt></a></td> 
   <td>Changes a randomly chosen element of the array representation to a random value uniformly distributed in [0,1].</td> 
  </tr> 
  <tr class=""a""> 
   <td>mutationRate</td> 
   <td>.1</td> 
   <td>Apply mutation with probability 0.1 - that is, 10% of the time.</td> 
  </tr> 
  <tr class=""b""> 
   <td>selectionPolicy</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/genetics/TournamentSelection.html""> 
     <clt fqn=""org.apache.commons.math3.genetics.TournamentSelection"" api=""TournamentSelection"" kind=""class"">
       TournamentSelection 
     </clt></a></td> 
   <td>Each of the two selected chromosomes is selected based on an n-ary tournament -- this is done by drawing n random chromosomes without replacement from the population, and then selecting the fittest chromosome among them.</td> 
  </tr> 
 </tbody> 
</table> The algorithm starts with an 
<tt>initial</tt> population of 
<tt>Chromosomes.</tt> and executes until the specified 
<a href=""../apidocs/org/apache/commons/math3/genetics/StoppingCondition.html""> 
 <clt fqn=""org.apache.commons.math3.genetics.StoppingCondition"" api=""StoppingCondition"" kind=""class"">
   StoppingCondition 
 </clt></a> is reached. In the example above, a 
<a href=""../apidocs/org/apache/commons/math3/genetics/FixedGenerationCount.html""> 
 <clt fqn=""org.apache.commons.math3.genetics.FixedGenerationCount"" api=""FixedGenerationCount"" kind=""class"">
   FixedGenerationCount 
 </clt></a> stopping condition is used, which means the algorithm proceeds through a fixed number of generations.","TournamentSelection","org.apache.commons.math3.genetics.TournamentSelection","class",1
,"14 Genetic Algorithms","14.3 Implementation","<h3>14.3 Implementation</h3> 
<p> Here is an example GA execution: </p> 
<div class=""source""> 
 <pre>
// initialize a new genetic algorithm
GeneticAlgorithm ga = new GeneticAlgorithm(
    new OnePointCrossover&lt;Integer&gt;(),
    1,
    new RandomKeyMutation(),
    0.10,
    new TournamentSelection(TOURNAMENT_ARITY)
);
        
// initial population
Population initial = getInitialPopulation();
        
// stopping condition
StoppingCondition stopCond = new FixedGenerationCount(NUM_GENERATIONS);
        
// run the algorithm
Population finalPopulation = ga.evolve(initial, stopCond);
        
// best chromosome from the final population
Chromosome bestFinal = finalPopulation.getFittestChromosome();
        </pre> 
</div> The arguments to the 
<tt> 
 <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm"" api=""GeneticAlgorithm"" kind=""class"">
   GeneticAlgorithm 
 </clt></tt> constructor above are: 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Parameter</th> 
   <th>value in example</th> 
   <th>meaning</th> 
  </tr> 
  <tr class=""b""> 
   <td>crossoverPolicy</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/genetics/OnePointCrossover.html""> 
     <clt fqn=""org.apache.commons.math3.genetics.OnePointCrossover"" api=""OnePointCrossover"" kind=""class"">
       OnePointCrossover 
     </clt></a></td> 
   <td>A random crossover point is selected and the first part from each parent is copied to the corresponding child, and the second parts are copied crosswise.</td> 
  </tr> 
  <tr class=""a""> 
   <td>crossoverRate</td> 
   <td>1</td> 
   <td>Always apply crossover</td> 
  </tr> 
  <tr class=""b""> 
   <td>mutationPolicy</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/genetics/RandomKeyMutation.html""> 
     <clt fqn=""org.apache.commons.math3.genetics.RandomKeyMutation"" api=""RandomKeyMutation"" kind=""class"">
       RandomKeyMutation 
     </clt></a></td> 
   <td>Changes a randomly chosen element of the array representation to a random value uniformly distributed in [0,1].</td> 
  </tr> 
  <tr class=""a""> 
   <td>mutationRate</td> 
   <td>.1</td> 
   <td>Apply mutation with probability 0.1 - that is, 10% of the time.</td> 
  </tr> 
  <tr class=""b""> 
   <td>selectionPolicy</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/genetics/TournamentSelection.html""> 
     <clt fqn=""org.apache.commons.math3.genetics.TournamentSelection"" api=""TournamentSelection"" kind=""class"">
       TournamentSelection 
     </clt></a></td> 
   <td>Each of the two selected chromosomes is selected based on an n-ary tournament -- this is done by drawing n random chromosomes without replacement from the population, and then selecting the fittest chromosome among them.</td> 
  </tr> 
 </tbody> 
</table> The algorithm starts with an 
<tt>initial</tt> population of 
<tt>Chromosomes.</tt> and executes until the specified 
<a href=""../apidocs/org/apache/commons/math3/genetics/StoppingCondition.html""> 
 <clt fqn=""org.apache.commons.math3.genetics.StoppingCondition"" api=""StoppingCondition"" kind=""class"">
   StoppingCondition 
 </clt></a> is reached. In the example above, a 
<a href=""../apidocs/org/apache/commons/math3/genetics/FixedGenerationCount.html""> 
 <clt fqn=""org.apache.commons.math3.genetics.FixedGenerationCount"" api=""FixedGenerationCount"" kind=""class"">
   FixedGenerationCount 
 </clt></a> stopping condition is used, which means the algorithm proceeds through a fixed number of generations.","StoppingCondition","org.apache.commons.math3.genetics.StoppingCondition","class",0
,"14 Genetic Algorithms","14.3 Implementation","<h3>14.3 Implementation</h3> 
<p> Here is an example GA execution: </p> 
<div class=""source""> 
 <pre>
// initialize a new genetic algorithm
GeneticAlgorithm ga = new GeneticAlgorithm(
    new OnePointCrossover&lt;Integer&gt;(),
    1,
    new RandomKeyMutation(),
    0.10,
    new TournamentSelection(TOURNAMENT_ARITY)
);
        
// initial population
Population initial = getInitialPopulation();
        
// stopping condition
StoppingCondition stopCond = new FixedGenerationCount(NUM_GENERATIONS);
        
// run the algorithm
Population finalPopulation = ga.evolve(initial, stopCond);
        
// best chromosome from the final population
Chromosome bestFinal = finalPopulation.getFittestChromosome();
        </pre> 
</div> The arguments to the 
<tt> 
 <clt fqn=""org.apache.commons.math3.genetics.GeneticAlgorithm"" api=""GeneticAlgorithm"" kind=""class"">
   GeneticAlgorithm 
 </clt></tt> constructor above are: 
<table border=""0"" class=""bodyTable""> 
 <tbody> 
  <tr class=""a""> 
   <th>Parameter</th> 
   <th>value in example</th> 
   <th>meaning</th> 
  </tr> 
  <tr class=""b""> 
   <td>crossoverPolicy</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/genetics/OnePointCrossover.html""> 
     <clt fqn=""org.apache.commons.math3.genetics.OnePointCrossover"" api=""OnePointCrossover"" kind=""class"">
       OnePointCrossover 
     </clt></a></td> 
   <td>A random crossover point is selected and the first part from each parent is copied to the corresponding child, and the second parts are copied crosswise.</td> 
  </tr> 
  <tr class=""a""> 
   <td>crossoverRate</td> 
   <td>1</td> 
   <td>Always apply crossover</td> 
  </tr> 
  <tr class=""b""> 
   <td>mutationPolicy</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/genetics/RandomKeyMutation.html""> 
     <clt fqn=""org.apache.commons.math3.genetics.RandomKeyMutation"" api=""RandomKeyMutation"" kind=""class"">
       RandomKeyMutation 
     </clt></a></td> 
   <td>Changes a randomly chosen element of the array representation to a random value uniformly distributed in [0,1].</td> 
  </tr> 
  <tr class=""a""> 
   <td>mutationRate</td> 
   <td>.1</td> 
   <td>Apply mutation with probability 0.1 - that is, 10% of the time.</td> 
  </tr> 
  <tr class=""b""> 
   <td>selectionPolicy</td> 
   <td><a href=""../apidocs/org/apache/commons/math3/genetics/TournamentSelection.html""> 
     <clt fqn=""org.apache.commons.math3.genetics.TournamentSelection"" api=""TournamentSelection"" kind=""class"">
       TournamentSelection 
     </clt></a></td> 
   <td>Each of the two selected chromosomes is selected based on an n-ary tournament -- this is done by drawing n random chromosomes without replacement from the population, and then selecting the fittest chromosome among them.</td> 
  </tr> 
 </tbody> 
</table> The algorithm starts with an 
<tt>initial</tt> population of 
<tt>Chromosomes.</tt> and executes until the specified 
<a href=""../apidocs/org/apache/commons/math3/genetics/StoppingCondition.html""> 
 <clt fqn=""org.apache.commons.math3.genetics.StoppingCondition"" api=""StoppingCondition"" kind=""class"">
   StoppingCondition 
 </clt></a> is reached. In the example above, a 
<a href=""../apidocs/org/apache/commons/math3/genetics/FixedGenerationCount.html""> 
 <clt fqn=""org.apache.commons.math3.genetics.FixedGenerationCount"" api=""FixedGenerationCount"" kind=""class"">
   FixedGenerationCount 
 </clt></a> stopping condition is used, which means the algorithm proceeds through a fixed number of generations.","FixedGenerationCount","org.apache.commons.math3.genetics.FixedGenerationCount","class",0
,"11 Geometry","11.2 Euclidean spaces","<h3>11.2 Euclidean spaces</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/geometry/euclidean/oned/Interval.html""> 
  <clt fqn=""org.apache.commons.math3.geometry.euclidean.oned.Interval"" api=""Interval"" kind=""unknown"">
    Interval 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.html""> 
  <clt fqn=""org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet"" api=""IntervalsSet"" kind=""class"">
    IntervalsSet 
  </clt></a> represent one dimensional regions. All classical set operations are available for intervals sets: union, intersection, symmetric difference (exclusive or), difference, complement, as well as region predicates (point inside/outside/on boundary, emptiness, other region contained). It is also possible to compute geometrical properties like size, barycenter or boundary size. Intervals sets can be built by constructive geometry (union, intersection ...) or from a boundary representation. </p> 
<p> <a href=""../apidocs/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.html""> 
  <clt fqn=""org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet"" api=""PolygonsSet"" kind=""class"">
    PolygonsSet 
  </clt></a> represent two dimensional regions. All classical set operations are available for polygons sets: union, intersection, symmetric difference (exclusive or), difference, complement, as well as region predicates (point inside/outside/on boundary, emptiness, other region contained). It is also possible to compute geometrical properties like size, barycenter or boundary size and to extract the vertices. Polygons sets can be built by constructive geometry (union, intersection ...) or from a boundary representation. </p>","Interval","org.apache.commons.math3.geometry.euclidean.oned.Interval","class",1
,"11 Geometry","11.2 Euclidean spaces","<h3>11.2 Euclidean spaces</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/geometry/euclidean/oned/Interval.html""> 
  <clt fqn=""org.apache.commons.math3.geometry.euclidean.oned.Interval"" api=""Interval"" kind=""unknown"">
    Interval 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.html""> 
  <clt fqn=""org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet"" api=""IntervalsSet"" kind=""class"">
    IntervalsSet 
  </clt></a> represent one dimensional regions. All classical set operations are available for intervals sets: union, intersection, symmetric difference (exclusive or), difference, complement, as well as region predicates (point inside/outside/on boundary, emptiness, other region contained). It is also possible to compute geometrical properties like size, barycenter or boundary size. Intervals sets can be built by constructive geometry (union, intersection ...) or from a boundary representation. </p> 
<p> <a href=""../apidocs/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.html""> 
  <clt fqn=""org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet"" api=""PolygonsSet"" kind=""class"">
    PolygonsSet 
  </clt></a> represent two dimensional regions. All classical set operations are available for polygons sets: union, intersection, symmetric difference (exclusive or), difference, complement, as well as region predicates (point inside/outside/on boundary, emptiness, other region contained). It is also possible to compute geometrical properties like size, barycenter or boundary size and to extract the vertices. Polygons sets can be built by constructive geometry (union, intersection ...) or from a boundary representation. </p>","IntervalsSet","org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet","class",1
,"11 Geometry","11.2 Euclidean spaces","<h3>11.2 Euclidean spaces</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/geometry/euclidean/oned/Interval.html""> 
  <clt fqn=""org.apache.commons.math3.geometry.euclidean.oned.Interval"" api=""Interval"" kind=""unknown"">
    Interval 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.html""> 
  <clt fqn=""org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet"" api=""IntervalsSet"" kind=""class"">
    IntervalsSet 
  </clt></a> represent one dimensional regions. All classical set operations are available for intervals sets: union, intersection, symmetric difference (exclusive or), difference, complement, as well as region predicates (point inside/outside/on boundary, emptiness, other region contained). It is also possible to compute geometrical properties like size, barycenter or boundary size. Intervals sets can be built by constructive geometry (union, intersection ...) or from a boundary representation. </p> 
<p> <a href=""../apidocs/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.html""> 
  <clt fqn=""org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet"" api=""PolygonsSet"" kind=""class"">
    PolygonsSet 
  </clt></a> represent two dimensional regions. All classical set operations are available for polygons sets: union, intersection, symmetric difference (exclusive or), difference, complement, as well as region predicates (point inside/outside/on boundary, emptiness, other region contained). It is also possible to compute geometrical properties like size, barycenter or boundary size and to extract the vertices. Polygons sets can be built by constructive geometry (union, intersection ...) or from a boundary representation. </p>","PolygonsSet","org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet","class",1
,"11 Geometry","11.2 Euclidean spaces - part 2","<h3>11.2 Euclidean spaces - part 2</h3>
<p> <a href=""../apidocs/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSet.html""> 
  <clt fqn=""org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet"" api=""PolyhedronsSet"" kind=""class"">
    PolyhedronsSet 
  </clt></a> represent three dimensional regions. All classical set operations are available for polyhedrons sets: union, intersection, symmetric difference (exclusive or), difference, complement, as well as region predicates (point inside/outside/on boundary, emptiness, other region contained). It is also possible to compute geometrical properties like size, barycenter or boundary size and to extract the vertices. Polyhedrons sets can be built by constructive geometry (union, intersection ...) or from a boundary representation. </p> 
<p> <a href=""../apidocs/org/apache/commons/math3/geometry/euclidean/threed/Vector3D.html""> 
  <clt fqn=""org.apache.commons.math3.geometry.euclidean.threed.Vector3D"" api=""Vector3D"" kind=""unknown"">
    Vector3D 
  </clt></a> provides a simple vector type. One important feature is that instances of this class are guaranteed to be immutable, this greatly simplifies modelling dynamical systems with changing states: once a vector has been computed, a reference to it is known to preserve its state as long as the reference itself is preserved. </p> 
<p> Numerous constructors are available to create vectors. In addition to the straightforward cartesian coordinates constructor, a constructor using azimuthal coordinates can build normalized vectors and linear constructors from one, two, three or four base vectors are also available. Constants have been defined for the most commons vectors (plus and minus canonical axes, null vector, and special vectors with infinite or NaN coordinates). </p>","PolyhedronsSet","org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet","class",1
,"11 Geometry","11.2 Euclidean spaces - part 2","<h3>11.2 Euclidean spaces - part 2</h3>
<p> <a href=""../apidocs/org/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSet.html""> 
  <clt fqn=""org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet"" api=""PolyhedronsSet"" kind=""class"">
    PolyhedronsSet 
  </clt></a> represent three dimensional regions. All classical set operations are available for polyhedrons sets: union, intersection, symmetric difference (exclusive or), difference, complement, as well as region predicates (point inside/outside/on boundary, emptiness, other region contained). It is also possible to compute geometrical properties like size, barycenter or boundary size and to extract the vertices. Polyhedrons sets can be built by constructive geometry (union, intersection ...) or from a boundary representation. </p> 
<p> <a href=""../apidocs/org/apache/commons/math3/geometry/euclidean/threed/Vector3D.html""> 
  <clt fqn=""org.apache.commons.math3.geometry.euclidean.threed.Vector3D"" api=""Vector3D"" kind=""unknown"">
    Vector3D 
  </clt></a> provides a simple vector type. One important feature is that instances of this class are guaranteed to be immutable, this greatly simplifies modelling dynamical systems with changing states: once a vector has been computed, a reference to it is known to preserve its state as long as the reference itself is preserved. </p> 
<p> Numerous constructors are available to create vectors. In addition to the straightforward cartesian coordinates constructor, a constructor using azimuthal coordinates can build normalized vectors and linear constructors from one, two, three or four base vectors are also available. Constants have been defined for the most commons vectors (plus and minus canonical axes, null vector, and special vectors with infinite or NaN coordinates). </p>","Vector3D","org.apache.commons.math3.geometry.euclidean.threed.Vector3D","class",1
,"11 Geometry","11.2 Euclidean spaces - part 3","<h3>11.2 Euclidean spaces - part 3</h3>
<p> The generic vectorial space operations are available including dot product, normalization, orthogonal vector finding and angular separation computation which have a specific meaning in 3D. The 3D geometry specific cross product is of course also implemented. </p> 
<p> <a href=""../apidocs/org/apache/commons/math3/geometry/euclidean/threed/Vector3DFormat.html""> 
  <clt fqn=""org.apache.commons.math3.geometry.euclidean.threed.Vector3DFormat"" api=""Vector3DFormat"" kind=""class"">
    Vector3DFormat 
  </clt></a> is a specialized format for formatting output or parsing input with text representation of 3D vectors. </p> 
<p> <a href=""../apidocs/org/apache/commons/math3/geometry/euclidean/threed/Rotation.html""> 
  <clt fqn=""org.apache.commons.math3.geometry.euclidean.threed.Rotation"" api=""Rotation"" kind=""unknown"">
    Rotation 
  </clt></a> represents 3D rotations. Rotation instances are also immutable objects, as Vector3D instances. </p> 
<p> Rotations can be represented by several different mathematical entities (matrices, axe and angle, Cardan or Euler angles, quaternions). This class presents a higher level abstraction, more user-oriented and hiding implementation details. Well, for the curious, we use quaternions for the internal representation. The user can build a rotation from any of these representations, and any of these representations can be retrieved from a <tt> 
  <clt fqn=""org.apache.commons.math3.geometry.euclidean.threed.Rotation"" api=""Rotation"" kind=""unknown"">
    Rotation 
  </clt></tt> instance (see the various constructors and getters). In addition, a rotation can also be built implicitely from a set of vectors and their image. </p>","Vector3DFormat","org.apache.commons.math3.geometry.euclidean.threed.Vector3DFormat","class",0
,"11 Geometry","11.2 Euclidean spaces - part 3","<h3>11.2 Euclidean spaces - part 3</h3>
<p> The generic vectorial space operations are available including dot product, normalization, orthogonal vector finding and angular separation computation which have a specific meaning in 3D. The 3D geometry specific cross product is of course also implemented. </p> 
<p> <a href=""../apidocs/org/apache/commons/math3/geometry/euclidean/threed/Vector3DFormat.html""> 
  <clt fqn=""org.apache.commons.math3.geometry.euclidean.threed.Vector3DFormat"" api=""Vector3DFormat"" kind=""class"">
    Vector3DFormat 
  </clt></a> is a specialized format for formatting output or parsing input with text representation of 3D vectors. </p> 
<p> <a href=""../apidocs/org/apache/commons/math3/geometry/euclidean/threed/Rotation.html""> 
  <clt fqn=""org.apache.commons.math3.geometry.euclidean.threed.Rotation"" api=""Rotation"" kind=""unknown"">
    Rotation 
  </clt></a> represents 3D rotations. Rotation instances are also immutable objects, as Vector3D instances. </p> 
<p> Rotations can be represented by several different mathematical entities (matrices, axe and angle, Cardan or Euler angles, quaternions). This class presents a higher level abstraction, more user-oriented and hiding implementation details. Well, for the curious, we use quaternions for the internal representation. The user can build a rotation from any of these representations, and any of these representations can be retrieved from a <tt> 
  <clt fqn=""org.apache.commons.math3.geometry.euclidean.threed.Rotation"" api=""Rotation"" kind=""unknown"">
    Rotation 
  </clt></tt> instance (see the various constructors and getters). In addition, a rotation can also be built implicitely from a set of vectors and their image. </p>","Rotation","org.apache.commons.math3.geometry.euclidean.threed.Rotation","class",1
,"11 Geometry","11.2 Euclidean spaces - part 6","<h3>11.2 Euclidean spaces - part 6</h3>
<p> These examples show that a rotation means what the user wants it to mean, so this class does not push the user towards one specific definition and hence does not provide methods like <tt>projectVectorIntoDestinationFrame</tt> or <tt>computeTransformedDirection</tt>. It provides simpler and more generic methods: <tt> 
  <clt fqn=""org.apache.commons.math3.geometry.euclidean.threed.Rotation.applyTo"" api=""Rotation"" kind=""method"">
   Rotation.applyTo(Vector3D)
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.geometry.euclidean.threed.Rotation.applyInverseTo"" api=""Rotation"" kind=""method"">
   Rotation.applyInverseTo(Vector3D)
  </clt></tt>. </p> 
<p> Since a rotation is basically a vectorial operator, several rotations can be composed together and the composite operation <tt>r = r<sub>1</sub> o r<sub>2</sub></tt> (which means that for each vector <tt>u</tt>, <tt>r(u) = r<sub>1</sub>(r<sub>2</sub>(u))</tt>) is also a rotation. Hence we can consider that in addition to vectors, a rotation can be applied to other rotations as well (or to itself). With our previous notations, we would say we can apply <tt>r<sub>1</sub></tt> to <tt>r<sub>2</sub></tt> and the result we get is <tt>r = r<sub>1</sub> o r<sub>2</sub></tt>. For this purpose, the class provides the methods: <tt> 
  <clt fqn=""org.apache.commons.math3.geometry.euclidean.threed.Rotation.applyTo"" api=""Rotation"" kind=""method"">
   Rotation.applyTo(Rotation)
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.geometry.euclidean.threed.Rotation.applyInverseTo"" api=""Rotation"" kind=""method"">
   Rotation.applyInverseTo(Rotation)
  </clt></tt>. </p>","Rotation","org.apache.commons.math3.geometry.euclidean.threed.Rotation","class",1
,"11 Geometry","11.3 Binary Space Partitioning","<h3>11.3 Binary 
 <clt fqn=""org.apache.commons.math3.geometry.Space"" api=""Space"" kind=""class"">
   Space 
 </clt> Partitioning</h3> 
<p> <a href=""../apidocs/org/apache/commons/math3/geometry/partitioning/BSPTree.html""> BSP trees</a> are an efficient way to represent space partitions and to associate attributes with each cell. Each node in a BSP tree represents a convex region which is partitioned in two convex sub-regions at each side of a cut hyperplane. The root tree contains the complete space. </p> 
<p> The main use of such partitions is to use a boolean attribute to define an inside/outside property, hence representing arbitrary polytopes (line segments in 1D, polygons in 2D and polyhedrons in 3D) and to operate on them. </p> 
<p> Another example would be to represent Voronoi tesselations, the attribute of each cell holding the defining point of the cell. </p>","Space","org.apache.commons.math3.geometry.Space","class",0
,"3 Linear Algebra","3.2 Real matrices","<h3>3.2 Real matrices</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/linear/RealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.RealMatrix"" api=""RealMatrix"" kind=""class"">
    RealMatrix 
  </clt></a> interface represents a matrix with real numbers as entries. The following basic matrix operations are supported: </p> 
<ul> 
 <li>Matrix addition, subtraction, multiplication</li> 
 <li>Scalar addition and multiplication</li> 
 <li>transpose</li> 
 <li>Norm and Trace</li> 
 <li>Operation on a vector</li> 
</ul> 
<p> Example: </p> 
<div class=""source""> 
 <pre>
// Create a real matrix with two rows and three columns
double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};
RealMatrix m = new Array2DRowRealMatrix(matrixData);

// One more with three rows, two columns
double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};
RealMatrix n = new Array2DRowRealMatrix(matrixData2);

// Note: The constructor copies  the input double[][] array.

// Now multiply m by n
RealMatrix p = m.multiply(n);
System.out.println(p.getRowDimension());    // 2
System.out.println(p.getColumnDimension()); // 2

// Invert p, using LU decomposition
RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();
         </pre> 
</div> 
<p> The three main implementations of the interface are <a href=""../apidocs/org/apache/commons/math3/linear/Array2DRowRealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.Array2DRowRealMatrix"" api=""Array2DRowRealMatrix"" kind=""class"">
    Array2DRowRealMatrix 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/linear/BlockRealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.BlockRealMatrix"" api=""BlockRealMatrix"" kind=""class"">
    BlockRealMatrix 
  </clt></a> for dense matrices (the second one being more suited to dimensions above 50 or 100) and <a href=""../apidocs/org/apache/commons/math3/linear/SparseRealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.SparseRealMatrix"" api=""SparseRealMatrix"" kind=""class"">
    SparseRealMatrix 
  </clt></a> for sparse matrices. </p>","RealMatrix","org.apache.commons.math3.linear.RealMatrix","class",1
,"3 Linear Algebra","3.2 Real matrices","<h3>3.2 Real matrices</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/linear/RealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.RealMatrix"" api=""RealMatrix"" kind=""class"">
    RealMatrix 
  </clt></a> interface represents a matrix with real numbers as entries. The following basic matrix operations are supported: </p> 
<ul> 
 <li>Matrix addition, subtraction, multiplication</li> 
 <li>Scalar addition and multiplication</li> 
 <li>transpose</li> 
 <li>Norm and Trace</li> 
 <li>Operation on a vector</li> 
</ul> 
<p> Example: </p> 
<div class=""source""> 
 <pre>
// Create a real matrix with two rows and three columns
double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};
RealMatrix m = new Array2DRowRealMatrix(matrixData);

// One more with three rows, two columns
double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};
RealMatrix n = new Array2DRowRealMatrix(matrixData2);

// Note: The constructor copies  the input double[][] array.

// Now multiply m by n
RealMatrix p = m.multiply(n);
System.out.println(p.getRowDimension());    // 2
System.out.println(p.getColumnDimension()); // 2

// Invert p, using LU decomposition
RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();
         </pre> 
</div> 
<p> The three main implementations of the interface are <a href=""../apidocs/org/apache/commons/math3/linear/Array2DRowRealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.Array2DRowRealMatrix"" api=""Array2DRowRealMatrix"" kind=""class"">
    Array2DRowRealMatrix 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/linear/BlockRealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.BlockRealMatrix"" api=""BlockRealMatrix"" kind=""class"">
    BlockRealMatrix 
  </clt></a> for dense matrices (the second one being more suited to dimensions above 50 or 100) and <a href=""../apidocs/org/apache/commons/math3/linear/SparseRealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.SparseRealMatrix"" api=""SparseRealMatrix"" kind=""class"">
    SparseRealMatrix 
  </clt></a> for sparse matrices. </p>","Array2DRowRealMatrix","org.apache.commons.math3.linear.Array2DRowRealMatrix","class",0
,"3 Linear Algebra","3.2 Real matrices","<h3>3.2 Real matrices</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/linear/RealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.RealMatrix"" api=""RealMatrix"" kind=""class"">
    RealMatrix 
  </clt></a> interface represents a matrix with real numbers as entries. The following basic matrix operations are supported: </p> 
<ul> 
 <li>Matrix addition, subtraction, multiplication</li> 
 <li>Scalar addition and multiplication</li> 
 <li>transpose</li> 
 <li>Norm and Trace</li> 
 <li>Operation on a vector</li> 
</ul> 
<p> Example: </p> 
<div class=""source""> 
 <pre>
// Create a real matrix with two rows and three columns
double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};
RealMatrix m = new Array2DRowRealMatrix(matrixData);

// One more with three rows, two columns
double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};
RealMatrix n = new Array2DRowRealMatrix(matrixData2);

// Note: The constructor copies  the input double[][] array.

// Now multiply m by n
RealMatrix p = m.multiply(n);
System.out.println(p.getRowDimension());    // 2
System.out.println(p.getColumnDimension()); // 2

// Invert p, using LU decomposition
RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();
         </pre> 
</div> 
<p> The three main implementations of the interface are <a href=""../apidocs/org/apache/commons/math3/linear/Array2DRowRealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.Array2DRowRealMatrix"" api=""Array2DRowRealMatrix"" kind=""class"">
    Array2DRowRealMatrix 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/linear/BlockRealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.BlockRealMatrix"" api=""BlockRealMatrix"" kind=""class"">
    BlockRealMatrix 
  </clt></a> for dense matrices (the second one being more suited to dimensions above 50 or 100) and <a href=""../apidocs/org/apache/commons/math3/linear/SparseRealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.SparseRealMatrix"" api=""SparseRealMatrix"" kind=""class"">
    SparseRealMatrix 
  </clt></a> for sparse matrices. </p>","BlockRealMatrix","org.apache.commons.math3.linear.BlockRealMatrix","class",0
,"3 Linear Algebra","3.2 Real matrices","<h3>3.2 Real matrices</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/linear/RealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.RealMatrix"" api=""RealMatrix"" kind=""class"">
    RealMatrix 
  </clt></a> interface represents a matrix with real numbers as entries. The following basic matrix operations are supported: </p> 
<ul> 
 <li>Matrix addition, subtraction, multiplication</li> 
 <li>Scalar addition and multiplication</li> 
 <li>transpose</li> 
 <li>Norm and Trace</li> 
 <li>Operation on a vector</li> 
</ul> 
<p> Example: </p> 
<div class=""source""> 
 <pre>
// Create a real matrix with two rows and three columns
double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};
RealMatrix m = new Array2DRowRealMatrix(matrixData);

// One more with three rows, two columns
double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};
RealMatrix n = new Array2DRowRealMatrix(matrixData2);

// Note: The constructor copies  the input double[][] array.

// Now multiply m by n
RealMatrix p = m.multiply(n);
System.out.println(p.getRowDimension());    // 2
System.out.println(p.getColumnDimension()); // 2

// Invert p, using LU decomposition
RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();
         </pre> 
</div> 
<p> The three main implementations of the interface are <a href=""../apidocs/org/apache/commons/math3/linear/Array2DRowRealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.Array2DRowRealMatrix"" api=""Array2DRowRealMatrix"" kind=""class"">
    Array2DRowRealMatrix 
  </clt></a> and <a href=""../apidocs/org/apache/commons/math3/linear/BlockRealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.BlockRealMatrix"" api=""BlockRealMatrix"" kind=""class"">
    BlockRealMatrix 
  </clt></a> for dense matrices (the second one being more suited to dimensions above 50 or 100) and <a href=""../apidocs/org/apache/commons/math3/linear/SparseRealMatrix.html""> 
  <clt fqn=""org.apache.commons.math3.linear.SparseRealMatrix"" api=""SparseRealMatrix"" kind=""class"">
    SparseRealMatrix 
  </clt></a> for sparse matrices. </p>","SparseRealMatrix","org.apache.commons.math3.linear.SparseRealMatrix","class",0
,"3 Linear Algebra","3.3 Real vectors","<h3>3.3 Real vectors</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/linear/RealVector.html""> 
  <clt fqn=""org.apache.commons.math3.linear.RealVector"" api=""RealVector"" kind=""class"">
    RealVector 
  </clt></a> interface represents a vector with real numbers as entries. The following basic matrix operations are supported: </p> 
<ul> 
 <li>Vector addition, subtraction</li> 
 <li>Element by element multiplication, division</li> 
 <li>Scalar addition, subtraction, multiplication, division and power</li> 
 <li>Mapping of mathematical functions (cos, sin ...)</li> 
 <li>Dot product, outer product</li> 
 <li>Distance and norm according to norms L1, L2 and Linf</li> 
</ul> 
<p> The <a href=""../apidocs/org/apache/commons/math3/linear/RealVectorFormat.html""> 
  <clt fqn=""org.apache.commons.math3.linear.RealVectorFormat"" api=""RealVectorFormat"" kind=""class"">
    RealVectorFormat 
  </clt></a> class handles input/output of vectors in a customizable textual format. </p>","RealVector","org.apache.commons.math3.linear.RealVector","class",1
,"3 Linear Algebra","3.3 Real vectors","<h3>3.3 Real vectors</h3> 
<p> The <a href=""../apidocs/org/apache/commons/math3/linear/RealVector.html""> 
  <clt fqn=""org.apache.commons.math3.linear.RealVector"" api=""RealVector"" kind=""class"">
    RealVector 
  </clt></a> interface represents a vector with real numbers as entries. The following basic matrix operations are supported: </p> 
<ul> 
 <li>Vector addition, subtraction</li> 
 <li>Element by element multiplication, division</li> 
 <li>Scalar addition, subtraction, multiplication, division and power</li> 
 <li>Mapping of mathematical functions (cos, sin ...)</li> 
 <li>Dot product, outer product</li> 
 <li>Distance and norm according to norms L1, L2 and Linf</li> 
</ul> 
<p> The <a href=""../apidocs/org/apache/commons/math3/linear/RealVectorFormat.html""> 
  <clt fqn=""org.apache.commons.math3.linear.RealVectorFormat"" api=""RealVectorFormat"" kind=""class"">
    RealVectorFormat 
  </clt></a> class handles input/output of vectors in a customizable textual format. </p>","RealVectorFormat","org.apache.commons.math3.linear.RealVectorFormat","class",0
,"3 Linear Algebra","3.4 Solving linear systems","<h3>3.4 Solving linear systems</h3> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver.solve"" api=""DecompositionSolver"" kind=""method"">
   DecompositionSolver.solve()
  </clt></tt> methods of the <a href=""../apidocs/org/apache/commons/math3/linear/DecompositionSolver.html""> 
  <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver"" api=""DecompositionSolver"" kind=""class"">
    DecompositionSolver 
  </clt></a> interface support solving linear systems of equations of the form AX=B, either in linear sense or in least square sense. A <tt> 
  <clt fqn=""org.apache.commons.math3.linear.RealMatrix"" api=""RealMatrix"" kind=""class"">
    RealMatrix 
  </clt></tt> instance is used to represent the coefficient matrix of the system. Solving the system is a two phases process: first the coefficient matrix is decomposed in some way and then a solver built from the decomposition solves the system. This allows to compute the decomposition and build the solver only once if several systems have to be solved with the same coefficient matrix. </p> 
<p> For example, to solve the linear system </p> 
<div> 
 <pre>
           2x + 3y - 2z = 1
           -x + 7y + 6x = -2
           4x - 3y - 5z = 1
          </pre> 
</div> 
<div class=""source""> 
 <pre>
RealMatrix coefficients =
    new Array2DRowRealMatrix(new double[][] { { 2, 3, -2 }, { -1, 7, 6 }, { 4, -3, -5 } },
                       false);
DecompositionSolver solver = new LUDecompositionImpl(coefficients).getSolver();
          </pre> 
</div> 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector"" api=""RealVector"" kind=""class"">
   RealVector 
 </clt></tt> 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver.solve"" api=""DecompositionSolver"" kind=""method"">
  DecompositionSolver.solve(RealVector)
 </clt></tt> 
<div class=""source""> 
 <pre>
RealVector constants = new ArrayRealVector(new double[] { 1, -2, 1 }, false);
RealVector solution = solver.solve(constants);
          </pre> 
</div> 
<tt>solution</tt> 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector.getEntry"" api=""RealVector"" kind=""method"">
  solution.RealVector.getEntry(0)
 </clt></tt> 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector.getEntry"" api=""RealVector"" kind=""method"">
  solution.RealVector.getEntry(1)
 </clt></tt> 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector.getEntry"" api=""RealVector"" kind=""method"">
  solution.RealVector.getEntry(2)
 </clt></tt>","DecompositionSolver","org.apache.commons.math3.linear.DecompositionSolver","class",1
,"3 Linear Algebra","3.4 Solving linear systems","<h3>3.4 Solving linear systems</h3> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver.solve"" api=""DecompositionSolver"" kind=""method"">
   DecompositionSolver.solve()
  </clt></tt> methods of the <a href=""../apidocs/org/apache/commons/math3/linear/DecompositionSolver.html""> 
  <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver"" api=""DecompositionSolver"" kind=""class"">
    DecompositionSolver 
  </clt></a> interface support solving linear systems of equations of the form AX=B, either in linear sense or in least square sense. A <tt> 
  <clt fqn=""org.apache.commons.math3.linear.RealMatrix"" api=""RealMatrix"" kind=""class"">
    RealMatrix 
  </clt></tt> instance is used to represent the coefficient matrix of the system. Solving the system is a two phases process: first the coefficient matrix is decomposed in some way and then a solver built from the decomposition solves the system. This allows to compute the decomposition and build the solver only once if several systems have to be solved with the same coefficient matrix. </p> 
<p> For example, to solve the linear system </p> 
<div> 
 <pre>
           2x + 3y - 2z = 1
           -x + 7y + 6x = -2
           4x - 3y - 5z = 1
          </pre> 
</div> 
<div class=""source""> 
 <pre>
RealMatrix coefficients =
    new Array2DRowRealMatrix(new double[][] { { 2, 3, -2 }, { -1, 7, 6 }, { 4, -3, -5 } },
                       false);
DecompositionSolver solver = new LUDecompositionImpl(coefficients).getSolver();
          </pre> 
</div> 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector"" api=""RealVector"" kind=""class"">
   RealVector 
 </clt></tt> 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver.solve"" api=""DecompositionSolver"" kind=""method"">
  DecompositionSolver.solve(RealVector)
 </clt></tt> 
<div class=""source""> 
 <pre>
RealVector constants = new ArrayRealVector(new double[] { 1, -2, 1 }, false);
RealVector solution = solver.solve(constants);
          </pre> 
</div> 
<tt>solution</tt> 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector.getEntry"" api=""RealVector"" kind=""method"">
  solution.RealVector.getEntry(0)
 </clt></tt> 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector.getEntry"" api=""RealVector"" kind=""method"">
  solution.RealVector.getEntry(1)
 </clt></tt> 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector.getEntry"" api=""RealVector"" kind=""method"">
  solution.RealVector.getEntry(2)
 </clt></tt>","RealMatrix","org.apache.commons.math3.linear.RealMatrix","class",0
,"3 Linear Algebra","3.4 Solving linear systems","<h3>3.4 Solving linear systems</h3> 
<p> The <tt> 
  <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver.solve"" api=""DecompositionSolver"" kind=""method"">
   DecompositionSolver.solve()
  </clt></tt> methods of the <a href=""../apidocs/org/apache/commons/math3/linear/DecompositionSolver.html""> 
  <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver"" api=""DecompositionSolver"" kind=""class"">
    DecompositionSolver 
  </clt></a> interface support solving linear systems of equations of the form AX=B, either in linear sense or in least square sense. A <tt> 
  <clt fqn=""org.apache.commons.math3.linear.RealMatrix"" api=""RealMatrix"" kind=""class"">
    RealMatrix 
  </clt></tt> instance is used to represent the coefficient matrix of the system. Solving the system is a two phases process: first the coefficient matrix is decomposed in some way and then a solver built from the decomposition solves the system. This allows to compute the decomposition and build the solver only once if several systems have to be solved with the same coefficient matrix. </p> 
<p> For example, to solve the linear system </p> 
<div> 
 <pre>
           2x + 3y - 2z = 1
           -x + 7y + 6x = -2
           4x - 3y - 5z = 1
          </pre> 
</div> 
<div class=""source""> 
 <pre>
RealMatrix coefficients =
    new Array2DRowRealMatrix(new double[][] { { 2, 3, -2 }, { -1, 7, 6 }, { 4, -3, -5 } },
                       false);
DecompositionSolver solver = new LUDecompositionImpl(coefficients).getSolver();
          </pre> 
</div> 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector"" api=""RealVector"" kind=""class"">
   RealVector 
 </clt></tt> 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver.solve"" api=""DecompositionSolver"" kind=""method"">
  DecompositionSolver.solve(RealVector)
 </clt></tt> 
<div class=""source""> 
 <pre>
RealVector constants = new ArrayRealVector(new double[] { 1, -2, 1 }, false);
RealVector solution = solver.solve(constants);
          </pre> 
</div> 
<tt>solution</tt> 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector.getEntry"" api=""RealVector"" kind=""method"">
  solution.RealVector.getEntry(0)
 </clt></tt> 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector.getEntry"" api=""RealVector"" kind=""method"">
  solution.RealVector.getEntry(1)
 </clt></tt> 
<tt> 
 <clt fqn=""org.apache.commons.math3.linear.RealVector.getEntry"" api=""RealVector"" kind=""method"">
  solution.RealVector.getEntry(2)
 </clt></tt>","RealVector","org.apache.commons.math3.linear.RealVector","class",0
,"3 Linear Algebra","3.4 Solving linear systems - part 2","<h3>3.4 Solving linear systems - part 2</h3>
<p> Each type of decomposition has its specific semantics and constraints on the coefficient matrix as shown in the following table. For algorithms that solve AX=B in least squares sense the value returned for X is such that the residual AX-B has minimal norm. If an exact solution exist (i.e. if for some X the residual AX-B is exactly 0), then this exact solution is also the solution in least square sense. This implies that algorithms suited for least squares problems can also be used to solve exact problems, but the reverse is not true. </p> 
<table class=""bodyTable"" border=""1"" align=""center""> 
 <tbody> 
  <tr class=""a""> 
   <td colspan=""2""><font size=""+2"">Decomposition algorithms</font></td> 
  </tr> 
  <tr class=""b""> 
   <td>Name</td> 
   <td>coefficients matrix</td> 
   <td>problem type</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/LUDecomposition.html"">LU</a></td> 
   <td>square</td> 
   <td>exact solution only</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/CholeskyDecomposition.html"">Cholesky</a></td> 
   <td>symmetric positive definite</td> 
   <td>exact solution only</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/QRDecomposition.html"">QR</a></td> 
   <td>any</td> 
   <td>least squares solution</td> 
  </tr> 
  <tr class=""b""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/EigenDecomposition.html"">eigen decomposition</a></td> 
   <td>square</td> 
   <td>exact solution only</td> 
  </tr> 
  <tr class=""a""> 
   <td><a href=""../apidocs/org/apache/commons/math3/linear/SingularValueDecomposition.html"">SVD</a></td> 
   <td>any</td> 
   <td>least squares solution</td> 
  </tr> 
 </tbody> 
</table> 
<p> It is possible to use a simple array of double instead of a <tt> 
  <clt fqn=""org.apache.commons.math3.linear.RealVector"" api=""RealVector"" kind=""class"">
    RealVector 
  </clt></tt>. In this case, the solution will be provided also as an array of double. </p>","RealVector","org.apache.commons.math3.linear.RealVector","class",0
,"3 Linear Algebra","3.4 Solving linear systems - part 3","<h3>3.4 Solving linear systems - part 3</h3>
<p> It is possible to solve multiple systems with the same coefficient matrix in one method call. To do this, create a matrix whose column vectors correspond to the constant vectors for the systems to be solved and use <tt> 
  <clt fqn=""org.apache.commons.math3.linear.DecompositionSolver.solve"" api=""DecompositionSolver"" kind=""method"">
   DecompositionSolver.solve(RealMatrix),
  </clt></tt> which returns a matrix with column vectors representing the solutions. </p>","DecompositionSolver","org.apache.commons.math3.linear.DecompositionSolver","class",1
,"3 Linear Algebra","3.5 Eigenvalues/eigenvectors and singular values/singular vectors","<h3>3.5 Eigenvalues/eigenvectors and singular values/singular vectors</h3> 
<p> Decomposition algorithms may be used for themselves and not only for linear system solving. This is of prime interest with eigen decomposition and singular value decomposition. </p> 
<p> The <tt>getEigenvalue()</tt>, <tt>getEigenvalues()</tt>, <tt>getEigenVector()</tt>, <tt> 
  <clt fqn=""org.apache.commons.math3.linear.EigenDecomposition.getV"" api=""EigenDecomposition"" kind=""method"">
   EigenDecomposition.getV()
  </clt></tt>, <tt> 
  <clt fqn=""org.apache.commons.math3.linear.EigenDecomposition.getD"" api=""EigenDecomposition"" kind=""method"">
   EigenDecomposition.getD()
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.linear.EigenDecomposition.getVT"" api=""EigenDecomposition"" kind=""method"">
   EigenDecomposition.getVT()
  </clt></tt> methods of the <tt> 
  <clt fqn=""org.apache.commons.math3.linear.EigenDecomposition"" api=""EigenDecomposition"" kind=""class"">
    EigenDecomposition 
  </clt></tt> interface support solving eigenproblems of the form AX = lambda X where lambda is a real scalar. </p> 
<p>The <tt> 
  <clt fqn=""org.apache.commons.math3.linear.SingularValueDecomposition.getSingularValues"" api=""SingularValueDecomposition"" kind=""method"">
   SingularValueDecomposition.getSingularValues()
  </clt></tt>, <tt> 
  <clt fqn=""org.apache.commons.math3.linear.SingularValueDecomposition.getU"" api=""SingularValueDecomposition"" kind=""method"">
   SingularValueDecomposition.getU()
  </clt></tt>, <tt> 
  <clt fqn=""org.apache.commons.math3.linear.SingularValueDecomposition.getS"" api=""SingularValueDecomposition"" kind=""method"">
   SingularValueDecomposition.getS()
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.linear.SingularValueDecomposition.getV"" api=""SingularValueDecomposition"" kind=""method"">
   SingularValueDecomposition.getV()
  </clt></tt> methods of the <tt> 
  <clt fqn=""org.apache.commons.math3.linear.SingularValueDecomposition"" api=""SingularValueDecomposition"" kind=""class"">
    SingularValueDecomposition 
  </clt></tt> interface allow to solve singular values problems of the form AXi = lambda Yi where lambda is a real scalar, and where the Xi and Yi vectors form orthogonal bases of their respective vector spaces (which may have different dimensions). </p>","EigenDecomposition","org.apache.commons.math3.linear.EigenDecomposition","class",1
,"3 Linear Algebra","3.5 Eigenvalues/eigenvectors and singular values/singular vectors","<h3>3.5 Eigenvalues/eigenvectors and singular values/singular vectors</h3> 
<p> Decomposition algorithms may be used for themselves and not only for linear system solving. This is of prime interest with eigen decomposition and singular value decomposition. </p> 
<p> The <tt>getEigenvalue()</tt>, <tt>getEigenvalues()</tt>, <tt>getEigenVector()</tt>, <tt> 
  <clt fqn=""org.apache.commons.math3.linear.EigenDecomposition.getV"" api=""EigenDecomposition"" kind=""method"">
   EigenDecomposition.getV()
  </clt></tt>, <tt> 
  <clt fqn=""org.apache.commons.math3.linear.EigenDecomposition.getD"" api=""EigenDecomposition"" kind=""method"">
   EigenDecomposition.getD()
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.linear.EigenDecomposition.getVT"" api=""EigenDecomposition"" kind=""method"">
   EigenDecomposition.getVT()
  </clt></tt> methods of the <tt> 
  <clt fqn=""org.apache.commons.math3.linear.EigenDecomposition"" api=""EigenDecomposition"" kind=""class"">
    EigenDecomposition 
  </clt></tt> interface support solving eigenproblems of the form AX = lambda X where lambda is a real scalar. </p> 
<p>The <tt> 
  <clt fqn=""org.apache.commons.math3.linear.SingularValueDecomposition.getSingularValues"" api=""SingularValueDecomposition"" kind=""method"">
   SingularValueDecomposition.getSingularValues()
  </clt></tt>, <tt> 
  <clt fqn=""org.apache.commons.math3.linear.SingularValueDecomposition.getU"" api=""SingularValueDecomposition"" kind=""method"">
   SingularValueDecomposition.getU()
  </clt></tt>, <tt> 
  <clt fqn=""org.apache.commons.math3.linear.SingularValueDecomposition.getS"" api=""SingularValueDecomposition"" kind=""method"">
   SingularValueDecomposition.getS()
  </clt></tt> and <tt> 
  <clt fqn=""org.apache.commons.math3.linear.SingularValueDecomposition.getV"" api=""SingularValueDecomposition"" kind=""method"">
   SingularValueDecomposition.getV()
  </clt></tt> methods of the <tt> 
  <clt fqn=""org.apache.commons.math3.linear.SingularValueDecomposition"" api=""SingularValueDecomposition"" kind=""class"">
    SingularValueDecomposition 
  </clt></tt> interface allow to solve singular values problems of the form AXi = lambda Yi where lambda is a real scalar, and where the Xi and Yi vectors form orthogonal bases of their respective vector spaces (which may have different dimensions). </p>","SingularValueDecomposition","org.apache.commons.math3.linear.SingularValueDecomposition","class",1
,"3 Linear Algebra","3.6 Non-real fields (complex, fractions ...)","<h3>3.6 Non-real fields (complex, fractions ...)</h3> 
<p> In addition to the real field, matrices and vectors using non-real <a href=""../apidocs/org/apache/commons/math3/FieldElement.html"">field elements</a> can be used. The fields already supported by the library are: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/complex/Complex.html""> 
   <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""unknown"">
     Complex 
   </clt></a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/fraction/Fraction.html""> 
   <clt fqn=""org.apache.commons.math3.fraction.Fraction"" api=""Fraction"" kind=""unknown"">
     Fraction 
   </clt></a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/fraction/BigFraction.html""> 
   <clt fqn=""org.apache.commons.math3.fraction.BigFraction"" api=""BigFraction"" kind=""class"">
     BigFraction 
   </clt></a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/util/BigReal.html""> 
   <clt fqn=""org.apache.commons.math3.util.BigReal"" api=""BigReal"" kind=""class"">
     BigReal 
   </clt></a></li> 
</ul>","Complex","org.apache.commons.math3.complex.Complex","class",0
,"3 Linear Algebra","3.6 Non-real fields (complex, fractions ...)","<h3>3.6 Non-real fields (complex, fractions ...)</h3> 
<p> In addition to the real field, matrices and vectors using non-real <a href=""../apidocs/org/apache/commons/math3/FieldElement.html"">field elements</a> can be used. The fields already supported by the library are: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/complex/Complex.html""> 
   <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""unknown"">
     Complex 
   </clt></a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/fraction/Fraction.html""> 
   <clt fqn=""org.apache.commons.math3.fraction.Fraction"" api=""Fraction"" kind=""unknown"">
     Fraction 
   </clt></a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/fraction/BigFraction.html""> 
   <clt fqn=""org.apache.commons.math3.fraction.BigFraction"" api=""BigFraction"" kind=""class"">
     BigFraction 
   </clt></a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/util/BigReal.html""> 
   <clt fqn=""org.apache.commons.math3.util.BigReal"" api=""BigReal"" kind=""class"">
     BigReal 
   </clt></a></li> 
</ul>","Fraction","org.apache.commons.math3.fraction.Fraction","class",0
,"3 Linear Algebra","3.6 Non-real fields (complex, fractions ...)","<h3>3.6 Non-real fields (complex, fractions ...)</h3> 
<p> In addition to the real field, matrices and vectors using non-real <a href=""../apidocs/org/apache/commons/math3/FieldElement.html"">field elements</a> can be used. The fields already supported by the library are: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/complex/Complex.html""> 
   <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""unknown"">
     Complex 
   </clt></a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/fraction/Fraction.html""> 
   <clt fqn=""org.apache.commons.math3.fraction.Fraction"" api=""Fraction"" kind=""unknown"">
     Fraction 
   </clt></a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/fraction/BigFraction.html""> 
   <clt fqn=""org.apache.commons.math3.fraction.BigFraction"" api=""BigFraction"" kind=""class"">
     BigFraction 
   </clt></a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/util/BigReal.html""> 
   <clt fqn=""org.apache.commons.math3.util.BigReal"" api=""BigReal"" kind=""class"">
     BigReal 
   </clt></a></li> 
</ul>","BigFraction","org.apache.commons.math3.fraction.BigFraction","class",0
,"3 Linear Algebra","3.6 Non-real fields (complex, fractions ...)","<h3>3.6 Non-real fields (complex, fractions ...)</h3> 
<p> In addition to the real field, matrices and vectors using non-real <a href=""../apidocs/org/apache/commons/math3/FieldElement.html"">field elements</a> can be used. The fields already supported by the library are: </p> 
<ul> 
 <li><a href=""../apidocs/org/apache/commons/math3/complex/Complex.html""> 
   <clt fqn=""org.apache.commons.math3.complex.Complex"" api=""Complex"" kind=""unknown"">
     Complex 
   </clt></a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/fraction/Fraction.html""> 
   <clt fqn=""org.apache.commons.math3.fraction.Fraction"" api=""Fraction"" kind=""unknown"">
     Fraction 
   </clt></a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/fraction/BigFraction.html""> 
   <clt fqn=""org.apache.commons.math3.fraction.BigFraction"" api=""BigFraction"" kind=""class"">
     BigFraction 
   </clt></a></li> 
 <li><a href=""../apidocs/org/apache/commons/math3/util/BigReal.html""> 
   <clt fqn=""org.apache.commons.math3.util.BigReal"" api=""BigReal"" kind=""class"">
     BigReal 
   </clt></a></li> 
</ul>","BigReal","org.apache.commons.math3.util.BigReal","class",0
