,"Section1-Intorduction","Section1-Intorduction","<h2>Introduction<a name=""Introduction""></a></h2>
<p>
Joda Time is like an iceberg, 9/10ths of it is invisible to user-code.
Many, perhaps most, applications will never need to see what's below the surface.
This document provides an introduction to the Joda-Time API for the
average user, not for the would-be API developer.
</p>
<p>
The bulk of the
text is devoted to code snippets that display the most common usage scenarios
in which the library classes are used. In particular, we cover the usage of the
key <tt>DateTime</tt>, <tt>Interval</tt>, <tt>Duration</tt>
and <tt>Period</tt> classes.
</p>
<p>
We finish with a look at the important topic of formatting and parsing and a few
more advanced topics.
</p>","DateTime","DateTime","class",0
,"Section1-Intorduction","Section1-Intorduction","<h2>Introduction<a name=""Introduction""></a></h2>
<p>
Joda Time is like an iceberg, 9/10ths of it is invisible to user-code.
Many, perhaps most, applications will never need to see what's below the surface.
This document provides an introduction to the Joda-Time API for the
average user, not for the would-be API developer.
</p>
<p>
The bulk of the
text is devoted to code snippets that display the most common usage scenarios
in which the library classes are used. In particular, we cover the usage of the
key <tt>DateTime</tt>, <tt>Interval</tt>, <tt>Duration</tt>
and <tt>Period</tt> classes.
</p>
<p>
We finish with a look at the important topic of formatting and parsing and a few
more advanced topics.
</p>","Interval","Interval","class",0
,"Section1-Intorduction","Section1-Intorduction","<h2>Introduction<a name=""Introduction""></a></h2>
<p>
Joda Time is like an iceberg, 9/10ths of it is invisible to user-code.
Many, perhaps most, applications will never need to see what's below the surface.
This document provides an introduction to the Joda-Time API for the
average user, not for the would-be API developer.
</p>
<p>
The bulk of the
text is devoted to code snippets that display the most common usage scenarios
in which the library classes are used. In particular, we cover the usage of the
key <tt>DateTime</tt>, <tt>Interval</tt>, <tt>Duration</tt>
and <tt>Period</tt> classes.
</p>
<p>
We finish with a look at the important topic of formatting and parsing and a few
more advanced topics.
</p>","Duration","Duration","class",0
,"Section1-Intorduction","Section1-Intorduction","<h2>Introduction<a name=""Introduction""></a></h2>
<p>
Joda Time is like an iceberg, 9/10ths of it is invisible to user-code.
Many, perhaps most, applications will never need to see what's below the surface.
This document provides an introduction to the Joda-Time API for the
average user, not for the would-be API developer.
</p>
<p>
The bulk of the
text is devoted to code snippets that display the most common usage scenarios
in which the library classes are used. In particular, we cover the usage of the
key <tt>DateTime</tt>, <tt>Interval</tt>, <tt>Duration</tt>
and <tt>Period</tt> classes.
</p>
<p>
We finish with a look at the important topic of formatting and parsing and a few
more advanced topics.
</p>","Period","Period","class",0
,"Section3-Instants","Section3-Instants","<div class=""section""><h2>Instants<a name=""Instants""></a></h2>
<p>
The most frequently used concept in Joda-Time is that of the <i>instant</i>.
An Instant is defined as <i>a moment in the datetime continuum specified as a
number of milliseconds from 1970-01-01T00:00Z</i>.
This definition of milliseconds is consistent with that of the JDK in <tt>Date</tt>
or <tt>Calendar</tt>. Interoperating between the two APIs is thus simple.
</p>
<p>
Within Joda-Time an instant is represented by the
<tt>ReadableInstant</tt> interface. The main implementation
of this interface, and the class that the average API user needs to be
most familiar with, is <tt>DateTime</tt>. DateTime is immutable - and once
created the values do not change. Thus, this class can safely be passed around
and used in multiple threads without synchronization.
</p>
<p>
The millisecond instant can be converted to any date time field using a
<i><tt>Chronology</tt></i>.
To assist with this, methods are provided on
<tt>DateTime</tt> that act as getters for the most common date and
time fields.
</p>
<p>
We discuss the chronology concept a litte further on in this overview.
</p>
<p>
A companion mutable class to <tt>DateTime</tt> is
<tt>MutableDateTime</tt>. Objects
of this class can be modified and are not thread-safe.
</p>
<p>
Other implementations of <tt>ReadableInstant</tt> include <tt>Instant</tt>
and <tt>DateMidnight</tt>.
</p></div>","DateTime","DateTime	","class",1
,"Section3-Instants","Section3-Instants","<div class=""section""><h2>Instants<a name=""Instants""></a></h2>
<p>
The most frequently used concept in Joda-Time is that of the <i>instant</i>.
An Instant is defined as <i>a moment in the datetime continuum specified as a
number of milliseconds from 1970-01-01T00:00Z</i>.
This definition of milliseconds is consistent with that of the JDK in <tt>Date</tt>
or <tt>Calendar</tt>. Interoperating between the two APIs is thus simple.
</p>
<p>
Within Joda-Time an instant is represented by the
<tt>ReadableInstant</tt> interface. The main implementation
of this interface, and the class that the average API user needs to be
most familiar with, is <tt>DateTime</tt>. DateTime is immutable - and once
created the values do not change. Thus, this class can safely be passed around
and used in multiple threads without synchronization.
</p>
<p>
The millisecond instant can be converted to any date time field using a
<i><tt>Chronology</tt></i>.
To assist with this, methods are provided on
<tt>DateTime</tt> that act as getters for the most common date and
time fields.
</p>
<p>
We discuss the chronology concept a litte further on in this overview.
</p>
<p>
A companion mutable class to <tt>DateTime</tt> is
<tt>MutableDateTime</tt>. Objects
of this class can be modified and are not thread-safe.
</p>
<p>
Other implementations of <tt>ReadableInstant</tt> include <tt>Instant</tt>
and <tt>DateMidnight</tt>.
</p></div>","Chronology","Chronology	","class",1
,"Section3-Instants","Section3-Instants","<div class=""section""><h2>Instants<a name=""Instants""></a></h2>
<p>
The most frequently used concept in Joda-Time is that of the <i>instant</i>.
An Instant is defined as <i>a moment in the datetime continuum specified as a
number of milliseconds from 1970-01-01T00:00Z</i>.
This definition of milliseconds is consistent with that of the JDK in <tt>Date</tt>
or <tt>Calendar</tt>. Interoperating between the two APIs is thus simple.
</p>
<p>
Within Joda-Time an instant is represented by the
<tt>ReadableInstant</tt> interface. The main implementation
of this interface, and the class that the average API user needs to be
most familiar with, is <tt>DateTime</tt>. DateTime is immutable - and once
created the values do not change. Thus, this class can safely be passed around
and used in multiple threads without synchronization.
</p>
<p>
The millisecond instant can be converted to any date time field using a
<i>Chronology</i>.
To assist with this, methods are provided on
<tt>DateTime</tt> that act as getters for the most common date and
time fields.
</p>
<p>
We discuss the chronology concept a litte further on in this overview.
</p>
<p>
A companion mutable class to <tt>DateTime</tt> is
<tt>MutableDateTime</tt>. Objects
of this class can be modified and are not thread-safe.
</p>
<p>
Other implementations of <tt>ReadableInstant</tt> include <tt>Instant</tt>
and <tt>DateMidnight</tt>.
</p></div>","ReadableInstant","ReadableInstant","class",0
,"Section3-Instants","Section3-Instants","<div class=""section""><h2>Instants<a name=""Instants""></a></h2>
<p>
The most frequently used concept in Joda-Time is that of the <i>instant</i>.
An Instant is defined as <i>a moment in the datetime continuum specified as a
number of milliseconds from 1970-01-01T00:00Z</i>.
This definition of milliseconds is consistent with that of the JDK in <tt>Date</tt>
or <tt>Calendar</tt>. Interoperating between the two APIs is thus simple.
</p>
<p>
Within Joda-Time an instant is represented by the
<tt>ReadableInstant</tt> interface. The main implementation
of this interface, and the class that the average API user needs to be
most familiar with, is <tt>DateTime</tt>. DateTime is immutable - and once
created the values do not change. Thus, this class can safely be passed around
and used in multiple threads without synchronization.
</p>
<p>
The millisecond instant can be converted to any date time field using a
<i>Chronology</i>.
To assist with this, methods are provided on
<tt>DateTime</tt> that act as getters for the most common date and
time fields.
</p>
<p>
We discuss the chronology concept a litte further on in this overview.
</p>
<p>
A companion mutable class to <tt>DateTime</tt> is
<tt>MutableDateTime</tt>. Objects
of this class can be modified and are not thread-safe.
</p>
<p>
Other implementations of <tt>ReadableInstant</tt> include <tt>Instant</tt>
and <tt>DateMidnight</tt>.
</p></div>","MutableDateTime","MutableDateTime	","class",1
,"Section3-Instants","Section3-Instants","<div class=""section""><h2>Instants<a name=""Instants""></a></h2>
<p>
The most frequently used concept in Joda-Time is that of the <i><tt>Instant</tt></i>.
An Instant is defined as <i>a moment in the datetime continuum specified as a
number of milliseconds from 1970-01-01T00:00Z</i>.
This definition of milliseconds is consistent with that of the JDK in <tt>Date</tt>
or <tt>Calendar</tt>. Interoperating between the two APIs is thus simple.
</p>
<p>
Within Joda-Time an instant is represented by the
<tt>ReadableInstant</tt> interface. The main implementation
of this interface, and the class that the average API user needs to be
most familiar with, is <tt>DateTime</tt>. DateTime is immutable - and once
created the values do not change. Thus, this class can safely be passed around
and used in multiple threads without synchronization.
</p>
<p>
The millisecond instant can be converted to any date time field using a
<i>Chronology</i>.
To assist with this, methods are provided on
<tt>DateTime</tt> that act as getters for the most common date and
time fields.
</p>
<p>
We discuss the chronology concept a litte further on in this overview.
</p>
<p>
A companion mutable class to <tt>DateTime</tt> is
<tt>MutableDateTime</tt>. Objects
of this class can be modified and are not thread-safe.
</p>
<p>
Other implementations of <tt>ReadableInstant</tt> include <tt>Instant</tt>
and <tt>DateMidnight</tt>.
</p></div>","Instant","Instant	","class",1
,"Section3-Instants","Section3-Instants","<div class=""section""><h2>Instants<a name=""Instants""></a></h2>
<p>
The most frequently used concept in Joda-Time is that of the <i>instant</i>.
An Instant is defined as <i>a moment in the datetime continuum specified as a
number of milliseconds from 1970-01-01T00:00Z</i>.
This definition of milliseconds is consistent with that of the JDK in <tt>Date</tt>
or <tt>Calendar</tt>. Interoperating between the two APIs is thus simple.
</p>
<p>
Within Joda-Time an instant is represented by the
<tt>ReadableInstant</tt> interface. The main implementation
of this interface, and the class that the average API user needs to be
most familiar with, is <tt>DateTime</tt>. DateTime is immutable - and once
created the values do not change. Thus, this class can safely be passed around
and used in multiple threads without synchronization.
</p>
<p>
The millisecond instant can be converted to any date time field using a
<i>Chronology</i>.
To assist with this, methods are provided on
<tt>DateTime</tt> that act as getters for the most common date and
time fields.
</p>
<p>
We discuss the chronology concept a litte further on in this overview.
</p>
<p>
A companion mutable class to <tt>DateTime</tt> is
<tt>MutableDateTime</tt>. Objects
of this class can be modified and are not thread-safe.
</p>
<p>
Other implementations of <tt>ReadableInstant</tt> include <tt>Instant</tt>
and <tt>DateMidnight</tt>.
</p></div>","DateMidnight","DateMidnight","class",0
,"Section3-Instants","Subsection3.1-Fields","<div class=""section""><h3>Fields<a name=""Fields""></a></h3>
<p>
The main API of <tt>DateTime</tt> has been kept small, limited to just
get methods for each calendar field. So, for instance, the 'day-of-year' calendar
field would be retrieved by calling the <tt>getDayOfYear()</tt> method. For
a complete list of fields and their descriptions, see the
<a href=""field.html"">field reference</a>.
</p>
</div>","DateTime","DateTime","class",0
,"Section3-Instants","Subsection3.1-Fields","<div class=""section""><h3>Fields<a name=""Fields""></a></h3>
<p>
The main API of <tt>DateTime</tt> has been kept small, limited to just
get methods for each calendar field. So, for instance, the 'day-of-year' calendar
field would be retrieved by calling the <tt>getDayOfYear()</tt> method. For
a complete list of fields and their descriptions, see the
<a href=""field.html"">field reference</a>.
</p>
</div>","getDayOfYear()","DateTime.getDayOfYear()","class",0
,"Section3-Instants","SubSection3.2-Properties ","<div class=""section""><h3>Properties<a name=""Properties""></a></h3>
<p>
There is much more power available, however, through the use of what is termed a
<i>property</i>. Each calendar field is associated with such a property.
Thus, 'day-of-year', whose value is directly returned by the method
<tt>getDayOfYear()</tt>, is also associated with the property returned by
the <tt>dayOfYear()</tt> method. The property class associated with
<tt>DateTime</tt> is <tt>DateTime.Property</tt>.
</p>
<p>
Knowing the methods on the property is the secret to making the most of the API.
We have more to say on the usage of properties later in this document.
</p>
</div>
</div>","DateTime","DateTime","class",0
,"Section3-Instants","SubSection3.2-Properties ","<div class=""section""><h3>Properties<a name=""Properties""></a></h3>
<p>
There is much more power available, however, through the use of what is termed a
<i>property</i>. Each calendar field is associated with such a property.
Thus, 'day-of-year', whose value is directly returned by the method
<tt>getDayOfYear()</tt>, is also associated with the property returned by
the <tt>dayOfYear()</tt> method. The property class associated with
<tt>DateTime</tt> is <tt>DateTime.Property</tt>.
</p>
<p>
Knowing the methods on the property is the secret to making the most of the API.
We have more to say on the usage of properties later in this document.
</p>
</div>
</div>","getDayOfYear()","DateTime.getDayOfYear()","class",0
,"Section3-Instants","SubSection3.2-Properties ","<div class=""section""><h3>Properties<a name=""Properties""></a></h3>
<p>
There is much more power available, however, through the use of what is termed a
<i>property</i>. Each calendar field is associated with such a property.
Thus, 'day-of-year', whose value is directly returned by the method
<tt>getDayOfYear()</tt>, is also associated with the property returned by
the <tt>dayOfYear()</tt> method. The property class associated with
<tt>DateTime</tt> is <tt>DateTime.Property</tt>.
</p>
<p>
Knowing the methods on the property is the secret to making the most of the API.
We have more to say on the usage of properties later in this document.
</p>
</div>
</div>","dayOfYear()","DateTime.dayOfYear()","class",0
,"Section3-Instants","SubSection3.2-Properties ","<div class=""section""><h3>Properties<a name=""Properties""></a></h3>
<p>
There is much more power available, however, through the use of what is termed a
<i>property</i>. Each calendar field is associated with such a property.
Thus, 'day-of-year', whose value is directly returned by the method
<tt>getDayOfYear()</tt>, is also associated with the property returned by
the <tt>dayOfYear()</tt> method. The property class associated with
<tt>DateTime</tt> is <tt>DateTime.Property</tt>.
</p>
<p>
Knowing the methods on the property is the secret to making the most of the API.
We have more to say on the usage of properties later in this document.
</p>
</div>
</div>","DateTime.Property","DateTime.Property	","class",1
,"Section4-Intervals","Section4-Intervals","<div class=""section""><h2>Intervals<a name=""Intervals""></a></h2>
<p>
An <i><tt>Interval</tt></i> in Joda-Time represents an interval of time from one
instant to another instant. Both instants are fully specified instants in the
datetime continuum, complete with time zone.
</p>
<p>
<tt>Intervals</tt> are implemented as <i>half-open</i>, which is to say that the start instant is
inclusive but the end instant is exclusive. The end is always greater than or equal to the start.
Both end-points are restricted to having the same chronology and the same time zone.
</p>
<p>
Two implementations are provided, <tt>Interval</tt> and <tt>MutableInterval</tt>,
both are specializations of <tt>ReadableInterval</tt>.
</p>
</div>","Interval","Interval	","class",1
,"Section4-Intervals","Section4-Intervals","<div class=""section""><h2>Intervals<a name=""Intervals""></a></h2>
<p>
An <i>interval</i> in Joda-Time represents an interval of time from one
instant to another instant. Both instants are fully specified instants in the
datetime continuum, complete with time zone.
</p>
<p>
Intervals are implemented as <i>half-open</i>, which is to say that the start instant is
inclusive but the end instant is exclusive. The end is always greater than or equal to the start.
Both end-points are restricted to having the same chronology and the same time zone.
</p>
<p>
Two implementations are provided, <tt>Interval</tt> and <tt>MutableInterval</tt>,
both are specializations of <tt>ReadableInterval</tt>.
</p>
</div>","MutableInterval","MutableInterval","class",0
,"Section4-Intervals","Section4-Intervals","<div class=""section""><h2>Intervals<a name=""Intervals""></a></h2>
<p>
An <i>interval</i> in Joda-Time represents an interval of time from one
instant to another instant. Both instants are fully specified instants in the
datetime continuum, complete with time zone.
</p>
<p>
Intervals are implemented as <i>half-open</i>, which is to say that the start instant is
inclusive but the end instant is exclusive. The end is always greater than or equal to the start.
Both end-points are restricted to having the same chronology and the same time zone.
</p>
<p>
Two implementations are provided, <tt>Interval</tt> and <tt>MutableInterval</tt>,
both are specializations of <tt>ReadableInterval</tt>.
</p>
</div>","ReadableInterval","ReadableInterval","class",0
,"Section5-Durations ","Section5-Durations ","<div class=""section""><h2>Durations<a name=""Durations""></a></h2>
<p>
A <i><tt>Duration</tt></i> in Joda-Time represents a duration of time measured in milliseconds.
The duration is often obtained from an interval.
</p>
<p>
<tt>Durations</tt> are a very simple concept, and the implementation is also simple.
They have no chronology or time zone, and consist solely of the millisecond duration.
</p>
<p>
<tt>Durations</tt> can be added to an instant, or to either
end of an interval to change those objects.
In datetime maths you could say:
</p><div class=""source""><pre>
      instant  +  duration  =  instant
</pre></div>

<p>
Currently, there is only one implementation of the <tt>ReadableDuration</tt>
interface: <tt>Duration</tt>.
</p>
</div>","Duration","Duration	","class",1
,"Section5-Durations ","Section5-Durations ","<div class=""section""><h2>Durations<a name=""Durations""></a></h2>
<p>
A <i>duration</i> in Joda-Time represents a duration of time measured in milliseconds.
The duration is often obtained from an interval.
</p>
<p>
Durations are a very simple concept, and the implementation is also simple.
They have no chronology or time zone, and consist solely of the millisecond duration.
</p>
<p>
Durations can be added to an instant, or to either
end of an interval to change those objects.
In datetime maths you could say:
</p><div class=""source""><pre>
      instant  +  duration  =  instant
</pre></div>

<p>
Currently, there is only one implementation of the <tt>ReadableDuration</tt>
interface: <tt>Duration</tt>.
</p>
</div>","ReadableDuration","ReadableDuration","class",0
,"Section6-Periods","Section6-Periods","<div class=""section""><h2>Periods<a name=""Periods""></a></h2>

<p>
A <i><tt>Period</tt></i> in Joda-Time represents a period of time defined in terms of fields,
for example, 3 years 5 months 2 days and 7 hours.
This differs from a duration in that it is inexact in terms of milliseconds.
A period can only be resolved to an exact number of milliseconds by specifying the
instant (including chronology and time zone) it is relative to.
</p>
<p>
For example, consider a period of 1 month.
If you add this period to the 1st February (ISO) then you will get the 1st March.
If you add the same period to the 1st March you will get the 1st April.
But the duration added (in milliseconds) in these two cases is very different.
</p>
<p>
As a second example, consider adding 1 day at the daylight savings boundary.
If you use a period to do the addition then either 23 or 25 hours will be added as appropriate.
If you had created a duration equal to 24 hours, then you would end up with the wrong result.
</p>
<p>
<tt>Periods</tt> are implemented as a set of <tt>int</tt> fields.
The standard set of fields in a period are years, months, weeks, days, hours, minutes, seconds
and millis.
The <tt>PeriodType</tt> class allows this set
of fields to be restricted, for example to elimate weeks.
This is significant when converting a duration or interval to a period, as the calculation
needs to know which period fields it should populate.
</p>
<p>
Methods exist on periods to obtain each field value.
<tt>Periods</tt> are not associated with either a chronology or a time zone.
</p>
<p>
<tt>Periods</tt> can be added to an instant, or to either
end of an interval to change those objects.
In datetime maths you could say:
</p><div class=""source""><pre>
      instant  +  period  =  instant
</pre></div>

<p>
There are two implementations of the <tt>ReadablePeriod</tt> interface,
<tt>Period</tt> and <tt>MutablePeriod</tt>.
</p>
</div>","Period","Period	","class",1
,"Section6-Periods","Section6-Periods","<div class=""section""><h2>Periods<a name=""Periods""></a></h2>

<p>
A <i>period</i> in Joda-Time represents a period of time defined in terms of fields,
for example, 3 years 5 months 2 days and 7 hours.
This differs from a duration in that it is inexact in terms of milliseconds.
A period can only be resolved to an exact number of milliseconds by specifying the
instant (including chronology and time zone) it is relative to.
</p>
<p>
For example, consider a period of 1 month.
If you add this period to the 1st February (ISO) then you will get the 1st March.
If you add the same period to the 1st March you will get the 1st April.
But the duration added (in milliseconds) in these two cases is very different.
</p>
<p>
As a second example, consider adding 1 day at the daylight savings boundary.
If you use a period to do the addition then either 23 or 25 hours will be added as appropriate.
If you had created a duration equal to 24 hours, then you would end up with the wrong result.
</p>
<p>
Periods are implemented as a set of <tt>int</tt> fields.
The standard set of fields in a period are years, months, weeks, days, hours, minutes, seconds
and millis.
The <tt>PeriodType</tt> class allows this set
of fields to be restricted, for example to elimate weeks.
This is significant when converting a duration or interval to a period, as the calculation
needs to know which period fields it should populate.
</p>
<p>
Methods exist on periods to obtain each field value.
Periods are not associated with either a chronology or a time zone.
</p>
<p>
Periods can be added to an instant, or to either
end of an interval to change those objects.
In datetime maths you could say:
</p><div class=""source""><pre>
      instant  +  period  =  instant
</pre></div>

<p>
There are two implementations of the <tt>ReadablePeriod</tt> interface,
<tt>Period</tt> and <tt>MutablePeriod</tt>.
</p>
</div>","PeriodType","PeriodType	","class",1
,"Section6-Periods","Section6-Periods","<div class=""section""><h2>Periods<a name=""Periods""></a></h2>

<p>
A <i>period</i> in Joda-Time represents a period of time defined in terms of fields,
for example, 3 years 5 months 2 days and 7 hours.
This differs from a duration in that it is inexact in terms of milliseconds.
A period can only be resolved to an exact number of milliseconds by specifying the
instant (including chronology and time zone) it is relative to.
</p>
<p>
For example, consider a period of 1 month.
If you add this period to the 1st February (ISO) then you will get the 1st March.
If you add the same period to the 1st March you will get the 1st April.
But the duration added (in milliseconds) in these two cases is very different.
</p>
<p>
As a second example, consider adding 1 day at the daylight savings boundary.
If you use a period to do the addition then either 23 or 25 hours will be added as appropriate.
If you had created a duration equal to 24 hours, then you would end up with the wrong result.
</p>
<p>
Periods are implemented as a set of <tt>int</tt> fields.
The standard set of fields in a period are years, months, weeks, days, hours, minutes, seconds
and millis.
The <tt>PeriodType</tt> class allows this set
of fields to be restricted, for example to elimate weeks.
This is significant when converting a duration or interval to a period, as the calculation
needs to know which period fields it should populate.
</p>
<p>
Methods exist on periods to obtain each field value.
Periods are not associated with either a chronology or a time zone.
</p>
<p>
Periods can be added to an instant, or to either
end of an interval to change those objects.
In datetime maths you could say:
</p><div class=""source""><pre>
      instant  +  period  =  instant
</pre></div>

<p>
There are two implementations of the <tt>ReadablePeriod</tt> interface,
<tt>Period</tt> and <tt>MutablePeriod</tt>.
</p>
</div>","ReadablePeriod","ReadablePeriod","class",0
,"Section6-Periods","Section6-Periods","<div class=""section""><h2>Periods<a name=""Periods""></a></h2>

<p>
A <i>period</i> in Joda-Time represents a period of time defined in terms of fields,
for example, 3 years 5 months 2 days and 7 hours.
This differs from a duration in that it is inexact in terms of milliseconds.
A period can only be resolved to an exact number of milliseconds by specifying the
instant (including chronology and time zone) it is relative to.
</p>
<p>
For example, consider a period of 1 month.
If you add this period to the 1st February (ISO) then you will get the 1st March.
If you add the same period to the 1st March you will get the 1st April.
But the duration added (in milliseconds) in these two cases is very different.
</p>
<p>
As a second example, consider adding 1 day at the daylight savings boundary.
If you use a period to do the addition then either 23 or 25 hours will be added as appropriate.
If you had created a duration equal to 24 hours, then you would end up with the wrong result.
</p>
<p>
Periods are implemented as a set of <tt>int</tt> fields.
The standard set of fields in a period are years, months, weeks, days, hours, minutes, seconds
and millis.
The <tt>PeriodType</tt> class allows this set
of fields to be restricted, for example to elimate weeks.
This is significant when converting a duration or interval to a period, as the calculation
needs to know which period fields it should populate.
</p>
<p>
Methods exist on periods to obtain each field value.
Periods are not associated with either a chronology or a time zone.
</p>
<p>
Periods can be added to an instant, or to either
end of an interval to change those objects.
In datetime maths you could say:
</p><div class=""source""><pre>
      instant  +  period  =  instant
</pre></div>

<p>
There are two implementations of the <tt>ReadablePeriod</tt> interface,
<tt>Period</tt> and <tt>MutablePeriod</tt>.
</p>
</div>","MutablePeriod","MutablePeriod","class",0
,"Section7-Chronology","Section7-Chronology","<div class=""section""><h2>Chronology<a name=""Chronology""></a></h2>
<p>
The Joda-Time design is based around the
<i>Chronology</i>. It is a calculation engine that supports the complex
rules for a calendar system. It encapsulates the field objects, which are used
on demand to split the absolute time instant into recognisable calendar
fields like 'day-of-week'. It is effectively a pluggable calendar system.
</p>
<p>
The actual calculations of the chronology are split between the
<tt>Chronology</tt> class itself and the field classes -
<tt>DateTimeField</tt> and <tt>DurationField</tt>.
Together, the subclasses of these three classes form the bulk of the code
in the library.
Most users will never need to use or refer directly to the subclasses.
Instead, they will simply obtain the chronology and use it as a singleton, as follows:
</p><div class=""source""><pre>
Chronology coptic = CopticChronology.getInstance(),
</pre></div>

<p>
Internally, all the chronology, field, etc. classes are maintained as singletons.
Thus there is an initial setup cost when using Joda-Time, but after that only
the main API instance classes
(<tt>DateTime</tt>, <tt>Interval</tt>, <tt>Period</tt>, etc.)
have creation and garbage collector costs.
</p>
<p>
Although the Chronology is key to the design, it is not key to using the API !!
</p>
<p>
For most applications, the Chronology can be ignored as it will default to the
<tt>ISOChronology</tt>. This is suitable for most uses.
You would change it if you need accurate dates before October 15, 1582,
or whenever the Julian calendar ceased in the territory you're interested in).
You'd also change it if you need a specific calendar like the Coptic calendar illustrated earlier.
</p>
</div>","DateTime","DateTime","class",0
,"Section7-Chronology","Section7-Chronology","<div class=""section""><h2>Chronology<a name=""Chronology""></a></h2>
<p>
The Joda-Time design is based around the
<i>Chronology</i>. It is a calculation engine that supports the complex
rules for a calendar system. It encapsulates the field objects, which are used
on demand to split the absolute time instant into recognisable calendar
fields like 'day-of-week'. It is effectively a pluggable calendar system.
</p>
<p>
The actual calculations of the chronology are split between the
<tt>Chronology</tt> class itself and the field classes -
<tt>DateTimeField</tt> and <tt>DurationField</tt>.
Together, the subclasses of these three classes form the bulk of the code
in the library.
Most users will never need to use or refer directly to the subclasses.
Instead, they will simply obtain the chronology and use it as a singleton, as follows:
</p><div class=""source""><pre>
Chronology coptic = CopticChronology.getInstance(),
</pre></div>

<p>
Internally, all the chronology, field, etc. classes are maintained as singletons.
Thus there is an initial setup cost when using Joda-Time, but after that only
the main API instance classes
(<tt>DateTime</tt>, <tt>Interval</tt>, <tt>Period</tt>, etc.)
have creation and garbage collector costs.
</p>
<p>
Although the Chronology is key to the design, it is not key to using the API !!
</p>
<p>
For most applications, the Chronology can be ignored as it will default to the
ISOChronology. This is suitable for most uses.
You would change it if you need accurate dates before October 15, 1582,
or whenever the Julian calendar ceased in the territory you're interested in).
You'd also change it if you need a specific calendar like the Coptic calendar illustrated earlier.
</p>
</div>","Interval","Interval","class",0
,"Section7-Chronology","Section7-Chronology","<div class=""section""><h2>Chronology<a name=""Chronology""></a></h2>
<p>
The Joda-Time design is based around the
<i>Chronology</i>. It is a calculation engine that supports the complex
rules for a calendar system. It encapsulates the field objects, which are used
on demand to split the absolute time instant into recognisable calendar
fields like 'day-of-week'. It is effectively a pluggable calendar system.
</p>
<p>
The actual calculations of the chronology are split between the
<tt>Chronology</tt> class itself and the field classes -
<tt>DateTimeField</tt> and <tt>DurationField</tt>.
Together, the subclasses of these three classes form the bulk of the code
in the library.
Most users will never need to use or refer directly to the subclasses.
Instead, they will simply obtain the chronology and use it as a singleton, as follows:
</p><div class=""source""><pre>
Chronology coptic = CopticChronology.getInstance(),
</pre></div>

<p>
Internally, all the chronology, field, etc. classes are maintained as singletons.
Thus there is an initial setup cost when using Joda-Time, but after that only
the main API instance classes
(<tt>DateTime</tt>, <tt>Interval</tt>, <tt>Period</tt>, etc.)
have creation and garbage collector costs.
</p>
<p>
Although the Chronology is key to the design, it is not key to using the API !!
</p>
<p>
For most applications, the Chronology can be ignored as it will default to the
ISOChronology. This is suitable for most uses.
You would change it if you need accurate dates before October 15, 1582,
or whenever the Julian calendar ceased in the territory you're interested in).
You'd also change it if you need a specific calendar like the Coptic calendar illustrated earlier.
</p>
</div>","Period","Period","class",0
,"Section7-Chronology","Section7-Chronology","<div class=""section""><h2>Chronology<a name=""Chronology""></a></h2>
<p>
The Joda-Time design is based around the
<i><tt>Chronology</tt></i>. It is a calculation engine that supports the complex
rules for a calendar system. It encapsulates the field objects, which are used
on demand to split the absolute time instant into recognisable calendar
fields like 'day-of-week'. It is effectively a pluggable calendar system.
</p>
<p>
The actual calculations of the chronology are split between the
<tt>Chronology</tt> class itself and the field classes -
<tt>DateTimeField</tt> and <tt>DurationField</tt>.
Together, the subclasses of these three classes form the bulk of the code
in the library.
Most users will never need to use or refer directly to the subclasses.
Instead, they will simply obtain the chronology and use it as a singleton, as follows:
</p><div class=""source""><pre>
Chronology coptic = CopticChronology.getInstance(),
</pre></div>

<p>
Internally, all the chronology, field, etc. classes are maintained as singletons.
Thus there is an initial setup cost when using Joda-Time, but after that only
the main API instance classes
(<tt>DateTime</tt>, <tt>Interval</tt>, <tt>Period</tt>, etc.)
have creation and garbage collector costs.
</p>
<p>
Although the <tt>Chronology</tt> is key to the design, it is not key to using the API !!
</p>
<p>
For most applications, the <tt>Chronology</tt> can be ignored as it will default to the
ISOChronology. This is suitable for most uses.
You would change it if you need accurate dates before October 15, 1582,
or whenever the Julian calendar ceased in the territory you're interested in).
You'd also change it if you need a specific calendar like the Coptic calendar illustrated earlier.
</p>
</div>","Chronology","Chronology	","class",1
,"Section7-Chronology","Section7-Chronology","<div class=""section""><h2>Chronology<a name=""Chronology""></a></h2>
<p>
The Joda-Time design is based around the
<i>Chronology</i>. It is a calculation engine that supports the complex
rules for a calendar system. It encapsulates the field objects, which are used
on demand to split the absolute time instant into recognisable calendar
fields like 'day-of-week'. It is effectively a pluggable calendar system.
</p>
<p>
The actual calculations of the chronology are split between the
<tt>Chronology</tt> class itself and the field classes -
<tt>DateTimeField</tt> and <tt>DurationField</tt>.
Together, the subclasses of these three classes form the bulk of the code
in the library.
Most users will never need to use or refer directly to the subclasses.
Instead, they will simply obtain the chronology and use it as a singleton, as follows:
</p><div class=""source""><pre>
Chronology coptic = CopticChronology.getInstance(),
</pre></div>

<p>
Internally, all the chronology, field, etc. classes are maintained as singletons.
Thus there is an initial setup cost when using Joda-Time, but after that only
the main API instance classes
(<tt>DateTime</tt>, <tt>Interval</tt>, <tt>Period</tt>, etc.)
have creation and garbage collector costs.
</p>
<p>
Although the Chronology is key to the design, it is not key to using the API !!
</p>
<p>
For most applications, the Chronology can be ignored as it will default to the
ISOChronology. This is suitable for most uses.
You would change it if you need accurate dates before October 15, 1582,
or whenever the Julian calendar ceased in the territory you're interested in).
You'd also change it if you need a specific calendar like the Coptic calendar illustrated earlier.
</p>
</div>","DateTimeField","DateTimeField","class",0
,"Section7-Chronology","Section7-Chronology","<div class=""section""><h2>Chronology<a name=""Chronology""></a></h2>
<p>
The Joda-Time design is based around the
<i>Chronology</i>. It is a calculation engine that supports the complex
rules for a calendar system. It encapsulates the field objects, which are used
on demand to split the absolute time instant into recognisable calendar
fields like 'day-of-week'. It is effectively a pluggable calendar system.
</p>
<p>
The actual calculations of the chronology are split between the
<tt>Chronology</tt> class itself and the field classes -
<tt>DateTimeField</tt> and <tt>DurationField</tt>.
Together, the subclasses of these three classes form the bulk of the code
in the library.
Most users will never need to use or refer directly to the subclasses.
Instead, they will simply obtain the chronology and use it as a singleton, as follows:
</p><div class=""source""><pre>
Chronology coptic = CopticChronology.getInstance(),
</pre></div>

<p>
Internally, all the chronology, field, etc. classes are maintained as singletons.
Thus there is an initial setup cost when using Joda-Time, but after that only
the main API instance classes
(<tt>DateTime</tt>, <tt>Interval</tt>, <tt>Period</tt>, etc.)
have creation and garbage collector costs.
</p>
<p>
Although the Chronology is key to the design, it is not key to using the API !!
</p>
<p>
For most applications, the Chronology can be ignored as it will default to the
<tt>ISOChronology</tt>. This is suitable for most uses.
You would change it if you need accurate dates before October 15, 1582,
or whenever the Julian calendar ceased in the territory you're interested in).
You'd also change it if you need a specific calendar like the Coptic calendar illustrated earlier.
</p>
</div>","ISOChronology","ISOChronology	","class",1
,"Section7-Chronology","Section7-Chronology","<div class=""section""><h2>Chronology<a name=""Chronology""></a></h2>
<p>
The Joda-Time design is based around the
<i>Chronology</i>. It is a calculation engine that supports the complex
rules for a calendar system. It encapsulates the field objects, which are used
on demand to split the absolute time instant into recognisable calendar
fields like 'day-of-week'. It is effectively a pluggable calendar system.
</p>
<p>
The actual calculations of the chronology are split between the
<tt>Chronology</tt> class itself and the field classes -
<tt>DateTimeField</tt> and <tt>DurationField</tt>.
Together, the subclasses of these three classes form the bulk of the code
in the library.
Most users will never need to use or refer directly to the subclasses.
Instead, they will simply obtain the chronology and use it as a singleton, as follows:
</p><div class=""source""><pre>
Chronology coptic = CopticChronology.getInstance(),
</pre></div>

<p>
Internally, all the chronology, field, etc. classes are maintained as singletons.
Thus there is an initial setup cost when using Joda-Time, but after that only
the main API instance classes
(<tt>DateTime</tt>, <tt>Interval</tt>, <tt>Period</tt>, etc.)
have creation and garbage collector costs.
</p>
<p>
Although the Chronology is key to the design, it is not key to using the API !!
</p>
<p>
For most applications, the Chronology can be ignored as it will default to the
ISOChronology. This is suitable for most uses.
You would change it if you need accurate dates before October 15, 1582,
or whenever the Julian calendar ceased in the territory you're interested in).
You'd also change it if you need a specific calendar like the Coptic calendar illustrated earlier.
</p>
</div>","DurationField","DurationField","class",0
,"Section9-Interface usage","Section9-Interface usage","<div class=""section""><h2>Interface usage<a name=""Interface_usage""></a></h2>
<p>
As you have seen, Joda-Time defines a number of new interfaces which are visible
throughout the javadocs. The most important is <tt>ReadableInstant</tt> which
currently has 4 implementations.
Other significant interfaces include <tt>ReadableInterval</tt> and
<tt>ReadablePeriod</tt>. These are currently used as generalizations for
a value-only and a mutable class, respectively.
</p>
<p>
An important point to mention here is that the Joda interfaces are used differently
than, for instance, the JDK Collections Framework interfaces.
When working with a Collections interface, such as <tt>List</tt> or <tt>Map</tt>
you will normally hold your variable as a type of <tt>List</tt> or <tt>Map</tt>, 
only referencing the concrete class when you create the object.
</p><div class=""source""><pre>
    List list = new ArrayList(),
    Map map = new HashMap(),
</pre></div>
In Joda-Time, the interfaces exist to allow <i>interoperation</i> between similar
date implementations, such as a mutable and immutable version of a class.
As such, they only offer a subset of the methods of the concrete class.
<i>For most work, you will reference the concrete class, not the interface</i>.
This gives access to the full power of the library.
<div class=""source""><pre>
    DateTime dt = new DateTime(),
</pre></div>

<p>
For maximum flexibility however, you might choose to declare your method
parameters using the Joda-Time interface.
A method on the interface can obtain the concrete class for use within the method.
</p><div class=""source""><pre>
    public void process(ReadableDateTime dateTime) {
        DateTime dt = dateTime.toDateTime(),
    }
</pre></div>

</div>","ReadableInstant","ReadableInstant","class",0
,"Section9-Interface usage","Section9-Interface usage","<div class=""section""><h2>Interface usage<a name=""Interface_usage""></a></h2>
<p>
As you have seen, Joda-Time defines a number of new interfaces which are visible
throughout the javadocs. The most important is <tt>ReadableInstant</tt> which
currently has 4 implementations.
Other significant interfaces include <tt>ReadableInterval</tt> and
<tt>ReadablePeriod</tt>. These are currently used as generalizations for
a value-only and a mutable class, respectively.
</p>
<p>
An important point to mention here is that the Joda interfaces are used differently
than, for instance, the JDK Collections Framework interfaces.
When working with a Collections interface, such as <tt>List</tt> or <tt>Map</tt>
you will normally hold your variable as a type of <tt>List</tt> or <tt>Map</tt>, 
only referencing the concrete class when you create the object.
</p><div class=""source""><pre>
    List list = new ArrayList(),
    Map map = new HashMap(),
</pre></div>
In Joda-Time, the interfaces exist to allow <i>interoperation</i> between similar
date implementations, such as a mutable and immutable version of a class.
As such, they only offer a subset of the methods of the concrete class.
<i>For most work, you will reference the concrete class, not the interface</i>.
This gives access to the full power of the library.
<div class=""source""><pre>
    DateTime dt = new DateTime(),
</pre></div>

<p>
For maximum flexibility however, you might choose to declare your method
parameters using the Joda-Time interface.
A method on the interface can obtain the concrete class for use within the method.
</p><div class=""source""><pre>
    public void process(ReadableDateTime dateTime) {
        DateTime dt = dateTime.toDateTime(),
    }
</pre></div>

</div>","ReadableInterval","ReadableInterval","class",0
,"Section9-Interface usage","Section9-Interface usage","<div class=""section""><h2>Interface usage<a name=""Interface_usage""></a></h2>
<p>
As you have seen, Joda-Time defines a number of new interfaces which are visible
throughout the javadocs. The most important is <tt>ReadableInstant</tt> which
currently has 4 implementations.
Other significant interfaces include <tt>ReadableInterval</tt> and
<tt>ReadablePeriod</tt>. These are currently used as generalizations for
a value-only and a mutable class, respectively.
</p>
<p>
An important point to mention here is that the Joda interfaces are used differently
than, for instance, the JDK Collections Framework interfaces.
When working with a Collections interface, such as <tt>List</tt> or <tt>Map</tt>
you will normally hold your variable as a type of <tt>List</tt> or <tt>Map</tt>, 
only referencing the concrete class when you create the object.
</p><div class=""source""><pre>
    List list = new ArrayList(),
    Map map = new HashMap(),
</pre></div>
In Joda-Time, the interfaces exist to allow <i>interoperation</i> between similar
date implementations, such as a mutable and immutable version of a class.
As such, they only offer a subset of the methods of the concrete class.
<i>For most work, you will reference the concrete class, not the interface</i>.
This gives access to the full power of the library.
<div class=""source""><pre>
    DateTime dt = new DateTime(),
</pre></div>

<p>
For maximum flexibility however, you might choose to declare your method
parameters using the Joda-Time interface.
A method on the interface can obtain the concrete class for use within the method.
</p><div class=""source""><pre>
    public void process(ReadableDateTime dateTime) {
        DateTime dt = dateTime.toDateTime(),
    }
</pre></div>

</div>","ReadablePeriod","ReadablePeriod","class",0
,"Section11-Working with DateTime","SubSection11.1-Construction","<div class=""section""><h3>Construction<a name=""Construction""></a></h3>
<p>
A datetime object is created by using a <tt>DateTime</tt> constructor. The default
constructor is used as follows
</p><div class=""source""><pre>
    DateTime dt = new DateTime(),
</pre></div>
and creates a datetime object representing the current date and time in milliseconds
as determined by the system clock. It is constructed using the ISO
calendar in the default time zone.
<p>
To create a datetime object representing a specific date and time, you may use an
initialization string:
</p><div class=""source""><pre>
    DateTime dt = new DateTime(&quot,2004-12-13T21:39:45.618-08:00&quot,),
</pre></div>
The initialization string must be in a format that is compatible with the ISO8601
standard.

<p>
<tt>DateTime</tt> also provides
<a href=""apidocs/org/joda/time/DateTime.html#constructor_summary"">other
constructors</a> to create a specific date and time using a variety of standard
fields. This also permits the use of any calendar and timezone.
</p>
</div>","DateTime","DateTime	","class",1
,"Section11-Working with DateTime","SubSection11.2-JDK Interoperability","<div class=""section""><h3>JDK Interoperability<a name=""JDK_Interoperability""></a></h3>
<p>
The <tt>DateTime</tt> class has a constructor which takes an <tt>Object</tt>
as input. In particular this constructor can be passed a JDK <tt>Date</tt>,
JDK <tt>Calendar</tt> or JDK <tt>GregorianCalendar</tt> (It also accepts an
ISO8601 formatted String, or <tt>Long</tt> object representing milliseconds). This is one half
of the interoperability with the JDK. The other half of interoperability with JDK
is provided by <tt>DateTime</tt> methods which return JDK objects.
</p>
<p>
Thus inter-conversion between Joda <tt>DateTime</tt> and JDK <tt>Date</tt>
can be performed as follows
</p><div class=""source""><pre>
    // from Joda to JDK
    DateTime dt = new DateTime(),
    Date jdkDate = dt.toDate(),

    // from JDK to Joda
    dt = new DateTime(jdkDate),
</pre></div>

<p>
Similarly, for JDK <tt>Calendar</tt>:
</p><div class=""source""><pre>
    // from Joda to JDK
    DateTime dt = new DateTime(),
    Calendar jdkCal = dt.toCalendar(Locale.CHINESE),

    // from JDK to Joda
    dt = new DateTime(jdkCal),
</pre></div>

<p>
and JDK <tt>GregorianCalendar</tt>:
</p><div class=""source""><pre>
    // from Joda to JDK
    DateTime dt = new DateTime(),
    GregorianCalendar jdkGCal = dt.toGregorianCalendar(),

    // from JDK to Joda
    dt = new DateTime(jdkGCal),
</pre></div>

</div>
</div>","DateTime","DateTime","class",1
,"Section12-Querying DateTimes","Section12-Querying DateTimes","<div class=""section""><h2>Querying DateTimes<a name=""Querying_DateTimes""></a></h2>
<p>
The separation of the calculation of calendar fields (<tt>DateTimeField</tt>)
from the representation of the calendar instant (<tt>DateTime</tt>) makes
for a powerful and flexible API. The connection
between the two is maintained by the property (<tt>DateTime.Property</tt>)
which provides access to the field.
</p>
<p>
For instance, the direct way to get the day of week for a particular
<tt>DateTime</tt>, involves calling the method
</p><div class=""source""><pre>
    int iDoW = dt.getDayOfWeek(),
</pre></div>
where <tt>iDoW</tt> can take the values (from class
<tt>DateTimeConstants</tt>).
<div class=""source""><pre>
    public static final int MONDAY = 1,
    public static final int TUESDAY = 2,
    public static final int WEDNESDAY = 3,
    public static final int THURSDAY = 4,
    public static final int FRIDAY = 5,
    public static final int SATURDAY = 6,
    public static final int SUNDAY = 7,
</pre></div>","DateTime","DateTime","class",0
,"Section12-Querying DateTimes","Section12-Querying DateTimes","<div class=""section""><h2>Querying DateTimes<a name=""Querying_DateTimes""></a></h2>
<p>
The separation of the calculation of calendar fields (<tt>DateTimeField</tt>)
from the representation of the calendar instant (<tt>DateTime</tt>) makes
for a powerful and flexible API. The connection
between the two is maintained by the property (<tt>DateTime.Property</tt>)
which provides access to the field.
</p>
<p>
For instance, the direct way to get the day of week for a particular
<tt>DateTime</tt>, involves calling the method
</p><div class=""source""><pre>
    int iDoW = dt.getDayOfWeek(),
</pre></div>
where <tt>iDoW</tt> can take the values (from class
<tt>DateTimeConstants</tt>).
<div class=""source""><pre>
    public static final int MONDAY = 1,
    public static final int TUESDAY = 2,
    public static final int WEDNESDAY = 3,
    public static final int THURSDAY = 4,
    public static final int FRIDAY = 5,
    public static final int SATURDAY = 6,
    public static final int SUNDAY = 7,
</pre></div>","DateTime.Property","DateTime.Property","class",0
,"Section12-Querying DateTimes","Section12-Querying DateTimes","<div class=""section""><h2>Querying DateTimes<a name=""Querying_DateTimes""></a></h2>
<p>
The separation of the calculation of calendar fields (<tt>DateTimeField</tt>)
from the representation of the calendar instant (<tt>DateTime</tt>) makes
for a powerful and flexible API. The connection
between the two is maintained by the property (<tt>DateTime.Property</tt>)
which provides access to the field.
</p>
<p>
For instance, the direct way to get the day of week for a particular
<tt>DateTime</tt>, involves calling the method
</p><div class=""source""><pre>
    int iDoW = dt.getDayOfWeek(),
</pre></div>
where <tt>iDoW</tt> can take the values (from class
<tt>DateTimeConstants</tt>).
<div class=""source""><pre>
    public static final int MONDAY = 1,
    public static final int TUESDAY = 2,
    public static final int WEDNESDAY = 3,
    public static final int THURSDAY = 4,
    public static final int FRIDAY = 5,
    public static final int SATURDAY = 6,
    public static final int SUNDAY = 7,
</pre></div>","DateTimeField","DateTimeField","class",0
,"Section12-Querying DateTimes","Section12-Querying DateTimes","<div class=""section""><h2>Querying DateTimes<a name=""Querying_DateTimes""></a></h2>
<p>
The separation of the calculation of calendar fields (<tt>DateTimeField</tt>)
from the representation of the calendar instant (<tt>DateTime</tt>) makes
for a powerful and flexible API. The connection
between the two is maintained by the property (<tt>DateTime.Property</tt>)
which provides access to the field.
</p>
<p>
For instance, the direct way to get the day of week for a particular
<tt>DateTime</tt>, involves calling the method
</p><div class=""source""><pre>
    int iDoW = dt.getDayOfWeek(),
</pre></div>
where <tt>iDoW</tt> can take the values (from class
<tt>DateTimeConstants</tt>).
<div class=""source""><pre>
    public static final int MONDAY = 1,
    public static final int TUESDAY = 2,
    public static final int WEDNESDAY = 3,
    public static final int THURSDAY = 4,
    public static final int FRIDAY = 5,
    public static final int SATURDAY = 6,
    public static final int SUNDAY = 7,
</pre></div>","DateTimeConstants","DateTimeConstants","class",0
,"Section12-Querying DateTimes","SubSection12.1-Accessing fields","<div class=""section""><h3>Accessing fields<a name=""Accessing_fields""></a></h3>
<p>The direct methods are fine for simple usage, but more flexibility can be achieved via the
property/field mechanism. The day of week property is obtained by
</p><div class=""source""><pre>
    DateTime.Property pDoW = dt.dayOfWeek(),
</pre></div>
which can be used to get richer information about the field, such as
<div class=""source""><pre>
    String strST = pDoW.getAsShortText(), // returns &quot,Mon&quot,, &quot,Tue&quot,, etc.
    String strT = pDoW.getAsText(), // returns &quot,Monday&quot,, &quot,Tuesday&quot,, etc.
</pre></div>
which return short and long name strings (based on the current locale)
of the day-of-week. Localized versions of these methods are also available, thus
<div class=""source""><pre>
    String strTF = pDoW.getAsText(Locale.FRENCH), // returns &quot,Lundi&quot,, etc.
</pre></div>
can be used to return the day-of-week name string in French.

<p>
Of course, the original integer value of the field is still accessible as
</p><div class=""source""><pre>
    iDoW = pDoW.get(),
</pre></div>
The property also provides access to other values associated with the field
such as metadata on the minimum and maximum text size, leap status, related 
durations, etc. For a complete reference, see the
<a href=""apidocs/org/joda/time/field/AbstractReadableInstantFieldProperty.html"">documentation</a>
for the base class <tt>AbstractReadableInstantFieldProperty</tt>

<p>
In practice, one would not actually create the intermediate <tt>pDoW</tt>
variable. The code is easier to read if the methods are called on anonymous
intermediate objects. Thus, for example,
</p><div class=""source""><pre>
    strT = dt.dayOfWeek().getAsText(),
    iDoW = dt.dayOfWeek().get(),
</pre></div>
would be written instead of the more indirect code presented earlier.

<p>
Note: For the single case of getting the numerical value of a field, we recommend
using the get method on the main <tt>DateTime</tt> object as it is more efficient.
</p><div class=""source""><pre>
    iDoW = dt.getDayOfWeek(),
</pre></div>","AbstractReadableInstantFieldProperty","AbstractReadableInstantFieldProperty","class",0
,"Section12-Querying DateTimes","SubSection12.2-Date fields","<div class=""section""><h3>Date fields<a name=""Date_fields""></a></h3>
<p>
The <tt>DateTime</tt> implementation provides a complete list of standard
calendar fields:
</p><div class=""source""><pre>
    dt.getEra(),
    dt.getYear(),
    dt.getWeekyear(),
    dt.getCenturyOfEra(),
    dt.getYearOfEra(),
    dt.getYearOfCentury(),
    dt.getMonthOfYear(),
    dt.getWeekOfWeekyear(),
    dt.getDayOfYear(),
    dt.getDayOfMonth(),
    dt.getDayOfWeek(),
</pre></div>
Each of these also has a corresponding property method, which returns a
<tt>DateTime.Property</tt> binding to the appropriate field, such as
<tt>year()</tt> or <tt>monthOfYear()</tt>.
The fields represented by these properties behave pretty much as their
names would suggest. The precise definitions are available in the
<a href=""field.html"">field reference</a>.

<p>
As you would expect, all the methods we showed above in the day-of-week example
can be applied to any of these properties. For example, to extract the standard
month, day and year fields from a datetime, we can write
</p><div class=""source""><pre>
    String month = dt.monthOfYear().getAsText(),
    int maxDay = dt.dayOfMonth().getMaximumValue(),
    boolean leapYear = dt.yearOfEra().isLeap(),
</pre></div>

</div>","DateTime","DateTime","class",0
,"Section12-Querying DateTimes","SubSection12.2-Date fields","<div class=""section""><h3>Date fields<a name=""Date_fields""></a></h3>
<p>
The <tt>DateTime</tt> implementation provides a complete list of standard
calendar fields:
</p><div class=""source""><pre>
    dt.getEra(),
    dt.getYear(),
    dt.getWeekyear(),
    dt.getCenturyOfEra(),
    dt.getYearOfEra(),
    dt.getYearOfCentury(),
    dt.getMonthOfYear(),
    dt.getWeekOfWeekyear(),
    dt.getDayOfYear(),
    dt.getDayOfMonth(),
    dt.getDayOfWeek(),
</pre></div>
Each of these also has a corresponding property method, which returns a
<tt>DateTime.Property</tt> binding to the appropriate field, such as
<tt>year()</tt> or <tt>monthOfYear()</tt>.
The fields represented by these properties behave pretty much as their
names would suggest. The precise definitions are available in the
<a href=""field.html"">field reference</a>.

<p>
As you would expect, all the methods we showed above in the day-of-week example
can be applied to any of these properties. For example, to extract the standard
month, day and year fields from a datetime, we can write
</p><div class=""source""><pre>
    String month = dt.monthOfYear().getAsText(),
    int maxDay = dt.dayOfMonth().getMaximumValue(),
    boolean leapYear = dt.yearOfEra().isLeap(),
</pre></div>

</div>","DateTime.Property","DateTime.Property","class",0
,"Section12-Querying DateTimes","SubSection12.2-Date fields","<div class=""section""><h3>Date fields<a name=""Date_fields""></a></h3>
<p>
The <tt>DateTime</tt> implementation provides a complete list of standard
calendar fields:
</p><div class=""source""><pre>
    dt.getEra(),
    dt.getYear(),
    dt.getWeekyear(),
    dt.getCenturyOfEra(),
    dt.getYearOfEra(),
    dt.getYearOfCentury(),
    dt.getMonthOfYear(),
    dt.getWeekOfWeekyear(),
    dt.getDayOfYear(),
    dt.getDayOfMonth(),
    dt.getDayOfWeek(),
</pre></div>
Each of these also has a corresponding property method, which returns a
<tt>DateTime.Property</tt> binding to the appropriate field, such as
<tt>year()</tt> or <tt>monthOfYear()</tt>.
The fields represented by these properties behave pretty much as their
names would suggest. The precise definitions are available in the
<a href=""field.html"">field reference</a>.

<p>
As you would expect, all the methods we showed above in the day-of-week example
can be applied to any of these properties. For example, to extract the standard
month, day and year fields from a datetime, we can write
</p><div class=""source""><pre>
    String month = dt.monthOfYear().getAsText(),
    int maxDay = dt.dayOfMonth().getMaximumValue(),
    boolean leapYear = dt.yearOfEra().isLeap(),
</pre></div>

</div>","year()","DateTime.year()","class",0
,"Section12-Querying DateTimes","SubSection12.2-Date fields","<div class=""section""><h3>Date fields<a name=""Date_fields""></a></h3>
<p>
The <tt>DateTime</tt> implementation provides a complete list of standard
calendar fields:
</p><div class=""source""><pre>
    dt.getEra(),
    dt.getYear(),
    dt.getWeekyear(),
    dt.getCenturyOfEra(),
    dt.getYearOfEra(),
    dt.getYearOfCentury(),
    dt.getMonthOfYear(),
    dt.getWeekOfWeekyear(),
    dt.getDayOfYear(),
    dt.getDayOfMonth(),
    dt.getDayOfWeek(),
</pre></div>
Each of these also has a corresponding property method, which returns a
<tt>DateTime.Property</tt> binding to the appropriate field, such as
<tt>year()</tt> or <tt>monthOfYear()</tt>.
The fields represented by these properties behave pretty much as their
names would suggest. The precise definitions are available in the
<a href=""field.html"">field reference</a>.

<p>
As you would expect, all the methods we showed above in the day-of-week example
can be applied to any of these properties. For example, to extract the standard
month, day and year fields from a datetime, we can write
</p><div class=""source""><pre>
    String month = dt.monthOfYear().getAsText(),
    int maxDay = dt.dayOfMonth().getMaximumValue(),
    boolean leapYear = dt.yearOfEra().isLeap(),
</pre></div>

</div>","monthOfYear()","DateTime.monthOfYear()","class",0
,"Section12-Querying DateTimes","SubSection12.3-Time fields","<div class=""section""><h3>Time fields<a name=""Time_fields""></a></h3>
<p>
Another set of properties access fields representing intra-day durations for
time calculations. Thus to compute the hours, minutes and seconds of the instant
represented by a <tt>DateTime</tt>, we would write
</p><div class=""source""><pre>
    int hour = dt.getHourOfDay(),
    int min = dt.getMinuteOfHour(),
    int sec = dt.getSecondOfMinute(),
</pre></div>
Again each of these has a corresponding property method for more complex manipulation.
The complete list of time fields can be found in the 
<a href=""field.html"">field reference</a>.

</div>","DateTime","DateTime","class",1
,"Section13-Manipulating DateTimes","Section13-Manipulating DateTimes","<div class=""section""><h2>Manipulating DateTimes<a name=""Manipulating_DateTimes""></a></h2>
<p>
<tt>DateTime</tt> objects have value semantics, and cannot be modified after
construction (they are immutable).
Therefore, most simple manipulation of a datetime object involves
construction of a new datetime as a modified copy of the original.
</p>
<p>
WARNING: <i>A common mistake to make with immutable classes is to forget to assign
the result to a variable. Remember that calling an add or set method on an
immtable object has no effect on that object - only the result is updated.</i>
</p></div>","DateTime","DateTime","class",1
,"Section13-Manipulating DateTimes","SubSection13.1-Modifying fields","<div class=""section""><h3>Modifying fields<a name=""Modifying_fields""></a></h3>
<p>
One way to do this is to use methods on properties. To
return to our prior example, if we wish to modify the <tt>dt</tt> object
by changing its day-of-week field to Monday we can do so by using the
<tt>setCopy</tt> method of the property:
</p><div class=""source""><pre>
    DateTime result = dt.dayOfWeek().setCopy(DateTimeConstants.MONDAY),
</pre></div>
Note: If the <tt>DateTime</tt> object is already set to Monday then the same
object will be returned.

<p>
To add to a date you could use the <tt>addToCopy</tt> method.
</p><div class=""source""><pre>
    DateTime result = dt.dayOfWeek().addToCopy(3),
</pre></div>

</div>","DateTime","DateTime","class",1
,"Section13-Manipulating DateTimes","SubSection13.1-Modifying fields","<div class=""section""><h3>Modifying fields<a name=""Modifying_fields""></a></h3>
<p>
One way to do this is to use methods on properties. To
return to our prior example, if we wish to modify the <tt>dt</tt> object
by changing its day-of-week field to Monday we can do so by using the
<tt>setCopy</tt> method of the property:
</p><div class=""source""><pre>
    DateTime result = dt.dayOfWeek().setCopy(DateTimeConstants.MONDAY),
</pre></div>
Note: If the <tt>DateTime</tt> object is already set to Monday then the same
object will be returned.

<p>
To add to a date you could use the <tt>addToCopy</tt> method.
</p><div class=""source""><pre>
    DateTime result = dt.dayOfWeek().addToCopy(3),
</pre></div>

</div>","setCopy","DateTime.Property.setCopy","class",1
,"Section13-Manipulating DateTimes","SubSection13.1-Modifying fields","<div class=""section""><h3>Modifying fields<a name=""Modifying_fields""></a></h3>
<p>
One way to do this is to use methods on properties. To
return to our prior example, if we wish to modify the <tt>dt</tt> object
by changing its day-of-week field to Monday we can do so by using the
<tt>setCopy</tt> method of the property:
</p><div class=""source""><pre>
    DateTime result = dt.dayOfWeek().setCopy(DateTimeConstants.MONDAY),
</pre></div>
Note: If the <tt>DateTime</tt> object is already set to Monday then the same
object will be returned.

<p>
To add to a date you could use the <tt>addToCopy</tt> method.
</p><div class=""source""><pre>
    DateTime result = dt.dayOfWeek().addToCopy(3),
</pre></div>

</div>","addToCopy","DateTime.Property.addToCopy","class",1
,"Section13-Manipulating DateTimes","SubSection13.2-DateTime methods","<div class=""section""><h3>DateTime methods<a name=""DateTime_methods""></a></h3>
<p>
Another means of accomplishing similar calculations is to use methods on the
<tt>DateTime</tt> object itself. Thus we could add 3 days to <tt>dt</tt>
directly as follows:
</p><div class=""source""><pre>
    DateTime result = dt.plusDays(3),
</pre></div>

</div>","DateTime","DateTime","class",0
,"Section13-Manipulating DateTimes","SubSection13.3-Using a MutableDateTime","<div class=""section""><h3>Using a MutableDateTime<a name=""Using_a_MutableDateTime""></a></h3>
<p>
The methods outlined above are suitable for simple calculations involving one
or two fields. In situations where multiple fields need to be modified, it is
more efficient to create a mutable copy of the datetime, modify the copy and
finally create a new value datetime.
</p><div class=""source""><pre>
    MutableDateTime mdt = dt.toMutableDateTime(),
    // perform various calculations on mdt
    ...
    DateTime result = mdt.toDateTime(),
</pre></div>
<tt>MutableDateTime</tt> has a number of methods, including standard setters,
for directly modifying the datetime.

</div>","MutableDateTime","MutableDateTime","class",1
,"Section14-Changing TimeZone","Section14-Changing TimeZone","<div class=""section""><h2>Changing TimeZone<a name=""Changing_TimeZone""></a></h2>
<p>
<tt>DateTime</tt> comes with support for a couple of common timezone
calculations. For instance, if you want to get the local time in London at this
very moment, you would do the following
</p><div class=""source""><pre>
    // get current moment in default time zone
    DateTime dt = new DateTime(),
    // translate to London local time
    DateTime dtLondon = dt.withZone(DateTimeZone.forID(&quot,Europe/London&quot,)),
</pre></div>
where <tt>DateTimeZone.forID(&quot,Europe/London&quot,)</tt> returns the timezone
value for London. The resulting value <tt>dtLondon</tt> has the same absolute
millisecond time, but a different set of field values.

<p>
There is also support for the reverse operation, i.e. to get the datetime (absolute
millisecond) corresponding to the moment when London has the same local time as
exists in the default time zone <i>now</i>. This is done as follows
</p><div class=""source""><pre>
    // get current moment in default time zone
    DateTime dt = new DateTime(),
    // find the moment when London will have / had the same time
    dtLondonSameTime = dt.withZoneRetainFields(DateTimeZone.forID(&quot,Europe/London&quot,)),
</pre></div>

<p>
A set of all TimeZone ID strings (such as &quot,Europe/London&quot,) may be obtained by
calling <tt>DateTimeZone.getAvailableIDs()</tt>. A full list of available
time zones is provided <a href=""timezones.html"">here</a>.
</p>
</div>","DateTime","DateTime","class",1
,"Section14-Changing TimeZone","Section14-Changing TimeZone","<div class=""section""><h2>Changing TimeZone<a name=""Changing_TimeZone""></a></h2>
<p>
<tt>DateTime</tt> comes with support for a couple of common timezone
calculations. For instance, if you want to get the local time in London at this
very moment, you would do the following
</p><div class=""source""><pre>
    // get current moment in default time zone
    DateTime dt = new DateTime(),
    // translate to London local time
    DateTime dtLondon = dt.withZone(DateTimeZone.forID(&quot,Europe/London&quot,)),
</pre></div>
where <tt>DateTimeZone.forID(&quot,Europe/London&quot,)</tt> returns the timezone
value for London. The resulting value <tt>dtLondon</tt> has the same absolute
millisecond time, but a different set of field values.

<p>
There is also support for the reverse operation, i.e. to get the datetime (absolute
millisecond) corresponding to the moment when London has the same local time as
exists in the default time zone <i>now</i>. This is done as follows
</p><div class=""source""><pre>
    // get current moment in default time zone
    DateTime dt = new DateTime(),
    // find the moment when London will have / had the same time
    dtLondonSameTime = dt.withZoneRetainFields(DateTimeZone.forID(&quot,Europe/London&quot,)),
</pre></div>

<p>
A set of all TimeZone ID strings (such as &quot,Europe/London&quot,) may be obtained by
calling <tt>DateTimeZone.getAvailableIDs()</tt>. A full list of available
time zones is provided <a href=""timezones.html"">here</a>.
</p>
</div>","DateTimeZone.getAvailableIDs()","DateTimeZone.getAvailableIDs()","class",1
,"Section15-Changing Chronology","Section15-Changing Chronology","<div class=""section""><h2>Changing <tt>Chronology</tt><a name=""Changing_Chronology""></a></h2>
<p>
The <tt>DateTime</tt> class also has one method for changing calendars. This
allows you to change the calendar for a given moment in time. Thus if you want to
get the datetime for the current time, but in the Buddhist Calendar, you would do
</p><div class=""source""><pre>
    // get current moment in default time zone
    DateTime dt = new DateTime(),
    dt.getYear(),  // returns 2004
    // change to Buddhist chronology
    DateTime dtBuddhist = dt.withChronology(BuddhistChronology.getInstance()),
    dtBuddhist.getYear(),  // returns 2547
</pre></div>
where <tt>BuddhistChronology.getInstance()</tt> is a factory method for obtaining a
Buddhist chronology.

</div>","Chronology","Chronology","class",0
,"Section15-Changing Chronology","Section15-Changing Chronology","<div class=""section""><h2>Changing <tt>Chronology</tt><a name=""Changing_Chronology""></a></h2>
<p>
The <tt>DateTime</tt> class also has one method for changing calendars. This
allows you to change the calendar for a given moment in time. Thus if you want to
get the datetime for the current time, but in the Buddhist Calendar, you would do
</p><div class=""source""><pre>
    // get current moment in default time zone
    DateTime dt = new DateTime(),
    dt.getYear(),  // returns 2004
    // change to Buddhist chronology
    DateTime dtBuddhist = dt.withChronology(BuddhistChronology.getInstance()),
    dtBuddhist.getYear(),  // returns 2547
</pre></div>
where <tt>BuddhistChronology.getInstance()</tt> is a factory method for obtaining a
Buddhist chronology.

</div>","DateTime","DateTime","class",1
,"Section15-Changing Chronology","Section15-Changing Chronology","<div class=""section""><h2>Changing <tt>Chronology</tt><a name=""Changing_Chronology""></a></h2>
<p>
The <tt>DateTime</tt> class also has one method for changing calendars. This
allows you to change the calendar for a given moment in time. Thus if you want to
get the datetime for the current time, but in the Buddhist Calendar, you would do
</p><div class=""source""><pre>
    // get current moment in default time zone
    DateTime dt = new DateTime(),
    dt.getYear(),  // returns 2004
    // change to Buddhist chronology
    DateTime dtBuddhist = dt.withChronology(BuddhistChronology.getInstance()),
    dtBuddhist.getYear(),  // returns 2547
</pre></div>
where <tt>BuddhistChronology.getInstance()</tt> is a factory method for obtaining a
Buddhist chronology.

</div>","BuddhistChronology.getInstance()","BuddhistChronology.getInstance()","class",1
,"Section16-Input and Output","SubSection16.1-Formatters","<div class=""section""><h3>Formatters<a name=""Formatters""></a></h3>
<p>
All printing and parsing is performed using a <tt>DateTimeFormatter</tt> object.
Given such an object <tt>fmt</tt>, parsing is performed as follows
</p><div class=""source""><pre>
    String strInputDateTime,
    // string is populated with a date time string in some fashion
    ...
    DateTime dt = fmt.parseDateTime(strInputDateTime),
</pre></div>
Thus a <tt>DateTime</tt> object is returned from the parse method of the
formatter. Similarly, output is performed as
<div class=""source""><pre>
    String strOutputDateTime = fmt.print(dt),
</pre></div>

</div>","DateTime","DateTime","class",0
,"Section16-Input and Output","SubSection16.2-Standard Formatters","<div class=""section""><h3>Standard Formatters<a name=""Standard_Formatters""></a></h3>
<p>
Support for standard formats based on ISO8601 is provided by the
<tt>ISODateTimeFormat</tt> class. This provides a number of factory methods.
</p>
<p>
For example, if you wanted to use the ISO standard format for <i>datetime</i>,
which is <tt>yyyy-MM-dd'T'HH:mm:ss.SSSZZ</tt>, you would initialize
<tt>fmt</tt> as
</p><div class=""source""><pre>
    DateTimeFormatter fmt = ISODateTimeFormat.dateTime(),
</pre></div>
You would then use <tt>fmt</tt> as described above, to read or write datetime
objects in this format.

</div>","ISODateTimeFormat","ISODateTimeFormat","class",1
,"Section16-Input and Output","SubSection16.3-Custom Formatters","<div class=""section""><h3>Custom Formatters<a name=""Custom_Formatters""></a></h3>
<p>
If you need a custom formatter which can be described in terms of
a format pattern, you can use the factory method provided by the
<tt>DateTimeFormat</tt> class. Thus to get a formatter for a 4 digit year,
2 digit month and 2 digit day of month, i.e. a format of <tt>yyyyMMdd</tt>
you would do
</p><div class=""source""><pre>
    DateTimeFormatter fmt = DateTimeFormat.forPattern(&quot,yyyyMMdd&quot,),
</pre></div>
The pattern string is compatible with JDK date patterns.

<p>
You may need to print or parse in a particular <tt>Locale</tt>.
This is achieved by calling the <tt>withLocale</tt> method on a formatter,
which returns another formatter based on the original.
</p><div class=""source""><pre>
    DateTimeFormatter fmt = DateTimeFormat.forPattern(&quot,yyyyMMdd&quot,),
    DateTimeFormatter frenchFmt = fmt.withLocale(Locale.FRENCH),
    DateTimeFormatter germanFmt = fmt.withLocale(Locale.GERMAN),
</pre></div>
Formatters are immutable, so the original is not altered by the
<tt>withLocale</tt> method.

</div>","withLocale","DateTimeFormat.withLocale","class",1
,"Section16-Input and Output","SubSection16.3-Custom Formatters","<div class=""section""><h3>Custom Formatters<a name=""Custom_Formatters""></a></h3>
<p>
If you need a custom formatter which can be described in terms of
a format pattern, you can use the factory method provided by the
<tt>DateTimeFormat</tt> class. Thus to get a formatter for a 4 digit year,
2 digit month and 2 digit day of month, i.e. a format of <tt>yyyyMMdd</tt>
you would do
</p><div class=""source""><pre>
    DateTimeFormatter fmt = DateTimeFormat.forPattern(&quot,yyyyMMdd&quot,),
</pre></div>
The pattern string is compatible with JDK date patterns.

<p>
You may need to print or parse in a particular <tt>Locale</tt>.
This is achieved by calling the <tt>withLocale</tt> method on a formatter,
which returns another formatter based on the original.
</p><div class=""source""><pre>
    DateTimeFormatter fmt = DateTimeFormat.forPattern(&quot,yyyyMMdd&quot,),
    DateTimeFormatter frenchFmt = fmt.withLocale(Locale.FRENCH),
    DateTimeFormatter germanFmt = fmt.withLocale(Locale.GERMAN),
</pre></div>
Formatters are immutable, so the original is not altered by the
<tt>withLocale</tt> method.

</div>","DateTimeFormat","DateTimeFormat","class",1
,"Section16-Input and Output","SubSection16.4-Freaky Formatters","<div class=""section""><h3>Freaky Formatters<a name=""Freaky_Formatters""></a></h3>
<p>
Finally, if you have a format that is not easily represented by a pattern string,
Joda Time architecture exposes a builder class that can be used to build a custom
formatter which is programatically defined. Thus if you wanted a formatter to
print and parse dates of the form &quot,22-Jan-65&quot,, you could do the following:
</p><div class=""source""><pre>
    DateTimeFormatter fmt = new DateTimeFormatterBuilder()
            .appendDayOfMonth(2)
            .appendLiteral('-')
            .appendMonthOfYearShortText()
            .appendLiteral('-')
            .appendTwoDigitYear(1956)  // pivot = 1956
            .toFormatter(),
</pre></div>
Each append method appends a new field to be parsed/printed to the
calling builder and returns a new builder. The final <tt>toFormatter</tt> method
creates the actual formatter that will be used to print/parse.

<p>
What is particularly interesting about this format is the two digit year. Since
the interpretation of a two digit year is ambiguous, the
<tt>appendTwoDigitYear</tt> takes an extra parameter that defines the 100 year
range of the two digits, by specifying the mid point of the range. In this example
the range will be (1956 - 50) = 1906, to (1956 + 49) = 2005. Thus 04 will be 2004
but 07 will be 1907. This kind of conversion is not possible with ordinary format
strings, highlighting the power of the Joda time formatting architecture.
</p>
</div>","toFormatter","DateTimeFormatterBuilder.toFormatter","class",1
,"Section16-Input and Output","SubSection16.4-Freaky Formatters","<div class=""section""><h3>Freaky Formatters<a name=""Freaky_Formatters""></a></h3>
<p>
Finally, if you have a format that is not easily represented by a pattern string,
Joda Time architecture exposes a builder class that can be used to build a custom
formatter which is programatically defined. Thus if you wanted a formatter to
print and parse dates of the form &quot,22-Jan-65&quot,, you could do the following:
</p><div class=""source""><pre>
    DateTimeFormatter fmt = new DateTimeFormatterBuilder()
            .appendDayOfMonth(2)
            .appendLiteral('-')
            .appendMonthOfYearShortText()
            .appendLiteral('-')
            .appendTwoDigitYear(1956)  // pivot = 1956
            .toFormatter(),
</pre></div>
Each append method appends a new field to be parsed/printed to the
calling builder and returns a new builder. The final <tt>toFormatter</tt> method
creates the actual formatter that will be used to print/parse.

<p>
What is particularly interesting about this format is the two digit year. Since
the interpretation of a two digit year is ambiguous, the
<tt>appendTwoDigitYear</tt> takes an extra parameter that defines the 100 year
range of the two digits, by specifying the mid point of the range. In this example
the range will be (1956 - 50) = 1906, to (1956 + 49) = 2005. Thus 04 will be 2004
but 07 will be 1907. This kind of conversion is not possible with ordinary format
strings, highlighting the power of the Joda time formatting architecture.
</p>
</div>","appendTwoDigitYear","DateTimeFormatterBuilder.appendTwoDigitYear","class",1
,"Section16-Input and Output","SubSection16.5-Direct access","<div class=""section""><h3>Direct access<a name=""Direct_access""></a></h3>
<p>
To simplify the access to the formatter architecture, methods have been
provided on the datetime classes such as <tt>DateTime</tt>.
</p><div class=""source""><pre>
    DateTime dt = new DateTime(),
    String a = dt.toString(),
    String b = dt.toString(&quot,dd:MM:yy&quot,),
    String c = dt.toString(&quot,EEE&quot,, Locale.FRENCH),
    DateTimeFormatter fmt = ...,
    String d = dt.toString(fmt),
</pre></div>
Each of the four results demonstrates a different way to use the formatters.
Result <tt>a</tt> is the standard ISO8601 string for the DateTime.
Result <tt>b</tt> will output using the pattern 'dd:MM:yy' (note that
patterns are cached internally).
Result <tt>c</tt> will output using the pattern 'EEE' in French.
Result <tt>d</tt> will output using the specified formatter, and is thus
the same as <tt>fmt.print(dt)</tt>.

</div>","DateTime","DateTime","class",0
,"Section17-Advanced features","SubSection17.1-Change the Current Time","<div class=""section""><h3>Change the Current Time<a name=""Change_the_Current_Time""></a></h3>
<p>
Joda-Time allows you to change the current time.
All methods that get the current time are indirected via <tt>DateTimeUtils</tt>.
This allows the current time to be changed, which can be very useful for testing.
</p><div class=""source""><pre>
    // always return the same time when querying current time
    DateTimeUtils.setCurrentMillisFixed(millis),
    // offset the real time
    DateTimeUtils.setCurrentMillisOffset(millis),
</pre></div>
Note that changing the current time this way does not affect the system clock.

</div>","DateTimeUtils","DateTimeUtils","class",1
,"Section17-Advanced features","Section17.2-Converters","<div class=""section""><h3>Converters<a name=""Converters""></a></h3>
<p>
The constructors on each major concrete class in the API take an <tt>Object</tt>
as a parameter.
This is passed to the converter subsystem which is responsible for converting
the object to one acceptable to Joda-Time.
For example, the converters can convert a JDK <tt>Date</tt> object to a <tt>DateTime</tt>.
If required, you can add your own converters to those supplied in Joda-Time.
</p>
</div>","DateTime","DateTime","class",0
,"Section17-Advanced features","Section17.3-Security","<div class=""section""><h3>Security<a name=""Security""></a></h3>
<p>
Joda-Time includes hooks into the standard JDK security scheme for sensitive changes.
These include changing the time zone handler, changing the current time and changing
the converters.
See <tt>JodaTimePermission</tt> for details.
</p>
</div>","JodaTimePermission","JodaTimePermission","class",1
