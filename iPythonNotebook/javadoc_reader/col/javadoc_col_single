java.util.Collections: java.util.Collections:  This class consists exclusively of static methods that operate on or return collections. It contains polymorphic algorithms that operate on collections, "wrappers", which return a new collection backed by a specified collection, and a few other odds and ends. The methods of this class all throw a NullPointerException if the collections or class objects provided to them are null. The documentation for the polymorphic algorithms contained in this class generally includes a brief description of the implementation. Such descriptions should be regarded as implementation notes, rather than parts of the specification. Implementors should feel free to substitute other algorithms, so long as the specification itself is adhered to. (For example, the algorithm used by sort does not have to be a mergesort, but it does have to be stable.) The "destructive" algorithms contained in this class, that is, the algorithms that modify the collection on which they operate, are specified to throw UnsupportedOperationException if the collection does not support the appropriate mutation primitive(s), such as the set method. These algorithms may, but are not required to, throw this exception if an invocation would have no effect on the collection. For example, invoking the sort method on an unmodifiable list that is already sorted may or may not throw UnsupportedOperationException. This class is a member of the  Java Collections Framework.
java.util.Collections: java.util.Collections.CheckedList.replaceAll	(	UnaryOperator	):  Replaces each element of this list with the result of applying the operator to that element. Errors or runtime exceptions thrown by the operator are relayed to the caller.
java.util.Collections: java.util.Collections.CheckedMap.CheckedEntrySet:  We need this class in addition to CheckedSet as Map.Entry permits modification of the backing Map via the setValue operation. This class is subtle: there are many possible attacks that must be thwarted.
java.util.Collections: java.util.Collections.CheckedMap.CheckedEntrySet.CheckedEntry:  This "wrapper class" serves two purposes: it prevents the client from modifying the backing Map, by short-circuiting the setValue method, and it protects the backing Map against an ill-behaved Map.Entry that attempts to modify another Map.Entry when asked to perform an equality check.
java.util.Collections: java.util.Collections.CheckedMap.CheckedEntrySet.contains	(	Object	):  This method is overridden to protect the backing set against an object with a nefarious equals function that senses that the equality-candidate is Map.Entry and calls its setValue method.
java.util.Collections: java.util.Collections.CheckedMap.CheckedEntrySet.containsAll	(	Collection	):  The bulk collection methods are overridden to protect against an unscrupulous collection whose contains(Object o) method senses when o is a Map.Entry, and calls o.setValue.
java.util.Collections: java.util.Collections.SynchronizedList.readResolve	(	):  SynchronizedRandomAccessList instances are serialized as SynchronizedList instances to allow them to be deserialized in pre-1.4 JREs (which do not have SynchronizedRandomAccessList). This method inverts the transformation. As a beneficial side-effect, it also grafts the RandomAccess marker onto SynchronizedList instances that were serialized in pre-1.4 JREs. Note: Unfortunately, SynchronizedRandomAccessList instances serialized in 1.4.1 and deserialized in 1.4 will become SynchronizedList instances, as this method was missing in 1.4.
java.util.Collections: java.util.Collections.SynchronizedNavigableMap:  A synchronized NavigableMap.
java.util.Collections: java.util.Collections.SynchronizedRandomAccessList.writeReplace	(	):  Allows instances to be deserialized in pre-1.4 JREs (which do not have SynchronizedRandomAccessList). SynchronizedList has a readResolve method that inverts this transformation upon deserialization.
java.util.Collections: java.util.Collections.UnmodifiableList.readResolve	(	):  UnmodifiableRandomAccessList instances are serialized as UnmodifiableList instances to allow them to be deserialized in pre-1.4 JREs (which do not have UnmodifiableRandomAccessList). This method inverts the transformation. As a beneficial side-effect, it also grafts the RandomAccess marker onto UnmodifiableList instances that were serialized in pre-1.4 JREs. Note: Unfortunately, UnmodifiableRandomAccessList instances serialized in 1.4.1 and deserialized in 1.4 will become UnmodifiableList instances, as this method was missing in 1.4.
java.util.Collections: java.util.Collections.UnmodifiableMap.UnmodifiableEntrySet:  We need this class in addition to UnmodifiableSet as Map.Entries themselves permit modification of the backing Map via their setValue operation. This class is subtle: there are many possible attacks that must be thwarted.
java.util.Collections: java.util.Collections.UnmodifiableMap.UnmodifiableEntrySet.UnmodifiableEntry:  This "wrapper class" serves two purposes: it prevents the client from modifying the backing Map, by short-circuiting the setValue method, and it protects the backing Map against an ill-behaved Map.Entry that attempts to modify another Map Entry when asked to perform an equality check.
java.util.Collections: java.util.Collections.UnmodifiableMap.UnmodifiableEntrySet.contains	(	Object	):  This method is overridden to protect the backing set against an object with a nefarious equals function that senses that the equality-candidate is Map.Entry and calls its setValue method.
java.util.Collections: java.util.Collections.UnmodifiableMap.UnmodifiableEntrySet.containsAll	(	Collection	):  The next two methods are overridden to protect against an unscrupulous List whose contains(Object o) method senses when o is a Map.Entry, and calls o.setValue.
java.util.Collections: java.util.Collections.UnmodifiableNavigableMap.EmptyNavigableMap:  A class for the EMPTY_NAVIGABLE_MAP which needs readResolve to preserve singleton property.
java.util.Collections: java.util.Collections.UnmodifiableNavigableSet:  Wraps a navigable set and disables all of the mutative operations.
java.util.Collections: java.util.Collections.UnmodifiableNavigableSet.EmptyNavigableSet:  A singleton empty unmodifiable navigable set used for emptyNavigableSet().
java.util.Collections: java.util.Collections.UnmodifiableRandomAccessList.writeReplace	(	):  Allows instances to be deserialized in pre-1.4 JREs (which do not have UnmodifiableRandomAccessList). UnmodifiableList has a readResolve method that inverts this transformation upon deserialization.
java.util.Collections: java.util.Collections.addAll	(	Collection	T	):  Adds all of the specified elements to the specified collection. Elements to be added may be specified individually or as an array. The behavior of this convenience method is identical to that of c.addAll(Arrays.asList(elements)), but this method is likely to run significantly faster under most implementations. When elements are specified individually, this method provides a convenient way to add a few elements to an existing collection:  Collections.addAll(flavors, "Peaches 'n Plutonium", "Rocky Racoon"); 
java.util.Collections: java.util.Collections.asLifoQueue	(	Deque	):  Returns a view of a Deque as a Last-in-first-out (Lifo) Queue. Method add is mapped to push, remove is mapped to pop and so on. This view can be useful when you would like to use a method requiring a Queue but you need Lifo ordering. Each method invocation on the queue returned by this method results in exactly one method invocation on the backing deque, with one exception. The addAll method is implemented as a sequence of addFirst invocations on the backing deque.
java.util.Collections: java.util.Collections.binarySearch	(	List	T	):  Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the Comparable natural ordering of its elements (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the list contains multiple elements equal to the specified object, there is no guarantee which one will be found. This method runs in log(n) time for a "random access" list (which provides near-constant-time positional access). If the specified list does not implement the RandomAccess interface and is large, this method will do an iterator-based binary search that performs O(n) link traversals and O(log n) element comparisons.
java.util.Collections: java.util.Collections.binarySearch	(	List	T	Comparator	):  Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort() sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If the list contains multiple elements equal to the specified object, there is no guarantee which one will be found. This method runs in log(n) time for a "random access" list (which provides near-constant-time positional access). If the specified list does not implement the RandomAccess interface and is large, this method will do an iterator-based binary search that performs O(n) link traversals and O(log n) element comparisons.
java.util.Collections: java.util.Collections.checkedCollection	(	Collection	Class	):  Returns a dynamically typesafe view of the specified collection. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a collection contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the collection takes place through the view, it is guaranteed that the collection cannot contain an incorrectly typed element. The generics mechanism in the language provides compile-time (static) type checking, but it is possible to defeat this mechanism with unchecked casts. Usually this is not a problem, as the compiler issues warnings on all such unchecked operations. There are, however, times when static type checking alone is not sufficient. For example, suppose a collection is passed to a third-party library and it is imperative that the library code not corrupt the collection by inserting an element of the wrong type. Another use of dynamically typesafe views is debugging. Suppose a program fails with a ClassCastException, indicating that an incorrectly typed element was put into a parameterized collection. Unfortunately, the exception can occur at any time after the erroneous element is inserted, so it typically provides little or no information as to the real source of the problem. If the problem is reproducible, one can quickly determine its source by temporarily modifying the program to wrap the collection with a dynamically typesafe view. For example, this declaration:  Collection c = new HashSet<>(); may be replaced temporarily by this one:  Collection c = Collections.checkedCollection( new HashSet<>(), String.class); Running the program again will cause it to fail at the point where an incorrectly typed element is inserted into the collection, clearly identifying the source of the problem. Once the problem is fixed, the modified declaration may be reverted back to the original. The returned collection does not pass the hashCode and equals operations through to the backing collection, but relies on Object's equals and hashCode methods. This is necessary to preserve the contracts of these operations in the case that the backing collection is a set or a list. The returned collection will be serializable if the specified collection is serializable. Since null is considered to be a value of any reference type, the returned collection permits insertion of null elements whenever the backing collection does.
java.util.Collections: java.util.Collections.checkedList	(	List	Class	):  Returns a dynamically typesafe view of the specified list. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a list contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the list takes place through the view, it is guaranteed that the list cannot contain an incorrectly typed element. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned list will be serializable if the specified list is serializable. Since null is considered to be a value of any reference type, the returned list permits insertion of null elements whenever the backing list does.
java.util.Collections: java.util.Collections.checkedMap	(	Map	Class	Class	):  Returns a dynamically typesafe view of the specified map. Any attempt to insert a mapping whose key or value have the wrong type will result in an immediate ClassCastException. Similarly, any attempt to modify the value currently associated with a key will result in an immediate ClassCastException, whether the modification is attempted directly through the map itself, or through a Map.Entry instance obtained from the map's entrySet() entry set view. Assuming a map contains no incorrectly typed keys or values prior to the time a dynamically typesafe view is generated, and that all subsequent access to the map takes place through the view (or one of its collection views), it is guaranteed that the map cannot contain an incorrectly typed key or value. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned map will be serializable if the specified map is serializable. Since null is considered to be a value of any reference type, the returned map permits insertion of null keys or values whenever the backing map does.
java.util.Collections: java.util.Collections.checkedNavigableMap	(	NavigableMap	Class	Class	):  Returns a dynamically typesafe view of the specified navigable map. Any attempt to insert a mapping whose key or value have the wrong type will result in an immediate ClassCastException. Similarly, any attempt to modify the value currently associated with a key will result in an immediate ClassCastException, whether the modification is attempted directly through the map itself, or through a Map.Entry instance obtained from the map's entrySet() entry set view. Assuming a map contains no incorrectly typed keys or values prior to the time a dynamically typesafe view is generated, and that all subsequent access to the map takes place through the view (or one of its collection views), it is guaranteed that the map cannot contain an incorrectly typed key or value. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned map will be serializable if the specified map is serializable. Since null is considered to be a value of any reference type, the returned map permits insertion of null keys or values whenever the backing map does.
java.util.Collections: java.util.Collections.checkedNavigableSet	(	NavigableSet	Class	):  Returns a dynamically typesafe view of the specified navigable set. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a navigable set contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the navigable set takes place through the view, it is guaranteed that the navigable set cannot contain an incorrectly typed element. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned navigable set will be serializable if the specified navigable set is serializable. Since null is considered to be a value of any reference type, the returned navigable set permits insertion of null elements whenever the backing sorted set does.
java.util.Collections: java.util.Collections.checkedQueue	(	Queue	Class	):  Returns a dynamically typesafe view of the specified queue. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a queue contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the queue takes place through the view, it is guaranteed that the queue cannot contain an incorrectly typed element. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned queue will be serializable if the specified queue is serializable. Since null is considered to be a value of any reference type, the returned queue permits insertion of null elements whenever the backing queue does.
java.util.Collections: java.util.Collections.checkedSet	(	Set	Class	):  Returns a dynamically typesafe view of the specified set. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a set contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the set takes place through the view, it is guaranteed that the set cannot contain an incorrectly typed element. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned set will be serializable if the specified set is serializable. Since null is considered to be a value of any reference type, the returned set permits insertion of null elements whenever the backing set does.
java.util.Collections: java.util.Collections.checkedSortedMap	(	SortedMap	Class	Class	):  Returns a dynamically typesafe view of the specified sorted map. Any attempt to insert a mapping whose key or value have the wrong type will result in an immediate ClassCastException. Similarly, any attempt to modify the value currently associated with a key will result in an immediate ClassCastException, whether the modification is attempted directly through the map itself, or through a Map.Entry instance obtained from the map's entrySet() entry set view. Assuming a map contains no incorrectly typed keys or values prior to the time a dynamically typesafe view is generated, and that all subsequent access to the map takes place through the view (or one of its collection views), it is guaranteed that the map cannot contain an incorrectly typed key or value. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned map will be serializable if the specified map is serializable. Since null is considered to be a value of any reference type, the returned map permits insertion of null keys or values whenever the backing map does.
java.util.Collections: java.util.Collections.checkedSortedSet	(	SortedSet	Class	):  Returns a dynamically typesafe view of the specified sorted set. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a sorted set contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the sorted set takes place through the view, it is guaranteed that the sorted set cannot contain an incorrectly typed element. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned sorted set will be serializable if the specified sorted set is serializable. Since null is considered to be a value of any reference type, the returned sorted set permits insertion of null elements whenever the backing sorted set does.
java.util.Collections: java.util.Collections.copy	(	List	List	):  Copies all of the elements from one list into another. After the operation, the index of each copied element in the destination list will be identical to its index in the source list. The destination list must be at least as long as the source list. If it is longer, the remaining elements in the destination list are unaffected.  This method runs in linear time.
java.util.Collections: java.util.Collections.disjoint	(	Collection	Collection	):  Returns true if the two specified collections have no elements in common. Care must be exercised if this method is used on collections that do not comply with the general contract for Collection. Implementations may elect to iterate over either collection and test for containment in the other collection (or to perform any equivalent computation). If either collection uses a nonstandard equality test (as does a SortedSet whose ordering is not compatible with equals, or the key set of an IdentityHashMap), both collections must use the same nonstandard equality test, or the result of this method is undefined. Care must also be exercised when using collections that have restrictions on the elements that they may contain. Collection implementations are allowed to throw exceptions for any operation involving elements they deem ineligible. For absolute safety the specified collections should contain only elements which are eligible elements for both collections. Note that it is permissible to pass the same collection in both parameters, in which case the method will return true if and only if the collection is empty.
java.util.Collections: java.util.Collections.emptyEnumeration	(	):  Returns an enumeration that has no elements. More precisely,  hasMoreElements always returns false.  nextElement always throws NoSuchElementException.  Implementations of this method are permitted, but not required, to return the same object from multiple invocations.
java.util.Collections: java.util.Collections.emptyIterator	(	):  Returns an iterator that has no elements. More precisely,  hasNext always returns false. next always throws NoSuchElementException. remove always throws IllegalStateException.  Implementations of this method are permitted, but not required, to return the same object from multiple invocations.
java.util.Collections: java.util.Collections.emptyList	(	):  Returns an empty list (immutable). This list is serializable. This example illustrates the type-safe way to obtain an empty list:  List<String> s = Collections.emptyList(); 
java.util.Collections: java.util.Collections.emptyListIterator	(	):  Returns a list iterator that has no elements. More precisely,  hasNext and hasPrevious always return false. next and previous always throw NoSuchElementException. remove and set always throw IllegalStateException. add always throws UnsupportedOperationException. nextIndex always returns 0. previousIndex always returns -1.  Implementations of this method are permitted, but not required, to return the same object from multiple invocations.
java.util.Collections: java.util.Collections.emptyMap	(	):  Returns an empty map (immutable). This map is serializable. This example illustrates the type-safe way to obtain an empty map:  Map<String, Date> s = Collections.emptyMap(); 
java.util.Collections: java.util.Collections.emptyNavigableMap	(	):  Returns an empty navigable map (immutable). This map is serializable. This example illustrates the type-safe way to obtain an empty map:  NavigableMap s = Collections.emptyNavigableMap();
java.util.Collections: java.util.Collections.emptyNavigableSet	(	):  Returns an empty navigable set (immutable). This set is serializable. This example illustrates the type-safe way to obtain an empty navigable set:  NavigableSet s = Collections.emptyNavigableSet();
java.util.Collections: java.util.Collections.emptySet	(	):  Returns an empty set (immutable). This set is serializable. Unlike the like-named field, this method is parameterized. This example illustrates the type-safe way to obtain an empty set:  Set<String> s = Collections.emptySet(); 
java.util.Collections: java.util.Collections.emptySortedMap	(	):  Returns an empty sorted map (immutable). This map is serializable. This example illustrates the type-safe way to obtain an empty map:  SortedMap s = Collections.emptySortedMap();
java.util.Collections: java.util.Collections.emptySortedSet	(	):  Returns an empty sorted set (immutable). This set is serializable. This example illustrates the type-safe way to obtain an empty sorted set:  SortedSet s = Collections.emptySortedSet();
java.util.Collections: java.util.Collections.enumeration	(	Collection	):  Returns an enumeration over the specified collection. This provides interoperability with legacy APIs that require an enumeration as input.
java.util.Collections: java.util.Collections.eq	(	Object	Object	):  Returns true if the specified arguments are equal, or both null. NB: Do not replace with Object.equals until JDK-8015417 is resolved.
java.util.Collections: java.util.Collections.fill	(	List	T	):  Replaces all of the elements of the specified list with the specified element.  This method runs in linear time.
java.util.Collections: java.util.Collections.frequency	(	Collection	Object	):  Returns the number of elements in the specified collection equal to the specified object. More formally, returns the number of elements e in the collection such that (o == null ? e == null : o.equals(e)).
java.util.Collections: java.util.Collections.get	(	ListIterator	int	):  Gets the ith element from the given list by repositioning the specified list listIterator.
java.util.Collections: java.util.Collections.indexOfSubList	(	List	List	):  Returns the starting position of the first occurrence of the specified target list within the specified source list, or -1 if there is no such occurrence. More formally, returns the lowest index i such that source.subList(i, i+target.size()).equals(target), or -1 if there is no such index. (Returns -1 if target.size() > source.size()) This implementation uses the "brute force" technique of scanning over the source list, looking for a match with the target at each location in turn.
java.util.Collections: java.util.Collections.lastIndexOfSubList	(	List	List	):  Returns the starting position of the last occurrence of the specified target list within the specified source list, or -1 if there is no such occurrence. More formally, returns the highest index i such that source.subList(i, i+target.size()).equals(target), or -1 if there is no such index. (Returns -1 if target.size() > source.size()) This implementation uses the "brute force" technique of iterating over the source list, looking for a match with the target at each location in turn.
java.util.Collections: java.util.Collections.list	(	Enumeration	):  Returns an array list containing the elements returned by the specified enumeration in the order they are returned by the enumeration. This method provides interoperability between legacy APIs that return enumerations and new APIs that require collections.
java.util.Collections: java.util.Collections.max	(	Collection	):  Returns the maximum element of the given collection, according to the natural ordering of its elements. All elements in the collection must implement the Comparable interface. Furthermore, all elements in the collection must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the collection). This method iterates over the entire collection, hence it requires time proportional to the size of the collection.
java.util.Collections: java.util.Collections.max	(	Collection	Comparator	):  Returns the maximum element of the given collection, according to the order induced by the specified comparator. All elements in the collection must be mutually comparable by the specified comparator (that is, comp.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the collection). This method iterates over the entire collection, hence it requires time proportional to the size of the collection.
java.util.Collections: java.util.Collections.min	(	Collection	):  Returns the minimum element of the given collection, according to the natural ordering of its elements. All elements in the collection must implement the Comparable interface. Furthermore, all elements in the collection must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the collection). This method iterates over the entire collection, hence it requires time proportional to the size of the collection.
java.util.Collections: java.util.Collections.min	(	Collection	Comparator	):  Returns the minimum element of the given collection, according to the order induced by the specified comparator. All elements in the collection must be mutually comparable by the specified comparator (that is, comp.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the collection). This method iterates over the entire collection, hence it requires time proportional to the size of the collection.
java.util.Collections: java.util.Collections.nCopies	(	int	T	):  Returns an immutable list consisting of n copies of the specified object. The newly allocated data object is tiny (it contains a single reference to the data object). This method is useful in combination with the List.addAll method to grow lists. The returned list is serializable.
java.util.Collections: java.util.Collections.newSetFromMap	(	Map	):  Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>()); 
java.util.Collections: java.util.Collections.replaceAll	(	List	T	T	):  Replaces all occurrences of one specified value in a list with another. More formally, replaces with newVal each element e in list such that (oldVal==null ? e==null : oldVal.equals(e)). (This method has no effect on the size of the list.)
java.util.Collections: java.util.Collections.reverse	(	List	):  Reverses the order of the elements in the specified list. This method runs in linear time.
java.util.Collections: java.util.Collections.reverseOrder	(	):  Returns a comparator that imposes the reverse of the natural ordering on a collection of objects that implement the Comparable interface. (The natural ordering is the ordering imposed by the objects' own compareTo method.) This enables a simple idiom for sorting (or maintaining) collections (or arrays) of objects that implement the Comparable interface in reverse-natural-order. For example, suppose a is an array of strings. Then:  Arrays.sort(a, Collections.reverseOrder());  sorts the array in reverse-lexicographic (alphabetical) order. The returned comparator is serializable.
java.util.Collections: java.util.Collections.reverseOrder	(	Comparator	):  Returns a comparator that imposes the reverse ordering of the specified comparator. If the specified comparator is null, this method is equivalent to reverseOrder() (in other words, it returns a comparator that imposes the reverse of the natural ordering on a collection of objects that implement the Comparable interface). The returned comparator is serializable (assuming the specified comparator is also serializable or null).
java.util.Collections: java.util.Collections.rotate	(	List	int	):  Rotates the elements in the specified list by the specified distance. After calling this method, the element at index i will be the element previously at index (i - distance) mod list.size(), for all values of i between 0 and list.size()-1, inclusive. (This method has no effect on the size of the list.) For example, suppose list comprises [t, a, n, k, s]. After invoking Collections.rotate(list, 1) (or Collections.rotate(list, -4)), list will comprise [s, t, a, n, k]. Note that this method can usefully be applied to sublists to move one or more elements within a list while preserving the order of the remaining elements. For example, the following idiom moves the element at index j forward to position k (which must be greater than or equal to j):  Collections.rotate(list.subList(j, k+1), -1);  To make this concrete, suppose list comprises [a, b, c, d, e]. To move the element at index 1 (b) forward two positions, perform the following invocation:  Collections.rotate(l.subList(1, 4), -1);  The resulting list is [a, c, d, b, e]. To move more than one element forward, increase the absolute value of the rotation distance. To move elements backward, use a positive shift distance. If the specified list is small or implements the RandomAccess interface, this implementation exchanges the first element into the location it should go, and then repeatedly exchanges the displaced element into the location it should go until a displaced element is swapped into the first element. If necessary, the process is repeated on the second and successive elements, until the rotation is complete. If the specified list is large and doesn't implement the RandomAccess interface, this implementation breaks the list into two sublist views around index -distance mod size. Then the reverse() method is invoked on each sublist view, and finally it is invoked on the entire list. For a more complete description of both algorithms, see Section 2.3 of Jon Bentley's Programming Pearls (Addison-Wesley, 1986).
java.util.Collections: java.util.Collections.shuffle	(	List	):  Randomly permutes the specified list using a default source of randomness. All permutations occur with approximately equal likelihood. The hedge "approximately" is used in the foregoing description because default source of randomness is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm would choose permutations with perfect uniformity. This implementation traverses the list backwards, from the last element up to the second, repeatedly swapping a randomly selected element into the "current position". Elements are randomly selected from the portion of the list that runs from the first element to the current position, inclusive. This method runs in linear time. If the specified list does not implement the RandomAccess interface and is large, this implementation dumps the specified list into an array before shuffling it, and dumps the shuffled array back into the list. This avoids the quadratic behavior that would result from shuffling a "sequential access" list in place.
java.util.Collections: java.util.Collections.shuffle	(	List	Random	):  Randomly permute the specified list using the specified source of randomness. All permutations occur with equal likelihood assuming that the source of randomness is fair. This implementation traverses the list backwards, from the last element up to the second, repeatedly swapping a randomly selected element into the "current position". Elements are randomly selected from the portion of the list that runs from the first element to the current position, inclusive. This method runs in linear time. If the specified list does not implement the RandomAccess interface and is large, this implementation dumps the specified list into an array before shuffling it, and dumps the shuffled array back into the list. This avoids the quadratic behavior that would result from shuffling a "sequential access" list in place.
java.util.Collections: java.util.Collections.singleton	(	T	):  Returns an immutable set containing only the specified object. The returned set is serializable.
java.util.Collections: java.util.Collections.singletonList	(	T	):  Returns an immutable list containing only the specified object. The returned list is serializable.
java.util.Collections: java.util.Collections.singletonMap	(	K	V	):  Returns an immutable map, mapping only the specified key to the specified value. The returned map is serializable.
java.util.Collections: java.util.Collections.singletonSpliterator	(	T	):  Creates a Spliterator with only the specified element
java.util.Collections: java.util.Collections.sort	(	List	):  Sorts the specified list into ascending order, according to the Comparable natural ordering of its elements. All elements in the list must implement the Comparable interface. Furthermore, all elements in the list must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the list). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The specified list must be modifiable, but need not be resizable.
java.util.Collections: java.util.Collections.sort	(	List	Comparator	):  Sorts the specified list according to the order induced by the specified comparator. All elements in the list must be mutually comparable using the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the list). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The specified list must be modifiable, but need not be resizable.
java.util.Collections: java.util.Collections.swap	(	List	int	int	):  Swaps the elements at the specified positions in the specified list. (If the specified positions are equal, invoking this method leaves the list unchanged.)
java.util.Collections: java.util.Collections.swap	(	Object[]	int	int	):  Swaps the two specified elements in the specified array.
java.util.Collections: java.util.Collections.synchronizedCollection	(	Collection	):  Returns a synchronized (thread-safe) collection backed by the specified collection. In order to guarantee serial access, it is critical that all access to the backing collection is accomplished through the returned collection. It is imperative that the user manually synchronize on the returned collection when traversing it via Iterator, Spliterator or Stream:  Collection c = Collections.synchronizedCollection(myCollection); ... synchronized (c) { Iterator i = c.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned collection does not pass the hashCode and equals operations through to the backing collection, but relies on Object's equals and hashCode methods. This is necessary to preserve the contracts of these operations in the case that the backing collection is a set or a list. The returned collection will be serializable if the specified collection is serializable.
java.util.Collections: java.util.Collections.synchronizedList	(	List	):  Returns a synchronized (thread-safe) list backed by the specified list. In order to guarantee serial access, it is critical that all access to the backing list is accomplished through the returned list. It is imperative that the user manually synchronize on the returned list when iterating over it:  List list = Collections.synchronizedList(new ArrayList()); ... synchronized (list) { Iterator i = list.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned list will be serializable if the specified list is serializable.
java.util.Collections: java.util.Collections.synchronizedMap	(	Map	):  Returns a synchronized (thread-safe) map backed by the specified map. In order to guarantee serial access, it is critical that all access to the backing map is accomplished through the returned map. It is imperative that the user manually synchronize on the returned map when iterating over any of its collection views:  Map m = Collections.synchronizedMap(new HashMap()); ... Set s = m.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not s! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned map will be serializable if the specified map is serializable.
java.util.Collections: java.util.Collections.synchronizedNavigableMap	(	NavigableMap	):  Returns a synchronized (thread-safe) navigable map backed by the specified navigable map. In order to guarantee serial access, it is critical that all access to the backing navigable map is accomplished through the returned navigable map (or its views). It is imperative that the user manually synchronize on the returned navigable map when iterating over any of its collection views, or the collections views of any of its subMap, headMap or tailMap views.  NavigableMap m = Collections.synchronizedNavigableMap(new TreeMap()); ... Set s = m.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not s! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  or:  NavigableMap m = Collections.synchronizedNavigableMap(new TreeMap()); NavigableMap m2 = m.subMap(foo, true, bar, false); ... Set s2 = m2.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not m2 or s2! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned navigable map will be serializable if the specified navigable map is serializable.
java.util.Collections: java.util.Collections.synchronizedNavigableSet	(	NavigableSet	):  Returns a synchronized (thread-safe) navigable set backed by the specified navigable set. In order to guarantee serial access, it is critical that all access to the backing navigable set is accomplished through the returned navigable set (or its views). It is imperative that the user manually synchronize on the returned navigable set when iterating over it or any of its subSet, headSet, or tailSet views.  NavigableSet s = Collections.synchronizedNavigableSet(new TreeSet()); ... synchronized (s) { Iterator i = s.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  or:  NavigableSet s = Collections.synchronizedNavigableSet(new TreeSet()); NavigableSet s2 = s.headSet(foo, true); ... synchronized (s) { // Note: s, not s2!!! Iterator i = s2.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned navigable set will be serializable if the specified navigable set is serializable.
java.util.Collections: java.util.Collections.synchronizedSet	(	Set	):  Returns a synchronized (thread-safe) set backed by the specified set. In order to guarantee serial access, it is critical that all access to the backing set is accomplished through the returned set. It is imperative that the user manually synchronize on the returned set when iterating over it:  Set s = Collections.synchronizedSet(new HashSet()); ... synchronized (s) { Iterator i = s.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned set will be serializable if the specified set is serializable.
java.util.Collections: java.util.Collections.synchronizedSortedMap	(	SortedMap	):  Returns a synchronized (thread-safe) sorted map backed by the specified sorted map. In order to guarantee serial access, it is critical that all access to the backing sorted map is accomplished through the returned sorted map (or its views). It is imperative that the user manually synchronize on the returned sorted map when iterating over any of its collection views, or the collections views of any of its subMap, headMap or tailMap views.  SortedMap m = Collections.synchronizedSortedMap(new TreeMap()); ... Set s = m.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not s! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  or:  SortedMap m = Collections.synchronizedSortedMap(new TreeMap()); SortedMap m2 = m.subMap(foo, bar); ... Set s2 = m2.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not m2 or s2! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned sorted map will be serializable if the specified sorted map is serializable.
java.util.Collections: java.util.Collections.synchronizedSortedSet	(	SortedSet	):  Returns a synchronized (thread-safe) sorted set backed by the specified sorted set. In order to guarantee serial access, it is critical that all access to the backing sorted set is accomplished through the returned sorted set (or its views). It is imperative that the user manually synchronize on the returned sorted set when iterating over it or any of its subSet, headSet, or tailSet views.  SortedSet s = Collections.synchronizedSortedSet(new TreeSet()); ... synchronized (s) { Iterator i = s.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  or:  SortedSet s = Collections.synchronizedSortedSet(new TreeSet()); SortedSet s2 = s.headSet(foo); ... synchronized (s) { // Note: s, not s2!!! Iterator i = s2.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned sorted set will be serializable if the specified sorted set is serializable.
java.util.Collections: java.util.Collections.unmodifiableCollection	(	Collection	):  Returns an unmodifiable view of the specified collection. This method allows modules to provide users with "read-only" access to internal collections. Query operations on the returned collection "read through" to the specified collection, and attempts to modify the returned collection, whether direct or via its iterator, result in an UnsupportedOperationException. The returned collection does not pass the hashCode and equals operations through to the backing collection, but relies on Object's equals and hashCode methods. This is necessary to preserve the contracts of these operations in the case that the backing collection is a set or a list. The returned collection will be serializable if the specified collection is serializable.
java.util.Collections: java.util.Collections.unmodifiableList	(	List	):  Returns an unmodifiable view of the specified list. This method allows modules to provide users with "read-only" access to internal lists. Query operations on the returned list "read through" to the specified list, and attempts to modify the returned list, whether direct or via its iterator, result in an UnsupportedOperationException. The returned list will be serializable if the specified list is serializable. Similarly, the returned list will implement RandomAccess if the specified list does.
java.util.Collections: java.util.Collections.unmodifiableMap	(	Map	):  Returns an unmodifiable view of the specified map. This method allows modules to provide users with "read-only" access to internal maps. Query operations on the returned map "read through" to the specified map, and attempts to modify the returned map, whether direct or via its collection views, result in an UnsupportedOperationException. The returned map will be serializable if the specified map is serializable.
java.util.Collections: java.util.Collections.unmodifiableNavigableMap	(	NavigableMap	):  Returns an unmodifiable view of the specified navigable map. This method allows modules to provide users with "read-only" access to internal navigable maps. Query operations on the returned navigable map "read through" to the specified navigable map. Attempts to modify the returned navigable map, whether direct, via its collection views, or via its subMap, headMap, or tailMap views, result in an UnsupportedOperationException. The returned navigable map will be serializable if the specified navigable map is serializable.
java.util.Collections: java.util.Collections.unmodifiableNavigableSet	(	NavigableSet	):  Returns an unmodifiable view of the specified navigable set. This method allows modules to provide users with "read-only" access to internal navigable sets. Query operations on the returned navigable set "read through" to the specified navigable set. Attempts to modify the returned navigable set, whether direct, via its iterator, or via its subSet, headSet, or tailSet views, result in an UnsupportedOperationException. The returned navigable set will be serializable if the specified navigable set is serializable.
java.util.Collections: java.util.Collections.unmodifiableSet	(	Set	):  Returns an unmodifiable view of the specified set. This method allows modules to provide users with "read-only" access to internal sets. Query operations on the returned set "read through" to the specified set, and attempts to modify the returned set, whether direct or via its iterator, result in an UnsupportedOperationException. The returned set will be serializable if the specified set is serializable.
java.util.Collections: java.util.Collections.unmodifiableSortedMap	(	SortedMap	):  Returns an unmodifiable view of the specified sorted map. This method allows modules to provide users with "read-only" access to internal sorted maps. Query operations on the returned sorted map "read through" to the specified sorted map. Attempts to modify the returned sorted map, whether direct, via its collection views, or via its subMap, headMap, or tailMap views, result in an UnsupportedOperationException. The returned sorted map will be serializable if the specified sorted map is serializable.
java.util.Collections: java.util.Collections.unmodifiableSortedSet	(	SortedSet	):  Returns an unmodifiable view of the specified sorted set. This method allows modules to provide users with "read-only" access to internal sorted sets. Query operations on the returned sorted set "read through" to the specified sorted set. Attempts to modify the returned sorted set, whether direct, via its iterator, or via its subSet, headSet, or tailSet views, result in an UnsupportedOperationException. The returned sorted set will be serializable if the specified sorted set is serializable.
java.util.List: java.util.List:  An ordered collection (also known as a sequence). The user of this interface has precise control over where in the list each element is inserted. The user can access elements by their integer index (position in the list), and search for elements in the list. Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare. The List interface places additional stipulations, beyond those specified in the Collection interface, on the contracts of the iterator, add, remove, equals, and hashCode methods. Declarations for other inherited methods are also included here for convenience. The List interface provides four methods for positional (indexed) access to list elements. Lists (like Java arrays) are zero based. Note that these operations may execute in time proportional to the index value for some implementations (the LinkedList class, for example). Thus, iterating over the elements in a list is typically preferable to indexing through it if the caller does not know the implementation. The List interface provides a special iterator, called a ListIterator, that allows element insertion and replacement, and bidirectional access in addition to the normal operations that the Iterator interface provides. A method is provided to obtain a list iterator that starts at a specified position in the list. The List interface provides two methods to search for a specified object. From a performance standpoint, these methods should be used with caution. In many implementations they will perform costly linear searches. The List interface provides two methods to efficiently insert and remove multiple elements at an arbitrary point in the list. Note: While it is permissible for lists to contain themselves as elements, extreme caution is advised: the equals and hashCode methods are no longer well defined on such a list. Some list implementations have restrictions on the elements that they may contain. For example, some implementations prohibit null elements, and some have restrictions on the types of their elements. Attempting to add an ineligible element throws an unchecked exception, typically NullPointerException or ClassCastException. Attempting to query the presence of an ineligible element may throw an exception, or it may simply return false; some implementations will exhibit the former behavior and some will exhibit the latter. More generally, attempting an operation on an ineligible element whose completion would not result in the insertion of an ineligible element into the list may throw an exception or it may succeed, at the option of the implementation. Such exceptions are marked as "optional" in the specification for this interface. This interface is a member of the  Java Collections Framework.
java.util.List: java.util.List.add	(	E	):  Appends the specified element to the end of this list (optional operation). Lists that support this operation may place limitations on what elements may be added to this list. In particular, some lists will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. List classes should clearly specify in their documentation any restrictions on what elements may be added.
java.util.List: java.util.List.add	(	int	E	):  Inserts the specified element at the specified position in this list (optional operation). Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices).
java.util.List: java.util.List.addAll	(	Collection	):  Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's iterator (optional operation). The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (Note that this will occur if the specified collection is this list, and it's nonempty.)
java.util.List: java.util.List.addAll	(	int	Collection	):  Inserts all of the elements in the specified collection into this list at the specified position (optional operation). Shifts the element currently at that position (if any) and any subsequent elements to the right (increases their indices). The new elements will appear in this list in the order that they are returned by the specified collection's iterator. The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (Note that this will occur if the specified collection is this list, and it's nonempty.)
java.util.List: java.util.List.clear	(	):  Removes all of the elements from this list (optional operation). The list will be empty after this call returns.
java.util.List: java.util.List.contains	(	Object	):  Returns true if this list contains the specified element. More formally, returns true if and only if this list contains at least one element e such that (o==null?e==null:o.equals(e)).
java.util.List: java.util.List.containsAll	(	Collection	):  Returns true if this list contains all of the elements of the specified collection.
java.util.List: java.util.List.equals	(	Object	):  Compares the specified object with this list for equality. Returns true if and only if the specified object is also a list, both lists have the same size, and all corresponding pairs of elements in the two lists are equal. (Two elements e1 and e2 are equal if (e1==null ? e2==null : e1.equals(e2)).) In other words, two lists are defined to be equal if they contain the same elements in the same order. This definition ensures that the equals method works properly across different implementations of the List interface.
java.util.List: java.util.List.get	(	int	):  Returns the element at the specified position in this list.
java.util.List: java.util.List.hashCode	(	):  Returns the hash code value for this list. The hash code of a list is defined to be the result of the following calculation: int hashCode = 1; for (E e : list) hashCode = 31*hashCode + (e==null ? 0 : e.hashCode()); This ensures that list1.equals(list2) implies that list1.hashCode()==list2.hashCode() for any two lists, list1 and list2, as required by the general contract of hashCode.
java.util.List: java.util.List.indexOf	(	Object	):  Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the lowest index i such that (o==null?get(i)==null:o.equals(get(i))), or -1 if there is no such index.
java.util.List: java.util.List.isEmpty	(	):  Returns true if this list contains no elements.
java.util.List: java.util.List.iterator	(	):  Returns an iterator over the elements in this list in proper sequence.
java.util.List: java.util.List.lastIndexOf	(	Object	):  Returns the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the highest index i such that (o==null?get(i)==null:o.equals(get(i))), or -1 if there is no such index.
java.util.List: java.util.List.listIterator	(	):  Returns a list iterator over the elements in this list (in proper sequence).
java.util.List: java.util.List.listIterator	(	int	):  Returns a list iterator over the elements in this list (in proper sequence), starting at the specified position in the list. The specified index indicates the first element that would be returned by an initial call to next. An initial call to previous would return the element with the specified index minus one.
java.util.List: java.util.List.remove	(	Object	):  Removes the first occurrence of the specified element from this list, if it is present (optional operation). If this list does not contain the element, it is unchanged. More formally, removes the element with the lowest index i such that (o==null?get(i)==null:o.equals(get(i))) (if such an element exists). Returns true if this list contained the specified element (or equivalently, if this list changed as a result of the call).
java.util.List: java.util.List.remove	(	int	):  Removes the element at the specified position in this list (optional operation). Shifts any subsequent elements to the left (subtracts one from their indices). Returns the element that was removed from the list.
java.util.List: java.util.List.removeAll	(	Collection	):  Removes from this list all of its elements that are contained in the specified collection (optional operation).
java.util.List: java.util.List.replaceAll	(	UnaryOperator	):  Replaces each element of this list with the result of applying the operator to that element. Errors or runtime exceptions thrown by the operator are relayed to the caller.
java.util.List: java.util.List.retainAll	(	Collection	):  Retains only the elements in this list that are contained in the specified collection (optional operation). In other words, removes from this list all of its elements that are not contained in the specified collection.
java.util.List: java.util.List.set	(	int	E	):  Replaces the element at the specified position in this list with the specified element (optional operation).
java.util.List: java.util.List.size	(	):  Returns the number of elements in this list. If this list contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
java.util.List: java.util.List.sort	(	Comparator	):  Sorts this list according to the order induced by the specified Comparator. All elements in this list must be mutually comparable using the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the list). If the specified comparator is null then all elements in this list must implement the Comparable interface and the elements' Comparable natural ordering should be used. This list must be modifiable, but need not be resizable.
java.util.List: java.util.List.spliterator	(	):  Creates a Spliterator over the elements in this list. The Spliterator reports SIZED and ORDERED. Implementations should document the reporting of additional characteristic values.
java.util.List: java.util.List.subList	(	int	int	):  Returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive. (If fromIndex and toIndex are equal, the returned list is empty.) The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa. The returned list supports all of the optional list operations supported by this list. This method eliminates the need for explicit range operations (of the sort that commonly exist for arrays). Any operation that expects a list can be used as a range operation by passing a subList view instead of a whole list. For example, the following idiom removes a range of elements from a list: list.subList(from, to).clear(); Similar idioms may be constructed for indexOf and lastIndexOf, and all of the algorithms in the Collections class can be applied to a subList. The semantics of the list returned by this method become undefined if the backing list (i.e., this list) is structurally modified in any way other than via the returned list. (Structural modifications are those that change the size of this list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.)
java.util.List: java.util.List.toArray	(	):  Returns an array containing all of the elements in this list in proper sequence (from first to last element). The returned array will be "safe" in that no references to it are maintained by this list. (In other words, this method must allocate a new array even if this list is backed by an array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.List: java.util.List.toArray	(	T[]	):  Returns an array containing all of the elements in this list in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array. If the list fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this list. If the list fits in the specified array with room to spare (i.e., the array has more elements than the list), the element in the array immediately following the end of the list is set to null. (This is useful in determining the length of the list only if the caller knows that the list does not contain any null elements.) Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a list known to contain only strings. The following code can be used to dump the list into a newly allocated array of String: String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.Comparator: java.util.Comparator:  A comparison function, which imposes a total ordering on some collection of objects. Comparators can be passed to a sort method (such as sort() Collections.sort or sort() Arrays.sort) to allow precise control over the sort order. Comparators can also be used to control the order of certain data structures (such as SortedSet sorted sets or SortedMap sorted maps), or to provide an ordering for collections of objects that don't have a Comparable natural ordering. The ordering imposed by a comparator c on a set of elements S is said to be consistent with equals if and only if c.compare(e1, e2)==0 has the same boolean value as e1.equals(e2) for every e1 and e2 in S. Caution should be exercised when using a comparator capable of imposing an ordering inconsistent with equals to order a sorted set (or sorted map). Suppose a sorted set (or sorted map) with an explicit comparator c is used with elements (or keys) drawn from a set S. If the ordering imposed by c on S is inconsistent with equals, the sorted set (or sorted map) will behave "strangely." In particular the sorted set (or sorted map) will violate the general contract for set (or map), which is defined in terms of equals. For example, suppose one adds two elements a and b such that (a.equals(b) && c.compare(a, b) != 0) to an empty TreeSet with comparator c. The second add operation will return true (and the size of the tree set will increase) because a and b are not equivalent from the tree set's perspective, even though this is contrary to the specification of the add Set.add method. Note: It is generally a good idea for comparators to also implement java.io.Serializable, as they may be used as ordering methods in serializable data structures (like TreeSet, TreeMap). In order for the data structure to serialize successfully, the comparator (if provided) must implement Serializable. For the mathematically inclined, the relation that defines the imposed ordering that a given comparator c imposes on a given set of objects S is: {(x, y) such that c.compare(x, y) <= 0}.  The quotient for this total order is: {(x, y) such that c.compare(x, y) == 0}.  It follows immediately from the contract for compare that the quotient is an equivalence relation on S, and that the imposed ordering is a total order on S. When we say that the ordering imposed by c on S is consistent with equals, we mean that the quotient for the ordering is the equivalence relation defined by the objects' equals() equals(Object) method(s): {(x, y) such that x.equals(y)}.  Unlike Comparable, a comparator may optionally permit comparison of null arguments, while maintaining the requirements for an equivalence relation. This interface is a member of the  Java Collections Framework.
java.util.Comparator: java.util.Comparator.compare	(	T	T	):  Compares its two arguments for order. Returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. In the foregoing description, the notation sgn(expression) designates the mathematical signum function, which is defined to return one of -1, 0, or 1 according to whether the value of expression is negative, zero or positive. The implementor must ensure that sgn(compare(x, y)) == -sgn(compare(y, x)) for all x and y. (This implies that compare(x, y) must throw an exception if and only if compare(y, x) throws an exception.) The implementor must also ensure that the relation is transitive: ((compare(x, y)>0) && (compare(y, z)>0)) implies compare(x, z)>0. Finally, the implementor must ensure that compare(x, y)==0 implies that sgn(compare(x, z))==sgn(compare(y, z)) for all z. It is generally the case, but not strictly required that (compare(x, y)==0) == (x.equals(y)). Generally speaking, any comparator that violates this condition should clearly indicate this fact. The recommended language is "Note: this comparator imposes orderings that are inconsistent with equals."
java.util.Comparator: java.util.Comparator.comparing	(	Function	):  Accepts a function that extracts a java.lang.Comparable Comparable sort key from a type T, and returns a Comparator that compares by that sort key. The returned comparator is serializable if the specified function is also serializable.
java.util.Comparator: java.util.Comparator.comparing	(	Function	Comparator	):  Accepts a function that extracts a sort key from a type T, and returns a Comparator that compares by that sort key using the specified Comparator. The returned comparator is serializable if the specified function and comparator are both serializable.
java.util.Comparator: java.util.Comparator.comparingDouble	(	ToDoubleFunction	):  Accepts a function that extracts a double sort key from a type T, and returns a Comparator that compares by that sort key. The returned comparator is serializable if the specified function is also serializable.
java.util.Comparator: java.util.Comparator.comparingInt	(	ToIntFunction	):  Accepts a function that extracts an int sort key from a type T, and returns a Comparator that compares by that sort key. The returned comparator is serializable if the specified function is also serializable.
java.util.Comparator: java.util.Comparator.comparingLong	(	ToLongFunction	):  Accepts a function that extracts a long sort key from a type T, and returns a Comparator that compares by that sort key. The returned comparator is serializable if the specified function is also serializable.
java.util.Comparator: java.util.Comparator.equals	(	Object	):  Indicates whether some other object is "equal to" this comparator. This method must obey the general contract of equals(). Additionally, this method can return true only if the specified object is also a comparator and it imposes the same ordering as this comparator. Thus, comp1.equals(comp2) implies that sgn(comp1.compare(o1, o2))==sgn(comp2.compare(o1, o2)) for every object reference o1 and o2. Note that it is always safe not to override Object.equals(Object). However, overriding this method may, in some cases, improve performance by allowing programs to determine that two distinct comparators impose the same order.
java.util.Comparator: java.util.Comparator.naturalOrder	(	):  Returns a comparator that compares Comparable objects in natural order. The returned comparator is serializable and throws NullPointerException when comparing null.
java.util.Comparator: java.util.Comparator.nullsFirst	(	Comparator	):  Returns a null-friendly comparator that considers null to be less than non-null. When both are null, they are considered equal. If both are non-null, the specified Comparator is used to determine the order. If the specified comparator is null, then the returned comparator considers all non-null values to be equal. The returned comparator is serializable if the specified comparator is serializable.
java.util.Comparator: java.util.Comparator.nullsLast	(	Comparator	):  Returns a null-friendly comparator that considers null to be greater than non-null. When both are null, they are considered equal. If both are non-null, the specified Comparator is used to determine the order. If the specified comparator is null, then the returned comparator considers all non-null values to be equal. The returned comparator is serializable if the specified comparator is serializable.
java.util.Comparator: java.util.Comparator.reverseOrder	(	):  Returns a comparator that imposes the reverse of the natural ordering. The returned comparator is serializable and throws NullPointerException when comparing null.
java.util.Comparator: java.util.Comparator.reversed	(	):  Returns a comparator that imposes the reverse ordering of this comparator.
java.util.Comparator: java.util.Comparator.thenComparing	(	Comparator	):  Returns a lexicographic-order comparator with another comparator. If this Comparator considers two elements equal, i.e. compare(a, b) == 0, other is used to determine the order. The returned comparator is serializable if the specified comparator is also serializable.
java.util.Comparator: java.util.Comparator.thenComparing	(	Function	):  Returns a lexicographic-order comparator with a function that extracts a Comparable sort key.
java.util.Comparator: java.util.Comparator.thenComparing	(	Function	Comparator	):  Returns a lexicographic-order comparator with a function that extracts a key to be compared with the given Comparator.
java.util.Comparator: java.util.Comparator.thenComparingDouble	(	ToDoubleFunction	):  Returns a lexicographic-order comparator with a function that extracts a double sort key.
java.util.Comparator: java.util.Comparator.thenComparingInt	(	ToIntFunction	):  Returns a lexicographic-order comparator with a function that extracts a int sort key.
java.util.Comparator: java.util.Comparator.thenComparingLong	(	ToLongFunction	):  Returns a lexicographic-order comparator with a function that extracts a long sort key.
java.util.Collection: java.util.Collection:  The root interface in the collection hierarchy. A collection represents a group of objects, known as its elements. Some collections allow duplicate elements and others do not. Some are ordered and others unordered. The JDK does not provide any direct implementations of this interface: it provides implementations of more specific subinterfaces like Set and List. This interface is typically used to pass collections around and manipulate them where maximum generality is desired. Bags or multisets (unordered collections that may contain duplicate elements) should implement this interface directly. All general-purpose Collection implementation classes (which typically implement Collection indirectly through one of its subinterfaces) should provide two "standard" constructors: a void (no arguments) constructor, which creates an empty collection, and a constructor with a single argument of type Collection, which creates a new collection with the same elements as its argument. In effect, the latter constructor allows the user to copy any collection, producing an equivalent collection of the desired implementation type. There is no way to enforce this convention (as interfaces cannot contain constructors) but all of the general-purpose Collection implementations in the Java platform libraries comply. The "destructive" methods contained in this interface, that is, the methods that modify the collection on which they operate, are specified to throw UnsupportedOperationException if this collection does not support the operation. If this is the case, these methods may, but are not required to, throw an UnsupportedOperationException if the invocation would have no effect on the collection. For example, invoking the addAll() method on an unmodifiable collection may, but is not required to, throw the exception if the collection to be added is empty.  Some collection implementations have restrictions on the elements that they may contain. For example, some implementations prohibit null elements, and some have restrictions on the types of their elements. Attempting to add an ineligible element throws an unchecked exception, typically NullPointerException or ClassCastException. Attempting to query the presence of an ineligible element may throw an exception, or it may simply return false; some implementations will exhibit the former behavior and some will exhibit the latter. More generally, attempting an operation on an ineligible element whose completion would not result in the insertion of an ineligible element into the collection may throw an exception or it may succeed, at the option of the implementation. Such exceptions are marked as "optional" in the specification for this interface. It is up to each collection to determine its own synchronization policy. In the absence of a stronger guarantee by the implementation, undefined behavior may result from the invocation of any method on a collection that is being mutated by another thread; this includes direct invocations, passing the collection to a method that might perform invocations, and using an existing iterator to examine the collection. Many methods in Collections Framework interfaces are defined in terms of the equals() method. For example, the specification for the contains() contains(Object o) method says: "returns true if and only if this collection contains at least one element e such that (o==null ? e==null : o.equals(e))." This specification should not be construed to imply that invoking Collection.contains with a non-null argument o will cause o.equals(e) to be invoked for any element e. Implementations are free to implement optimizations whereby the equals invocation is avoided, for example, by first comparing the hash codes of the two elements. (The hashCode() specification guarantees that two objects with unequal hash codes cannot be equal.) More generally, implementations of the various Collections Framework interfaces are free to take advantage of the specified behavior of underlying Object methods wherever the implementor deems it appropriate. Some collection operations which perform recursive traversal of the collection may fail with an exception for self-referential instances where the collection directly or indirectly contains itself. This includes the clone(), equals(), hashCode() and toString() methods. Implementations may optionally handle the self-referential scenario, however most current implementations do not do so. This interface is a member of the  Java Collections Framework.
java.util.Collection: java.util.Collection.add	(	E	):  Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.
java.util.Collection: java.util.Collection.addAll	(	Collection	):  Adds all of the elements in the specified collection to this collection (optional operation). The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (This implies that the behavior of this call is undefined if the specified collection is this collection, and this collection is nonempty.)
java.util.Collection: java.util.Collection.clear	(	):  Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.
java.util.Collection: java.util.Collection.contains	(	Object	):  Returns true if this collection contains the specified element. More formally, returns true if and only if this collection contains at least one element e such that (o==null?e==null:o.equals(e)).
java.util.Collection: java.util.Collection.containsAll	(	Collection	):  Returns true if this collection contains all of the elements in the specified collection.
java.util.Collection: java.util.Collection.equals	(	Object	):  Compares the specified object with this collection for equality.  While the Collection interface adds no stipulations to the general contract for the Object.equals, programmers who implement the Collection interface "directly" (in other words, create a class that is a Collection but is not a Set or a List) must exercise care if they choose to override the Object.equals. It is not necessary to do so, and the simplest course of action is to rely on Object's implementation, but the implementor may wish to implement a "value comparison" in place of the default "reference comparison." (The List and Set interfaces mandate such value comparisons.) The general contract for the Object.equals method states that equals must be symmetric (in other words, a.equals(b) if and only if b.equals(a)). The contracts for List.equals and Set.equals state that lists are only equal to other lists, and sets to other sets. Thus, a custom equals method for a collection class that implements neither the List nor Set interface must return false when this collection is compared to any list or set. (By the same logic, it is not possible to write a class that correctly implements both the Set and List interfaces.)
java.util.Collection: java.util.Collection.hashCode	(	):  Returns the hash code value for this collection. While the Collection interface adds no stipulations to the general contract for the Object.hashCode method, programmers should take note that any class that overrides the Object.equals method must also override the Object.hashCode method in order to satisfy the general contract for the Object.hashCode method. In particular, c1.equals(c2) implies that c1.hashCode()==c2.hashCode().
java.util.Collection: java.util.Collection.isEmpty	(	):  Returns true if this collection contains no elements.
java.util.Collection: java.util.Collection.iterator	(	):  Returns an iterator over the elements in this collection. There are no guarantees concerning the order in which the elements are returned (unless this collection is an instance of some class that provides a guarantee).
java.util.Collection: java.util.Collection.parallelStream	(	):  Returns a possibly parallel Stream with this collection as its source. It is allowable for this method to return a sequential stream. This method should be overridden when the spliterator() method cannot return a spliterator that is IMMUTABLE, CONCURRENT, or late-binding. (See spliterator() for details.)
java.util.Collection: java.util.Collection.remove	(	Object	):  Removes a single instance of the specified element from this collection, if it is present (optional operation). More formally, removes an element e such that (o==null?e==null:o.equals(e)), if this collection contains one or more such elements. Returns true if this collection contained the specified element (or equivalently, if this collection changed as a result of the call).
java.util.Collection: java.util.Collection.removeAll	(	Collection	):  Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.
java.util.Collection: java.util.Collection.removeIf	(	Predicate	):  Removes all of the elements of this collection that satisfy the given predicate. Errors or runtime exceptions thrown during iteration or by the predicate are relayed to the caller.
java.util.Collection: java.util.Collection.retainAll	(	Collection	):  Retains only the elements in this collection that are contained in the specified collection (optional operation). In other words, removes from this collection all of its elements that are not contained in the specified collection.
java.util.Collection: java.util.Collection.size	(	):  Returns the number of elements in this collection. If this collection contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
java.util.Collection: java.util.Collection.spliterator	(	):  Creates a Spliterator over the elements in this collection. Implementations should document characteristic values reported by the spliterator. Such characteristic values are not required to be reported if the spliterator reports SIZED and this collection contains no elements. The default implementation should be overridden by subclasses that can return a more efficient spliterator. In order to preserve expected laziness behavior for the stream() and parallelStream()} methods, spliterators should either have the characteristic of IMMUTABLE or CONCURRENT, or be late-binding. If none of these is practical, the overriding class should describe the spliterator's documented policy of binding and structural interference, and should override the stream() and parallelStream() methods to create streams using a Supplier of the spliterator, as in: Stream s = StreamSupport.stream(() -> spliterator(), spliteratorCharacteristics) These requirements ensure that streams produced by the stream() and parallelStream() methods will reflect the contents of the collection as of initiation of the terminal stream operation.
java.util.Collection: java.util.Collection.stream	(	):  Returns a sequential Stream with this collection as its source. This method should be overridden when the spliterator() method cannot return a spliterator that is IMMUTABLE, CONCURRENT, or late-binding. (See spliterator() for details.)
java.util.Collection: java.util.Collection.toArray	(	):  Returns an array containing all of the elements in this collection. If this collection makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. The returned array will be "safe" in that no references to it are maintained by this collection. (In other words, this method must allocate a new array even if this collection is backed by an array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.Collection: java.util.Collection.toArray	(	T[]	):  Returns an array containing all of the elements in this collection; the runtime type of the returned array is that of the specified array. If the collection fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this collection. If this collection fits in the specified array with room to spare (i.e., the array has more elements than this collection), the element in the array immediately following the end of the collection is set to null. (This is useful in determining the length of this collection only if the caller knows that this collection does not contain any null elements.) If this collection makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a collection known to contain only strings. The following code can be used to dump the collection into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.AbstractList: java.util.AbstractList:  This class provides a skeletal implementation of the List interface to minimize the effort required to implement this interface backed by a "random access" data store (such as an array). For sequential access data (such as a linked list), AbstractSequentialList should be used in preference to this class. To implement an unmodifiable list, the programmer needs only to extend this class and provide implementations for the get() and size() size() methods. To implement a modifiable list, the programmer must additionally override the set() set(int, E) method (which otherwise throws an UnsupportedOperationException). If the list is variable-size the programmer must additionally override the add() add(int, E) and remove() methods. The programmer should generally provide a void (no argument) and collection constructor, as per the recommendation in the Collection interface specification. Unlike the other abstract collection implementations, the programmer does not have to provide an iterator implementation; the iterator and list iterator are implemented by this class, on top of the "random access" methods: get(), set() set(int, E), add() add(int, E) and remove(). The documentation for each non-abstract method in this class describes its implementation in detail. Each of these methods may be overridden if the collection being implemented admits a more efficient implementation. This class is a member of the  Java Collections Framework.
java.util.AbstractList: java.util.AbstractList.AbstractList	(	):  Sole constructor. (For invocation by subclass constructors, typically implicit.)
java.util.AbstractList: java.util.AbstractList.add	(	E	):  Appends the specified element to the end of this list (optional operation). Lists that support this operation may place limitations on what elements may be added to this list. In particular, some lists will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. List classes should clearly specify in their documentation any restrictions on what elements may be added. This implementation calls add(size(), e). Note that this implementation throws an UnsupportedOperationException unless add() add(int, E) is overridden.
java.util.AbstractList: java.util.AbstractList.add	(	int	E	):  Inserts the specified element at the specified position in this list (optional operation). Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices). This implementation always throws an UnsupportedOperationException.
java.util.AbstractList: java.util.AbstractList.addAll	(	int	Collection	):  Inserts all of the elements in the specified collection into this list at the specified position (optional operation). Shifts the element currently at that position (if any) and any subsequent elements to the right (increases their indices). The new elements will appear in this list in the order that they are returned by the specified collection's iterator. The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (Note that this will occur if the specified collection is this list, and it's nonempty.) This implementation gets an iterator over the specified collection and iterates over it, inserting the elements obtained from the iterator into this list at the appropriate position, one at a time, using add(int, E). Many implementations will override this method for efficiency. Note that this implementation throws an UnsupportedOperationException unless add() add(int, E) is overridden.
java.util.AbstractList: java.util.AbstractList.clear	(	):  Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.
java.util.AbstractList: java.util.AbstractList.equals	(	Object	):  Compares the specified object with this list for equality. Returns true if and only if the specified object is also a list, both lists have the same size, and all corresponding pairs of elements in the two lists are equal. (Two elements e1 and e2 are equal if (e1==null ? e2==null : e1.equals(e2)).) In other words, two lists are defined to be equal if they contain the same elements in the same order. This implementation first checks if the specified object is this list. If so, it returns true; if not, it checks if the specified object is a list. If not, it returns false; if so, it iterates over both lists, comparing corresponding pairs of elements. If any comparison returns false, this method returns false. If either iterator runs out of elements before the other it returns false (as the lists are of unequal length); otherwise it returns true when the iterations complete.
java.util.AbstractList: java.util.AbstractList.get	(	int	):  Returns the element at the specified position in this list.
java.util.AbstractList: java.util.AbstractList.hashCode	(	):  Returns the hash code value for this list. This implementation uses exactly the code that is used to define the list hash function in the documentation for the hashCode method.
java.util.AbstractList: java.util.AbstractList.indexOf	(	Object	):  Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the lowest index i such that (o==null?get(i)==null:o.equals(get(i))), or -1 if there is no such index. This implementation first gets a list iterator (with listIterator()). Then, it iterates over the list until the specified element is found or the end of the list is reached.
java.util.AbstractList: java.util.AbstractList.iterator	(	):  Returns an iterator over the elements in this list in proper sequence. This implementation returns a straightforward implementation of the iterator interface, relying on the backing list's size(), get(int), and remove(int) methods. Note that the iterator returned by this method will throw an UnsupportedOperationException in response to its remove method unless the list's remove(int) method is overridden. This implementation can be made to throw runtime exceptions in the face of concurrent modification, as described in the specification for the (protected) modCount field.
java.util.AbstractList: java.util.AbstractList.lastIndexOf	(	Object	):  Returns the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the highest index i such that (o==null?get(i)==null:o.equals(get(i))), or -1 if there is no such index. This implementation first gets a list iterator that points to the end of the list (with listIterator(size())). Then, it iterates backwards over the list until the specified element is found, or the beginning of the list is reached.
java.util.AbstractList: java.util.AbstractList.listIterator	(	):  Returns a list iterator over the elements in this list (in proper sequence). This implementation returns listIterator(0).
java.util.AbstractList: java.util.AbstractList.listIterator	(	int	):  Returns a list iterator over the elements in this list (in proper sequence), starting at the specified position in the list. The specified index indicates the first element that would be returned by an initial call to next. An initial call to previous would return the element with the specified index minus one. This implementation returns a straightforward implementation of the ListIterator interface that extends the implementation of the Iterator interface returned by the iterator() method. The ListIterator implementation relies on the backing list's get(int), set(int, E), add(int, E) and remove(int) methods. Note that the list iterator returned by this implementation will throw an UnsupportedOperationException in response to its remove, set and add methods unless the list's remove(int), set(int, E), and add(int, E) methods are overridden. This implementation can be made to throw runtime exceptions in the face of concurrent modification, as described in the specification for the (protected) modCount field.
java.util.AbstractList: java.util.AbstractList.remove	(	int	):  Removes the element at the specified position in this list (optional operation). Shifts any subsequent elements to the left (subtracts one from their indices). Returns the element that was removed from the list. This implementation always throws an UnsupportedOperationException.
java.util.AbstractList: java.util.AbstractList.removeRange	(	int	int	):  Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive. Shifts any succeeding elements to the left (reduces their index). This call shortens the list by (toIndex - fromIndex) elements. (If toIndex==fromIndex, this operation has no effect.) This method is called by the clear operation on this list and its subLists. Overriding this method to take advantage of the internals of the list implementation can substantially improve the performance of the clear operation on this list and its subLists. This implementation gets a list iterator positioned before fromIndex, and repeatedly calls ListIterator.next followed by ListIterator.remove until the entire range has been removed. Note: if ListIterator.remove requires linear time, this implementation requires quadratic time.
java.util.AbstractList: java.util.AbstractList.set	(	int	E	):  Replaces the element at the specified position in this list with the specified element (optional operation). This implementation always throws an UnsupportedOperationException.
java.util.AbstractList: java.util.AbstractList.subList	(	int	int	):  Returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive. (If fromIndex and toIndex are equal, the returned list is empty.) The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa. The returned list supports all of the optional list operations supported by this list. This method eliminates the need for explicit range operations (of the sort that commonly exist for arrays). Any operation that expects a list can be used as a range operation by passing a subList view instead of a whole list. For example, the following idiom removes a range of elements from a list: list.subList(from, to).clear(); Similar idioms may be constructed for indexOf and lastIndexOf, and all of the algorithms in the Collections class can be applied to a subList. The semantics of the list returned by this method become undefined if the backing list (i.e., this list) is structurally modified in any way other than via the returned list. (Structural modifications are those that change the size of this list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.) This implementation returns a list that subclasses AbstractList. The subclass stores, in private fields, the offset of the subList within the backing list, the size of the subList (which can change over its lifetime), and the expected modCount value of the backing list. There are two variants of the subclass, one of which implements RandomAccess. If this list implements RandomAccess the returned list will be an instance of the subclass that implements RandomAccess. The subclass's set(int, E), get(int), add(int, E), remove(int), addAll(int, Collection) and removeRange(int, int) methods all delegate to the corresponding methods on the backing abstract list, after bounds-checking the index and adjusting for the offset. The addAll(Collection c) method merely returns addAll(size, c). The listIterator(int) method returns a "wrapper object" over a list iterator on the backing list, which is created with the corresponding method on the backing list. The iterator method merely returns listIterator(), and the size method merely returns the subclass's size field. All methods first check to see if the actual modCount of the backing list is equal to its expected value, and throw a ConcurrentModificationException if it is not.
java.util.AbstractCollection: java.util.AbstractCollection:  This class provides a skeletal implementation of the Collection interface, to minimize the effort required to implement this interface.  To implement an unmodifiable collection, the programmer needs only to extend this class and provide implementations for the iterator and size methods. (The iterator returned by the iterator method must implement hasNext and next.) To implement a modifiable collection, the programmer must additionally override this class's add method (which otherwise throws an UnsupportedOperationException), and the iterator returned by the iterator method must additionally implement its remove method. The programmer should generally provide a void (no argument) and Collection constructor, as per the recommendation in the Collection interface specification. The documentation for each non-abstract method in this class describes its implementation in detail. Each of these methods may be overridden if the collection being implemented admits a more efficient implementation. This class is a member of the  Java Collections Framework.
java.util.AbstractCollection: java.util.AbstractCollection.AbstractCollection	(	):  Sole constructor. (For invocation by subclass constructors, typically implicit.)
java.util.AbstractCollection: java.util.AbstractCollection.add	(	E	):  Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns. This implementation always throws an UnsupportedOperationException.
java.util.AbstractCollection: java.util.AbstractCollection.addAll	(	Collection	):  Adds all of the elements in the specified collection to this collection (optional operation). The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (This implies that the behavior of this call is undefined if the specified collection is this collection, and this collection is nonempty.) This implementation iterates over the specified collection, and adds each object returned by the iterator to this collection, in turn. Note that this implementation will throw an UnsupportedOperationException unless add is overridden (assuming the specified collection is non-empty).
java.util.AbstractCollection: java.util.AbstractCollection.clear	(	):  Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns. This implementation iterates over this collection, removing each element using the Iterator.remove operation. Most implementations will probably choose to override this method for efficiency. Note that this implementation will throw an UnsupportedOperationException if the iterator returned by this collection's iterator method does not implement the remove method and this collection is non-empty.
java.util.AbstractCollection: java.util.AbstractCollection.contains	(	Object	):  Returns true if this collection contains the specified element. More formally, returns true if and only if this collection contains at least one element e such that (o==null?e==null:o.equals(e)). This implementation iterates over the elements in the collection, checking each element in turn for equality with the specified element.
java.util.AbstractCollection: java.util.AbstractCollection.containsAll	(	Collection	):  Returns true if this collection contains all of the elements in the specified collection. This implementation iterates over the specified collection, checking each element returned by the iterator in turn to see if it's contained in this collection. If all elements are so contained true is returned, otherwise false.
java.util.AbstractCollection: java.util.AbstractCollection.finishToArray	(	T[]	Iterator	):  Reallocates the array being used within toArray when the iterator returned more elements than expected, and finishes filling it from the iterator.
java.util.AbstractCollection: java.util.AbstractCollection.isEmpty	(	):  Returns true if this collection contains no elements. This implementation returns size() == 0.
java.util.AbstractCollection: java.util.AbstractCollection.iterator	(	):  Returns an iterator over the elements contained in this collection.
java.util.AbstractCollection: java.util.AbstractCollection.remove	(	Object	):  Removes a single instance of the specified element from this collection, if it is present (optional operation). More formally, removes an element e such that (o==null?e==null:o.equals(e)), if this collection contains one or more such elements. Returns true if this collection contained the specified element (or equivalently, if this collection changed as a result of the call). This implementation iterates over the collection looking for the specified element. If it finds the element, it removes the element from the collection using the iterator's remove method. Note that this implementation throws an UnsupportedOperationException if the iterator returned by this collection's iterator method does not implement the remove method and this collection contains the specified object.
java.util.AbstractCollection: java.util.AbstractCollection.removeAll	(	Collection	):  Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection. This implementation iterates over this collection, checking each element returned by the iterator in turn to see if it's contained in the specified collection. If it's so contained, it's removed from this collection with the iterator's remove method. Note that this implementation will throw an UnsupportedOperationException if the iterator returned by the iterator method does not implement the remove method and this collection contains one or more elements in common with the specified collection.
java.util.AbstractCollection: java.util.AbstractCollection.retainAll	(	Collection	):  Retains only the elements in this collection that are contained in the specified collection (optional operation). In other words, removes from this collection all of its elements that are not contained in the specified collection. This implementation iterates over this collection, checking each element returned by the iterator in turn to see if it's contained in the specified collection. If it's not so contained, it's removed from this collection with the iterator's remove method. Note that this implementation will throw an UnsupportedOperationException if the iterator returned by the iterator method does not implement the remove method and this collection contains one or more elements not present in the specified collection.
java.util.AbstractCollection: java.util.AbstractCollection.toArray	(	):  Returns an array containing all of the elements in this collection. If this collection makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. The returned array will be "safe" in that no references to it are maintained by this collection. (In other words, this method must allocate a new array even if this collection is backed by an array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs. This implementation returns an array containing all the elements returned by this collection's iterator, in the same order, stored in consecutive elements of the array, starting with index 0. The length of the returned array is equal to the number of elements returned by the iterator, even if the size of this collection changes during iteration, as might happen if the collection permits concurrent modification during iteration. The size method is called only as an optimization hint; the correct result is returned even if the iterator returns a different number of elements. This method is equivalent to:  List list = new ArrayList(size()); for (E e : this) list.add(e); return list.toArray();
java.util.AbstractCollection: java.util.AbstractCollection.toArray	(	T[]	):  Returns an array containing all of the elements in this collection; the runtime type of the returned array is that of the specified array. If the collection fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this collection. If this collection fits in the specified array with room to spare (i.e., the array has more elements than this collection), the element in the array immediately following the end of the collection is set to null. (This is useful in determining the length of this collection only if the caller knows that this collection does not contain any null elements.) If this collection makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a collection known to contain only strings. The following code can be used to dump the collection into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray(). This implementation returns an array containing all the elements returned by this collection's iterator in the same order, stored in consecutive elements of the array, starting with index 0. If the number of elements returned by the iterator is too large to fit into the specified array, then the elements are returned in a newly allocated array with length equal to the number of elements returned by the iterator, even if the size of this collection changes during iteration, as might happen if the collection permits concurrent modification during iteration. The size method is called only as an optimization hint; the correct result is returned even if the iterator returns a different number of elements. This method is equivalent to:  List list = new ArrayList(size()); for (E e : this) list.add(e); return list.toArray(a);
java.util.AbstractCollection: java.util.AbstractCollection.toString	(	):  Returns a string representation of this collection. The string representation consists of a list of the collection's elements in the order they are returned by its iterator, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (comma and space). Elements are converted to strings as by valueOf().
java.util.AbstractMap: java.util.AbstractMap:  This class provides a skeletal implementation of the Map interface, to minimize the effort required to implement this interface. To implement an unmodifiable map, the programmer needs only to extend this class and provide an implementation for the entrySet method, which returns a set-view of the map's mappings. Typically, the returned set will, in turn, be implemented atop AbstractSet. This set should not support the add or remove methods, and its iterator should not support the remove method. To implement a modifiable map, the programmer must additionally override this class's put method (which otherwise throws an UnsupportedOperationException), and the iterator returned by entrySet().iterator() must additionally implement its remove method. The programmer should generally provide a void (no argument) and map constructor, as per the recommendation in the Map interface specification. The documentation for each non-abstract method in this class describes its implementation in detail. Each of these methods may be overridden if the map being implemented admits a more efficient implementation. This class is a member of the  Java Collections Framework.
java.util.AbstractMap: java.util.AbstractMap.AbstractMap	(	):  Sole constructor. (For invocation by subclass constructors, typically implicit.)
java.util.AbstractMap: java.util.AbstractMap.SimpleEntry:  An Entry maintaining a key and a value. The value may be changed using the setValue method. This class facilitates the process of building custom map implementations. For example, it may be convenient to return arrays of SimpleEntry instances in method Map.entrySet().toArray.
java.util.AbstractMap: java.util.AbstractMap.SimpleEntry.SimpleEntry	(	Entry	):  Creates an entry representing the same mapping as the specified entry.
java.util.AbstractMap: java.util.AbstractMap.SimpleEntry.SimpleEntry	(	K	V	):  Creates an entry representing a mapping from the specified key to the specified value.
java.util.AbstractMap: java.util.AbstractMap.SimpleEntry.equals	(	Object	):  Compares the specified object with this entry for equality. Returns true if the given object is also a map entry and the two entries represent the same mapping. More formally, two entries e1 and e2 represent the same mapping if (e1.getKey()==null ? e2.getKey()==null : e1.getKey().equals(e2.getKey())) && (e1.getValue()==null ? e2.getValue()==null : e1.getValue().equals(e2.getValue())) This ensures that the equals method works properly across different implementations of the Map.Entry interface.
java.util.AbstractMap: java.util.AbstractMap.SimpleEntry.getKey	(	):  Returns the key corresponding to this entry.
java.util.AbstractMap: java.util.AbstractMap.SimpleEntry.getValue	(	):  Returns the value corresponding to this entry.
java.util.AbstractMap: java.util.AbstractMap.SimpleEntry.hashCode	(	):  Returns the hash code value for this map entry. The hash code of a map entry e is defined to be:  (e.getKey()==null ? 0 : e.getKey().hashCode()) ^ (e.getValue()==null ? 0 : e.getValue().hashCode()) This ensures that e1.equals(e2) implies that e1.hashCode()==e2.hashCode() for any two Entries e1 and e2, as required by the general contract of hashCode.
java.util.AbstractMap: java.util.AbstractMap.SimpleEntry.setValue	(	V	):  Replaces the value corresponding to this entry with the specified value.
java.util.AbstractMap: java.util.AbstractMap.SimpleEntry.toString	(	):  Returns a String representation of this map entry. This implementation returns the string representation of this entry's key followed by the equals character ("=") followed by the string representation of this entry's value.
java.util.AbstractMap: java.util.AbstractMap.SimpleImmutableEntry:  An Entry maintaining an immutable key and value. This class does not support method setValue. This class may be convenient in methods that return thread-safe snapshots of key-value mappings.
java.util.AbstractMap: java.util.AbstractMap.SimpleImmutableEntry.SimpleImmutableEntry	(	Entry	):  Creates an entry representing the same mapping as the specified entry.
java.util.AbstractMap: java.util.AbstractMap.SimpleImmutableEntry.SimpleImmutableEntry	(	K	V	):  Creates an entry representing a mapping from the specified key to the specified value.
java.util.AbstractMap: java.util.AbstractMap.SimpleImmutableEntry.equals	(	Object	):  Compares the specified object with this entry for equality. Returns true if the given object is also a map entry and the two entries represent the same mapping. More formally, two entries e1 and e2 represent the same mapping if (e1.getKey()==null ? e2.getKey()==null : e1.getKey().equals(e2.getKey())) && (e1.getValue()==null ? e2.getValue()==null : e1.getValue().equals(e2.getValue())) This ensures that the equals method works properly across different implementations of the Map.Entry interface.
java.util.AbstractMap: java.util.AbstractMap.SimpleImmutableEntry.getKey	(	):  Returns the key corresponding to this entry.
java.util.AbstractMap: java.util.AbstractMap.SimpleImmutableEntry.getValue	(	):  Returns the value corresponding to this entry.
java.util.AbstractMap: java.util.AbstractMap.SimpleImmutableEntry.hashCode	(	):  Returns the hash code value for this map entry. The hash code of a map entry e is defined to be:  (e.getKey()==null ? 0 : e.getKey().hashCode()) ^ (e.getValue()==null ? 0 : e.getValue().hashCode()) This ensures that e1.equals(e2) implies that e1.hashCode()==e2.hashCode() for any two Entries e1 and e2, as required by the general contract of hashCode.
java.util.AbstractMap: java.util.AbstractMap.SimpleImmutableEntry.setValue	(	V	):  Replaces the value corresponding to this entry with the specified value (optional operation). This implementation simply throws UnsupportedOperationException, as this class implements an immutable map entry.
java.util.AbstractMap: java.util.AbstractMap.SimpleImmutableEntry.toString	(	):  Returns a String representation of this map entry. This implementation returns the string representation of this entry's key followed by the equals character ("=") followed by the string representation of this entry's value.
java.util.AbstractMap: java.util.AbstractMap.clear	(	):  Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.
java.util.AbstractMap: java.util.AbstractMap.clone	(	):  Returns a shallow copy of this AbstractMap instance: the keys and values themselves are not cloned.
java.util.AbstractMap: java.util.AbstractMap.containsKey	(	Object	):  Returns true if this map contains a mapping for the specified key. More formally, returns true if and only if this map contains a mapping for a key k such that (key==null ? k==null : key.equals(k)). (There can be at most one such mapping.)
java.util.AbstractMap: java.util.AbstractMap.containsValue	(	Object	):  Returns true if this map maps one or more keys to the specified value. More formally, returns true if and only if this map contains at least one mapping to a value v such that (value==null ? v==null : value.equals(v)). This operation will probably require time linear in the map size for most implementations of the Map interface.
java.util.AbstractMap: java.util.AbstractMap.eq	(	Object	Object	):  Utility method for SimpleEntry and SimpleImmutableEntry. Test for equality, checking for nulls. NB: Do not replace with Object.equals until JDK-8015417 is resolved.
java.util.AbstractMap: java.util.AbstractMap.equals	(	Object	):  Compares the specified object with this map for equality. Returns true if the given object is also a map and the two maps represent the same mappings. More formally, two maps m1 and m2 represent the same mappings if m1.entrySet().equals(m2.entrySet()). This ensures that the equals method works properly across different implementations of the Map interface.
java.util.AbstractMap: java.util.AbstractMap.get	(	Object	):  Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that (key==null ? k==null : key.equals(k)), then this method returns v; otherwise it returns null. (There can be at most one such mapping.) If this map permits null values, then a return value of null does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to null. The containsKey operation may be used to distinguish these two cases.
java.util.AbstractMap: java.util.AbstractMap.hashCode	(	):  Returns the hash code value for this map. The hash code of a map is defined to be the sum of the hash codes of each entry in the map's entrySet() view. This ensures that m1.equals(m2) implies that m1.hashCode()==m2.hashCode() for any two maps m1 and m2, as required by the general contract of hashCode.
java.util.AbstractMap: java.util.AbstractMap.isEmpty	(	):  Returns true if this map contains no key-value mappings.
java.util.AbstractMap: java.util.AbstractMap.keySet	(	):  Returns a Set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.AbstractMap: java.util.AbstractMap.put	(	K	V	):  Associates the specified value with the specified key in this map (optional operation). If the map previously contained a mapping for the key, the old value is replaced by the specified value. (A map m is said to contain a mapping for a key k if and only if containsKey() m.containsKey(k) would return true.)
java.util.AbstractMap: java.util.AbstractMap.putAll	(	Map	):  Copies all of the mappings from the specified map to this map (optional operation). The effect of this call is equivalent to that of calling put() put(k, v) on this map once for each mapping from key k to value v in the specified map. The behavior of this operation is undefined if the specified map is modified while the operation is in progress.
java.util.AbstractMap: java.util.AbstractMap.remove	(	Object	):  Removes the mapping for a key from this map if it is present (optional operation). More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. If this map permits null values, then a return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.
java.util.AbstractMap: java.util.AbstractMap.size	(	):  Returns the number of key-value mappings in this map. If the map contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
java.util.AbstractMap: java.util.AbstractMap.toString	(	):  Returns a string representation of this map. The string representation consists of a list of key-value mappings in the order returned by the map's entrySet view's iterator, enclosed in braces ("{}"). Adjacent mappings are separated by the characters ", " (comma and space). Each key-value mapping is rendered as the key followed by an equals sign ("=") followed by the associated value. Keys and values are converted to strings as by valueOf().
java.util.AbstractMap: java.util.AbstractMap.values	(	):  Returns a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.Set: java.util.Set:  A collection that contains no duplicate elements. More formally, sets contain no pair of elements e1 and e2 such that e1.equals(e2), and at most one null element. As implied by its name, this interface models the mathematical set abstraction. The Set interface places additional stipulations, beyond those inherited from the Collection interface, on the contracts of all constructors and on the contracts of the add, equals and hashCode methods. Declarations for other inherited methods are also included here for convenience. (The specifications accompanying these declarations have been tailored to the Set interface, but they do not contain any additional stipulations.) The additional stipulation on constructors is, not surprisingly, that all constructors must create a set that contains no duplicate elements (as defined above). Note: Great care must be exercised if mutable objects are used as set elements. The behavior of a set is not specified if the value of an object is changed in a manner that affects equals comparisons while the object is an element in the set. A special case of this prohibition is that it is not permissible for a set to contain itself as an element. Some set implementations have restrictions on the elements that they may contain. For example, some implementations prohibit null elements, and some have restrictions on the types of their elements. Attempting to add an ineligible element throws an unchecked exception, typically NullPointerException or ClassCastException. Attempting to query the presence of an ineligible element may throw an exception, or it may simply return false; some implementations will exhibit the former behavior and some will exhibit the latter. More generally, attempting an operation on an ineligible element whose completion would not result in the insertion of an ineligible element into the set may throw an exception or it may succeed, at the option of the implementation. Such exceptions are marked as "optional" in the specification for this interface. This interface is a member of the  Java Collections Framework.
java.util.Set: java.util.Set.add	(	E	):  Adds the specified element to this set if it is not already present (optional operation). More formally, adds the specified element e to this set if the set contains no element e2 such that (e==null?e2==null:e.equals(e2)). If this set already contains the element, the call leaves the set unchanged and returns false. In combination with the restriction on constructors, this ensures that sets never contain duplicate elements. The stipulation above does not imply that sets must accept all elements; sets may refuse to add any particular element, including null, and throw an exception, as described in the specification for add Collection.add. Individual set implementations should clearly document any restrictions on the elements that they may contain.
java.util.Set: java.util.Set.addAll	(	Collection	):  Adds all of the elements in the specified collection to this set if they're not already present (optional operation). If the specified collection is also a set, the addAll operation effectively modifies this set so that its value is the union of the two sets. The behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.Set: java.util.Set.clear	(	):  Removes all of the elements from this set (optional operation). The set will be empty after this call returns.
java.util.Set: java.util.Set.contains	(	Object	):  Returns true if this set contains the specified element. More formally, returns true if and only if this set contains an element e such that (o==null?e==null:o.equals(e)).
java.util.Set: java.util.Set.containsAll	(	Collection	):  Returns true if this set contains all of the elements of the specified collection. If the specified collection is also a set, this method returns true if it is a subset of this set.
java.util.Set: java.util.Set.equals	(	Object	):  Compares the specified object with this set for equality. Returns true if the specified object is also a set, the two sets have the same size, and every member of the specified set is contained in this set (or equivalently, every member of this set is contained in the specified set). This definition ensures that the equals method works properly across different implementations of the set interface.
java.util.Set: java.util.Set.hashCode	(	):  Returns the hash code value for this set. The hash code of a set is defined to be the sum of the hash codes of the elements in the set, where the hash code of a null element is defined to be zero. This ensures that s1.equals(s2) implies that s1.hashCode()==s2.hashCode() for any two sets s1 and s2, as required by the general contract of hashCode.
java.util.Set: java.util.Set.isEmpty	(	):  Returns true if this set contains no elements.
java.util.Set: java.util.Set.iterator	(	):  Returns an iterator over the elements in this set. The elements are returned in no particular order (unless this set is an instance of some class that provides a guarantee).
java.util.Set: java.util.Set.remove	(	Object	):  Removes the specified element from this set if it is present (optional operation). More formally, removes an element e such that (o==null?e==null:o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)
java.util.Set: java.util.Set.removeAll	(	Collection	):  Removes from this set all of its elements that are contained in the specified collection (optional operation). If the specified collection is also a set, this operation effectively modifies this set so that its value is the asymmetric set difference of the two sets.
java.util.Set: java.util.Set.retainAll	(	Collection	):  Retains only the elements in this set that are contained in the specified collection (optional operation). In other words, removes from this set all of its elements that are not contained in the specified collection. If the specified collection is also a set, this operation effectively modifies this set so that its value is the intersection of the two sets.
java.util.Set: java.util.Set.size	(	):  Returns the number of elements in this set (its cardinality). If this set contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
java.util.Set: java.util.Set.spliterator	(	):  Creates a Spliterator over the elements in this set. The Spliterator reports DISTINCT. Implementations should document the reporting of additional characteristic values.
java.util.Set: java.util.Set.toArray	(	):  Returns an array containing all of the elements in this set. If this set makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. The returned array will be "safe" in that no references to it are maintained by this set. (In other words, this method must allocate a new array even if this set is backed by an array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.Set: java.util.Set.toArray	(	T[]	):  Returns an array containing all of the elements in this set; the runtime type of the returned array is that of the specified array. If the set fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this set. If this set fits in the specified array with room to spare (i.e., the array has more elements than this set), the element in the array immediately following the end of the set is set to null. (This is useful in determining the length of this set only if the caller knows that this set does not contain any null elements.) If this set makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a set known to contain only strings. The following code can be used to dump the set into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.Map: java.util.Map:  An object that maps keys to values. A map cannot contain duplicate keys; each key can map to at most one value. This interface takes the place of the Dictionary class, which was a totally abstract class rather than an interface. The Map interface provides three collection views, which allow a map's contents to be viewed as a set of keys, collection of values, or set of key-value mappings. The order of a map is defined as the order in which the iterators on the map's collection views return their elements. Some map implementations, like the TreeMap class, make specific guarantees as to their order; others, like the HashMap class, do not. Note: great care must be exercised if mutable objects are used as map keys. The behavior of a map is not specified if the value of an object is changed in a manner that affects equals comparisons while the object is a key in the map. A special case of this prohibition is that it is not permissible for a map to contain itself as a key. While it is permissible for a map to contain itself as a value, extreme caution is advised: the equals and hashCode methods are no longer well defined on such a map. All general-purpose map implementation classes should provide two "standard" constructors: a void (no arguments) constructor which creates an empty map, and a constructor with a single argument of type Map, which creates a new map with the same key-value mappings as its argument. In effect, the latter constructor allows the user to copy any map, producing an equivalent map of the desired class. There is no way to enforce this recommendation (as interfaces cannot contain constructors) but all of the general-purpose map implementations in the JDK comply. The "destructive" methods contained in this interface, that is, the methods that modify the map on which they operate, are specified to throw UnsupportedOperationException if this map does not support the operation. If this is the case, these methods may, but are not required to, throw an UnsupportedOperationException if the invocation would have no effect on the map. For example, invoking the putAll() method on an unmodifiable map may, but is not required to, throw the exception if the map whose mappings are to be "superimposed" is empty. Some map implementations have restrictions on the keys and values they may contain. For example, some implementations prohibit null keys and values, and some have restrictions on the types of their keys. Attempting to insert an ineligible key or value throws an unchecked exception, typically NullPointerException or ClassCastException. Attempting to query the presence of an ineligible key or value may throw an exception, or it may simply return false; some implementations will exhibit the former behavior and some will exhibit the latter. More generally, attempting an operation on an ineligible key or value whose completion would not result in the insertion of an ineligible element into the map may throw an exception or it may succeed, at the option of the implementation. Such exceptions are marked as "optional" in the specification for this interface. Many methods in Collections Framework interfaces are defined in terms of the equals() method. For example, the specification for the containsKey() containsKey(Object key) method says: "returns true if and only if this map contains a mapping for a key k such that (key==null ? k==null : key.equals(k))." This specification should not be construed to imply that invoking Map.containsKey with a non-null argument key will cause key.equals(k) to be invoked for any key k. Implementations are free to implement optimizations whereby the equals invocation is avoided, for example, by first comparing the hash codes of the two keys. (The hashCode() specification guarantees that two objects with unequal hash codes cannot be equal.) More generally, implementations of the various Collections Framework interfaces are free to take advantage of the specified behavior of underlying Object methods wherever the implementor deems it appropriate. Some map operations which perform recursive traversal of the map may fail with an exception for self-referential instances where the map directly or indirectly contains itself. This includes the clone(), equals(), hashCode() and toString() methods. Implementations may optionally handle the self-referential scenario, however most current implementations do not do so. This interface is a member of the  Java Collections Framework.
java.util.Map: java.util.Map.Entry:  A map entry (key-value pair). The Map.entrySet method returns a collection-view of the map, whose elements are of this class. The only way to obtain a reference to a map entry is from the iterator of this collection-view. These Map.Entry objects are valid only for the duration of the iteration; more formally, the behavior of a map entry is undefined if the backing map has been modified after the entry was returned by the iterator, except through the setValue operation on the map entry.
java.util.Map: java.util.Map.Entry.comparingByKey	(	):  Returns a comparator that compares Map.Entry in natural order on key. The returned comparator is serializable and throws NullPointerException when comparing an entry with a null key.
java.util.Map: java.util.Map.Entry.comparingByKey	(	Comparator	):  Returns a comparator that compares Map.Entry by key using the given Comparator. The returned comparator is serializable if the specified comparator is also serializable.
java.util.Map: java.util.Map.Entry.comparingByValue	(	):  Returns a comparator that compares Map.Entry in natural order on value. The returned comparator is serializable and throws NullPointerException when comparing an entry with null values.
java.util.Map: java.util.Map.Entry.comparingByValue	(	Comparator	):  Returns a comparator that compares Map.Entry by value using the given Comparator. The returned comparator is serializable if the specified comparator is also serializable.
java.util.Map: java.util.Map.Entry.equals	(	Object	):  Compares the specified object with this entry for equality. Returns true if the given object is also a map entry and the two entries represent the same mapping. More formally, two entries e1 and e2 represent the same mapping if (e1.getKey()==null ? e2.getKey()==null : e1.getKey().equals(e2.getKey())) && (e1.getValue()==null ? e2.getValue()==null : e1.getValue().equals(e2.getValue()))  This ensures that the equals method works properly across different implementations of the Map.Entry interface.
java.util.Map: java.util.Map.Entry.getKey	(	):  Returns the key corresponding to this entry.
java.util.Map: java.util.Map.Entry.getValue	(	):  Returns the value corresponding to this entry. If the mapping has been removed from the backing map (by the iterator's remove operation), the results of this call are undefined.
java.util.Map: java.util.Map.Entry.hashCode	(	):  Returns the hash code value for this map entry. The hash code of a map entry e is defined to be:  (e.getKey()==null ? 0 : e.getKey().hashCode()) ^ (e.getValue()==null ? 0 : e.getValue().hashCode())  This ensures that e1.equals(e2) implies that e1.hashCode()==e2.hashCode() for any two Entries e1 and e2, as required by the general contract of Object.hashCode.
java.util.Map: java.util.Map.Entry.setValue	(	V	):  Replaces the value corresponding to this entry with the specified value (optional operation). (Writes through to the map.) The behavior of this call is undefined if the mapping has already been removed from the map (by the iterator's remove operation).
java.util.Map: java.util.Map.clear	(	):  Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.
java.util.Map: java.util.Map.compute	(	K	BiFunction	):  Attempts to compute a mapping for the specified key and its current mapped value (or null if there is no current mapping). For example, to either create or append a String msg to a value mapping:  map.compute(key, (k, v) -> (v == null) ? msg : v.concat(msg)) (Method merge merge() is often simpler to use for such purposes.) If the function returns null, the mapping is removed (or remains absent if initially absent). If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.
java.util.Map: java.util.Map.computeIfAbsent	(	K	Function	):  If the specified key is not already associated with a value (or is mapped to null), attempts to compute its value using the given mapping function and enters it into this map unless null. If the function returns null no mapping is recorded. If the function itself throws an (unchecked) exception, the exception is rethrown, and no mapping is recorded. The most common usage is to construct a new object serving as an initial mapped value or memoized result, as in:  map.computeIfAbsent(key, k -> new Value(f(k))); Or to implement a multi-value map, Map>, supporting multiple values per key:  map.computeIfAbsent(key, k -> new HashSet()).add(v);
java.util.Map: java.util.Map.computeIfPresent	(	K	BiFunction	):  If the value for the specified key is present and non-null, attempts to compute a new mapping given the key and its current mapped value. If the function returns null, the mapping is removed. If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.
java.util.Map: java.util.Map.containsKey	(	Object	):  Returns true if this map contains a mapping for the specified key. More formally, returns true if and only if this map contains a mapping for a key k such that (key==null ? k==null : key.equals(k)). (There can be at most one such mapping.)
java.util.Map: java.util.Map.containsValue	(	Object	):  Returns true if this map maps one or more keys to the specified value. More formally, returns true if and only if this map contains at least one mapping to a value v such that (value==null ? v==null : value.equals(v)). This operation will probably require time linear in the map size for most implementations of the Map interface.
java.util.Map: java.util.Map.entrySet	(	):  Returns a Set view of the mappings contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation, or through the setValue operation on a map entry returned by the iterator) the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.Map: java.util.Map.equals	(	Object	):  Compares the specified object with this map for equality. Returns true if the given object is also a map and the two maps represent the same mappings. More formally, two maps m1 and m2 represent the same mappings if m1.entrySet().equals(m2.entrySet()). This ensures that the equals method works properly across different implementations of the Map interface.
java.util.Map: java.util.Map.forEach	(	BiConsumer	):  Performs the given action for each entry in this map until all entries have been processed or the action throws an exception. Unless otherwise specified by the implementing class, actions are performed in the order of entry set iteration (if an iteration order is specified.) Exceptions thrown by the action are relayed to the caller.
java.util.Map: java.util.Map.get	(	Object	):  Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that (key==null ? k==null : key.equals(k)), then this method returns v; otherwise it returns null. (There can be at most one such mapping.) If this map permits null values, then a return value of null does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to null. The containsKey operation may be used to distinguish these two cases.
java.util.Map: java.util.Map.getOrDefault	(	Object	V	):  Returns the value to which the specified key is mapped, or defaultValue if this map contains no mapping for the key.
java.util.Map: java.util.Map.hashCode	(	):  Returns the hash code value for this map. The hash code of a map is defined to be the sum of the hash codes of each entry in the map's entrySet() view. This ensures that m1.equals(m2) implies that m1.hashCode()==m2.hashCode() for any two maps m1 and m2, as required by the general contract of hashCode.
java.util.Map: java.util.Map.isEmpty	(	):  Returns true if this map contains no key-value mappings.
java.util.Map: java.util.Map.keySet	(	):  Returns a Set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.Map: java.util.Map.merge	(	K	V	BiFunction	):  If the specified key is not already associated with a value or is associated with null, associates it with the given non-null value. Otherwise, replaces the associated value with the results of the given remapping function, or removes if the result is null. This method may be of use when combining multiple mapped values for a key. For example, to either create or append a String msg to a value mapping:  map.merge(key, msg, String::concat) If the function returns null the mapping is removed. If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.
java.util.Map: java.util.Map.put	(	K	V	):  Associates the specified value with the specified key in this map (optional operation). If the map previously contained a mapping for the key, the old value is replaced by the specified value. (A map m is said to contain a mapping for a key k if and only if containsKey() m.containsKey(k) would return true.)
java.util.Map: java.util.Map.putAll	(	Map	):  Copies all of the mappings from the specified map to this map (optional operation). The effect of this call is equivalent to that of calling put() put(k, v) on this map once for each mapping from key k to value v in the specified map. The behavior of this operation is undefined if the specified map is modified while the operation is in progress.
java.util.Map: java.util.Map.putIfAbsent	(	K	V	):  If the specified key is not already associated with a value (or is mapped to null) associates it with the given value and returns null, else returns the current value.
java.util.Map: java.util.Map.remove	(	Object	):  Removes the mapping for a key from this map if it is present (optional operation). More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. If this map permits null values, then a return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.
java.util.Map: java.util.Map.remove	(	Object	Object	):  Removes the entry for the specified key only if it is currently mapped to the specified value.
java.util.Map: java.util.Map.replace	(	K	V	):  Replaces the entry for the specified key only if it is currently mapped to some value.
java.util.Map: java.util.Map.replace	(	K	V	V	):  Replaces the entry for the specified key only if currently mapped to the specified value.
java.util.Map: java.util.Map.replaceAll	(	BiFunction	):  Replaces each entry's value with the result of invoking the given function on that entry until all entries have been processed or the function throws an exception. Exceptions thrown by the function are relayed to the caller.
java.util.Map: java.util.Map.size	(	):  Returns the number of key-value mappings in this map. If the map contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
java.util.Map: java.util.Map.values	(	):  Returns a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.Deque: java.util.Deque:  A linear collection that supports element insertion and removal at both ends. The name deque is short for "double ended queue" and is usually pronounced "deck". Most Deque implementations place no fixed limits on the number of elements they may contain, but this interface supports capacity-restricted deques as well as those with no fixed size limit. This interface defines methods to access the elements at both ends of the deque. Methods are provided to insert, remove, and examine the element. Each of these methods exists in two forms: one throws an exception if the operation fails, the other returns a special value (either null or false, depending on the operation). The latter form of the insert operation is designed specifically for use with capacity-restricted Deque implementations; in most implementations, insert operations cannot fail. The twelve methods described above are summarized in the following table:  Summary of Deque methods    First Element (Head)  Last Element (Tail)    Throws exception Special value Throws exception Special value   Insert addFirst addFirst(e) offerFirst offerFirst(e) addLast addLast(e) offerLast offerLast(e)   Remove removeFirst removeFirst() pollFirst pollFirst() removeLast removeLast() pollLast pollLast()   Examine getFirst getFirst() peekFirst peekFirst() getLast getLast() peekLast peekLast()   This interface extends the Queue interface. When a deque is used as a queue, FIFO (First-In-First-Out) behavior results. Elements are added at the end of the deque and removed from the beginning. The methods inherited from the Queue interface are precisely equivalent to Deque methods as indicated in the following table:  Comparison of Queue and Deque methods   Queue Method  Equivalent Deque Method   add add(e) addLast addLast(e)   offer offer(e) offerLast offerLast(e)   remove remove() removeFirst removeFirst()   poll poll() pollFirst pollFirst()   element element() getFirst getFirst()   peek peek() peek peekFirst()   Deques can also be used as LIFO (Last-In-First-Out) stacks. This interface should be used in preference to the legacy Stack class. When a deque is used as a stack, elements are pushed and popped from the beginning of the deque. Stack methods are precisely equivalent to Deque methods as indicated in the table below:  Comparison of Stack and Deque methods   Stack Method  Equivalent Deque Method   push push(e) addFirst addFirst(e)   pop pop() removeFirst removeFirst()   peek peek() peekFirst peekFirst()   Note that the peek method works equally well when a deque is used as a queue or a stack; in either case, elements are drawn from the beginning of the deque. This interface provides two methods to remove interior elements, removeFirstOccurrence and removeLastOccurrence. Unlike the List interface, this interface does not provide support for indexed access to elements. While Deque implementations are not strictly required to prohibit the insertion of null elements, they are strongly encouraged to do so. Users of any Deque implementations that do allow null elements are strongly encouraged not to take advantage of the ability to insert nulls. This is so because null is used as a special return value by various methods to indicated that the deque is empty. Deque implementations generally do not define element-based versions of the equals and hashCode methods, but instead inherit the identity-based versions from class Object. This interface is a member of the  Java Collections Framework.
java.util.Deque: java.util.Deque.add	(	E	):  Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque) if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an IllegalStateException if no space is currently available. When using a capacity-restricted deque, it is generally preferable to use offer(). This method is equivalent to addLast.
java.util.Deque: java.util.Deque.addFirst	(	E	):  Inserts the specified element at the front of this deque if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available. When using a capacity-restricted deque, it is generally preferable to use method offerFirst.
java.util.Deque: java.util.Deque.addLast	(	E	):  Inserts the specified element at the end of this deque if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available. When using a capacity-restricted deque, it is generally preferable to use method offerLast. This method is equivalent to add.
java.util.Deque: java.util.Deque.contains	(	Object	):  Returns true if this deque contains the specified element. More formally, returns true if and only if this deque contains at least one element e such that (o==null?e==null:o.equals(e)).
java.util.Deque: java.util.Deque.descendingIterator	(	):  Returns an iterator over the elements in this deque in reverse sequential order. The elements will be returned in order from last (tail) to first (head).
java.util.Deque: java.util.Deque.element	(	):  Retrieves, but does not remove, the head of the queue represented by this deque (in other words, the first element of this deque). This method differs from peek only in that it throws an exception if this deque is empty. This method is equivalent to getFirst().
java.util.Deque: java.util.Deque.getFirst	(	):  Retrieves, but does not remove, the first element of this deque. This method differs from peekFirst only in that it throws an exception if this deque is empty.
java.util.Deque: java.util.Deque.getLast	(	):  Retrieves, but does not remove, the last element of this deque. This method differs from peekLast only in that it throws an exception if this deque is empty.
java.util.Deque: java.util.Deque.iterator	(	):  Returns an iterator over the elements in this deque in proper sequence. The elements will be returned in order from first (head) to last (tail).
java.util.Deque: java.util.Deque.offer	(	E	):  Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque) if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available. When using a capacity-restricted deque, this method is generally preferable to the add method, which can fail to insert an element only by throwing an exception. This method is equivalent to offerLast.
java.util.Deque: java.util.Deque.offerFirst	(	E	):  Inserts the specified element at the front of this deque unless it would violate capacity restrictions. When using a capacity-restricted deque, this method is generally preferable to the addFirst method, which can fail to insert an element only by throwing an exception.
java.util.Deque: java.util.Deque.offerLast	(	E	):  Inserts the specified element at the end of this deque unless it would violate capacity restrictions. When using a capacity-restricted deque, this method is generally preferable to the addLast method, which can fail to insert an element only by throwing an exception.
java.util.Deque: java.util.Deque.peek	(	):  Retrieves, but does not remove, the head of the queue represented by this deque (in other words, the first element of this deque), or returns null if this deque is empty. This method is equivalent to peekFirst().
java.util.Deque: java.util.Deque.peekFirst	(	):  Retrieves, but does not remove, the first element of this deque, or returns null if this deque is empty.
java.util.Deque: java.util.Deque.peekLast	(	):  Retrieves, but does not remove, the last element of this deque, or returns null if this deque is empty.
java.util.Deque: java.util.Deque.poll	(	):  Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque), or returns null if this deque is empty. This method is equivalent to pollFirst().
java.util.Deque: java.util.Deque.pollFirst	(	):  Retrieves and removes the first element of this deque, or returns null if this deque is empty.
java.util.Deque: java.util.Deque.pollLast	(	):  Retrieves and removes the last element of this deque, or returns null if this deque is empty.
java.util.Deque: java.util.Deque.pop	(	):  Pops an element from the stack represented by this deque. In other words, removes and returns the first element of this deque. This method is equivalent to removeFirst().
java.util.Deque: java.util.Deque.push	(	E	):  Pushes an element onto the stack represented by this deque (in other words, at the head of this deque) if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available. This method is equivalent to addFirst.
java.util.Deque: java.util.Deque.remove	(	):  Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque). This method differs from poll only in that it throws an exception if this deque is empty. This method is equivalent to removeFirst().
java.util.Deque: java.util.Deque.remove	(	Object	):  Removes the first occurrence of the specified element from this deque. If the deque does not contain the element, it is unchanged. More formally, removes the first element e such that (o==null?e==null:o.equals(e)) (if such an element exists). Returns true if this deque contained the specified element (or equivalently, if this deque changed as a result of the call). This method is equivalent to removeFirstOccurrence().
java.util.Deque: java.util.Deque.removeFirst	(	):  Retrieves and removes the first element of this deque. This method differs from pollFirst only in that it throws an exception if this deque is empty.
java.util.Deque: java.util.Deque.removeFirstOccurrence	(	Object	):  Removes the first occurrence of the specified element from this deque. If the deque does not contain the element, it is unchanged. More formally, removes the first element e such that (o==null?e==null:o.equals(e)) (if such an element exists). Returns true if this deque contained the specified element (or equivalently, if this deque changed as a result of the call).
java.util.Deque: java.util.Deque.removeLast	(	):  Retrieves and removes the last element of this deque. This method differs from pollLast only in that it throws an exception if this deque is empty.
java.util.Deque: java.util.Deque.removeLastOccurrence	(	Object	):  Removes the last occurrence of the specified element from this deque. If the deque does not contain the element, it is unchanged. More formally, removes the last element e such that (o==null?e==null:o.equals(e)) (if such an element exists). Returns true if this deque contained the specified element (or equivalently, if this deque changed as a result of the call).
java.util.Deque: java.util.Deque.size	(	):  Returns the number of elements in this deque.
java.util.LinkedList: java.util.LinkedList:  Doubly-linked list implementation of the List and Deque interfaces. Implements all optional list operations, and permits all elements (including null). All of the operations perform as could be expected for a doubly-linked list. Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index. Note that this implementation is not synchronized. If multiple threads access a linked list concurrently, and at least one of the threads modifies the list structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more elements; merely setting the value of an element is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the list. If no such object exists, the list should be "wrapped" using the synchronizedList Collections.synchronizedList method. This is best done at creation time, to prevent accidental unsynchronized access to the list: List list = Collections.synchronizedList(new LinkedList(...)); The iterators returned by this class's iterator and listIterator methods are fail-fast: if the list is structurally modified at any time after the iterator is created, in any way except through the Iterator's own remove or add methods, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. This class is a member of the  Java Collections Framework.
java.util.LinkedList: java.util.LinkedList.DescendingIterator:  Adapter to provide descending iterators via ListItr.previous
java.util.LinkedList: java.util.LinkedList.LLSpliterator:  A customized variant of Spliterators.IteratorSpliterator 
java.util.LinkedList: java.util.LinkedList.LinkedList	(	):  Constructs an empty list.
java.util.LinkedList: java.util.LinkedList.LinkedList	(	Collection	):  Constructs a list containing the elements of the specified collection, in the order they are returned by the collection's iterator.
java.util.LinkedList: java.util.LinkedList.add	(	E	):  Appends the specified element to the end of this list. This method is equivalent to addLast.
java.util.LinkedList: java.util.LinkedList.add	(	int	E	):  Inserts the specified element at the specified position in this list. Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices).
java.util.LinkedList: java.util.LinkedList.addAll	(	Collection	):  Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's iterator. The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (Note that this will occur if the specified collection is this list, and it's nonempty.)
java.util.LinkedList: java.util.LinkedList.addAll	(	int	Collection	):  Inserts all of the elements in the specified collection into this list, starting at the specified position. Shifts the element currently at that position (if any) and any subsequent elements to the right (increases their indices). The new elements will appear in the list in the order that they are returned by the specified collection's iterator.
java.util.LinkedList: java.util.LinkedList.addFirst	(	E	):  Inserts the specified element at the beginning of this list.
java.util.LinkedList: java.util.LinkedList.addLast	(	E	):  Appends the specified element to the end of this list. This method is equivalent to add.
java.util.LinkedList: java.util.LinkedList.clear	(	):  Removes all of the elements from this list. The list will be empty after this call returns.
java.util.LinkedList: java.util.LinkedList.clone	(	):  Returns a shallow copy of this LinkedList. (The elements themselves are not cloned.)
java.util.LinkedList: java.util.LinkedList.contains	(	Object	):  Returns true if this list contains the specified element. More formally, returns true if and only if this list contains at least one element e such that (o==null?e==null:o.equals(e)).
java.util.LinkedList: java.util.LinkedList.descendingIterator	(	):  Returns an iterator over the elements in this deque in reverse sequential order. The elements will be returned in order from last (tail) to first (head).
java.util.LinkedList: java.util.LinkedList.element	(	):  Retrieves, but does not remove, the head (first element) of this list.
java.util.LinkedList: java.util.LinkedList.get	(	int	):  Returns the element at the specified position in this list.
java.util.LinkedList: java.util.LinkedList.getFirst	(	):  Returns the first element in this list.
java.util.LinkedList: java.util.LinkedList.getLast	(	):  Returns the last element in this list.
java.util.LinkedList: java.util.LinkedList.indexOf	(	Object	):  Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the lowest index i such that (o==null?get(i)==null:o.equals(get(i))), or -1 if there is no such index.
java.util.LinkedList: java.util.LinkedList.isElementIndex	(	int	):  Tells if the argument is the index of an existing element.
java.util.LinkedList: java.util.LinkedList.isPositionIndex	(	int	):  Tells if the argument is the index of a valid position for an iterator or an add operation.
java.util.LinkedList: java.util.LinkedList.lastIndexOf	(	Object	):  Returns the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the highest index i such that (o==null?get(i)==null:o.equals(get(i))), or -1 if there is no such index.
java.util.LinkedList: java.util.LinkedList.linkBefore	(	E	Node	):  Inserts element e before non-null Node succ.
java.util.LinkedList: java.util.LinkedList.linkFirst	(	E	):  Links e as first element.
java.util.LinkedList: java.util.LinkedList.linkLast	(	E	):  Links e as last element.
java.util.LinkedList: java.util.LinkedList.listIterator	(	int	):  Returns a list-iterator of the elements in this list (in proper sequence), starting at the specified position in the list. Obeys the general contract of List.listIterator(int). The list-iterator is fail-fast: if the list is structurally modified at any time after the Iterator is created, in any way except through the list-iterator's own remove or add methods, the list-iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.
java.util.LinkedList: java.util.LinkedList.node	(	int	):  Returns the (non-null) Node at the specified element index.
java.util.LinkedList: java.util.LinkedList.offer	(	E	):  Adds the specified element as the tail (last element) of this list.
java.util.LinkedList: java.util.LinkedList.offerFirst	(	E	):  Inserts the specified element at the front of this list.
java.util.LinkedList: java.util.LinkedList.offerLast	(	E	):  Inserts the specified element at the end of this list.
java.util.LinkedList: java.util.LinkedList.outOfBoundsMsg	(	int	):  Constructs an IndexOutOfBoundsException detail message. Of the many possible refactorings of the error handling code, this "outlining" performs best with both server and client VMs.
java.util.LinkedList: java.util.LinkedList.peek	(	):  Retrieves, but does not remove, the head (first element) of this list.
java.util.LinkedList: java.util.LinkedList.peekFirst	(	):  Retrieves, but does not remove, the first element of this list, or returns null if this list is empty.
java.util.LinkedList: java.util.LinkedList.peekLast	(	):  Retrieves, but does not remove, the last element of this list, or returns null if this list is empty.
java.util.LinkedList: java.util.LinkedList.poll	(	):  Retrieves and removes the head (first element) of this list.
java.util.LinkedList: java.util.LinkedList.pollFirst	(	):  Retrieves and removes the first element of this list, or returns null if this list is empty.
java.util.LinkedList: java.util.LinkedList.pollLast	(	):  Retrieves and removes the last element of this list, or returns null if this list is empty.
java.util.LinkedList: java.util.LinkedList.pop	(	):  Pops an element from the stack represented by this list. In other words, removes and returns the first element of this list. This method is equivalent to removeFirst().
java.util.LinkedList: java.util.LinkedList.push	(	E	):  Pushes an element onto the stack represented by this list. In other words, inserts the element at the front of this list. This method is equivalent to addFirst.
java.util.LinkedList: java.util.LinkedList.readObject	(	java.io.ObjectInputStream	):  Reconstitutes this LinkedList instance from a stream (that is, deserializes it).
java.util.LinkedList: java.util.LinkedList.remove	(	):  Retrieves and removes the head (first element) of this list.
java.util.LinkedList: java.util.LinkedList.remove	(	Object	):  Removes the first occurrence of the specified element from this list, if it is present. If this list does not contain the element, it is unchanged. More formally, removes the element with the lowest index i such that (o==null?get(i)==null:o.equals(get(i))) (if such an element exists). Returns true if this list contained the specified element (or equivalently, if this list changed as a result of the call).
java.util.LinkedList: java.util.LinkedList.remove	(	int	):  Removes the element at the specified position in this list. Shifts any subsequent elements to the left (subtracts one from their indices). Returns the element that was removed from the list.
java.util.LinkedList: java.util.LinkedList.removeFirst	(	):  Removes and returns the first element from this list.
java.util.LinkedList: java.util.LinkedList.removeFirstOccurrence	(	Object	):  Removes the first occurrence of the specified element in this list (when traversing the list from head to tail). If the list does not contain the element, it is unchanged.
java.util.LinkedList: java.util.LinkedList.removeLast	(	):  Removes and returns the last element from this list.
java.util.LinkedList: java.util.LinkedList.removeLastOccurrence	(	Object	):  Removes the last occurrence of the specified element in this list (when traversing the list from head to tail). If the list does not contain the element, it is unchanged.
java.util.LinkedList: java.util.LinkedList.set	(	int	E	):  Replaces the element at the specified position in this list with the specified element.
java.util.LinkedList: java.util.LinkedList.size	(	):  Returns the number of elements in this list.
java.util.LinkedList: java.util.LinkedList.spliterator	(	):  Creates a late-binding and fail-fast Spliterator over the elements in this list. The Spliterator reports SIZED and ORDERED. Overriding implementations should document the reporting of additional characteristic values.
java.util.LinkedList: java.util.LinkedList.toArray	(	):  Returns an array containing all of the elements in this list in proper sequence (from first to last element). The returned array will be "safe" in that no references to it are maintained by this list. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.LinkedList: java.util.LinkedList.toArray	(	T[]	):  Returns an array containing all of the elements in this list in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array. If the list fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this list. If the list fits in the specified array with room to spare (i.e., the array has more elements than the list), the element in the array immediately following the end of the list is set to null. (This is useful in determining the length of the list only if the caller knows that the list does not contain any null elements.) Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a list known to contain only strings. The following code can be used to dump the list into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.LinkedList: java.util.LinkedList.unlink	(	Node	):  Unlinks non-null node x.
java.util.LinkedList: java.util.LinkedList.unlinkFirst	(	Node	):  Unlinks non-null first node f.
java.util.LinkedList: java.util.LinkedList.unlinkLast	(	Node	):  Unlinks non-null last node l.
java.util.LinkedList: java.util.LinkedList.writeObject	(	java.io.ObjectOutputStream	):  Saves the state of this LinkedList instance to a stream (that is, serializes it).
java.util.ArrayDeque: java.util.ArrayDeque:  Resizable-array implementation of the Deque interface. Array deques have no capacity restrictions; they grow as necessary to support usage. They are not thread-safe; in the absence of external synchronization, they do not support concurrent access by multiple threads. Null elements are prohibited. This class is likely to be faster than Stack when used as a stack, and faster than LinkedList when used as a queue. Most ArrayDeque operations run in amortized constant time. Exceptions include remove(), removeFirstOccurrence, removeLastOccurrence , contains, iterator iterator.remove(), and the bulk operations, all of which run in linear time. The iterators returned by this class's iterator method are fail-fast: If the deque is modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will generally throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces. This class is a member of the  Java Collections Framework.
java.util.ArrayDeque: java.util.ArrayDeque.ArrayDeque	(	):  Constructs an empty array deque with an initial capacity sufficient to hold 16 elements.
java.util.ArrayDeque: java.util.ArrayDeque.ArrayDeque	(	Collection	):  Constructs a deque containing the elements of the specified collection, in the order they are returned by the collection's iterator. (The first element returned by the collection's iterator becomes the first element, or front of the deque.)
java.util.ArrayDeque: java.util.ArrayDeque.ArrayDeque	(	int	):  Constructs an empty array deque with an initial capacity sufficient to hold the specified number of elements.
java.util.ArrayDeque: java.util.ArrayDeque.DeqSpliterator.DeqSpliterator	(	ArrayDeque	int	int	):  Creates new spliterator covering the given array and range 
java.util.ArrayDeque: java.util.ArrayDeque.add	(	E	):  Inserts the specified element at the end of this deque. This method is equivalent to addLast.
java.util.ArrayDeque: java.util.ArrayDeque.addFirst	(	E	):  Inserts the specified element at the front of this deque.
java.util.ArrayDeque: java.util.ArrayDeque.addLast	(	E	):  Inserts the specified element at the end of this deque. This method is equivalent to add.
java.util.ArrayDeque: java.util.ArrayDeque.allocateElements	(	int	):  Allocates empty array to hold the given number of elements.
java.util.ArrayDeque: java.util.ArrayDeque.clear	(	):  Removes all of the elements from this deque. The deque will be empty after this call returns.
java.util.ArrayDeque: java.util.ArrayDeque.clone	(	):  Returns a copy of this deque.
java.util.ArrayDeque: java.util.ArrayDeque.contains	(	Object	):  Returns true if this deque contains the specified element. More formally, returns true if and only if this deque contains at least one element e such that o.equals(e).
java.util.ArrayDeque: java.util.ArrayDeque.copyElements	(	T[]	):  Copies the elements from our element array into the specified array, in order (from first to last element in the deque). It is assumed that the array is large enough to hold all elements in the deque.
java.util.ArrayDeque: java.util.ArrayDeque.delete	(	int	):  Removes the element at the specified position in the elements array, adjusting head and tail as necessary. This can result in motion of elements backwards or forwards in the array. This method is called delete rather than remove to emphasize that its semantics differ from those of remove().
java.util.ArrayDeque: java.util.ArrayDeque.doubleCapacity	(	):  Doubles the capacity of this deque. Call only when full, i.e., when head and tail have wrapped around to become equal.
java.util.ArrayDeque: java.util.ArrayDeque.element	(	):  Retrieves, but does not remove, the head of the queue represented by this deque. This method differs from peek only in that it throws an exception if this deque is empty. This method is equivalent to getFirst.
java.util.ArrayDeque: java.util.ArrayDeque.getFirst	(	):  Retrieves, but does not remove, the first element of this deque. This method differs from peekFirst only in that it throws an exception if this deque is empty.
java.util.ArrayDeque: java.util.ArrayDeque.getLast	(	):  Retrieves, but does not remove, the last element of this deque. This method differs from peekLast only in that it throws an exception if this deque is empty.
java.util.ArrayDeque: java.util.ArrayDeque.isEmpty	(	):  Returns true if this deque contains no elements.
java.util.ArrayDeque: java.util.ArrayDeque.iterator	(	):  Returns an iterator over the elements in this deque. The elements will be ordered from first (head) to last (tail). This is the same order that elements would be dequeued (via successive calls to remove or popped (via successive calls to pop).
java.util.ArrayDeque: java.util.ArrayDeque.offer	(	E	):  Inserts the specified element at the end of this deque. This method is equivalent to offerLast.
java.util.ArrayDeque: java.util.ArrayDeque.offerFirst	(	E	):  Inserts the specified element at the front of this deque.
java.util.ArrayDeque: java.util.ArrayDeque.offerLast	(	E	):  Inserts the specified element at the end of this deque.
java.util.ArrayDeque: java.util.ArrayDeque.peek	(	):  Retrieves, but does not remove, the head of the queue represented by this deque, or returns null if this deque is empty. This method is equivalent to peekFirst.
java.util.ArrayDeque: java.util.ArrayDeque.poll	(	):  Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque), or returns null if this deque is empty. This method is equivalent to pollFirst.
java.util.ArrayDeque: java.util.ArrayDeque.pop	(	):  Pops an element from the stack represented by this deque. In other words, removes and returns the first element of this deque. This method is equivalent to removeFirst().
java.util.ArrayDeque: java.util.ArrayDeque.push	(	E	):  Pushes an element onto the stack represented by this deque. In other words, inserts the element at the front of this deque. This method is equivalent to addFirst.
java.util.ArrayDeque: java.util.ArrayDeque.readObject	(	java.io.ObjectInputStream	):  Reconstitutes this deque from a stream (that is, deserializes it).
java.util.ArrayDeque: java.util.ArrayDeque.remove	(	):  Retrieves and removes the head of the queue represented by this deque. This method differs from poll only in that it throws an exception if this deque is empty. This method is equivalent to removeFirst.
java.util.ArrayDeque: java.util.ArrayDeque.remove	(	Object	):  Removes a single instance of the specified element from this deque. If the deque does not contain the element, it is unchanged. More formally, removes the first element e such that o.equals(e) (if such an element exists). Returns true if this deque contained the specified element (or equivalently, if this deque changed as a result of the call). This method is equivalent to removeFirstOccurrence().
java.util.ArrayDeque: java.util.ArrayDeque.removeFirst	(	):  Retrieves and removes the first element of this deque. This method differs from pollFirst only in that it throws an exception if this deque is empty.
java.util.ArrayDeque: java.util.ArrayDeque.removeFirstOccurrence	(	Object	):  Removes the first occurrence of the specified element in this deque (when traversing the deque from head to tail). If the deque does not contain the element, it is unchanged. More formally, removes the first element e such that o.equals(e) (if such an element exists). Returns true if this deque contained the specified element (or equivalently, if this deque changed as a result of the call).
java.util.ArrayDeque: java.util.ArrayDeque.removeLast	(	):  Retrieves and removes the last element of this deque. This method differs from pollLast only in that it throws an exception if this deque is empty.
java.util.ArrayDeque: java.util.ArrayDeque.removeLastOccurrence	(	Object	):  Removes the last occurrence of the specified element in this deque (when traversing the deque from head to tail). If the deque does not contain the element, it is unchanged. More formally, removes the last element e such that o.equals(e) (if such an element exists). Returns true if this deque contained the specified element (or equivalently, if this deque changed as a result of the call).
java.util.ArrayDeque: java.util.ArrayDeque.size	(	):  Returns the number of elements in this deque.
java.util.ArrayDeque: java.util.ArrayDeque.spliterator	(	):  Creates a late-binding and fail-fast Spliterator over the elements in this deque. The Spliterator reports SIZED, SUBSIZED, ORDERED, and NONNULL. Overriding implementations should document the reporting of additional characteristic values.
java.util.ArrayDeque: java.util.ArrayDeque.toArray	(	):  Returns an array containing all of the elements in this deque in proper sequence (from first to last element). The returned array will be "safe" in that no references to it are maintained by this deque. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.ArrayDeque: java.util.ArrayDeque.toArray	(	T[]	):  Returns an array containing all of the elements in this deque in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array. If the deque fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this deque. If this deque fits in the specified array with room to spare (i.e., the array has more elements than this deque), the element in the array immediately following the end of the deque is set to null. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a deque known to contain only strings. The following code can be used to dump the deque into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.ArrayDeque: java.util.ArrayDeque.writeObject	(	java.io.ObjectOutputStream	):  Saves this deque to a stream (that is, serializes it).
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque:  An optionally-bounded BlockingDeque blocking deque based on linked nodes. The optional capacity bound constructor argument serves as a way to prevent excessive expansion. The capacity, if unspecified, is equal to MAX_VALUE. Linked nodes are dynamically created upon each insertion unless this would bring the deque above capacity. Most operations run in constant time (ignoring time spent blocking). Exceptions include remove(), removeFirstOccurrence, removeLastOccurrence, contains , iterator iterator.remove(), and the bulk operations, all of which run in linear time. This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces. This class is a member of the  Java Collections Framework.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.AbstractItr:  Base class for Iterators for LinkedBlockingDeque
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.AbstractItr.advance	(	):  Advances next.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.AbstractItr.succ	(	Node	):  Returns the successor node of the given non-null, but possibly previously deleted, node.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.DescendingItr:  Descending iterator 
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.Itr:  Forward iterator 
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.LBDSpliterator:  A customized variant of Spliterators.IteratorSpliterator 
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.LinkedBlockingDeque	(	):  Creates a LinkedBlockingDeque with a capacity of MAX_VALUE.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.LinkedBlockingDeque	(	Collection	):  Creates a LinkedBlockingDeque with a capacity of MAX_VALUE, initially containing the elements of the given collection, added in traversal order of the collection's iterator.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.LinkedBlockingDeque	(	int	):  Creates a LinkedBlockingDeque with the given (fixed) capacity.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.Node:  Doubly-linked list node class 
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.add	(	E	):  Inserts the specified element at the end of this deque unless it would violate capacity restrictions. When using a capacity-restricted deque, it is generally preferable to use method offer(). This method is equivalent to addLast.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.addFirst	(	E	):  Inserts the specified element at the front of this deque if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available. When using a capacity-restricted deque, it is generally preferable to use offerFirst().
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.addLast	(	E	):  Inserts the specified element at the end of this deque if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available. When using a capacity-restricted deque, it is generally preferable to use offerLast().
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.clear	(	):  Atomically removes all of the elements from this deque. The deque will be empty after this call returns.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.contains	(	Object	):  Returns true if this deque contains the specified element. More formally, returns true if and only if this deque contains at least one element e such that o.equals(e).
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.descendingIterator	(	):  Returns an iterator over the elements in this deque in reverse sequential order. The elements will be returned in order from last (tail) to first (head). The returned iterator is weakly consistent.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.drainTo	(	Collection	):  Removes all available elements from this queue and adds them to the given collection. This operation may be more efficient than repeatedly polling this queue. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.drainTo	(	Collection	int	):  Removes at most the given number of available elements from this queue and adds them to the given collection. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.element	(	):  Retrieves, but does not remove, the head of the queue represented by this deque. This method differs from peek only in that it throws an exception if this deque is empty. This method is equivalent to getFirst().
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.getFirst	(	):  Retrieves, but does not remove, the first element of this deque. This method differs from peekFirst only in that it throws an exception if this deque is empty.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.getLast	(	):  Retrieves, but does not remove, the last element of this deque. This method differs from peekLast only in that it throws an exception if this deque is empty.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.iterator	(	):  Returns an iterator over the elements in this deque in proper sequence. The elements will be returned in order from first (head) to last (tail). The returned iterator is weakly consistent.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.linkFirst	(	Node	):  Links node as first element, or returns false if full.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.linkLast	(	Node	):  Links node as last element, or returns false if full.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.offer	(	E	):  Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions. When using a capacity-restricted queue, this method is generally preferable to add, which can fail to insert an element only by throwing an exception.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.offer	(	E	long	TimeUnit	):  Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque), waiting up to the specified wait time if necessary for space to become available. This method is equivalent to offerLast().
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.offerFirst	(	E	):  Inserts the specified element at the front of this deque if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available. When using a capacity-restricted deque, this method is generally preferable to the addFirst() method, which can fail to insert an element only by throwing an exception.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.offerFirst	(	E	long	TimeUnit	):  Inserts the specified element at the front of this deque, waiting up to the specified wait time if necessary for space to become available.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.offerLast	(	E	):  Inserts the specified element at the end of this deque if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available. When using a capacity-restricted deque, this method is generally preferable to the addLast() method, which can fail to insert an element only by throwing an exception.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.offerLast	(	E	long	TimeUnit	):  Inserts the specified element at the end of this deque, waiting up to the specified wait time if necessary for space to become available.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.pop	(	):  Pops an element from the stack represented by this deque. In other words, removes and returns the first element of this deque. This method is equivalent to removeFirst().
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.push	(	E	):  Pushes an element onto the stack represented by this deque (in other words, at the head of this deque) if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available. This method is equivalent to addFirst().
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.put	(	E	):  Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque), waiting if necessary for space to become available. This method is equivalent to putLast().
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.putFirst	(	E	):  Inserts the specified element at the front of this deque, waiting if necessary for space to become available.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.putLast	(	E	):  Inserts the specified element at the end of this deque, waiting if necessary for space to become available.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.readObject	(	java.io.ObjectInputStream	):  Reconstitutes this deque from a stream (that is, deserializes it).
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.remainingCapacity	(	):  Returns the number of additional elements that this deque can ideally (in the absence of memory or resource constraints) accept without blocking. This is always equal to the initial capacity of this deque less the current size of this deque. Note that you cannot always tell if an attempt to insert an element will succeed by inspecting remainingCapacity because it may be the case that another thread is about to insert or remove an element.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.remove	(	):  Retrieves and removes the head of the queue represented by this deque. This method differs from poll only in that it throws an exception if this deque is empty. This method is equivalent to removeFirst().
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.remove	(	Object	):  Removes the first occurrence of the specified element from this deque. If the deque does not contain the element, it is unchanged. More formally, removes the first element e such that o.equals(e) (if such an element exists). Returns true if this deque contained the specified element (or equivalently, if this deque changed as a result of the call). This method is equivalent to removeFirstOccurrence().
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.removeFirst	(	):  Retrieves and removes the first element of this deque. This method differs from pollFirst only in that it throws an exception if this deque is empty.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.removeLast	(	):  Retrieves and removes the last element of this deque. This method differs from pollLast only in that it throws an exception if this deque is empty.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.size	(	):  Returns the number of elements in this deque.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.spliterator	(	):  Returns a Spliterator over the elements in this deque. The returned spliterator is weakly consistent. The Spliterator reports CONCURRENT, ORDERED, and NONNULL.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.toArray	(	):  Returns an array containing all of the elements in this deque, in proper sequence (from first to last element). The returned array will be "safe" in that no references to it are maintained by this deque. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.toArray	(	T[]	):  Returns an array containing all of the elements in this deque, in proper sequence; the runtime type of the returned array is that of the specified array. If the deque fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this deque. If this deque fits in the specified array with room to spare (i.e., the array has more elements than this deque), the element in the array immediately following the end of the deque is set to null. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a deque known to contain only strings. The following code can be used to dump the deque into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.unlink	(	Node	):  Unlinks x.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.unlinkFirst	(	):  Removes and returns first element, or null if empty.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.unlinkLast	(	):  Removes and returns last element, or null if empty.
java.util.concurrent.LinkedBlockingDeque: java.util.concurrent.LinkedBlockingDeque.writeObject	(	java.io.ObjectOutputStream	):  Saves this deque to a stream (that is, serializes it).
java.util.concurrent.BlockingQueue: java.util.concurrent.BlockingQueue:  A java.util.Queue that additionally supports operations that wait for the queue to become non-empty when retrieving an element, and wait for space to become available in the queue when storing an element. BlockingQueue methods come in four forms, with different ways of handling operations that cannot be satisfied immediately, but may be satisfied at some point in the future: one throws an exception, the second returns a special value (either null or false, depending on the operation), the third blocks the current thread indefinitely until the operation can succeed, and the fourth blocks for only a given maximum time limit before giving up. These methods are summarized in the following table:  Summary of BlockingQueue methods   Throws exception Special value Blocks Times out   Insert add add(e) offer offer(e) put put(e) offer() offer(e, time, unit)   Remove remove remove() poll poll() take take() poll() poll(time, unit)   Examine element element() peek peek() not applicable not applicable   A BlockingQueue does not accept null elements. Implementations throw NullPointerException on attempts to add, put or offer a null. A null is used as a sentinel value to indicate failure of poll operations. A BlockingQueue may be capacity bounded. At any given time it may have a remainingCapacity beyond which no additional elements can be put without blocking. A BlockingQueue without any intrinsic capacity constraints always reports a remaining capacity of Integer.MAX_VALUE. BlockingQueue implementations are designed to be used primarily for producer-consumer queues, but additionally support the java.util.Collection interface. So, for example, it is possible to remove an arbitrary element from a queue using remove(x). However, such operations are in general not performed very efficiently, and are intended for only occasional use, such as when a queued message is cancelled. BlockingQueue implementations are thread-safe. All queuing methods achieve their effects atomically using internal locks or other forms of concurrency control. However, the bulk Collection operations addAll, containsAll, retainAll and removeAll are not necessarily performed atomically unless specified otherwise in an implementation. So it is possible, for example, for addAll(c) to fail (throwing an exception) after adding only some of the elements in c. A BlockingQueue does not intrinsically support any kind of "close" or "shutdown" operation to indicate that no more items will be added. The needs and usage of such features tend to be implementation-dependent. For example, a common tactic is for producers to insert special end-of-stream or poison objects, that are interpreted accordingly when taken by consumers.  Usage example, based on a typical producer-consumer scenario. Note that a BlockingQueue can safely be used with multiple producers and multiple consumers.  class Producer implements Runnable private final BlockingQueue queue; Producer(BlockingQueue q) { queue = q; } public void run() { try { while (true) { queue.put(produce()); } } catch (InterruptedException ex) { ... handle ...} } Object produce() { ... } } class Consumer implements Runnable { private final BlockingQueue queue; Consumer(BlockingQueue q) { queue = q; } public void run() { try { while (true) { consume(queue.take()); } } catch (InterruptedException ex) { ... handle ...} } void consume(Object x) { ... } } class Setup { void main() { BlockingQueue q = new SomeQueueImplementation(); Producer p = new Producer(q); Consumer c1 = new Consumer(q); Consumer c2 = new Consumer(q); new Thread(p).start(); new Thread(c1).start(); new Thread(c2).start(); } }} Memory consistency effects: As with other concurrent collections, actions in a thread prior to placing an object into a BlockingQueue happen-before actions subsequent to the access or removal of that element from the BlockingQueue in another thread. This interface is a member of the  Java Collections Framework.
java.util.concurrent.BlockingQueue: java.util.concurrent.BlockingQueue.add	(	E	):  Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an IllegalStateException if no space is currently available. When using a capacity-restricted queue, it is generally preferable to use offer().
java.util.concurrent.BlockingQueue: java.util.concurrent.BlockingQueue.contains	(	Object	):  Returns true if this queue contains the specified element. More formally, returns true if and only if this queue contains at least one element e such that o.equals(e).
java.util.concurrent.BlockingQueue: java.util.concurrent.BlockingQueue.drainTo	(	Collection	):  Removes all available elements from this queue and adds them to the given collection. This operation may be more efficient than repeatedly polling this queue. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.BlockingQueue: java.util.concurrent.BlockingQueue.drainTo	(	Collection	int	):  Removes at most the given number of available elements from this queue and adds them to the given collection. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.BlockingQueue: java.util.concurrent.BlockingQueue.offer	(	E	):  Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available. When using a capacity-restricted queue, this method is generally preferable to add, which can fail to insert an element only by throwing an exception.
java.util.concurrent.BlockingQueue: java.util.concurrent.BlockingQueue.offer	(	E	long	TimeUnit	):  Inserts the specified element into this queue, waiting up to the specified wait time if necessary for space to become available.
java.util.concurrent.BlockingQueue: java.util.concurrent.BlockingQueue.poll	(	long	TimeUnit	):  Retrieves and removes the head of this queue, waiting up to the specified wait time if necessary for an element to become available.
java.util.concurrent.BlockingQueue: java.util.concurrent.BlockingQueue.put	(	E	):  Inserts the specified element into this queue, waiting if necessary for space to become available.
java.util.concurrent.BlockingQueue: java.util.concurrent.BlockingQueue.remainingCapacity	(	):  Returns the number of additional elements that this queue can ideally (in the absence of memory or resource constraints) accept without blocking, or Integer.MAX_VALUE if there is no intrinsic limit. Note that you cannot always tell if an attempt to insert an element will succeed by inspecting remainingCapacity because it may be the case that another thread is about to insert or remove an element.
java.util.concurrent.BlockingQueue: java.util.concurrent.BlockingQueue.remove	(	Object	):  Removes a single instance of the specified element from this queue, if it is present. More formally, removes an element e such that o.equals(e), if this queue contains one or more such elements. Returns true if this queue contained the specified element (or equivalently, if this queue changed as a result of the call).
java.util.concurrent.BlockingQueue: java.util.concurrent.BlockingQueue.take	(	):  Retrieves and removes the head of this queue, waiting if necessary until an element becomes available.
java.util.concurrent.ConcurrentMap: java.util.concurrent.ConcurrentMap:  A java.util.Map providing thread safety and atomicity guarantees. Memory consistency effects: As with other concurrent collections, actions in a thread prior to placing an object into a ConcurrentMap as a key or value happen-before actions subsequent to the access or removal of that object from the ConcurrentMap in another thread. This interface is a member of the  Java Collections Framework.
java.util.concurrent.ConcurrentMap: java.util.concurrent.ConcurrentMap.compute	(	K	BiFunction	):  Attempts to compute a mapping for the specified key and its current mapped value (or null if there is no current mapping). For example, to either create or append a String msg to a value mapping:  map.compute(key, (k, v) -> (v == null) ? msg : v.concat(msg)) (Method merge merge() is often simpler to use for such purposes.) If the function returns null, the mapping is removed (or remains absent if initially absent). If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.
java.util.concurrent.ConcurrentMap: java.util.concurrent.ConcurrentMap.computeIfAbsent	(	K	Function	):  If the specified key is not already associated with a value (or is mapped to null), attempts to compute its value using the given mapping function and enters it into this map unless null. If the function returns null no mapping is recorded. If the function itself throws an (unchecked) exception, the exception is rethrown, and no mapping is recorded. The most common usage is to construct a new object serving as an initial mapped value or memoized result, as in:  map.computeIfAbsent(key, k -> new Value(f(k))); Or to implement a multi-value map, Map>, supporting multiple values per key:  map.computeIfAbsent(key, k -> new HashSet()).add(v);
java.util.concurrent.ConcurrentMap: java.util.concurrent.ConcurrentMap.computeIfPresent	(	K	BiFunction	):  If the value for the specified key is present and non-null, attempts to compute a new mapping given the key and its current mapped value. If the function returns null, the mapping is removed. If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.
java.util.concurrent.ConcurrentMap: java.util.concurrent.ConcurrentMap.forEach	(	BiConsumer	):  Performs the given action for each entry in this map until all entries have been processed or the action throws an exception. Unless otherwise specified by the implementing class, actions are performed in the order of entry set iteration (if an iteration order is specified.) Exceptions thrown by the action are relayed to the caller.
java.util.concurrent.ConcurrentMap: java.util.concurrent.ConcurrentMap.getOrDefault	(	Object	V	):  Returns the value to which the specified key is mapped, or defaultValue if this map contains no mapping for the key.
java.util.concurrent.ConcurrentMap: java.util.concurrent.ConcurrentMap.merge	(	K	V	BiFunction	):  If the specified key is not already associated with a value or is associated with null, associates it with the given non-null value. Otherwise, replaces the associated value with the results of the given remapping function, or removes if the result is null. This method may be of use when combining multiple mapped values for a key. For example, to either create or append a String msg to a value mapping:  map.merge(key, msg, String::concat) If the function returns null the mapping is removed. If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.
java.util.concurrent.ConcurrentMap: java.util.concurrent.ConcurrentMap.putIfAbsent	(	K	V	):  If the specified key is not already associated with a value, associate it with the given value. This is equivalent to  if (!map.containsKey(key)) return map.put(key, value); else return map.get(key); except that the action is performed atomically.
java.util.concurrent.ConcurrentMap: java.util.concurrent.ConcurrentMap.remove	(	Object	Object	):  Removes the entry for a key only if currently mapped to a given value. This is equivalent to  if (map.containsKey(key) && Objects.equals(map.get(key), value)) map.remove(key); return true; } else return false; } except that the action is performed atomically.
java.util.concurrent.ConcurrentMap: java.util.concurrent.ConcurrentMap.replace	(	K	V	):  Replaces the entry for a key only if currently mapped to some value. This is equivalent to  if (map.containsKey(key)) return map.put(key, value); } else return null; } except that the action is performed atomically.
java.util.concurrent.ConcurrentMap: java.util.concurrent.ConcurrentMap.replace	(	K	V	V	):  Replaces the entry for a key only if currently mapped to a given value. This is equivalent to  if (map.containsKey(key) && Objects.equals(map.get(key), oldValue)) map.put(key, newValue); return true; } else return false; } except that the action is performed atomically.
java.util.concurrent.ConcurrentMap: java.util.concurrent.ConcurrentMap.replaceAll	(	BiFunction	):  Replaces each entry's value with the result of invoking the given function on that entry until all entries have been processed or the function throws an exception. Exceptions thrown by the function are relayed to the caller.
java.util.ArrayList: java.util.ArrayList:  Resizable-array implementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to Vector, except that it is unsynchronized.) The size, isEmpty, get, set, iterator, and listIterator operations run in constant time. The add operation runs in amortized constant time, that is, adding n elements requires O(n) time. All of the other operations run in linear time (roughly speaking). The constant factor is low compared to that for the LinkedList implementation. Each ArrayList instance has a capacity. The capacity is the size of the array used to store the elements in the list. It is always at least as large as the list size. As elements are added to an ArrayList, its capacity grows automatically. The details of the growth policy are not specified beyond the fact that adding an element has constant amortized time cost. An application can increase the capacity of an ArrayList instance before adding a large number of elements using the ensureCapacity operation. This may reduce the amount of incremental reallocation. Note that this implementation is not synchronized. If multiple threads access an ArrayList instance concurrently, and at least one of the threads modifies the list structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more elements, or explicitly resizes the backing array; merely setting the value of an element is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the list. If no such object exists, the list should be "wrapped" using the synchronizedList Collections.synchronizedList method. This is best done at creation time, to prevent accidental unsynchronized access to the list: List list = Collections.synchronizedList(new ArrayList(...));  The iterators returned by this class's iterator() and listIterator() methods are fail-fast: if the list is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove() or add() methods, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. This class is a member of the  Java Collections Framework.
java.util.ArrayList: java.util.ArrayList.ArrayList	(	):  Constructs an empty list with an initial capacity of ten.
java.util.ArrayList: java.util.ArrayList.ArrayList	(	Collection	):  Constructs a list containing the elements of the specified collection, in the order they are returned by the collection's iterator.
java.util.ArrayList: java.util.ArrayList.ArrayList	(	int	):  Constructs an empty list with the specified initial capacity.
java.util.ArrayList: java.util.ArrayList.ArrayListSpliterator:  Index-based split-by-two, lazily initialized Spliterator 
java.util.ArrayList: java.util.ArrayList.ArrayListSpliterator.ArrayListSpliterator	(	ArrayList	int	int	int	):  Create new spliterator covering the given range 
java.util.ArrayList: java.util.ArrayList.Itr:  An optimized version of AbstractList.Itr
java.util.ArrayList: java.util.ArrayList.ListItr:  An optimized version of AbstractList.ListItr
java.util.ArrayList: java.util.ArrayList.add	(	E	):  Appends the specified element to the end of this list.
java.util.ArrayList: java.util.ArrayList.add	(	int	E	):  Inserts the specified element at the specified position in this list. Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices).
java.util.ArrayList: java.util.ArrayList.addAll	(	Collection	):  Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's Iterator. The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (This implies that the behavior of this call is undefined if the specified collection is this list, and this list is nonempty.)
java.util.ArrayList: java.util.ArrayList.addAll	(	int	Collection	):  Inserts all of the elements in the specified collection into this list, starting at the specified position. Shifts the element currently at that position (if any) and any subsequent elements to the right (increases their indices). The new elements will appear in the list in the order that they are returned by the specified collection's iterator.
java.util.ArrayList: java.util.ArrayList.clear	(	):  Removes all of the elements from this list. The list will be empty after this call returns.
java.util.ArrayList: java.util.ArrayList.clone	(	):  Returns a shallow copy of this ArrayList instance. (The elements themselves are not copied.)
java.util.ArrayList: java.util.ArrayList.contains	(	Object	):  Returns true if this list contains the specified element. More formally, returns true if and only if this list contains at least one element e such that (o==null?e==null:o.equals(e)).
java.util.ArrayList: java.util.ArrayList.ensureCapacity	(	int	):  Increases the capacity of this ArrayList instance, if necessary, to ensure that it can hold at least the number of elements specified by the minimum capacity argument.
java.util.ArrayList: java.util.ArrayList.get	(	int	):  Returns the element at the specified position in this list.
java.util.ArrayList: java.util.ArrayList.grow	(	int	):  Increases the capacity to ensure that it can hold at least the number of elements specified by the minimum capacity argument.
java.util.ArrayList: java.util.ArrayList.indexOf	(	Object	):  Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the lowest index i such that (o==null?get(i)==null:o.equals(get(i))), or -1 if there is no such index.
java.util.ArrayList: java.util.ArrayList.isEmpty	(	):  Returns true if this list contains no elements.
java.util.ArrayList: java.util.ArrayList.iterator	(	):  Returns an iterator over the elements in this list in proper sequence. The returned iterator is fail-fast.
java.util.ArrayList: java.util.ArrayList.lastIndexOf	(	Object	):  Returns the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the highest index i such that (o==null?get(i)==null:o.equals(get(i))), or -1 if there is no such index.
java.util.ArrayList: java.util.ArrayList.listIterator	(	):  Returns a list iterator over the elements in this list (in proper sequence). The returned list iterator is fail-fast.
java.util.ArrayList: java.util.ArrayList.listIterator	(	int	):  Returns a list iterator over the elements in this list (in proper sequence), starting at the specified position in the list. The specified index indicates the first element that would be returned by an initial call to next. An initial call to previous would return the element with the specified index minus one. The returned list iterator is fail-fast.
java.util.ArrayList: java.util.ArrayList.outOfBoundsMsg	(	int	):  Constructs an IndexOutOfBoundsException detail message. Of the many possible refactorings of the error handling code, this "outlining" performs best with both server and client VMs.
java.util.ArrayList: java.util.ArrayList.rangeCheck	(	int	):  Checks if the given index is in range. If not, throws an appropriate runtime exception. This method does *not* check if the index is negative: It is always used immediately prior to an array access, which throws an ArrayIndexOutOfBoundsException if index is negative.
java.util.ArrayList: java.util.ArrayList.rangeCheckForAdd	(	int	):  A version of rangeCheck used by add and addAll.
java.util.ArrayList: java.util.ArrayList.readObject	(	java.io.ObjectInputStream	):  Reconstitute the ArrayList instance from a stream (that is, deserialize it).
java.util.ArrayList: java.util.ArrayList.remove	(	Object	):  Removes the first occurrence of the specified element from this list, if it is present. If the list does not contain the element, it is unchanged. More formally, removes the element with the lowest index i such that (o==null?get(i)==null:o.equals(get(i))) (if such an element exists). Returns true if this list contained the specified element (or equivalently, if this list changed as a result of the call).
java.util.ArrayList: java.util.ArrayList.remove	(	int	):  Removes the element at the specified position in this list. Shifts any subsequent elements to the left (subtracts one from their indices).
java.util.ArrayList: java.util.ArrayList.removeAll	(	Collection	):  Removes from this list all of its elements that are contained in the specified collection.
java.util.ArrayList: java.util.ArrayList.removeRange	(	int	int	):  Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive. Shifts any succeeding elements to the left (reduces their index). This call shortens the list by (toIndex - fromIndex) elements. (If toIndex==fromIndex, this operation has no effect.)
java.util.ArrayList: java.util.ArrayList.retainAll	(	Collection	):  Retains only the elements in this list that are contained in the specified collection. In other words, removes from this list all of its elements that are not contained in the specified collection.
java.util.ArrayList: java.util.ArrayList.set	(	int	E	):  Replaces the element at the specified position in this list with the specified element.
java.util.ArrayList: java.util.ArrayList.size	(	):  Returns the number of elements in this list.
java.util.ArrayList: java.util.ArrayList.spliterator	(	):  Creates a late-binding and fail-fast Spliterator over the elements in this list. The Spliterator reports SIZED, SUBSIZED, and ORDERED. Overriding implementations should document the reporting of additional characteristic values.
java.util.ArrayList: java.util.ArrayList.subList	(	int	int	):  Returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive. (If fromIndex and toIndex are equal, the returned list is empty.) The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa. The returned list supports all of the optional list operations. This method eliminates the need for explicit range operations (of the sort that commonly exist for arrays). Any operation that expects a list can be used as a range operation by passing a subList view instead of a whole list. For example, the following idiom removes a range of elements from a list:  list.subList(from, to).clear();  Similar idioms may be constructed for indexOf() and lastIndexOf(), and all of the algorithms in the Collections class can be applied to a subList. The semantics of the list returned by this method become undefined if the backing list (i.e., this list) is structurally modified in any way other than via the returned list. (Structural modifications are those that change the size of this list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.)
java.util.ArrayList: java.util.ArrayList.toArray	(	):  Returns an array containing all of the elements in this list in proper sequence (from first to last element). The returned array will be "safe" in that no references to it are maintained by this list. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.ArrayList: java.util.ArrayList.toArray	(	T[]	):  Returns an array containing all of the elements in this list in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array. If the list fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this list. If the list fits in the specified array with room to spare (i.e., the array has more elements than the list), the element in the array immediately following the end of the collection is set to null. (This is useful in determining the length of the list only if the caller knows that the list does not contain any null elements.)
java.util.ArrayList: java.util.ArrayList.trimToSize	(	):  Trims the capacity of this ArrayList instance to be the list's current size. An application can use this operation to minimize the storage of an ArrayList instance.
java.util.ArrayList: java.util.ArrayList.writeObject	(	java.io.ObjectOutputStream	):  Save the state of the ArrayList instance to a stream (that is, serialize it).
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList:  A thread-safe variant of java.util.ArrayList in which all mutative operations (add, set, and so on) are implemented by making a fresh copy of the underlying array. This is ordinarily too costly, but may be more efficient than alternatives when traversal operations vastly outnumber mutations, and is useful when you cannot or don't want to synchronize traversals, yet need to preclude interference among concurrent threads. The "snapshot" style iterator method uses a reference to the state of the array at the point that the iterator was created. This array never changes during the lifetime of the iterator, so interference is impossible and the iterator is guaranteed not to throw ConcurrentModificationException. The iterator will not reflect additions, removals, or changes to the list since the iterator was created. Element-changing operations on iterators themselves (remove, set, and add) are not supported. These methods throw UnsupportedOperationException. All elements are permitted, including null. Memory consistency effects: As with other concurrent collections, actions in a thread prior to placing an object into a CopyOnWriteArrayList happen-before actions subsequent to the access or removal of that element from the CopyOnWriteArrayList in another thread. This class is a member of the  Java Collections Framework.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.COWIterator.add	(	E	):  Not supported. Always throws UnsupportedOperationException.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.COWIterator.remove	(	):  Not supported. Always throws UnsupportedOperationException.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.COWIterator.set	(	E	):  Not supported. Always throws UnsupportedOperationException.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.COWSubList:  Sublist for CopyOnWriteArrayList. This class extends AbstractList merely for convenience, to avoid having to define addAll, etc. This doesn't hurt, but is wasteful. This class does not need or use modCount mechanics in AbstractList, but does need to check for concurrent modification using similar mechanics. On each operation, the array that we expect the backing list to use is checked and updated. Since we do this for all of the base operations invoked by those defined in AbstractList, all is well. While inefficient, this is not worth improving. The kinds of list operations inherited from AbstractList are already so slow on COW sublists that adding a bit more space/time doesn't seem even noticeable.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.CopyOnWriteArrayList	(	):  Creates an empty list.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.CopyOnWriteArrayList	(	Collection	):  Creates a list containing the elements of the specified collection, in the order they are returned by the collection's iterator.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.CopyOnWriteArrayList	(	E[]	):  Creates a list holding a copy of the given array.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.add	(	E	):  Appends the specified element to the end of this list.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.add	(	int	E	):  Inserts the specified element at the specified position in this list. Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices).
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.addAll	(	Collection	):  Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's iterator.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.addAll	(	int	Collection	):  Inserts all of the elements in the specified collection into this list, starting at the specified position. Shifts the element currently at that position (if any) and any subsequent elements to the right (increases their indices). The new elements will appear in this list in the order that they are returned by the specified collection's iterator.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.addAllAbsent	(	Collection	):  Appends all of the elements in the specified collection that are not already contained in this list, to the end of this list, in the order that they are returned by the specified collection's iterator.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.addIfAbsent	(	E	):  Appends the element, if not present.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.addIfAbsent	(	E	Object[]	):  A version of addIfAbsent using the strong hint that given recent snapshot does not contain e.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.clear	(	):  Removes all of the elements from this list. The list will be empty after this call returns.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.clone	(	):  Returns a shallow copy of this list. (The elements themselves are not copied.)
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.contains	(	Object	):  Returns true if this list contains the specified element. More formally, returns true if and only if this list contains at least one element e such that (o==null?e==null:o.equals(e)).
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.containsAll	(	Collection	):  Returns true if this list contains all of the elements of the specified collection.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.eq	(	Object	Object	):  Tests for equality, coping with nulls.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.equals	(	Object	):  Compares the specified object with this list for equality. Returns true if the specified object is the same object as this object, or if it is also a List and the sequence of elements returned by an iterator() over the specified list is the same as the sequence returned by an iterator over this list. The two sequences are considered to be the same if they have the same length and corresponding elements at the same position in the sequence are equal. Two elements e1 and e2 are considered equal if (e1==null ? e2==null : e1.equals(e2)).
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.get	(	int	):  Returns the element at the specified position in this list.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.getArray	(	):  Gets the array. Non-private so as to also be accessible from CopyOnWriteArraySet class.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.hashCode	(	):  Returns the hash code value for this list. This implementation uses the definition in hashCode.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.indexOf	(	E	int	):  Returns the index of the first occurrence of the specified element in this list, searching forwards from index, or returns -1 if the element is not found. More formally, returns the lowest index i such that (i>=index&&(e==null?get(i)==null:e.equals(get(i)))), or -1 if there is no such index.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.indexOf	(	Object	):  Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the lowest index i such that (o==null?get(i)==null:o.equals(get(i))), or -1 if there is no such index.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.indexOf	(	Object	Object[]	int	int	):  static version of indexOf, to allow repeated calls without needing to re-acquire array each time.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.isEmpty	(	):  Returns true if this list contains no elements.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.iterator	(	):  Returns an iterator over the elements in this list in proper sequence. The returned iterator provides a snapshot of the state of the list when the iterator was constructed. No synchronization is needed while traversing the iterator. The iterator does NOT support the remove method.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.lastIndexOf	(	E	int	):  Returns the index of the last occurrence of the specified element in this list, searching backwards from index, or returns -1 if the element is not found. More formally, returns the highest index i such that (i<=index&&(e==null?get(i)==null:e.equals(get(i)))), or -1 if there is no such index.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.lastIndexOf	(	Object	):  Returns the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the highest index i such that (o==null?get(i)==null:o.equals(get(i))), or -1 if there is no such index.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.lastIndexOf	(	Object	Object[]	int	):  static version of lastIndexOf.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.listIterator	(	):  Returns a list iterator over the elements in this list (in proper sequence). The returned iterator provides a snapshot of the state of the list when the iterator was constructed. No synchronization is needed while traversing the iterator. The iterator does NOT support the remove, set or add methods.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.listIterator	(	int	):  Returns a list iterator over the elements in this list (in proper sequence), starting at the specified position in the list. The specified index indicates the first element that would be returned by an initial call to next. An initial call to previous would return the element with the specified index minus one. The returned iterator provides a snapshot of the state of the list when the iterator was constructed. No synchronization is needed while traversing the iterator. The iterator does NOT support the remove, set or add methods.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.readObject	(	java.io.ObjectInputStream	):  Reconstitutes this list from a stream (that is, deserializes it).
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.remove	(	Object	):  Removes the first occurrence of the specified element from this list, if it is present. If this list does not contain the element, it is unchanged. More formally, removes the element with the lowest index i such that (o==null?get(i)==null:o.equals(get(i))) (if such an element exists). Returns true if this list contained the specified element (or equivalently, if this list changed as a result of the call).
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.remove	(	Object	Object[]	int	):  A version of remove(Object) using the strong hint that given recent snapshot contains o at the given index.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.remove	(	int	):  Removes the element at the specified position in this list. Shifts any subsequent elements to the left (subtracts one from their indices). Returns the element that was removed from the list.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.removeAll	(	Collection	):  Removes from this list all of its elements that are contained in the specified collection. This is a particularly expensive operation in this class because of the need for an internal temporary array.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.removeRange	(	int	int	):  Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive. Shifts any succeeding elements to the left (reduces their index). This call shortens the list by (toIndex - fromIndex) elements. (If toIndex==fromIndex, this operation has no effect.)
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.retainAll	(	Collection	):  Retains only the elements in this list that are contained in the specified collection. In other words, removes from this list all of its elements that are not contained in the specified collection.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.set	(	int	E	):  Replaces the element at the specified position in this list with the specified element.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.setArray	(	Object[]	):  Sets the array.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.size	(	):  Returns the number of elements in this list.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.spliterator	(	):  Returns a Spliterator over the elements in this list. The Spliterator reports IMMUTABLE, ORDERED, SIZED, and SUBSIZED. The spliterator provides a snapshot of the state of the list when the spliterator was constructed. No synchronization is needed while operating on the spliterator.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.subList	(	int	int	):  Returns a view of the portion of this list between fromIndex, inclusive, and toIndex, exclusive. The returned list is backed by this list, so changes in the returned list are reflected in this list. The semantics of the list returned by this method become undefined if the backing list (i.e., this list) is modified in any way other than via the returned list.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.toArray	(	):  Returns an array containing all of the elements in this list in proper sequence (from first to last element). The returned array will be "safe" in that no references to it are maintained by this list. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.toArray	(	T	):  Returns an array containing all of the elements in this list in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array. If the list fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this list. If this list fits in the specified array with room to spare (i.e., the array has more elements than this list), the element in the array immediately following the end of the list is set to null. (This is useful in determining the length of this list only if the caller knows that this list does not contain any null elements.) Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a list known to contain only strings. The following code can be used to dump the list into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.toString	(	):  Returns a string representation of this list. The string representation consists of the string representations of the list's elements in the order they are returned by its iterator, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (comma and space). Elements are converted to strings as by valueOf().
java.util.concurrent.CopyOnWriteArrayList: java.util.concurrent.CopyOnWriteArrayList.writeObject	(	java.io.ObjectOutputStream	):  Saves this list to a stream (that is, serializes it).
java.util.Vector: java.util.Vector:  The Vector class implements a growable array of objects. Like an array, it contains components that can be accessed using an integer index. However, the size of a Vector can grow or shrink as needed to accommodate adding and removing items after the Vector has been created. Each vector tries to optimize storage management by maintaining a capacity and a capacityIncrement. The capacity is always at least as large as the vector size; it is usually larger because as components are added to the vector, the vector's storage increases in chunks the size of capacityIncrement. An application can increase the capacity of a vector before inserting a large number of components; this reduces the amount of incremental reallocation.  The iterators returned by this class's iterator() and listIterator() methods are fail-fast: if the vector is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove() or add() methods, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. The Enumeration Enumerations returned by the elements() method are not fail-fast. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. As of the Java 2 platform v1.2, this class was retrofitted to implement the List interface, making it a member of the  Java Collections Framework. Unlike the new collection implementations, Vector is synchronized. If a thread-safe implementation is not needed, it is recommended to use ArrayList in place of Vector.
java.util.Vector: java.util.Vector.Itr:  An optimized version of AbstractList.Itr
java.util.Vector: java.util.Vector.ListItr:  An optimized version of AbstractList.ListItr
java.util.Vector: java.util.Vector.Vector	(	):  Constructs an empty vector so that its internal data array has size 10 and its standard capacity increment is zero.
java.util.Vector: java.util.Vector.Vector	(	Collection	):  Constructs a vector containing the elements of the specified collection, in the order they are returned by the collection's iterator.
java.util.Vector: java.util.Vector.Vector	(	int	):  Constructs an empty vector with the specified initial capacity and with its capacity increment equal to zero.
java.util.Vector: java.util.Vector.Vector	(	int	int	):  Constructs an empty vector with the specified initial capacity and capacity increment.
java.util.Vector: java.util.Vector.VectorSpliterator:  Similar to ArrayList Spliterator 
java.util.Vector: java.util.Vector.VectorSpliterator.VectorSpliterator	(	Vector	Object[]	int	int	int	):  Create new spliterator covering the given range 
java.util.Vector: java.util.Vector.add	(	E	):  Appends the specified element to the end of this Vector.
java.util.Vector: java.util.Vector.add	(	int	E	):  Inserts the specified element at the specified position in this Vector. Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices).
java.util.Vector: java.util.Vector.addAll	(	Collection	):  Appends all of the elements in the specified Collection to the end of this Vector, in the order that they are returned by the specified Collection's Iterator. The behavior of this operation is undefined if the specified Collection is modified while the operation is in progress. (This implies that the behavior of this call is undefined if the specified Collection is this Vector, and this Vector is nonempty.)
java.util.Vector: java.util.Vector.addAll	(	int	Collection	):  Inserts all of the elements in the specified Collection into this Vector at the specified position. Shifts the element currently at that position (if any) and any subsequent elements to the right (increases their indices). The new elements will appear in the Vector in the order that they are returned by the specified Collection's iterator.
java.util.Vector: java.util.Vector.addElement	(	E	):  Adds the specified component to the end of this vector, increasing its size by one. The capacity of this vector is increased if its size becomes greater than its capacity. This method is identical in functionality to the add() add(E) method (which is part of the List interface).
java.util.Vector: java.util.Vector.capacity	(	):  Returns the current capacity of this vector.
java.util.Vector: java.util.Vector.clear	(	):  Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).
java.util.Vector: java.util.Vector.clone	(	):  Returns a clone of this vector. The copy will contain a reference to a clone of the internal data array, not a reference to the original internal data array of this Vector object.
java.util.Vector: java.util.Vector.contains	(	Object	):  Returns true if this vector contains the specified element. More formally, returns true if and only if this vector contains at least one element e such that (o==null?e==null:o.equals(e)).
java.util.Vector: java.util.Vector.containsAll	(	Collection	):  Returns true if this Vector contains all of the elements in the specified Collection.
java.util.Vector: java.util.Vector.copyInto	(	Object[]	):  Copies the components of this vector into the specified array. The item at index k in this vector is copied into component k of anArray.
java.util.Vector: java.util.Vector.elementAt	(	int	):  Returns the component at the specified index. This method is identical in functionality to the get() method (which is part of the List interface).
java.util.Vector: java.util.Vector.elements	(	):  Returns an enumeration of the components of this vector. The returned Enumeration object will generate all items in this vector. The first item generated is the item at index 0, then the item at index 1, and so on.
java.util.Vector: java.util.Vector.ensureCapacity	(	int	):  Increases the capacity of this vector, if necessary, to ensure that it can hold at least the number of components specified by the minimum capacity argument. If the current capacity of this vector is less than minCapacity, then its capacity is increased by replacing its internal data array, kept in the field elementData, with a larger one. The size of the new data array will be the old size plus capacityIncrement, unless the value of capacityIncrement is less than or equal to zero, in which case the new capacity will be twice the old capacity; but if this new size is still smaller than minCapacity, then the new capacity will be minCapacity.
java.util.Vector: java.util.Vector.ensureCapacityHelper	(	int	):  This implements the unsynchronized semantics of ensureCapacity. Synchronized methods in this class can internally call this method for ensuring capacity without incurring the cost of an extra synchronization.
java.util.Vector: java.util.Vector.equals	(	Object	):  Compares the specified Object with this Vector for equality. Returns true if and only if the specified Object is also a List, both Lists have the same size, and all corresponding pairs of elements in the two Lists are equal. (Two elements e1 and e2 are equal if (e1==null ? e2==null : e1.equals(e2)).) In other words, two Lists are defined to be equal if they contain the same elements in the same order.
java.util.Vector: java.util.Vector.firstElement	(	):  Returns the first component (the item at index 0) of this vector.
java.util.Vector: java.util.Vector.get	(	int	):  Returns the element at the specified position in this Vector.
java.util.Vector: java.util.Vector.hashCode	(	):  Returns the hash code value for this Vector.
java.util.Vector: java.util.Vector.indexOf	(	Object	):  Returns the index of the first occurrence of the specified element in this vector, or -1 if this vector does not contain the element. More formally, returns the lowest index i such that (o==null?get(i)==null:o.equals(get(i))), or -1 if there is no such index.
java.util.Vector: java.util.Vector.indexOf	(	Object	int	):  Returns the index of the first occurrence of the specified element in this vector, searching forwards from index, or returns -1 if the element is not found. More formally, returns the lowest index i such that (i>=index&&(o==null?get(i)==null:o.equals(get(i)))), or -1 if there is no such index.
java.util.Vector: java.util.Vector.insertElementAt	(	E	int	):  Inserts the specified object as a component in this vector at the specified index. Each component in this vector with an index greater or equal to the specified index is shifted upward to have an index one greater than the value it had previously. The index must be a value greater than or equal to 0 and less than or equal to the current size of the vector. (If the index is equal to the current size of the vector, the new element is appended to the Vector.) This method is identical in functionality to the add() add(int, E) method (which is part of the List interface). Note that the add method reverses the order of the parameters, to more closely match array usage.
java.util.Vector: java.util.Vector.isEmpty	(	):  Tests if this vector has no components.
java.util.Vector: java.util.Vector.iterator	(	):  Returns an iterator over the elements in this list in proper sequence. The returned iterator is fail-fast.
java.util.Vector: java.util.Vector.lastElement	(	):  Returns the last component of the vector.
java.util.Vector: java.util.Vector.lastIndexOf	(	Object	):  Returns the index of the last occurrence of the specified element in this vector, or -1 if this vector does not contain the element. More formally, returns the highest index i such that (o==null?get(i)==null:o.equals(get(i))), or -1 if there is no such index.
java.util.Vector: java.util.Vector.lastIndexOf	(	Object	int	):  Returns the index of the last occurrence of the specified element in this vector, searching backwards from index, or returns -1 if the element is not found. More formally, returns the highest index i such that (i<=index&&(o==null?get(i)==null:o.equals(get(i)))), or -1 if there is no such index.
java.util.Vector: java.util.Vector.listIterator	(	):  Returns a list iterator over the elements in this list (in proper sequence). The returned list iterator is fail-fast.
java.util.Vector: java.util.Vector.listIterator	(	int	):  Returns a list iterator over the elements in this list (in proper sequence), starting at the specified position in the list. The specified index indicates the first element that would be returned by an initial call to next. An initial call to previous would return the element with the specified index minus one. The returned list iterator is fail-fast.
java.util.Vector: java.util.Vector.remove	(	Object	):  Removes the first occurrence of the specified element in this Vector If the Vector does not contain the element, it is unchanged. More formally, removes the element with the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))) (if such an element exists).
java.util.Vector: java.util.Vector.remove	(	int	):  Removes the element at the specified position in this Vector. Shifts any subsequent elements to the left (subtracts one from their indices). Returns the element that was removed from the Vector.
java.util.Vector: java.util.Vector.removeAll	(	Collection	):  Removes from this Vector all of its elements that are contained in the specified Collection.
java.util.Vector: java.util.Vector.removeAllElements	(	):  Removes all components from this vector and sets its size to zero. This method is identical in functionality to the clear method (which is part of the List interface).
java.util.Vector: java.util.Vector.removeElement	(	Object	):  Removes the first (lowest-indexed) occurrence of the argument from this vector. If the object is found in this vector, each component in the vector with an index greater or equal to the object's index is shifted downward to have an index one smaller than the value it had previously. This method is identical in functionality to the remove() method (which is part of the List interface).
java.util.Vector: java.util.Vector.removeElementAt	(	int	):  Deletes the component at the specified index. Each component in this vector with an index greater or equal to the specified index is shifted downward to have an index one smaller than the value it had previously. The size of this vector is decreased by 1. The index must be a value greater than or equal to 0 and less than the current size of the vector. This method is identical in functionality to the remove() method (which is part of the List interface). Note that the remove method returns the old value that was stored at the specified position.
java.util.Vector: java.util.Vector.removeRange	(	int	int	):  Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive. Shifts any succeeding elements to the left (reduces their index). This call shortens the list by (toIndex - fromIndex) elements. (If toIndex==fromIndex, this operation has no effect.)
java.util.Vector: java.util.Vector.retainAll	(	Collection	):  Retains only the elements in this Vector that are contained in the specified Collection. In other words, removes from this Vector all of its elements that are not contained in the specified Collection.
java.util.Vector: java.util.Vector.set	(	int	E	):  Replaces the element at the specified position in this Vector with the specified element.
java.util.Vector: java.util.Vector.setElementAt	(	E	int	):  Sets the component at the specified index of this vector to be the specified object. The previous component at that position is discarded. The index must be a value greater than or equal to 0 and less than the current size of the vector. This method is identical in functionality to the set() set(int, E) method (which is part of the List interface). Note that the set method reverses the order of the parameters, to more closely match array usage. Note also that the set method returns the old value that was stored at the specified position.
java.util.Vector: java.util.Vector.setSize	(	int	):  Sets the size of this vector. If the new size is greater than the current size, new null items are added to the end of the vector. If the new size is less than the current size, all components at index newSize and greater are discarded.
java.util.Vector: java.util.Vector.size	(	):  Returns the number of components in this vector.
java.util.Vector: java.util.Vector.spliterator	(	):  Creates a late-binding and fail-fast Spliterator over the elements in this list. The Spliterator reports SIZED, SUBSIZED, and ORDERED. Overriding implementations should document the reporting of additional characteristic values.
java.util.Vector: java.util.Vector.subList	(	int	int	):  Returns a view of the portion of this List between fromIndex, inclusive, and toIndex, exclusive. (If fromIndex and toIndex are equal, the returned List is empty.) The returned List is backed by this List, so changes in the returned List are reflected in this List, and vice-versa. The returned List supports all of the optional List operations supported by this List. This method eliminates the need for explicit range operations (of the sort that commonly exist for arrays). Any operation that expects a List can be used as a range operation by operating on a subList view instead of a whole List. For example, the following idiom removes a range of elements from a List:  list.subList(from, to).clear();  Similar idioms may be constructed for indexOf and lastIndexOf, and all of the algorithms in the Collections class can be applied to a subList. The semantics of the List returned by this method become undefined if the backing list (i.e., this List) is structurally modified in any way other than via the returned List. (Structural modifications are those that change the size of the List, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.)
java.util.Vector: java.util.Vector.toArray	(	):  Returns an array containing all of the elements in this Vector in the correct order.
java.util.Vector: java.util.Vector.toArray	(	T[]	):  Returns an array containing all of the elements in this Vector in the correct order; the runtime type of the returned array is that of the specified array. If the Vector fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this Vector. If the Vector fits in the specified array with room to spare (i.e., the array has more elements than the Vector), the element in the array immediately following the end of the Vector is set to null. (This is useful in determining the length of the Vector only if the caller knows that the Vector does not contain any null elements.)
java.util.Vector: java.util.Vector.toString	(	):  Returns a string representation of this Vector, containing the String representation of each element.
java.util.Vector: java.util.Vector.trimToSize	(	):  Trims the capacity of this vector to be the vector's current size. If the capacity of this vector is larger than its current size, then the capacity is changed to equal the size by replacing its internal data array, kept in the field elementData, with a smaller one. An application can use this operation to minimize the storage of a vector.
java.util.Vector: java.util.Vector.writeObject	(	java.io.ObjectOutputStream	):  Save the state of the Vector instance to a stream (that is, serialize it). This method performs synchronization to ensure the consistency of the serialized data.
java.util.LinkedHashMap: java.util.LinkedHashMap:  Hash table and linked list implementation of the Map interface, with predictable iteration order. This implementation differs from HashMap in that it maintains a doubly-linked list running through all of its entries. This linked list defines the iteration ordering, which is normally the order in which keys were inserted into the map (insertion-order). Note that insertion order is not affected if a key is re-inserted into the map. (A key k is reinserted into a map m if m.put(k, v) is invoked when m.containsKey(k) would return true immediately prior to the invocation.) This implementation spares its clients from the unspecified, generally chaotic ordering provided by HashMap (and Hashtable), without incurring the increased cost associated with TreeMap. It can be used to produce a copy of a map that has the same order as the original, regardless of the original map's implementation:  void foo(Map m) { Map copy = new LinkedHashMap(m); ... }  This technique is particularly useful if a module takes a map on input, copies it, and later returns results whose order is determined by that of the copy. (Clients generally appreciate having things returned in the same order they were presented.) A special LinkedHashMap() constructor is provided to create a linked hash map whose order of iteration is the order in which its entries were last accessed, from least-recently accessed to most-recently (access-order). This kind of map is well-suited to building LRU caches. Invoking the put, putIfAbsent, get, getOrDefault, compute, computeIfAbsent, computeIfPresent, or merge methods results in an access to the corresponding entry (assuming it exists after the invocation completes). The replace methods only result in an access of the entry if the value is replaced. The putAll method generates one entry access for each mapping in the specified map, in the order that key-value mappings are provided by the specified map's entry set iterator. No other methods generate entry accesses. In particular, operations on collection-views do not affect the order of iteration of the backing map. The removeEldestEntry() method may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map. This class provides all of the optional Map operations, and permits null elements. Like HashMap, it provides constant-time performance for the basic operations (add, contains and remove), assuming the hash function disperses elements properly among the buckets. Performance is likely to be just slightly below that of HashMap, due to the added expense of maintaining the linked list, with one exception: Iteration over the collection-views of a LinkedHashMap requires time proportional to the size of the map, regardless of its capacity. Iteration over a HashMap is likely to be more expensive, requiring time proportional to its capacity. A linked hash map has two parameters that affect its performance: initial capacity and load factor. They are defined precisely as for HashMap. Note, however, that the penalty for choosing an excessively high value for initial capacity is less severe for this class than for HashMap, as iteration times for this class are unaffected by capacity. Note that this implementation is not synchronized. If multiple threads access a linked hash map concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally. This is typically accomplished by synchronizing on some object that naturally encapsulates the map. If no such object exists, the map should be "wrapped" using the synchronizedMap Collections.synchronizedMap method. This is best done at creation time, to prevent accidental unsynchronized access to the map: Map m = Collections.synchronizedMap(new LinkedHashMap(...)); A structural modification is any operation that adds or deletes one or more mappings or, in the case of access-ordered linked hash maps, affects iteration order. In insertion-ordered linked hash maps, merely changing the value associated with a key that is already contained in the map is not a structural modification. In access-ordered linked hash maps, merely querying the map with get is a structural modification. ) The iterators returned by the iterator method of the collections returned by all of this class's collection view methods are fail-fast: if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. The spliterators returned by the spliterator method of the collections returned by all of this class's collection view methods are late-binding, fail-fast, and additionally report ORDERED. This class is a member of the  Java Collections Framework.
java.util.LinkedHashMap: java.util.LinkedHashMap.Entry:  HashMap.Node subclass for normal LinkedHashMap entries.
java.util.LinkedHashMap: java.util.LinkedHashMap.LinkedHashMap	(	):  Constructs an empty insertion-ordered LinkedHashMap instance with the default initial capacity (16) and load factor (0.75).
java.util.LinkedHashMap: java.util.LinkedHashMap.LinkedHashMap	(	Map	):  Constructs an insertion-ordered LinkedHashMap instance with the same mappings as the specified map. The LinkedHashMap instance is created with a default load factor (0.75) and an initial capacity sufficient to hold the mappings in the specified map.
java.util.LinkedHashMap: java.util.LinkedHashMap.LinkedHashMap	(	int	):  Constructs an empty insertion-ordered LinkedHashMap instance with the specified initial capacity and a default load factor (0.75).
java.util.LinkedHashMap: java.util.LinkedHashMap.LinkedHashMap	(	int	float	):  Constructs an empty insertion-ordered LinkedHashMap instance with the specified initial capacity and load factor.
java.util.LinkedHashMap: java.util.LinkedHashMap.LinkedHashMap	(	int	float	boolean	):  Constructs an empty LinkedHashMap instance with the specified initial capacity, load factor and ordering mode.
java.util.LinkedHashMap: java.util.LinkedHashMap.clear	(	):  Removes all of the mappings from this map. The map will be empty after this call returns.
java.util.LinkedHashMap: java.util.LinkedHashMap.containsValue	(	Object	):  Returns true if this map maps one or more keys to the specified value.
java.util.LinkedHashMap: java.util.LinkedHashMap.entrySet	(	):  Returns a Set view of the mappings contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation, or through the setValue operation on a map entry returned by the iterator) the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations. Its Spliterator typically provides faster sequential performance but much poorer parallel performance than that of HashMap.
java.util.LinkedHashMap: java.util.LinkedHashMap.get	(	Object	):  Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that (key==null ? k==null : key.equals(k)), then this method returns v; otherwise it returns null. (There can be at most one such mapping.) A return value of null does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to null. The containsKey operation may be used to distinguish these two cases.
java.util.LinkedHashMap: java.util.LinkedHashMap.getOrDefault	(	Object	V	):  
java.util.LinkedHashMap: java.util.LinkedHashMap.keySet	(	):  Returns a Set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations. Its Spliterator typically provides faster sequential performance but much poorer parallel performance than that of HashMap.
java.util.LinkedHashMap: java.util.LinkedHashMap.removeEldestEntry	(	Map.Entry	):  Returns true if this map should remove its eldest entry. This method is invoked by put and putAll after inserting a new entry into the map. It provides the implementor with the opportunity to remove the eldest entry each time a new one is added. This is useful if the map represents a cache: it allows the map to reduce memory consumption by deleting stale entries. Sample use: this override will allow the map to grow up to 100 entries and then delete the eldest entry each time a new entry is added, maintaining a steady state of 100 entries.  private static final int MAX_ENTRIES = 100; protected boolean removeEldestEntry(Map.Entry eldest) { return size() > MAX_ENTRIES; }  This method typically does not modify the map in any way, instead allowing the map to modify itself as directed by its return value. It is permitted for this method to modify the map directly, but if it does so, it must return false (indicating that the map should not attempt any further modification). The effects of returning true after modifying the map from within this method are unspecified. This implementation merely returns false (so that this map acts like a normal map - the eldest element is never removed).
java.util.LinkedHashMap: java.util.LinkedHashMap.values	(	):  Returns a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations. Its Spliterator typically provides faster sequential performance but much poorer parallel performance than that of HashMap.
java.util.EnumMap: java.util.EnumMap:  A specialized Map implementation for use with enum type keys. All of the keys in an enum map must come from a single enum type that is specified, explicitly or implicitly, when the map is created. Enum maps are represented internally as arrays. This representation is extremely compact and efficient. Enum maps are maintained in the natural order of their keys (the order in which the enum constants are declared). This is reflected in the iterators returned by the collections views (keySet(), entrySet(), and values()). Iterators returned by the collection views are weakly consistent: they will never throw ConcurrentModificationException and they may or may not show the effects of any modifications to the map that occur while the iteration is in progress. Null keys are not permitted. Attempts to insert a null key will throw NullPointerException. Attempts to test for the presence of a null key or to remove one will, however, function properly. Null values are permitted. Like most collection implementations EnumMap is not synchronized. If multiple threads access an enum map concurrently, and at least one of the threads modifies the map, it should be synchronized externally. This is typically accomplished by synchronizing on some object that naturally encapsulates the enum map. If no such object exists, the map should be "wrapped" using the synchronizedMap method. This is best done at creation time, to prevent accidental unsynchronized access:  Map<EnumKey, V> m = Collections.synchronizedMap(new EnumMap<EnumKey, V>(...));  Implementation note: All basic operations execute in constant time. They are likely (though not guaranteed) to be faster than their HashMap counterparts. This class is a member of the  Java Collections Framework.
java.util.EnumMap: java.util.EnumMap.EnumMap	(	Class	):  Creates an empty enum map with the specified key type.
java.util.EnumMap: java.util.EnumMap.EnumMap	(	EnumMap	):  Creates an enum map with the same key type as the specified enum map, initially containing the same mappings (if any).
java.util.EnumMap: java.util.EnumMap.EnumMap	(	Map	):  Creates an enum map initialized from the specified map. If the specified map is an EnumMap instance, this constructor behaves identically to EnumMap(). Otherwise, the specified map must contain at least one mapping (in order to determine the new enum map's key type).
java.util.EnumMap: java.util.EnumMap.clear	(	):  Removes all mappings from this map.
java.util.EnumMap: java.util.EnumMap.clone	(	):  Returns a shallow copy of this enum map. (The values themselves are not cloned.
java.util.EnumMap: java.util.EnumMap.containsKey	(	Object	):  Returns true if this map contains a mapping for the specified key.
java.util.EnumMap: java.util.EnumMap.containsValue	(	Object	):  Returns true if this map maps one or more keys to the specified value.
java.util.EnumMap: java.util.EnumMap.entrySet	(	):  Returns a Set view of the mappings contained in this map. The returned set obeys the general contract outlined in keySet(). The set's iterator will return the mappings in the order their keys appear in map, which is their natural order (the order in which the enum constants are declared).
java.util.EnumMap: java.util.EnumMap.equals	(	Object	):  Compares the specified object with this map for equality. Returns true if the given object is also a map and the two maps represent the same mappings, as specified in the equals() contract.
java.util.EnumMap: java.util.EnumMap.get	(	Object	):  Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that (key == k), then this method returns v; otherwise it returns null. (There can be at most one such mapping.) A return value of null does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to null. The containsKey operation may be used to distinguish these two cases.
java.util.EnumMap: java.util.EnumMap.getKeyUniverse	(	Class	):  Returns all of the values comprising K. The result is uncloned, cached, and shared by all callers.
java.util.EnumMap: java.util.EnumMap.hashCode	(	):  Returns the hash code value for this map. The hash code of a map is defined to be the sum of the hash codes of each entry in the map.
java.util.EnumMap: java.util.EnumMap.isValidKey	(	Object	):  Returns true if key is of the proper type to be a key in this enum map.
java.util.EnumMap: java.util.EnumMap.keySet	(	):  Returns a Set view of the keys contained in this map. The returned set obeys the general contract outlined in keySet(). The set's iterator will return the keys in their natural order (the order in which the enum constants are declared).
java.util.EnumMap: java.util.EnumMap.put	(	K	V	):  Associates the specified value with the specified key in this map. If the map previously contained a mapping for this key, the old value is replaced.
java.util.EnumMap: java.util.EnumMap.putAll	(	Map	):  Copies all of the mappings from the specified map to this map. These mappings will replace any mappings that this map had for any of the keys currently in the specified map.
java.util.EnumMap: java.util.EnumMap.readObject	(	java.io.ObjectInputStream	):  Reconstitute the EnumMap instance from a stream (i.e., deserialize it).
java.util.EnumMap: java.util.EnumMap.remove	(	Object	):  Removes the mapping for this key from this map if present.
java.util.EnumMap: java.util.EnumMap.size	(	):  Returns the number of key-value mappings in this map.
java.util.EnumMap: java.util.EnumMap.typeCheck	(	K	):  Throws an exception if e is not of the correct type for this enum set.
java.util.EnumMap: java.util.EnumMap.values	(	):  Returns a Collection view of the values contained in this map. The returned collection obeys the general contract outlined in values(). The collection's iterator will return the values in the order their corresponding keys appear in map, which is their natural order (the order in which the enum constants are declared).
java.util.EnumMap: java.util.EnumMap.writeObject	(	java.io.ObjectOutputStream	):  Save the state of the EnumMap instance to a stream (i.e., serialize it).
java.util.WeakHashMap: java.util.WeakHashMap:  Hash table based implementation of the Map interface, with weak keys. An entry in a WeakHashMap will automatically be removed when its key is no longer in ordinary use. More precisely, the presence of a mapping for a given key will not prevent the key from being discarded by the garbage collector, that is, made finalizable, finalized, and then reclaimed. When a key has been discarded its entry is effectively removed from the map, so this class behaves somewhat differently from other Map implementations.  Both null values and the null key are supported. This class has performance characteristics similar to those of the HashMap class, and has the same efficiency parameters of initial capacity and load factor.  Like most collection classes, this class is not synchronized. A synchronized WeakHashMap may be constructed using the synchronizedMap Collections.synchronizedMap method.  This class is intended primarily for use with key objects whose equals methods test for object identity using the == operator. Once such a key is discarded it can never be recreated, so it is impossible to do a lookup of that key in a WeakHashMap at some later time and be surprised that its entry has been removed. This class will work perfectly well with key objects whose equals methods are not based upon object identity, such as String instances. With such recreatable key objects, however, the automatic removal of WeakHashMap entries whose keys have been discarded may prove to be confusing.  The behavior of the WeakHashMap class depends in part upon the actions of the garbage collector, so several familiar (though not required) Map invariants do not hold for this class. Because the garbage collector may discard keys at any time, a WeakHashMap may behave as though an unknown thread is silently removing entries. In particular, even if you synchronize on a WeakHashMap instance and invoke none of its mutator methods, it is possible for the size method to return smaller values over time, for the isEmpty method to return false and then true, for the containsKey method to return true and later false for a given key, for the get method to return a value for a given key but later return null, for the put method to return null and the remove method to return false for a key that previously appeared to be in the map, and for successive examinations of the key set, the value collection, and the entry set to yield successively smaller numbers of elements.  Each key object in a WeakHashMap is stored indirectly as the referent of a weak reference. Therefore a key will automatically be removed only after the weak references to it, both inside and outside of the map, have been cleared by the garbage collector.  Implementation note: The value objects in a WeakHashMap are held by ordinary strong references. Thus care should be taken to ensure that value objects do not strongly refer to their own keys, either directly or indirectly, since that will prevent the keys from being discarded. Note that a value object may refer indirectly to its key via the WeakHashMap itself; that is, a value object may strongly refer to some other key object whose associated value object, in turn, strongly refers to the key of the first value object. If the values in the map do not rely on the map holding strong references to them, one way to deal with this is to wrap values themselves within WeakReferences before inserting, as in: m.put(key, new WeakReference(value)), and then unwrapping upon each get. The iterators returned by the iterator method of the collections returned by all of this class's "collection view methods" are fail-fast: if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. This class is a member of the  Java Collections Framework.
java.util.WeakHashMap: java.util.WeakHashMap.Entry:  The entries in this hash table extend WeakReference, using its main ref field as the key.
java.util.WeakHashMap: java.util.WeakHashMap.Entry.Entry	(	Object	V	ReferenceQueue	int	Entry	):  Creates new entry.
java.util.WeakHashMap: java.util.WeakHashMap.HashIterator.nextEntry	(	):  The common parts of next() across different types of iterators 
java.util.WeakHashMap: java.util.WeakHashMap.WeakHashMap	(	):  Constructs a new, empty WeakHashMap with the default initial capacity (16) and load factor (0.75).
java.util.WeakHashMap: java.util.WeakHashMap.WeakHashMap	(	Map	):  Constructs a new WeakHashMap with the same mappings as the specified map. The WeakHashMap is created with the default load factor (0.75) and an initial capacity sufficient to hold the mappings in the specified map.
java.util.WeakHashMap: java.util.WeakHashMap.WeakHashMap	(	int	):  Constructs a new, empty WeakHashMap with the given initial capacity and the default load factor (0.75).
java.util.WeakHashMap: java.util.WeakHashMap.WeakHashMap	(	int	float	):  Constructs a new, empty WeakHashMap with the given initial capacity and the given load factor.
java.util.WeakHashMap: java.util.WeakHashMap.WeakHashMapSpliterator:  Similar form as other hash Spliterators, but skips dead elements.
java.util.WeakHashMap: java.util.WeakHashMap.clear	(	):  Removes all of the mappings from this map. The map will be empty after this call returns.
java.util.WeakHashMap: java.util.WeakHashMap.containsKey	(	Object	):  Returns true if this map contains a mapping for the specified key.
java.util.WeakHashMap: java.util.WeakHashMap.containsNullValue	(	):  Special-case code for containsValue with null argument
java.util.WeakHashMap: java.util.WeakHashMap.containsValue	(	Object	):  Returns true if this map maps one or more keys to the specified value.
java.util.WeakHashMap: java.util.WeakHashMap.entrySet	(	):  Returns a Set view of the mappings contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation, or through the setValue operation on a map entry returned by the iterator) the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.WeakHashMap: java.util.WeakHashMap.eq	(	Object	Object	):  Checks for equality of non-null reference x and possibly-null y. By default uses Object.equals.
java.util.WeakHashMap: java.util.WeakHashMap.expungeStaleEntries	(	):  Expunges stale entries from the table.
java.util.WeakHashMap: java.util.WeakHashMap.get	(	Object	):  Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that (key==null ? k==null : key.equals(k)), then this method returns v; otherwise it returns null. (There can be at most one such mapping.) A return value of null does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to null. The containsKey operation may be used to distinguish these two cases.
java.util.WeakHashMap: java.util.WeakHashMap.getEntry	(	Object	):  Returns the entry associated with the specified key in this map. Returns null if the map contains no mapping for this key.
java.util.WeakHashMap: java.util.WeakHashMap.getTable	(	):  Returns the table after first expunging stale entries.
java.util.WeakHashMap: java.util.WeakHashMap.hash	(	Object	):  Retrieve object hash code and applies a supplemental hash function to the result hash, which defends against poor quality hash functions. This is critical because HashMap uses power-of-two length hash tables, that otherwise encounter collisions for hashCodes that do not differ in lower bits.
java.util.WeakHashMap: java.util.WeakHashMap.indexFor	(	int	int	):  Returns index for hash code h.
java.util.WeakHashMap: java.util.WeakHashMap.isEmpty	(	):  Returns true if this map contains no key-value mappings. This result is a snapshot, and may not reflect unprocessed entries that will be removed before next attempted access because they are no longer referenced.
java.util.WeakHashMap: java.util.WeakHashMap.keySet	(	):  Returns a Set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.WeakHashMap: java.util.WeakHashMap.maskNull	(	Object	):  Use NULL_KEY for key if it is null.
java.util.WeakHashMap: java.util.WeakHashMap.put	(	K	V	):  Associates the specified value with the specified key in this map. If the map previously contained a mapping for this key, the old value is replaced.
java.util.WeakHashMap: java.util.WeakHashMap.putAll	(	Map	):  Copies all of the mappings from the specified map to this map. These mappings will replace any mappings that this map had for any of the keys currently in the specified map.
java.util.WeakHashMap: java.util.WeakHashMap.remove	(	Object	):  Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.
java.util.WeakHashMap: java.util.WeakHashMap.removeMapping	(	Object	):  Special version of remove needed by Entry set 
java.util.WeakHashMap: java.util.WeakHashMap.resize	(	int	):  Rehashes the contents of this map into a new array with a larger capacity. This method is called automatically when the number of keys in this map reaches its threshold. If current capacity is MAXIMUM_CAPACITY, this method does not resize the map, but sets threshold to Integer.MAX_VALUE. This has the effect of preventing future calls.
java.util.WeakHashMap: java.util.WeakHashMap.size	(	):  Returns the number of key-value mappings in this map. This result is a snapshot, and may not reflect unprocessed entries that will be removed before next attempted access because they are no longer referenced.
java.util.WeakHashMap: java.util.WeakHashMap.transfer	(	Entry[]	Entry[]	):  Transfers all entries from src to dest tables 
java.util.WeakHashMap: java.util.WeakHashMap.unmaskNull	(	Object	):  Returns internal representation of null key back to caller as null.
java.util.WeakHashMap: java.util.WeakHashMap.values	(	):  Returns a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.IdentityHashMap: java.util.IdentityHashMap:  This class implements the Map interface with a hash table, using reference-equality in place of object-equality when comparing keys (and values). In other words, in an IdentityHashMap, two keys k1 and k2 are considered equal if and only if (k1==k2). (In normal Map implementations (like HashMap) two keys k1 and k2 are considered equal if and only if (k1==null ? k2==null : k1.equals(k2)).) This class is not a general-purpose Map implementation! While this class implements the Map interface, it intentionally violates Map's general contract, which mandates the use of the equals method when comparing objects. This class is designed for use only in the rare cases wherein reference-equality semantics are required. A typical use of this class is topology-preserving object graph transformations, such as serialization or deep-copying. To perform such a transformation, a program must maintain a "node table" that keeps track of all the object references that have already been processed. The node table must not equate distinct objects even if they happen to be equal. Another typical use of this class is to maintain proxy objects. For example, a debugging facility might wish to maintain a proxy object for each object in the program being debugged. This class provides all of the optional map operations, and permits null values and the null key. This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time. This class provides constant-time performance for the basic operations (get and put), assuming the system identity hash function (identityHashCode()) disperses elements properly among the buckets. This class has one tuning parameter (which affects performance but not semantics): expected maximum size. This parameter is the maximum number of key-value mappings that the map is expected to hold. Internally, this parameter is used to determine the number of buckets initially comprising the hash table. The precise relationship between the expected maximum size and the number of buckets is unspecified. If the size of the map (the number of key-value mappings) sufficiently exceeds the expected maximum size, the number of buckets is increased. Increasing the number of buckets ("rehashing") may be fairly expensive, so it pays to create identity hash maps with a sufficiently large expected maximum size. On the other hand, iteration over collection views requires time proportional to the number of buckets in the hash table, so it pays not to set the expected maximum size too high if you are especially concerned with iteration performance or memory usage. Note that this implementation is not synchronized. If multiple threads access an identity hash map concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more mappings; merely changing the value associated with a key that an instance already contains is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the map. If no such object exists, the map should be "wrapped" using the synchronizedMap Collections.synchronizedMap method. This is best done at creation time, to prevent accidental unsynchronized access to the map: Map m = Collections.synchronizedMap(new IdentityHashMap(...)); The iterators returned by the iterator method of the collections returned by all of this class's "collection view methods" are fail-fast: if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: fail-fast iterators should be used only to detect bugs. Implementation note: This is a simple linear-probe hash table, as described for example in texts by Sedgewick and Knuth. The array alternates holding keys and values. (This has better locality for large tables than does using separate arrays.) For many JRE implementations and operation mixes, this class will yield better performance than HashMap (which uses chaining rather than linear-probing). This class is a member of the  Java Collections Framework.
java.util.IdentityHashMap: java.util.IdentityHashMap.IdentityHashMap	(	):  Constructs a new, empty identity hash map with a default expected maximum size (21).
java.util.IdentityHashMap: java.util.IdentityHashMap.IdentityHashMap	(	Map	):  Constructs a new identity hash map containing the keys-value mappings in the specified map.
java.util.IdentityHashMap: java.util.IdentityHashMap.IdentityHashMap	(	int	):  Constructs a new, empty map with the specified expected maximum size. Putting more than the expected number of key-value mappings into the map may cause the internal data structure to grow, which may be somewhat time-consuming.
java.util.IdentityHashMap: java.util.IdentityHashMap.IdentityHashMapSpliterator:  Similar form as array-based Spliterators, but skips blank elements, and guestimates size as decreasing by half per split.
java.util.IdentityHashMap: java.util.IdentityHashMap.capacity	(	int	):  Returns the appropriate capacity for the given expected maximum size. Returns the smallest power of two between MINIMUM_CAPACITY and MAXIMUM_CAPACITY, inclusive, that is greater than (3 expectedMaxSize)/2, if such a number exists. Otherwise returns MAXIMUM_CAPACITY.
java.util.IdentityHashMap: java.util.IdentityHashMap.clear	(	):  Removes all of the mappings from this map. The map will be empty after this call returns.
java.util.IdentityHashMap: java.util.IdentityHashMap.clone	(	):  Returns a shallow copy of this identity hash map: the keys and values themselves are not cloned.
java.util.IdentityHashMap: java.util.IdentityHashMap.closeDeletion	(	int	):  Rehash all possibly-colliding entries following a deletion. This preserves the linear-probe collision properties required by get, put, etc.
java.util.IdentityHashMap: java.util.IdentityHashMap.containsKey	(	Object	):  Tests whether the specified object reference is a key in this identity hash map.
java.util.IdentityHashMap: java.util.IdentityHashMap.containsMapping	(	Object	Object	):  Tests if the specified key-value mapping is in the map.
java.util.IdentityHashMap: java.util.IdentityHashMap.containsValue	(	Object	):  Tests whether the specified object reference is a value in this identity hash map.
java.util.IdentityHashMap: java.util.IdentityHashMap.entrySet	(	):  Returns a Set view of the mappings contained in this map. Each element in the returned set is a reference-equality-based Map.Entry. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress, the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll and clear methods. It does not support the add or addAll methods. Like the backing map, the Map.Entry objects in the set returned by this method define key and value equality as reference-equality rather than object-equality. This affects the behavior of the equals and hashCode methods of these Map.Entry objects. A reference-equality based Map.Entry e is equal to an object o if and only if o is a Map.Entry and e.getKey()==o.getKey() && e.getValue()==o.getValue(). To accommodate these equals semantics, the hashCode method returns System.identityHashCode(e.getKey()) ^ System.identityHashCode(e.getValue()). Owing to the reference-equality-based semantics of the Map.Entry instances in the set returned by this method, it is possible that the symmetry and transitivity requirements of the equals() contract may be violated if any of the entries in the set is compared to a normal map entry, or if the set returned by this method is compared to a set of normal map entries (such as would be returned by a call to this method on a normal map). However, the Object.equals contract is guaranteed to hold among identity-based map entries, and among sets of such entries. 
java.util.IdentityHashMap: java.util.IdentityHashMap.equals	(	Object	):  Compares the specified object with this map for equality. Returns true if the given object is also a map and the two maps represent identical object-reference mappings. More formally, this map is equal to another map m if and only if this.entrySet().equals(m.entrySet()). Owing to the reference-equality-based semantics of this map it is possible that the symmetry and transitivity requirements of the Object.equals contract may be violated if this map is compared to a normal map. However, the Object.equals contract is guaranteed to hold among IdentityHashMap instances.
java.util.IdentityHashMap: java.util.IdentityHashMap.get	(	Object	):  Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that (key == k), then this method returns v; otherwise it returns null. (There can be at most one such mapping.) A return value of null does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to null. The containsKey operation may be used to distinguish these two cases.
java.util.IdentityHashMap: java.util.IdentityHashMap.hash	(	Object	int	):  Returns index for Object x.
java.util.IdentityHashMap: java.util.IdentityHashMap.hashCode	(	):  Returns the hash code value for this map. The hash code of a map is defined to be the sum of the hash codes of each entry in the map's entrySet() view. This ensures that m1.equals(m2) implies that m1.hashCode()==m2.hashCode() for any two IdentityHashMap instances m1 and m2, as required by the general contract of hashCode. Owing to the reference-equality-based semantics of the Map.Entry instances in the set returned by this map's entrySet method, it is possible that the contractual requirement of Object.hashCode mentioned in the previous paragraph will be violated if one of the two objects being compared is an IdentityHashMap instance and the other is a normal map.
java.util.IdentityHashMap: java.util.IdentityHashMap.init	(	int	):  Initializes object to be an empty map with the specified initial capacity, which is assumed to be a power of two between MINIMUM_CAPACITY and MAXIMUM_CAPACITY inclusive.
java.util.IdentityHashMap: java.util.IdentityHashMap.isEmpty	(	):  Returns true if this identity hash map contains no key-value mappings.
java.util.IdentityHashMap: java.util.IdentityHashMap.keySet	(	):  Returns an identity-based set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress, the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear methods. It does not support the add or addAll methods. While the object returned by this method implements the Set interface, it does not obey Set's general contract. Like its backing map, the set returned by this method defines element equality as reference-equality rather than object-equality. This affects the behavior of its contains, remove, containsAll, equals, and hashCode methods. The equals method of the returned set returns true only if the specified object is a set containing exactly the same object references as the returned set. The symmetry and transitivity requirements of the Object.equals contract may be violated if the set returned by this method is compared to a normal set. However, the Object.equals contract is guaranteed to hold among sets returned by this method. The hashCode method of the returned set returns the sum of the identity hashcodes of the elements in the set, rather than the sum of their hashcodes. This is mandated by the change in the semantics of the equals method, in order to enforce the general contract of the Object.hashCode method among sets returned by this method.
java.util.IdentityHashMap: java.util.IdentityHashMap.maskNull	(	Object	):  Use NULL_KEY for key if it is null.
java.util.IdentityHashMap: java.util.IdentityHashMap.nextKeyIndex	(	int	int	):  Circularly traverses table of size len.
java.util.IdentityHashMap: java.util.IdentityHashMap.put	(	K	V	):  Associates the specified value with the specified key in this identity hash map. If the map previously contained a mapping for the key, the old value is replaced.
java.util.IdentityHashMap: java.util.IdentityHashMap.putAll	(	Map	):  Copies all of the mappings from the specified map to this map. These mappings will replace any mappings that this map had for any of the keys currently in the specified map.
java.util.IdentityHashMap: java.util.IdentityHashMap.putForCreate	(	K	V	):  The put method for readObject. It does not resize the table, update modCount, etc.
java.util.IdentityHashMap: java.util.IdentityHashMap.readObject	(	java.io.ObjectInputStream	):  Reconstitutes the IdentityHashMap instance from a stream (i.e., deserializes it).
java.util.IdentityHashMap: java.util.IdentityHashMap.remove	(	Object	):  Removes the mapping for this key from this map if present.
java.util.IdentityHashMap: java.util.IdentityHashMap.removeMapping	(	Object	Object	):  Removes the specified key-value mapping from the map if it is present.
java.util.IdentityHashMap: java.util.IdentityHashMap.resize	(	int	):  Resizes the table if necessary to hold given capacity.
java.util.IdentityHashMap: java.util.IdentityHashMap.size	(	):  Returns the number of key-value mappings in this identity hash map.
java.util.IdentityHashMap: java.util.IdentityHashMap.unmaskNull	(	Object	):  Returns internal representation of null key back to caller as null.
java.util.IdentityHashMap: java.util.IdentityHashMap.values	(	):  Returns a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress, the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear methods. It does not support the add or addAll methods. While the object returned by this method implements the Collection interface, it does not obey Collection's general contract. Like its backing map, the collection returned by this method defines element equality as reference-equality rather than object-equality. This affects the behavior of its contains, remove and containsAll methods.
java.util.IdentityHashMap: java.util.IdentityHashMap.writeObject	(	java.io.ObjectOutputStream	):  Saves the state of the IdentityHashMap instance to a stream (i.e., serializes it).
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap:  A hash table supporting full concurrency of retrievals and high expected concurrency for updates. This class obeys the same functional specification as java.util.Hashtable, and includes versions of methods corresponding to each method of Hashtable. However, even though all operations are thread-safe, retrieval operations do not entail locking, and there is not any support for locking the entire table in a way that prevents all access. This class is fully interoperable with Hashtable in programs that rely on its thread safety but not on its synchronization details. Retrieval operations (including get) generally do not block, so may overlap with update operations (including put and remove). Retrievals reflect the results of the most recently completed update operations holding upon their onset. (More formally, an update operation for a given key bears a happens-before relation with any (non-null) retrieval for that key reporting the updated value.) For aggregate operations such as putAll and clear, concurrent retrievals may reflect insertion or removal of only some entries. Similarly, Iterators, Spliterators and Enumerations return elements reflecting the state of the hash table at some point at or since the creation of the iterator/enumeration. They do not throw java.util.ConcurrentModificationException ConcurrentModificationException. However, iterators are designed to be used by only one thread at a time. Bear in mind that the results of aggregate status methods including size, isEmpty, and containsValue are typically useful only when a map is not undergoing concurrent updates in other threads. Otherwise the results of these methods reflect transient states that may be adequate for monitoring or estimation purposes, but not for program control. The table is dynamically expanded when there are too many collisions (i.e., keys that have distinct hash codes but fall into the same slot modulo the table size), with the expected average effect of maintaining roughly two bins per mapping (corresponding to a 0.75 load factor threshold for resizing). There may be much variance around this average as mappings are added and removed, but overall, this maintains a commonly accepted time/space tradeoff for hash tables. However, resizing this or any other kind of hash table may be a relatively slow operation. When possible, it is a good idea to provide a size estimate as an optional initialCapacity constructor argument. An additional optional loadFactor constructor argument provides a further means of customizing initial table capacity by specifying the table density to be used in calculating the amount of space to allocate for the given number of elements. Also, for compatibility with previous versions of this class, constructors may optionally specify an expected concurrencyLevel as an additional hint for internal sizing. Note that using many keys with exactly the same hashCode() is a sure way to slow down performance of any hash table. To ameliorate impact, when keys are Comparable, this class may use comparison order among keys to help break ties. A Set projection of a ConcurrentHashMap may be created (using newKeySet() or newKeySet()), or viewed (using keySet() when only keys are of interest, and the mapped values are (perhaps transiently) not used or all take the same mapping value. A ConcurrentHashMap can be used as scalable frequency map (a form of histogram or multiset) by using java.util.concurrent.atomic.LongAdder values and initializing via computeIfAbsent. For example, to add a count to a ConcurrentHashMap freqs, you can use freqs.computeIfAbsent(k -> new LongAdder()).increment(); This class and its views and iterators implement all of the optional methods of the Map and Iterator interfaces. Like Hashtable but unlike HashMap, this class does not allow null to be used as a key or value. ConcurrentHashMaps support a set of sequential and parallel bulk operations that, unlike most Stream methods, are designed to be safely, and often sensibly, applied even with maps that are being concurrently updated by other threads; for example, when computing a snapshot summary of the values in a shared registry. There are three kinds of operation, each with four forms, accepting functions with Keys, Values, Entries, and (Key, Value) arguments and/or return values. Because the elements of a ConcurrentHashMap are not ordered in any particular way, and may be processed in different orders in different parallel executions, the correctness of supplied functions should not depend on any ordering, or on any other objects or values that may transiently change while computation is in progress; and except for forEach actions, should ideally be side-effect-free. Bulk operations on java.util.Map.Entry objects do not support method setValue.   forEach: Perform a given action on each element. A variant form applies a given transformation on each element before performing the action.  search: Return the first available non-null result of applying a given function on each element; skipping further search when a result is found.  reduce: Accumulate each element. The supplied reduction function cannot rely on ordering (more formally, it should be both associative and commutative). There are five variants:   Plain reductions. (There is not a form of this method for (key, value) function arguments since there is no corresponding return type.)  Mapped reductions that accumulate the results of a given function applied to each element.  Reductions to scalar doubles, longs, and ints, using a given basis value.    These bulk operations accept a parallelismThreshold argument. Methods proceed sequentially if the current map size is estimated to be less than the given threshold. Using a value of Long.MAX_VALUE suppresses all parallelism. Using a value of 1 results in maximal parallelism by partitioning into enough subtasks to fully utilize the commonPool() that is used for all parallel computations. Normally, you would initially choose one of these extreme values, and then measure performance of using in-between values that trade off overhead versus throughput. The concurrency properties of bulk operations follow from those of ConcurrentHashMap: Any non-null result returned from get(key) and related access methods bears a happens-before relation with the associated insertion or update. The result of any bulk operation reflects the composition of these per-element relations (but is not necessarily atomic with respect to the map as a whole unless it is somehow known to be quiescent). Conversely, because keys and values in the map are never null, null serves as a reliable atomic indicator of the current lack of any result. To maintain this property, null serves as an implicit basis for all non-scalar reduction operations. For the double, long, and int versions, the basis should be one that, when combined with any other value, returns that other value (more formally, it should be the identity element for the reduction). Most common reductions have these properties; for example, computing a sum with basis 0 or a minimum with basis MAX_VALUE. Search and transformation functions provided as arguments should similarly return null to indicate the lack of any result (in which case it is not used). In the case of mapped reductions, this also enables transformations to serve as filters, returning null (or, in the case of primitive specializations, the identity basis) if the element should not be combined. You can create compound transformations and filterings by composing them yourself under this "null means there is nothing there now" rule before using them in search or reduce operations. Methods accepting and/or returning Entry arguments maintain key-value associations. They may be useful for example when finding the key for the greatest value. Note that "plain" Entry arguments can be supplied using new AbstractMap.SimpleEntry(k,v). Bulk operations may complete abruptly, throwing an exception encountered in the application of a supplied function. Bear in mind when handling such exceptions that other concurrently executing functions could also have thrown exceptions, or would have done so if the first exception had not occurred. Speedups for parallel compared to sequential forms are common but not guaranteed. Parallel operations involving brief functions on small maps may execute more slowly than sequential forms if the underlying work to parallelize the computation is more expensive than the computation itself. Similarly, parallelization may not lead to much actual parallelism if all processors are busy performing unrelated tasks. All arguments to all task methods must be non-null. This class is a member of the  Java Collections Framework.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.BaseIterator:  Base of key, value, and entry Iterators. Adds fields to Traverser to support iterator.remove.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.BulkTask:  Base class for bulk tasks. Repeats some fields and code from class Traverser, because we need to subclass CountedCompleter.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.BulkTask.advance	(	):  Same as Traverser version
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.CollectionView:  Base class for views.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.CollectionView.clear	(	):  Removes all of the elements from this view, by removing all the mappings from the map backing this view.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.CollectionView.getMap	(	):  Returns the map backing this view.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.CollectionView.iterator	(	):  Returns an iterator over the elements in this collection. The returned iterator is weakly consistent.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.CollectionView.toString	(	):  Returns a string representation of this collection. The string representation consists of the string representations of the collection's elements in the order they are returned by its iterator, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (comma and space). Elements are converted to strings as by valueOf().
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.ConcurrentHashMap	(	):  Creates a new, empty map with the default initial table size (16).
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.ConcurrentHashMap	(	Map	):  Creates a new map with the same mappings as the given map.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.ConcurrentHashMap	(	int	):  Creates a new, empty map with an initial table size accommodating the specified number of elements without the need to dynamically resize.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.ConcurrentHashMap	(	int	float	):  Creates a new, empty map with an initial table size based on the given number of elements (initialCapacity) and initial table density (loadFactor).
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.ConcurrentHashMap	(	int	float	int	):  Creates a new, empty map with an initial table size based on the given number of elements (initialCapacity), table density (loadFactor), and number of concurrently updating threads (concurrencyLevel).
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.CounterCell:  A padded cell for distributing counts. Adapted from LongAdder and Striped64. See their internal docs for explanation.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.EntrySetView:  A view of a ConcurrentHashMap as a Set of (key, value) entries. This class cannot be directly instantiated. See entrySet().
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.EntrySetView.iterator	(	):  Returns an iterator over the elements in this collection. The returned iterator is weakly consistent.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.ForwardingNode:  A node inserted at head of bins during transfer operations.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.KeySetView:  A view of a ConcurrentHashMap as a Set of keys, in which additions may optionally be enabled by mapping to a common value. This class cannot be directly instantiated. See keySet() keySet(), keySet() keySet(V), newKeySet() newKeySet(), newKeySet() newKeySet(int).
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.KeySetView.add	(	K	):  Adds the specified key to this set view by mapping the key to the default mapped value in the backing map, if defined.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.KeySetView.addAll	(	Collection	):  Adds all of the elements in the specified collection to this set, as if by calling add on each one.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.KeySetView.contains	(	Object	):  
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.KeySetView.getMappedValue	(	):  Returns the default mapped value for additions, or null if additions are not supported.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.KeySetView.iterator	(	):  Returns an iterator over the elements in this collection. The returned iterator is weakly consistent.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.KeySetView.remove	(	Object	):  Removes the key from this map view, by removing the key (and its corresponding value) from the backing map. This method does nothing if the key is not in the map.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.MapEntry:  Exported Entry for EntryIterator
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.MapEntry.setValue	(	V	):  Sets our entry's value and writes through to the map. The value to return is somewhat arbitrary here. Since we do not necessarily track asynchronous changes, the most recent "previous" value could be different from what we return (or could even have been removed, in which case the put will re-establish). We do not and cannot guarantee more.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.Node:  Key-value entry. This class is never exported out as a user-mutable Map.Entry (i.e., one supporting setValue; see MapEntry below), but can be used for read-only traversals used in bulk tasks. Subclasses of Node with a negative hash field are special, and contain null keys and values (but are never exported). Otherwise, keys and vals are never null.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.Node.find	(	int	Object	):  Virtualized support for map.get(); overridden in subclasses.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.ReservationNode:  A place-holder node used in computeIfAbsent and compute
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.Segment:  Stripped-down version of helper class used in previous version, declared for the sake of serialization compatibility
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TableStack:  Records the table, its length, and current traversal index for a traverser that must process a region of a forwarded table before proceeding with current table.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.Traverser:  Encapsulates traversal for methods such as containsValue; also serves as a base class for other iterators and spliterators. Method advance visits once each still-valid node that was reachable upon iterator construction. It might miss some that were added to a bin after the bin was visited, which is OK wrt consistency guarantees. Maintaining this property in the face of possible ongoing resizes requires a fair amount of bookkeeping state that is difficult to optimize away amidst volatile accesses. Even so, traversal maintains reasonable throughput. Normally, iteration proceeds bin-by-bin traversing lists. However, if the table has been resized, then all future steps must traverse both the bin at the current index as well as at (index + baseSize); and so on for further resizings. To paranoically cope with potential sharing by users of iterators across threads, iteration terminates if a bounds checks fails for a table read.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.Traverser.advance	(	):  Advances if possible, returning next valid node, or null if none.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.Traverser.pushState	(	Node[]	int	int	):  Saves traversal state upon encountering a forwarding node.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.Traverser.recoverState	(	int	):  Possibly pops traversal state.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin:  TreeNodes used at the heads of bins. TreeBins do not hold user keys or values, but instead point to list of TreeNodes and their root. They also maintain a parasitic read-write lock forcing writers (who hold bin lock) to wait for readers (who do not) to complete before tree restructuring operations.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin.TreeBin	(	TreeNode	):  Creates bin with initial set of nodes headed by b.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin.checkInvariants	(	TreeNode	):  Recursive invariant check
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin.contendedLock	(	):  Possibly blocks awaiting root lock.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin.find	(	int	Object	):  Returns matching node or null if none. Tries to search using tree comparisons from root, but continues linear search when lock not available.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin.lockRoot	(	):  Acquires write lock for tree restructuring.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin.putTreeVal	(	int	K	V	):  Finds or adds a node.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin.removeTreeNode	(	TreeNode	):  Removes the given node, that must be present before this call. This is messier than typical red-black deletion code because we cannot swap the contents of an interior node with a leaf successor that is pinned by "next" pointers that are accessible independently of lock. So instead we swap the tree linkages.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin.tieBreakOrder	(	Object	Object	):  Tie-breaking utility for ordering insertions when equal hashCodes and non-comparable. We don't require a total order, just a consistent insertion rule to maintain equivalence across rebalancings. Tie-breaking further than necessary simplifies testing a bit.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeBin.unlockRoot	(	):  Releases write lock for tree restructuring.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeNode:  Nodes for use in TreeBins
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.TreeNode.findTreeNode	(	int	Object	Class	):  Returns the TreeNode (or null if not found) for the given key starting at given root.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.ValuesView:  A view of a ConcurrentHashMap as a Collection of values, in which additions are disabled. This class cannot be directly instantiated. See values().
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.addCount	(	long	int	):  Adds to count, and if table is too small and not already resizing, initiates transfer. If already resizing, helps perform transfer if work is available. Rechecks occupancy after a transfer to see if another resize is already needed because resizings are lagging additions.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.batchFor	(	long	):  Computes initial batch value for bulk tasks. The returned value is approximately exp2 of the number of times (minus one) to split task by two before executing leaf action. This value is faster to compute and more convenient to use as a guide to splitting than is the depth, since it is used while dividing by two anyway.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.clear	(	):  Removes all of the mappings from this map.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.comparableClassFor	(	Object	):  Returns x's Class if it is of the form "class C implements Comparable", else null.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.compareComparables	(	Class	Object	Object	):  Returns k.compareTo(x) if x matches kc (k's screened comparable class), else 0.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.compute	(	K	BiFunction	):  Attempts to compute a mapping for the specified key and its current mapped value (or null if there is no current mapping). The entire method invocation is performed atomically. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this Map.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.computeIfAbsent	(	K	Function	):  If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless null. The entire method invocation is performed atomically, so the function is applied at most once per key. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this map.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.computeIfPresent	(	K	BiFunction	):  If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value. The entire method invocation is performed atomically. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this map.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.contains	(	Object	):  Legacy method testing if some key maps into the specified value in this table. This method is identical in functionality to containsValue(), and exists solely to ensure full compatibility with class java.util.Hashtable, which supported this method prior to introduction of the Java Collections framework.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.containsKey	(	Object	):  Tests if the specified object is a key in this table.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.containsValue	(	Object	):  Returns true if this map maps one or more keys to the specified value. Note: This method may require a full traversal of the map, and is much slower than method containsKey.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.elements	(	):  Returns an enumeration of the values in this table.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.entrySet	(	):  Returns a Set view of the mappings contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. The view's iterators and spliterators are weakly consistent. The view's spliterator reports CONCURRENT, DISTINCT, and NONNULL.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.equals	(	Object	):  Compares the specified object with this map for equality. Returns true if the given object is a map with the same mappings as this map. This operation may return misleading results if either map is concurrently modified during execution of this method.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.forEach	(	long	BiConsumer	):  Performs the given action for each (key, value).
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.forEach	(	long	BiFunction	Consumer	):  Performs the given action for each non-null transformation of each (key, value).
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.forEachEntry	(	long	Consumer	):  Performs the given action for each entry.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.forEachEntry	(	long	Function	Consumer	):  Performs the given action for each non-null transformation of each entry.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.forEachKey	(	long	Consumer	):  Performs the given action for each key.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.forEachKey	(	long	Function	Consumer	):  Performs the given action for each non-null transformation of each key.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.forEachValue	(	long	Consumer	):  Performs the given action for each value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.forEachValue	(	long	Function	Consumer	):  Performs the given action for each non-null transformation of each value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.get	(	Object	):  Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that key.equals(k), then this method returns v; otherwise it returns null. (There can be at most one such mapping.)
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.getOrDefault	(	Object	V	):  Returns the value to which the specified key is mapped, or the given default value if this map contains no mapping for the key.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.hashCode	(	):  Returns the hash code value for this Map, i.e., the sum of, for each key-value pair in the map, key.hashCode() ^ value.hashCode().
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.helpTransfer	(	Node[]	Node	):  Helps transfer if a resize is in progress.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.initTable	(	):  Initializes table, using the size recorded in sizeCtl.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.isEmpty	(	):  Returns true if this map contains no key-value mappings.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.keySet	(	):  Returns a Set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. The set supports element removal, which removes the corresponding mapping from this map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations. The view's iterators and spliterators are weakly consistent. The view's spliterator reports CONCURRENT, DISTINCT, and NONNULL.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.keySet	(	V	):  Returns a Set view of the keys in this map, using the given common mapped value for any additions (i.e., add and addAll()). This is of course only appropriate if it is acceptable to use the same value for all additions from this view.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.keys	(	):  Returns an enumeration of the keys in this table.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.mappingCount	(	):  Returns the number of mappings. This method should be used instead of size because a ConcurrentHashMap may contain more mappings than can be represented as an int. The value returned is an estimate; the actual count may differ if there are concurrent insertions or removals.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.merge	(	K	V	BiFunction	):  If the specified key is not already associated with a (non-null) value, associates it with the given value. Otherwise, replaces the value with the results of the given remapping function, or removes if null. The entire method invocation is performed atomically. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this Map.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.newKeySet	(	):  Creates a new Set backed by a ConcurrentHashMap from the given type to Boolean.TRUE.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.newKeySet	(	int	):  Creates a new Set backed by a ConcurrentHashMap from the given type to Boolean.TRUE.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.put	(	K	V	):  Maps the specified key to the specified value in this table. Neither the key nor the value can be null. The value can be retrieved by calling the get method with a key that is equal to the original key.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.putAll	(	Map	):  Copies all of the mappings from the specified map to this one. These mappings replace any mappings that this map had for any of the keys currently in the specified map.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.putIfAbsent	(	K	V	):  If the specified key is not already associated with a value (or is mapped to null) associates it with the given value and returns null, else returns the current value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.putVal	(	K	V	boolean	):  Implementation for put and putIfAbsent 
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.readObject	(	java.io.ObjectInputStream	):  Reconstitutes the instance from a stream (that is, deserializes it).
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduce	(	long	BiFunction	BiFunction	):  Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceEntries	(	long	BiFunction	):  Returns the result of accumulating all entries using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceEntries	(	long	Function	BiFunction	):  Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceEntriesToDouble	(	long	ToDoubleFunction	double	DoubleBinaryOperator	):  Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceEntriesToInt	(	long	ToIntFunction	int	IntBinaryOperator	):  Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceEntriesToLong	(	long	ToLongFunction	long	LongBinaryOperator	):  Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceKeys	(	long	BiFunction	):  Returns the result of accumulating all keys using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceKeys	(	long	Function	BiFunction	):  Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceKeysToDouble	(	long	ToDoubleFunction	double	DoubleBinaryOperator	):  Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceKeysToInt	(	long	ToIntFunction	int	IntBinaryOperator	):  Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceKeysToLong	(	long	ToLongFunction	long	LongBinaryOperator	):  Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceToDouble	(	long	ToDoubleBiFunction	double	DoubleBinaryOperator	):  Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceToInt	(	long	ToIntBiFunction	int	IntBinaryOperator	):  Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceToLong	(	long	ToLongBiFunction	long	LongBinaryOperator	):  Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceValues	(	long	BiFunction	):  Returns the result of accumulating all values using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceValues	(	long	Function	BiFunction	):  Returns the result of accumulating the given transformation of all values using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceValuesToDouble	(	long	ToDoubleFunction	double	DoubleBinaryOperator	):  Returns the result of accumulating the given transformation of all values using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceValuesToInt	(	long	ToIntFunction	int	IntBinaryOperator	):  Returns the result of accumulating the given transformation of all values using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.reduceValuesToLong	(	long	ToLongFunction	long	LongBinaryOperator	):  Returns the result of accumulating the given transformation of all values using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.remove	(	Object	):  Removes the key (and its corresponding value) from this map. This method does nothing if the key is not in the map.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.remove	(	Object	Object	):  Removes the entry for the specified key only if it is currently mapped to the specified value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.replace	(	K	V	):  Replaces the entry for the specified key only if it is currently mapped to some value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.replace	(	K	V	V	):  Replaces the entry for the specified key only if currently mapped to the specified value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.replaceNode	(	Object	V	Object	):  Implementation for the four public remove/replace methods: Replaces node value with v, conditional upon match of cv if non-null. If resulting value is null, delete.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.resizeStamp	(	int	):  Returns the stamp bits for resizing a table of size n. Must be negative when shifted left by RESIZE_STAMP_SHIFT.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.search	(	long	BiFunction	):  Returns a non-null result from applying the given search function on each (key, value), or null if none. Upon success, further element processing is suppressed and the results of any other parallel invocations of the search function are ignored.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.searchEntries	(	long	Function	):  Returns a non-null result from applying the given search function on each entry, or null if none. Upon success, further element processing is suppressed and the results of any other parallel invocations of the search function are ignored.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.searchKeys	(	long	Function	):  Returns a non-null result from applying the given search function on each key, or null if none. Upon success, further element processing is suppressed and the results of any other parallel invocations of the search function are ignored.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.searchValues	(	long	Function	):  Returns a non-null result from applying the given search function on each value, or null if none. Upon success, further element processing is suppressed and the results of any other parallel invocations of the search function are ignored.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.size	(	):  Returns the number of key-value mappings in this map. If the map contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.spread	(	int	):  Spreads (XORs) higher bits of hash to lower and also forces top bit to 0. Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.) So we apply a transform that spreads the impact of higher bits downward. There is a tradeoff between speed, utility, and quality of bit-spreading. Because many common sets of hashes are already reasonably distributed (so don't benefit from spreading), and because we use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.tableSizeFor	(	int	):  Returns a power of two table size for the given desired capacity. See Hackers Delight, sec 3.2
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.toString	(	):  Returns a string representation of this map. The string representation consists of a list of key-value mappings (in no particular order) enclosed in braces (" "). Adjacent mappings are separated by the characters ", " (comma and space). Each key-value mapping is rendered as the key followed by an equals sign ("=") followed by the associated value.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.transfer	(	Node[]	Node[]	):  Moves and/or copies the nodes in each bin to new table. See above for explanation.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.treeifyBin	(	Node[]	int	):  Replaces all linked nodes in bin at given index unless table is too small, in which case resizes instead.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.tryPresize	(	int	):  Tries to presize table to accommodate the given number of elements.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.untreeify	(	Node	):  Returns a list on non-TreeNodes replacing those in given list.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.values	(	):  Returns a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. The collection supports element removal, which removes the corresponding mapping from this map, via the Iterator.remove, Collection.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations. The view's iterators and spliterators are weakly consistent. The view's spliterator reports CONCURRENT and NONNULL.
java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.writeObject	(	java.io.ObjectOutputStream	):  Saves the state of the ConcurrentHashMap instance to a stream (i.e., serializes it).
java.util.Queue: java.util.Queue:  A collection designed for holding elements prior to processing. Besides basic java.util.Collection Collection operations, queues provide additional insertion, extraction, and inspection operations. Each of these methods exists in two forms: one throws an exception if the operation fails, the other returns a special value (either null or false, depending on the operation). The latter form of the insert operation is designed specifically for use with capacity-restricted Queue implementations; in most implementations, insert operations cannot fail.  Summary of Queue methods   Throws exception Returns special value   Insert add add(e) offer offer(e)   Remove remove remove() poll poll()   Examine element element() peek peek()   Queues typically, but do not necessarily, order elements in a FIFO (first-in-first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator, or the elements' natural ordering, and LIFO queues (or stacks) which order the elements LIFO (last-in-first-out). Whatever the ordering used, the head of the queue is that element which would be removed by a call to remove() or poll(). In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. The offer method inserts an element if possible, otherwise returning false. This differs from the add Collection.add method, which can fail to add an element only by throwing an unchecked exception. The offer method is designed for use when failure is a normal, rather than exceptional occurrence, for example, in fixed-capacity (or "bounded") queues. The remove() and poll() methods remove and return the head of the queue. Exactly which element is removed from the queue is a function of the queue's ordering policy, which differs from implementation to implementation. The remove() and poll() methods differ only in their behavior when the queue is empty: the remove() method throws an exception, while the poll() method returns null. The element() and peek() methods return, but do not remove, the head of the queue. The Queue interface does not define the blocking queue methods, which are common in concurrent programming. These methods, which wait for elements to appear or for space to become available, are defined in the java.util.concurrent.BlockingQueue interface, which extends this interface. Queue implementations generally do not allow insertion of null elements, although some implementations, such as LinkedList, do not prohibit insertion of null. Even in the implementations that permit it, null should not be inserted into a Queue, as null is also used as a special return value by the poll method to indicate that the queue contains no elements. Queue implementations generally do not define element-based versions of methods equals and hashCode but instead inherit the identity based versions from class Object, because element-based equality is not always well-defined for queues with the same elements but different ordering properties. This interface is a member of the  Java Collections Framework.
java.util.Queue: java.util.Queue.add	(	E	):  Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an IllegalStateException if no space is currently available.
java.util.Queue: java.util.Queue.element	(	):  Retrieves, but does not remove, the head of this queue. This method differs from peek only in that it throws an exception if this queue is empty.
java.util.Queue: java.util.Queue.offer	(	E	):  Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions. When using a capacity-restricted queue, this method is generally preferable to add, which can fail to insert an element only by throwing an exception.
java.util.Queue: java.util.Queue.peek	(	):  Retrieves, but does not remove, the head of this queue, or returns null if this queue is empty.
java.util.Queue: java.util.Queue.poll	(	):  Retrieves and removes the head of this queue, or returns null if this queue is empty.
java.util.Queue: java.util.Queue.remove	(	):  Retrieves and removes the head of this queue. This method differs from poll only in that it throws an exception if this queue is empty.
java.util.PriorityQueue: java.util.PriorityQueue:  An unbounded priority Queue queue based on a priority heap. The elements of the priority queue are ordered according to their Comparable natural ordering, or by a Comparator provided at queue construction time, depending on which constructor is used. A priority queue does not permit null elements. A priority queue relying on natural ordering also does not permit insertion of non-comparable objects (doing so may result in ClassCastException). The head of this queue is the least element with respect to the specified ordering. If multiple elements are tied for least value, the head is one of those elements -- ties are broken arbitrarily. The queue retrieval operations poll, remove, peek, and element access the element at the head of the queue. A priority queue is unbounded, but has an internal capacity governing the size of an array used to store the elements on the queue. It is always at least as large as the queue size. As elements are added to a priority queue, its capacity grows automatically. The details of the growth policy are not specified. This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces. The Iterator provided in method iterator() is not guaranteed to traverse the elements of the priority queue in any particular order. If you need ordered traversal, consider using Arrays.sort(pq.toArray()). Note that this implementation is not synchronized. Multiple threads should not access a PriorityQueue instance concurrently if any of the threads modifies the queue. Instead, use the thread-safe java.util.concurrent.PriorityBlockingQueue class. Implementation note: this implementation provides O(log(n)) time for the enqueuing and dequeuing methods (offer, poll, remove() and add); linear time for the remove(Object) and contains(Object) methods; and constant time for the retrieval methods (peek, element, and size). This class is a member of the  Java Collections Framework.
java.util.PriorityQueue: java.util.PriorityQueue.PriorityQueue	(	):  Creates a PriorityQueue with the default initial capacity (11) that orders its elements according to their Comparable natural ordering.
java.util.PriorityQueue: java.util.PriorityQueue.PriorityQueue	(	Collection	):  Creates a PriorityQueue containing the elements in the specified collection. If the specified collection is an instance of a SortedSet or is another PriorityQueue, this priority queue will be ordered according to the same ordering. Otherwise, this priority queue will be ordered according to the Comparable natural ordering of its elements.
java.util.PriorityQueue: java.util.PriorityQueue.PriorityQueue	(	Comparator	):  Creates a PriorityQueue with the default initial capacity and whose elements are ordered according to the specified comparator.
java.util.PriorityQueue: java.util.PriorityQueue.PriorityQueue	(	PriorityQueue	):  Creates a PriorityQueue containing the elements in the specified priority queue. This priority queue will be ordered according to the same ordering as the given priority queue.
java.util.PriorityQueue: java.util.PriorityQueue.PriorityQueue	(	SortedSet	):  Creates a PriorityQueue containing the elements in the specified sorted set. This priority queue will be ordered according to the same ordering as the given sorted set.
java.util.PriorityQueue: java.util.PriorityQueue.PriorityQueue	(	int	):  Creates a PriorityQueue with the specified initial capacity that orders its elements according to their Comparable natural ordering.
java.util.PriorityQueue: java.util.PriorityQueue.PriorityQueue	(	int	Comparator	):  Creates a PriorityQueue with the specified initial capacity that orders its elements according to the specified comparator.
java.util.PriorityQueue: java.util.PriorityQueue.PriorityQueueSpliterator.PriorityQueueSpliterator	(	PriorityQueue	int	int	int	):  Creates new spliterator covering the given range 
java.util.PriorityQueue: java.util.PriorityQueue.add	(	E	):  Inserts the specified element into this priority queue.
java.util.PriorityQueue: java.util.PriorityQueue.clear	(	):  Removes all of the elements from this priority queue. The queue will be empty after this call returns.
java.util.PriorityQueue: java.util.PriorityQueue.comparator	(	):  Returns the comparator used to order the elements in this queue, or null if this queue is sorted according to the Comparable natural ordering of its elements.
java.util.PriorityQueue: java.util.PriorityQueue.contains	(	Object	):  Returns true if this queue contains the specified element. More formally, returns true if and only if this queue contains at least one element e such that o.equals(e).
java.util.PriorityQueue: java.util.PriorityQueue.grow	(	int	):  Increases the capacity of the array.
java.util.PriorityQueue: java.util.PriorityQueue.heapify	(	):  Establishes the heap invariant (described above) in the entire tree, assuming nothing about the order of the elements prior to the call.
java.util.PriorityQueue: java.util.PriorityQueue.initFromCollection	(	Collection	):  Initializes queue array with elements from the given Collection.
java.util.PriorityQueue: java.util.PriorityQueue.iterator	(	):  Returns an iterator over the elements in this queue. The iterator does not return the elements in any particular order.
java.util.PriorityQueue: java.util.PriorityQueue.offer	(	E	):  Inserts the specified element into this priority queue.
java.util.PriorityQueue: java.util.PriorityQueue.readObject	(	java.io.ObjectInputStream	):  Reconstitutes the PriorityQueue instance from a stream (that is, deserializes it).
java.util.PriorityQueue: java.util.PriorityQueue.remove	(	Object	):  Removes a single instance of the specified element from this queue, if it is present. More formally, removes an element e such that o.equals(e), if this queue contains one or more such elements. Returns true if and only if this queue contained the specified element (or equivalently, if this queue changed as a result of the call).
java.util.PriorityQueue: java.util.PriorityQueue.removeAt	(	int	):  Removes the ith element from queue. Normally this method leaves the elements at up to i-1, inclusive, untouched. Under these circumstances, it returns null. Occasionally, in order to maintain the heap invariant, it must swap a later element of the list with one earlier than i. Under these circumstances, this method returns the element that was previously at the end of the list and is now at some position before i. This fact is used by iterator.remove so as to avoid missing traversing elements.
java.util.PriorityQueue: java.util.PriorityQueue.removeEq	(	Object	):  Version of remove using reference equality, not equals. Needed by iterator.remove.
java.util.PriorityQueue: java.util.PriorityQueue.siftDown	(	int	E	):  Inserts item x at position k, maintaining heap invariant by demoting x down the tree repeatedly until it is less than or equal to its children or is a leaf.
java.util.PriorityQueue: java.util.PriorityQueue.siftUp	(	int	E	):  Inserts item x at position k, maintaining heap invariant by promoting x up the tree until it is greater than or equal to its parent, or is the root. To simplify and speed up coercions and comparisons. the Comparable and Comparator versions are separated into different methods that are otherwise identical. (Similarly for siftDown.)
java.util.PriorityQueue: java.util.PriorityQueue.spliterator	(	):  Creates a late-binding and fail-fast Spliterator over the elements in this queue. The Spliterator reports SIZED, SUBSIZED, and NONNULL. Overriding implementations should document the reporting of additional characteristic values.
java.util.PriorityQueue: java.util.PriorityQueue.toArray	(	):  Returns an array containing all of the elements in this queue. The elements are in no particular order. The returned array will be "safe" in that no references to it are maintained by this queue. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.PriorityQueue: java.util.PriorityQueue.toArray	(	T[]	):  Returns an array containing all of the elements in this queue; the runtime type of the returned array is that of the specified array. The returned array elements are in no particular order. If the queue fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this queue. If the queue fits in the specified array with room to spare (i.e., the array has more elements than the queue), the element in the array immediately following the end of the collection is set to null. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a queue known to contain only strings. The following code can be used to dump the queue into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.PriorityQueue: java.util.PriorityQueue.writeObject	(	java.io.ObjectOutputStream	):  Saves this queue to a stream (that is, serializes it).
java.util.HashSet: java.util.HashSet:  This class implements the Set interface, backed by a hash table (actually a HashMap instance). It makes no guarantees as to the iteration order of the set; in particular, it does not guarantee that the order will remain constant over time. This class permits the null element. This class offers constant time performance for the basic operations (add, remove, contains and size), assuming the hash function disperses the elements properly among the buckets. Iterating over this set requires time proportional to the sum of the HashSet instance's size (the number of elements) plus the "capacity" of the backing HashMap instance (the number of buckets). Thus, it's very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important. Note that this implementation is not synchronized. If multiple threads access a hash set concurrently, and at least one of the threads modifies the set, it must be synchronized externally. This is typically accomplished by synchronizing on some object that naturally encapsulates the set. If no such object exists, the set should be "wrapped" using the synchronizedSet Collections.synchronizedSet method. This is best done at creation time, to prevent accidental unsynchronized access to the set: Set s = Collections.synchronizedSet(new HashSet(...)); The iterators returned by this class's iterator method are fail-fast: if the set is modified at any time after the iterator is created, in any way except through the iterator's own remove method, the Iterator throws a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. This class is a member of the  Java Collections Framework.
java.util.HashSet: java.util.HashSet.HashSet	(	):  Constructs a new, empty set; the backing HashMap instance has default initial capacity (16) and load factor (0.75).
java.util.HashSet: java.util.HashSet.HashSet	(	Collection	):  Constructs a new set containing the elements in the specified collection. The HashMap is created with default load factor (0.75) and an initial capacity sufficient to contain the elements in the specified collection.
java.util.HashSet: java.util.HashSet.HashSet	(	int	):  Constructs a new, empty set; the backing HashMap instance has the specified initial capacity and default load factor (0.75).
java.util.HashSet: java.util.HashSet.HashSet	(	int	float	):  Constructs a new, empty set; the backing HashMap instance has the specified initial capacity and the specified load factor.
java.util.HashSet: java.util.HashSet.HashSet	(	int	float	boolean	):  Constructs a new, empty linked hash set. (This package private constructor is only used by LinkedHashSet.) The backing HashMap instance is a LinkedHashMap with the specified initial capacity and the specified load factor.
java.util.HashSet: java.util.HashSet.add	(	E	):  Adds the specified element to this set if it is not already present. More formally, adds the specified element e to this set if this set contains no element e2 such that (e==null?e2==null:e.equals(e2)). If this set already contains the element, the call leaves the set unchanged and returns false.
java.util.HashSet: java.util.HashSet.clear	(	):  Removes all of the elements from this set. The set will be empty after this call returns.
java.util.HashSet: java.util.HashSet.clone	(	):  Returns a shallow copy of this HashSet instance: the elements themselves are not cloned.
java.util.HashSet: java.util.HashSet.contains	(	Object	):  Returns true if this set contains the specified element. More formally, returns true if and only if this set contains an element e such that (o==null?e==null:o.equals(e)).
java.util.HashSet: java.util.HashSet.isEmpty	(	):  Returns true if this set contains no elements.
java.util.HashSet: java.util.HashSet.iterator	(	):  Returns an iterator over the elements in this set. The elements are returned in no particular order.
java.util.HashSet: java.util.HashSet.readObject	(	java.io.ObjectInputStream	):  Reconstitute the HashSet instance from a stream (that is, deserialize it).
java.util.HashSet: java.util.HashSet.remove	(	Object	):  Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null?e==null:o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)
java.util.HashSet: java.util.HashSet.size	(	):  Returns the number of elements in this set (its cardinality).
java.util.HashSet: java.util.HashSet.spliterator	(	):  Creates a late-binding and fail-fast Spliterator over the elements in this set. The Spliterator reports SIZED and DISTINCT. Overriding implementations should document the reporting of additional characteristic values.
java.util.HashSet: java.util.HashSet.writeObject	(	java.io.ObjectOutputStream	):  Save the state of this HashSet instance to a stream (that is, serialize it).
java.util.TreeSet: java.util.TreeSet:  A NavigableSet implementation based on a TreeMap. The elements are ordered using their Comparable natural ordering, or by a Comparator provided at set creation time, depending on which constructor is used. This implementation provides guaranteed log(n) time cost for the basic operations (add, remove and contains). Note that the ordering maintained by a set (whether or not an explicit comparator is provided) must be consistent with equals if it is to correctly implement the Set interface. (See Comparable or Comparator for a precise definition of consistent with equals.) This is so because the Set interface is defined in terms of the equals operation, but a TreeSet instance performs all element comparisons using its compareTo (or compare) method, so two elements that are deemed equal by this method are, from the standpoint of the set, equal. The behavior of a set is well-defined even if its ordering is inconsistent with equals; it just fails to obey the general contract of the Set interface. Note that this implementation is not synchronized. If multiple threads access a tree set concurrently, and at least one of the threads modifies the set, it must be synchronized externally. This is typically accomplished by synchronizing on some object that naturally encapsulates the set. If no such object exists, the set should be "wrapped" using the synchronizedSortedSet Collections.synchronizedSortedSet method. This is best done at creation time, to prevent accidental unsynchronized access to the set:  SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...)); The iterators returned by this class's iterator method are fail-fast: if the set is modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. This class is a member of the  Java Collections Framework.
java.util.TreeSet: java.util.TreeSet.TreeSet	(	):  Constructs a new, empty tree set, sorted according to the natural ordering of its elements. All elements inserted into the set must implement the Comparable interface. Furthermore, all such elements must be mutually comparable: e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the set. If the user attempts to add an element to the set that violates this constraint (for example, the user attempts to add a string element to a set whose elements are integers), the add call will throw a ClassCastException.
java.util.TreeSet: java.util.TreeSet.TreeSet	(	Collection	):  Constructs a new tree set containing the elements in the specified collection, sorted according to the natural ordering of its elements. All elements inserted into the set must implement the Comparable interface. Furthermore, all such elements must be mutually comparable: e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the set.
java.util.TreeSet: java.util.TreeSet.TreeSet	(	Comparator	):  Constructs a new, empty tree set, sorted according to the specified comparator. All elements inserted into the set must be mutually comparable by the specified comparator: comparator.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the set. If the user attempts to add an element to the set that violates this constraint, the add call will throw a ClassCastException.
java.util.TreeSet: java.util.TreeSet.TreeSet	(	NavigableMap	):  Constructs a set backed by the specified navigable map.
java.util.TreeSet: java.util.TreeSet.TreeSet	(	SortedSet	):  Constructs a new tree set containing the same elements and using the same ordering as the specified sorted set.
java.util.TreeSet: java.util.TreeSet.add	(	E	):  Adds the specified element to this set if it is not already present. More formally, adds the specified element e to this set if the set contains no element e2 such that (e==null?e2==null:e.equals(e2)). If this set already contains the element, the call leaves the set unchanged and returns false.
java.util.TreeSet: java.util.TreeSet.addAll	(	Collection	):  Adds all of the elements in the specified collection to this set.
java.util.TreeSet: java.util.TreeSet.ceiling	(	E	):  Returns the least element in this set greater than or equal to the given element, or null if there is no such element.
java.util.TreeSet: java.util.TreeSet.clear	(	):  Removes all of the elements from this set. The set will be empty after this call returns.
java.util.TreeSet: java.util.TreeSet.clone	(	):  Returns a shallow copy of this TreeSet instance. (The elements themselves are not cloned.)
java.util.TreeSet: java.util.TreeSet.contains	(	Object	):  Returns true if this set contains the specified element. More formally, returns true if and only if this set contains an element e such that (o==null?e==null:o.equals(e)).
java.util.TreeSet: java.util.TreeSet.descendingIterator	(	):  Returns an iterator over the elements in this set in descending order.
java.util.TreeSet: java.util.TreeSet.descendingSet	(	):  Returns a reverse order view of the elements contained in this set. The descending set is backed by this set, so changes to the set are reflected in the descending set, and vice-versa. If either set is modified while an iteration over either set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The returned set has an ordering equivalent to reverseOrder() Collections.reverseOrder(comparator()). The expression s.descendingSet().descendingSet() returns a view of s essentially equivalent to s.
java.util.TreeSet: java.util.TreeSet.first	(	):  Returns the first (lowest) element currently in this set.
java.util.TreeSet: java.util.TreeSet.floor	(	E	):  Returns the greatest element in this set less than or equal to the given element, or null if there is no such element.
java.util.TreeSet: java.util.TreeSet.headSet	(	E	):  Returns a view of the portion of this set whose elements are strictly less than toElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range. Equivalent to headSet(toElement, false).
java.util.TreeSet: java.util.TreeSet.headSet	(	E	boolean	):  Returns a view of the portion of this set whose elements are less than (or equal to, if inclusive is true) toElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range.
java.util.TreeSet: java.util.TreeSet.higher	(	E	):  Returns the least element in this set strictly greater than the given element, or null if there is no such element.
java.util.TreeSet: java.util.TreeSet.isEmpty	(	):  Returns true if this set contains no elements.
java.util.TreeSet: java.util.TreeSet.iterator	(	):  Returns an iterator over the elements in this set in ascending order.
java.util.TreeSet: java.util.TreeSet.last	(	):  Returns the last (highest) element currently in this set.
java.util.TreeSet: java.util.TreeSet.lower	(	E	):  Returns the greatest element in this set strictly less than the given element, or null if there is no such element.
java.util.TreeSet: java.util.TreeSet.pollFirst	(	):  Retrieves and removes the first (lowest) element, or returns null if this set is empty.
java.util.TreeSet: java.util.TreeSet.pollLast	(	):  Retrieves and removes the last (highest) element, or returns null if this set is empty.
java.util.TreeSet: java.util.TreeSet.readObject	(	java.io.ObjectInputStream	):  Reconstitute the TreeSet instance from a stream (that is, deserialize it).
java.util.TreeSet: java.util.TreeSet.remove	(	Object	):  Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null?e==null:o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)
java.util.TreeSet: java.util.TreeSet.size	(	):  Returns the number of elements in this set (its cardinality).
java.util.TreeSet: java.util.TreeSet.spliterator	(	):  Creates a late-binding and fail-fast Spliterator over the elements in this set. The Spliterator reports SIZED, DISTINCT, SORTED, and ORDERED. Overriding implementations should document the reporting of additional characteristic values. The spliterator's comparator (see getComparator()) is null if the tree set's comparator (see comparator()) is null. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the tree set's comparator.
java.util.TreeSet: java.util.TreeSet.subSet	(	E	E	):  Returns a view of the portion of this set whose elements range from fromElement, inclusive, to toElement, exclusive. (If fromElement and toElement are equal, the returned set is empty.) The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range. Equivalent to subSet(fromElement, true, toElement, false).
java.util.TreeSet: java.util.TreeSet.subSet	(	E	boolean	E	boolean	):  Returns a view of the portion of this set whose elements range from fromElement to toElement. If fromElement and toElement are equal, the returned set is empty unless fromInclusive and toInclusive are both true. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range.
java.util.TreeSet: java.util.TreeSet.tailSet	(	E	):  Returns a view of the portion of this set whose elements are greater than or equal to fromElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range. Equivalent to tailSet(fromElement, true).
java.util.TreeSet: java.util.TreeSet.tailSet	(	E	boolean	):  Returns a view of the portion of this set whose elements are greater than (or equal to, if inclusive is true) fromElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range.
java.util.TreeSet: java.util.TreeSet.writeObject	(	java.io.ObjectOutputStream	):  Save the state of the TreeSet instance to a stream (that is, serialize it).
java.util.LinkedHashSet: java.util.LinkedHashSet:  Hash table and linked list implementation of the Set interface, with predictable iteration order. This implementation differs from HashSet in that it maintains a doubly-linked list running through all of its entries. This linked list defines the iteration ordering, which is the order in which elements were inserted into the set (insertion-order). Note that insertion order is not affected if an element is re-inserted into the set. (An element e is reinserted into a set s if s.add(e) is invoked when s.contains(e) would return true immediately prior to the invocation.) This implementation spares its clients from the unspecified, generally chaotic ordering provided by HashSet, without incurring the increased cost associated with TreeSet. It can be used to produce a copy of a set that has the same order as the original, regardless of the original set's implementation:  void foo(Set s) { Set copy = new LinkedHashSet(s); ... }  This technique is particularly useful if a module takes a set on input, copies it, and later returns results whose order is determined by that of the copy. (Clients generally appreciate having things returned in the same order they were presented.) This class provides all of the optional Set operations, and permits null elements. Like HashSet, it provides constant-time performance for the basic operations (add, contains and remove), assuming the hash function disperses elements properly among the buckets. Performance is likely to be just slightly below that of HashSet, due to the added expense of maintaining the linked list, with one exception: Iteration over a LinkedHashSet requires time proportional to the size of the set, regardless of its capacity. Iteration over a HashSet is likely to be more expensive, requiring time proportional to its capacity. A linked hash set has two parameters that affect its performance: initial capacity and load factor. They are defined precisely as for HashSet. Note, however, that the penalty for choosing an excessively high value for initial capacity is less severe for this class than for HashSet, as iteration times for this class are unaffected by capacity. Note that this implementation is not synchronized. If multiple threads access a linked hash set concurrently, and at least one of the threads modifies the set, it must be synchronized externally. This is typically accomplished by synchronizing on some object that naturally encapsulates the set. If no such object exists, the set should be "wrapped" using the synchronizedSet Collections.synchronizedSet method. This is best done at creation time, to prevent accidental unsynchronized access to the set:  Set s = Collections.synchronizedSet(new LinkedHashSet(...)); The iterators returned by this class's iterator method are fail-fast: if the set is modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. This class is a member of the  Java Collections Framework.
java.util.LinkedHashSet: java.util.LinkedHashSet.LinkedHashSet	(	):  Constructs a new, empty linked hash set with the default initial capacity (16) and load factor (0.75).
java.util.LinkedHashSet: java.util.LinkedHashSet.LinkedHashSet	(	Collection	):  Constructs a new linked hash set with the same elements as the specified collection. The linked hash set is created with an initial capacity sufficient to hold the elements in the specified collection and the default load factor (0.75).
java.util.LinkedHashSet: java.util.LinkedHashSet.LinkedHashSet	(	int	):  Constructs a new, empty linked hash set with the specified initial capacity and the default load factor (0.75).
java.util.LinkedHashSet: java.util.LinkedHashSet.LinkedHashSet	(	int	float	):  Constructs a new, empty linked hash set with the specified initial capacity and load factor.
java.util.LinkedHashSet: java.util.LinkedHashSet.spliterator	(	):  Creates a late-binding and fail-fast Spliterator over the elements in this set. The Spliterator reports SIZED, DISTINCT, and ORDERED. Implementations should document the reporting of additional characteristic values.
java.util.EnumSet: java.util.EnumSet:  A specialized Set implementation for use with enum types. All of the elements in an enum set must come from a single enum type that is specified, explicitly or implicitly, when the set is created. Enum sets are represented internally as bit vectors. This representation is extremely compact and efficient. The space and time performance of this class should be good enough to allow its use as a high-quality, typesafe alternative to traditional int-based "bit flags." Even bulk operations (such as containsAll and retainAll) should run very quickly if their argument is also an enum set. The iterator returned by the iterator method traverses the elements in their natural order (the order in which the enum constants are declared). The returned iterator is weakly consistent: it will never throw ConcurrentModificationException and it may or may not show the effects of any modifications to the set that occur while the iteration is in progress. Null elements are not permitted. Attempts to insert a null element will throw NullPointerException. Attempts to test for the presence of a null element or to remove one will, however, function properly. Like most collection implementations, EnumSet is not synchronized. If multiple threads access an enum set concurrently, and at least one of the threads modifies the set, it should be synchronized externally. This is typically accomplished by synchronizing on some object that naturally encapsulates the enum set. If no such object exists, the set should be "wrapped" using the synchronizedSet method. This is best done at creation time, to prevent accidental unsynchronized access:  Set<MyEnum> s = Collections.synchronizedSet(EnumSet.noneOf(MyEnum.class));  Implementation note: All basic operations execute in constant time. They are likely (though not guaranteed) to be much faster than their HashSet counterparts. Even bulk operations execute in constant time if their argument is also an enum set. This class is a member of the  Java Collections Framework.
java.util.EnumSet: java.util.EnumSet.SerializationProxy:  This class is used to serialize all EnumSet instances, regardless of implementation type. It captures their "logical contents" and they are reconstructed using public static factories. This is necessary to ensure that the existence of a particular implementation type is an implementation detail.
java.util.EnumSet: java.util.EnumSet.addAll	(	):  Adds all of the elements from the appropriate enum type to this enum set, which is empty prior to the call.
java.util.EnumSet: java.util.EnumSet.addRange	(	E	E	):  Adds the specified range to this enum set, which is empty prior to the call.
java.util.EnumSet: java.util.EnumSet.allOf	(	Class	):  Creates an enum set containing all of the elements in the specified element type.
java.util.EnumSet: java.util.EnumSet.clone	(	):  Returns a copy of this set.
java.util.EnumSet: java.util.EnumSet.complement	(	):  Complements the contents of this enum set.
java.util.EnumSet: java.util.EnumSet.complementOf	(	EnumSet	):  Creates an enum set with the same element type as the specified enum set, initially containing all the elements of this type that are not contained in the specified set.
java.util.EnumSet: java.util.EnumSet.copyOf	(	Collection	):  Creates an enum set initialized from the specified collection. If the specified collection is an EnumSet instance, this static factory method behaves identically to copyOf(). Otherwise, the specified collection must contain at least one element (in order to determine the new enum set's element type).
java.util.EnumSet: java.util.EnumSet.copyOf	(	EnumSet	):  Creates an enum set with the same element type as the specified enum set, initially containing the same elements (if any).
java.util.EnumSet: java.util.EnumSet.getUniverse	(	Class	):  Returns all of the values comprising E. The result is uncloned, cached, and shared by all callers.
java.util.EnumSet: java.util.EnumSet.noneOf	(	Class	):  Creates an empty enum set with the specified element type.
java.util.EnumSet: java.util.EnumSet.of	(	E	):  Creates an enum set initially containing the specified element. Overloadings of this method exist to initialize an enum set with one through five elements. A sixth overloading is provided that uses the varargs feature. This overloading may be used to create an enum set initially containing an arbitrary number of elements, but is likely to run slower than the overloadings that do not use varargs.
java.util.EnumSet: java.util.EnumSet.of	(	E	E	):  Creates an enum set initially containing the specified elements. This factory, whose parameter list uses the varargs feature, may be used to create an enum set initially containing an arbitrary number of elements, but it is likely to run slower than the overloadings that do not use varargs.
java.util.EnumSet: java.util.EnumSet.of	(	E	E	E	):  Creates an enum set initially containing the specified elements. Overloadings of this method exist to initialize an enum set with one through five elements. A sixth overloading is provided that uses the varargs feature. This overloading may be used to create an enum set initially containing an arbitrary number of elements, but is likely to run slower than the overloadings that do not use varargs.
java.util.EnumSet: java.util.EnumSet.of	(	E	E	E	E	):  Creates an enum set initially containing the specified elements. Overloadings of this method exist to initialize an enum set with one through five elements. A sixth overloading is provided that uses the varargs feature. This overloading may be used to create an enum set initially containing an arbitrary number of elements, but is likely to run slower than the overloadings that do not use varargs.
java.util.EnumSet: java.util.EnumSet.of	(	E	E	E	E	E	):  Creates an enum set initially containing the specified elements. Overloadings of this method exist to initialize an enum set with one through five elements. A sixth overloading is provided that uses the varargs feature. This overloading may be used to create an enum set initially containing an arbitrary number of elements, but is likely to run slower than the overloadings that do not use varargs.
java.util.EnumSet: java.util.EnumSet.range	(	E	E	):  Creates an enum set initially containing all of the elements in the range defined by the two specified endpoints. The returned set will contain the endpoints themselves, which may be identical but must not be out of order.
java.util.EnumSet: java.util.EnumSet.typeCheck	(	E	):  Throws an exception if e is not of the correct type for this enum set.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet:  A java.util.Set that uses an internal CopyOnWriteArrayList for all of its operations. Thus, it shares the same basic properties:  It is best suited for applications in which set sizes generally stay small, read-only operations vastly outnumber mutative operations, and you need to prevent interference among threads during traversal. It is thread-safe. Mutative operations (add, set, remove, etc.) are expensive since they usually entail copying the entire underlying array. Iterators do not support the mutative remove operation. Traversal via iterators is fast and cannot encounter interference from other threads. Iterators rely on unchanging snapshots of the array at the time the iterators were constructed.  Sample Usage. The following code sketch uses a copy-on-write set to maintain a set of Handler objects that perform some action upon state updates.  class Handler { void handle(); ... } class X { private final CopyOnWriteArraySet handlers = new CopyOnWriteArraySet(); public void addHandler(Handler h) { handlers.add(h); } private long internalState; private synchronized void changeState() { internalState = ...; } public void update() { changeState(); for (Handler handler : handlers) handler.handle(); } }} This class is a member of the  Java Collections Framework.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.CopyOnWriteArraySet	(	):  Creates an empty set.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.CopyOnWriteArraySet	(	Collection	):  Creates a set containing all of the elements of the specified collection.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.add	(	E	):  Adds the specified element to this set if it is not already present. More formally, adds the specified element e to this set if the set contains no element e2 such that (e==null?e2==null:e.equals(e2)). If this set already contains the element, the call leaves the set unchanged and returns false.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.addAll	(	Collection	):  Adds all of the elements in the specified collection to this set if they're not already present. If the specified collection is also a set, the addAll operation effectively modifies this set so that its value is the union of the two sets. The behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.clear	(	):  Removes all of the elements from this set. The set will be empty after this call returns.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.contains	(	Object	):  Returns true if this set contains the specified element. More formally, returns true if and only if this set contains an element e such that (o==null?e==null:o.equals(e)).
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.containsAll	(	Collection	):  Returns true if this set contains all of the elements of the specified collection. If the specified collection is also a set, this method returns true if it is a subset of this set.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.eq	(	Object	Object	):  Tests for equality, coping with nulls.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.equals	(	Object	):  Compares the specified object with this set for equality. Returns true if the specified object is the same object as this object, or if it is also a Set and the elements returned by an iterator() over the specified set are the same as the elements returned by an iterator over this set. More formally, the two iterators are considered to return the same elements if they return the same number of elements and for every element e1 returned by the iterator over the specified set, there is an element e2 returned by the iterator over this set such that (e1==null ? e2==null : e1.equals(e2)).
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.isEmpty	(	):  Returns true if this set contains no elements.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.iterator	(	):  Returns an iterator over the elements contained in this set in the order in which these elements were added. The returned iterator provides a snapshot of the state of the set when the iterator was constructed. No synchronization is needed while traversing the iterator. The iterator does NOT support the remove method.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.remove	(	Object	):  Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null?e==null:o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.removeAll	(	Collection	):  Removes from this set all of its elements that are contained in the specified collection. If the specified collection is also a set, this operation effectively modifies this set so that its value is the asymmetric set difference of the two sets.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.retainAll	(	Collection	):  Retains only the elements in this set that are contained in the specified collection. In other words, removes from this set all of its elements that are not contained in the specified collection. If the specified collection is also a set, this operation effectively modifies this set so that its value is the intersection of the two sets.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.size	(	):  Returns the number of elements in this set.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.spliterator	(	):  Returns a Spliterator over the elements in this set in the order in which these elements were added. The Spliterator reports IMMUTABLE, DISTINCT, SIZED, and SUBSIZED. The spliterator provides a snapshot of the state of the set when the spliterator was constructed. No synchronization is needed while operating on the spliterator.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.toArray	(	):  Returns an array containing all of the elements in this set. If this set makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. The returned array will be "safe" in that no references to it are maintained by this set. (In other words, this method must allocate a new array even if this set is backed by an array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.concurrent.CopyOnWriteArraySet: java.util.concurrent.CopyOnWriteArraySet.toArray	(	T[]	):  Returns an array containing all of the elements in this set; the runtime type of the returned array is that of the specified array. If the set fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this set. If this set fits in the specified array with room to spare (i.e., the array has more elements than this set), the element in the array immediately following the end of the set is set to null. (This is useful in determining the length of this set only if the caller knows that this set does not contain any null elements.) If this set makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a set known to contain only strings. The following code can be used to dump the set into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.SortedMap: java.util.SortedMap:  A Map that further provides a total ordering on its keys. The map is ordered according to the Comparable natural ordering of its keys, or by a Comparator typically provided at sorted map creation time. This order is reflected when iterating over the sorted map's collection views (returned by the entrySet, keySet and values methods). Several additional operations are provided to take advantage of the ordering. (This interface is the map analogue of SortedSet.) All keys inserted into a sorted map must implement the Comparable interface (or be accepted by the specified comparator). Furthermore, all such keys must be mutually comparable: k1.compareTo(k2) (or comparator.compare(k1, k2)) must not throw a ClassCastException for any keys k1 and k2 in the sorted map. Attempts to violate this restriction will cause the offending method or constructor invocation to throw a ClassCastException. Note that the ordering maintained by a sorted map (whether or not an explicit comparator is provided) must be consistent with equals if the sorted map is to correctly implement the Map interface. (See the Comparable interface or Comparator interface for a precise definition of consistent with equals.) This is so because the Map interface is defined in terms of the equals operation, but a sorted map performs all key comparisons using its compareTo (or compare) method, so two keys that are deemed equal by this method are, from the standpoint of the sorted map, equal. The behavior of a tree map is well-defined even if its ordering is inconsistent with equals; it just fails to obey the general contract of the Map interface. All general-purpose sorted map implementation classes should provide four "standard" constructors. It is not possible to enforce this recommendation though as required constructors cannot be specified by interfaces. The expected "standard" constructors for all sorted map implementations are:  A void (no arguments) constructor, which creates an empty sorted map sorted according to the natural ordering of its keys. A constructor with a single argument of type Comparator, which creates an empty sorted map sorted according to the specified comparator. A constructor with a single argument of type Map, which creates a new map with the same key-value mappings as its argument, sorted according to the keys' natural ordering. A constructor with a single argument of type SortedMap, which creates a new sorted map with the same key-value mappings and the same ordering as the input sorted map.  Note: several methods return submaps with restricted key ranges. Such ranges are half-open, that is, they include their low endpoint but not their high endpoint (where applicable). If you need a closed range (which includes both endpoints), and the key type allows for calculation of the successor of a given key, merely request the subrange from lowEndpoint to successor(highEndpoint). For example, suppose that m is a map whose keys are strings. The following idiom obtains a view containing all of the key-value mappings in m whose keys are between low and high, inclusive: SortedMap<String, V> sub = m.subMap(low, high+"\0"); A similar technique can be used to generate an open range (which contains neither endpoint). The following idiom obtains a view containing all of the key-value mappings in m whose keys are between low and high, exclusive: SortedMap<String, V> sub = m.subMap(low+"\0", high); This interface is a member of the  Java Collections Framework.
java.util.SortedMap: java.util.SortedMap.comparator	(	):  Returns the comparator used to order the keys in this map, or null if this map uses the Comparable natural ordering of its keys.
java.util.SortedMap: java.util.SortedMap.entrySet	(	):  Returns a Set view of the mappings contained in this map. The set's iterator returns the entries in ascending key order. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation, or through the setValue operation on a map entry returned by the iterator) the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.SortedMap: java.util.SortedMap.firstKey	(	):  Returns the first (lowest) key currently in this map.
java.util.SortedMap: java.util.SortedMap.headMap	(	K	):  Returns a view of the portion of this map whose keys are strictly less than toKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range.
java.util.SortedMap: java.util.SortedMap.keySet	(	):  Returns a Set view of the keys contained in this map. The set's iterator returns the keys in ascending order. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.SortedMap: java.util.SortedMap.lastKey	(	):  Returns the last (highest) key currently in this map.
java.util.SortedMap: java.util.SortedMap.subMap	(	K	K	):  Returns a view of the portion of this map whose keys range from fromKey, inclusive, to toKey, exclusive. (If fromKey and toKey are equal, the returned map is empty.) The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range.
java.util.SortedMap: java.util.SortedMap.tailMap	(	K	):  Returns a view of the portion of this map whose keys are greater than or equal to fromKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range.
java.util.SortedMap: java.util.SortedMap.values	(	):  Returns a Collection view of the values contained in this map. The collection's iterator returns the values in ascending order of the corresponding keys. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
