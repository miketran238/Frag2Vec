java.util.AbstractCollection: This class provides a skeletal implementation of the Collection interface, to minimize the effort required to implement this interface.  To implement an unmodifiable collection, the programmer needs only to extend this class and provide implementations for the iterator and size methods. (The iterator returned by the iterator method must implement hasNext and next.) To implement a modifiable collection, the programmer must additionally override this class's add method (which otherwise throws an UnsupportedOperationException), and the iterator returned by the iterator method must additionally implement its remove method. The programmer should generally provide a void (no argument) and Collection constructor, as per the recommendation in the Collection interface specification. The documentation for each non-abstract method in this class describes its implementation in detail. Each of these methods may be overridden if the collection being implemented admits a more efficient implementation. This class is a member of the  Java Collections Framework.
java.util.AbstractCollection.AbstractCollection	(	): Sole constructor. (For invocation by subclass constructors, typically implicit.)
java.util.AbstractCollection.add	(	E	): Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns. This implementation always throws an UnsupportedOperationException.
java.util.AbstractCollection.addAll	(	Collection	): Adds all of the elements in the specified collection to this collection (optional operation). The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (This implies that the behavior of this call is undefined if the specified collection is this collection, and this collection is nonempty.) This implementation iterates over the specified collection, and adds each object returned by the iterator to this collection, in turn. Note that this implementation will throw an UnsupportedOperationException unless add is overridden (assuming the specified collection is non-empty).
java.util.AbstractCollection.clear	(	): Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns. This implementation iterates over this collection, removing each element using the Iterator.remove operation. Most implementations will probably choose to override this method for efficiency. Note that this implementation will throw an UnsupportedOperationException if the iterator returned by this collection's iterator method does not implement the remove method and this collection is non-empty.
java.util.AbstractCollection.contains	(	Object	): Returns true if this collection contains the specified element. More formally, returns true if and only if this collection contains at least one element e such that (o==null ? e==null : o.equals(e)). This implementation iterates over the elements in the collection, checking each element in turn for equality with the specified element.
java.util.AbstractCollection.containsAll	(	Collection	): Returns true if this collection contains all of the elements in the specified collection. This implementation iterates over the specified collection, checking each element returned by the iterator in turn to see if it's contained in this collection. If all elements are so contained true is returned, otherwise false.
java.util.AbstractCollection.finishToArray	(	T[]	Iterator	): Reallocates the array being used within toArray when the iterator returned more elements than expected, and finishes filling it from the iterator.
java.util.AbstractCollection.isEmpty	(	): Returns true if this collection contains no elements. This implementation returns size() == 0.
java.util.AbstractCollection.iterator	(	): Returns an iterator over the elements contained in this collection.
java.util.AbstractCollection.remove	(	Object	): Removes a single instance of the specified element from this collection, if it is present (optional operation). More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this collection contains one or more such elements. Returns true if this collection contained the specified element (or equivalently, if this collection changed as a result of the call). This implementation iterates over the collection looking for the specified element. If it finds the element, it removes the element from the collection using the iterator's remove method. Note that this implementation throws an UnsupportedOperationException if the iterator returned by this collection's iterator method does not implement the remove method and this collection contains the specified object.
java.util.AbstractCollection.removeAll	(	Collection	): Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection. This implementation iterates over this collection, checking each element returned by the iterator in turn to see if it's contained in the specified collection. If it's so contained, it's removed from this collection with the iterator's remove method. Note that this implementation will throw an UnsupportedOperationException if the iterator returned by the iterator method does not implement the remove method and this collection contains one or more elements in common with the specified collection.
java.util.AbstractCollection.retainAll	(	Collection	): Retains only the elements in this collection that are contained in the specified collection (optional operation). In other words, removes from this collection all of its elements that are not contained in the specified collection. This implementation iterates over this collection, checking each element returned by the iterator in turn to see if it's contained in the specified collection. If it's not so contained, it's removed from this collection with the iterator's remove method. Note that this implementation will throw an UnsupportedOperationException if the iterator returned by the iterator method does not implement the remove method and this collection contains one or more elements not present in the specified collection.
java.util.AbstractCollection.toArray	(	): Returns an array containing all of the elements in this collection. If this collection makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. The returned array will be "safe" in that no references to it are maintained by this collection. (In other words, this method must allocate a new array even if this collection is backed by an array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs. This implementation returns an array containing all the elements returned by this collection's iterator, in the same order, stored in consecutive elements of the array, starting with index 0. The length of the returned array is equal to the number of elements returned by the iterator, even if the size of this collection changes during iteration, as might happen if the collection permits concurrent modification during iteration. The size method is called only as an optimization hint; the correct result is returned even if the iterator returns a different number of elements. This method is equivalent to:  List list = new ArrayList(size()); for (E e : this) list.add(e); return list.toArray();
java.util.AbstractCollection.toArray	(	T[]	): Returns an array containing all of the elements in this collection; the runtime type of the returned array is that of the specified array. If the collection fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this collection. If this collection fits in the specified array with room to spare (i.e., the array has more elements than this collection), the element in the array immediately following the end of the collection is set to null. (This is useful in determining the length of this collection only if the caller knows that this collection does not contain any null elements.) If this collection makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a collection known to contain only strings. The following code can be used to dump the collection into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray(). This implementation returns an array containing all the elements returned by this collection's iterator in the same order, stored in consecutive elements of the array, starting with index 0. If the number of elements returned by the iterator is too large to fit into the specified array, then the elements are returned in a newly allocated array with length equal to the number of elements returned by the iterator, even if the size of this collection changes during iteration, as might happen if the collection permits concurrent modification during iteration. The size method is called only as an optimization hint; the correct result is returned even if the iterator returns a different number of elements. This method is equivalent to:  List list = new ArrayList(size()); for (E e : this) list.add(e); return list.toArray(a);
java.util.AbstractCollection.toString	(	): Returns a string representation of this collection. The string representation consists of a list of the collection's elements in the order they are returned by its iterator, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (comma and space). Elements are converted to strings as by valueOf().
java.util.AbstractList: This class provides a skeletal implementation of the List interface to minimize the effort required to implement this interface backed by a "random access" data store (such as an array). For sequential access data (such as a linked list), AbstractSequentialList should be used in preference to this class. To implement an unmodifiable list, the programmer needs only to extend this class and provide implementations for the get() and size() size() methods. To implement a modifiable list, the programmer must additionally override the set() set(int, E) method (which otherwise throws an UnsupportedOperationException). If the list is variable-size the programmer must additionally override the add() add(int, E) and remove() methods. The programmer should generally provide a void (no argument) and collection constructor, as per the recommendation in the Collection interface specification. Unlike the other abstract collection implementations, the programmer does not have to provide an iterator implementation; the iterator and list iterator are implemented by this class, on top of the "random access" methods: get(), set() set(int, E), add() add(int, E) and remove(). The documentation for each non-abstract method in this class describes its implementation in detail. Each of these methods may be overridden if the collection being implemented admits a more efficient implementation. This class is a member of the  Java Collections Framework.
java.util.AbstractList.AbstractList	(	): Sole constructor. (For invocation by subclass constructors, typically implicit.)
java.util.AbstractList.add	(	E	): Appends the specified element to the end of this list (optional operation). Lists that support this operation may place limitations on what elements may be added to this list. In particular, some lists will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. List classes should clearly specify in their documentation any restrictions on what elements may be added. This implementation calls add(size(), e). Note that this implementation throws an UnsupportedOperationException unless add() add(int, E) is overridden.
java.util.AbstractList.add	(	int	E	): Inserts the specified element at the specified position in this list (optional operation). Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices). This implementation always throws an UnsupportedOperationException.
java.util.AbstractList.addAll	(	int	Collection	): Inserts all of the elements in the specified collection into this list at the specified position (optional operation). Shifts the element currently at that position (if any) and any subsequent elements to the right (increases their indices). The new elements will appear in this list in the order that they are returned by the specified collection's iterator. The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (Note that this will occur if the specified collection is this list, and it's nonempty.) This implementation gets an iterator over the specified collection and iterates over it, inserting the elements obtained from the iterator into this list at the appropriate position, one at a time, using add(int, E). Many implementations will override this method for efficiency. Note that this implementation throws an UnsupportedOperationException unless add() add(int, E) is overridden.
java.util.AbstractList.clear	(	): Removes all of the elements from this list (optional operation). The list will be empty after this call returns. This implementation calls removeRange(0, size()). Note that this implementation throws an UnsupportedOperationException unless remove(int index) or removeRange(int fromIndex, int toIndex) is overridden.
java.util.AbstractList.equals	(	Object	): Compares the specified object with this list for equality. Returns true if and only if the specified object is also a list, both lists have the same size, and all corresponding pairs of elements in the two lists are equal. (Two elements e1 and e2 are equal if (e1==null ? e2==null : e1.equals(e2)).) In other words, two lists are defined to be equal if they contain the same elements in the same order. This implementation first checks if the specified object is this list. If so, it returns true; if not, it checks if the specified object is a list. If not, it returns false; if so, it iterates over both lists, comparing corresponding pairs of elements. If any comparison returns false, this method returns false. If either iterator runs out of elements before the other it returns false (as the lists are of unequal length); otherwise it returns true when the iterations complete.
java.util.AbstractList.get	(	int	): Returns the element at the specified position in this list.
java.util.AbstractList.hashCode	(	): Returns the hash code value for this list. This implementation uses exactly the code that is used to define the list hash function in the documentation for the hashCode method.
java.util.AbstractList.indexOf	(	Object	): Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index. This implementation first gets a list iterator (with listIterator()). Then, it iterates over the list until the specified element is found or the end of the list is reached.
java.util.AbstractList.iterator	(	): Returns an iterator over the elements in this list in proper sequence. This implementation returns a straightforward implementation of the iterator interface, relying on the backing list's size(), get(int), and remove(int) methods. Note that the iterator returned by this method will throw an UnsupportedOperationException in response to its remove method unless the list's remove(int) method is overridden. This implementation can be made to throw runtime exceptions in the face of concurrent modification, as described in the specification for the (protected) modCount field.
java.util.AbstractList.lastIndexOf	(	Object	): Returns the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the highest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index. This implementation first gets a list iterator that points to the end of the list (with listIterator(size())). Then, it iterates backwards over the list until the specified element is found, or the beginning of the list is reached.
java.util.AbstractList.listIterator	(	): Returns a list iterator over the elements in this list (in proper sequence). This implementation returns listIterator(0).
java.util.AbstractList.listIterator	(	int	): Returns a list iterator over the elements in this list (in proper sequence), starting at the specified position in the list. The specified index indicates the first element that would be returned by an initial call to next. An initial call to previous would return the element with the specified index minus one. This implementation returns a straightforward implementation of the ListIterator interface that extends the implementation of the Iterator interface returned by the iterator() method. The ListIterator implementation relies on the backing list's get(int), set(int, E), add(int, E) and remove(int) methods. Note that the list iterator returned by this implementation will throw an UnsupportedOperationException in response to its remove, set and add methods unless the list's remove(int), set(int, E), and add(int, E) methods are overridden. This implementation can be made to throw runtime exceptions in the face of concurrent modification, as described in the specification for the (protected) modCount field.
java.util.AbstractList.remove	(	int	): Removes the element at the specified position in this list (optional operation). Shifts any subsequent elements to the left (subtracts one from their indices). Returns the element that was removed from the list. This implementation always throws an UnsupportedOperationException.
java.util.AbstractList.removeRange	(	int	int	): Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive. Shifts any succeeding elements to the left (reduces their index). This call shortens the list by (toIndex - fromIndex) elements. (If toIndex==fromIndex, this operation has no effect.) This method is called by the clear operation on this list and its subLists. Overriding this method to take advantage of the internals of the list implementation can substantially improve the performance of the clear operation on this list and its subLists. This implementation gets a list iterator positioned before fromIndex, and repeatedly calls ListIterator.next followed by ListIterator.remove until the entire range has been removed. Note: if ListIterator.remove requires linear time, this implementation requires quadratic time.
java.util.AbstractList.set	(	int	E	): Replaces the element at the specified position in this list with the specified element (optional operation). This implementation always throws an UnsupportedOperationException.
java.util.AbstractList.subList	(	int	int	): Returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive. (If fromIndex and toIndex are equal, the returned list is empty.) The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa. The returned list supports all of the optional list operations supported by this list. This method eliminates the need for explicit range operations (of the sort that commonly exist for arrays). Any operation that expects a list can be used as a range operation by passing a subList view instead of a whole list. For example, the following idiom removes a range of elements from a list: list.subList(from, to).clear(); Similar idioms may be constructed for indexOf and lastIndexOf, and all of the algorithms in the Collections class can be applied to a subList. The semantics of the list returned by this method become undefined if the backing list (i.e., this list) is structurally modified in any way other than via the returned list. (Structural modifications are those that change the size of this list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.) This implementation returns a list that subclasses AbstractList. The subclass stores, in private fields, the offset of the subList within the backing list, the size of the subList (which can change over its lifetime), and the expected modCount value of the backing list. There are two variants of the subclass, one of which implements RandomAccess. If this list implements RandomAccess the returned list will be an instance of the subclass that implements RandomAccess. The subclass's set(int, E), get(int), add(int, E), remove(int), addAll(int, Collection) and removeRange(int, int) methods all delegate to the corresponding methods on the backing abstract list, after bounds-checking the index and adjusting for the offset. The addAll(Collection c) method merely returns addAll(size, c). The listIterator(int) method returns a "wrapper object" over a list iterator on the backing list, which is created with the corresponding method on the backing list. The iterator method merely returns listIterator(), and the size method merely returns the subclass's size field. All methods first check to see if the actual modCount of the backing list is equal to its expected value, and throw a ConcurrentModificationException if it is not.
java.util.AbstractMap: This class provides a skeletal implementation of the Map interface, to minimize the effort required to implement this interface. To implement an unmodifiable map, the programmer needs only to extend this class and provide an implementation for the entrySet method, which returns a set-view of the map's mappings. Typically, the returned set will, in turn, be implemented atop AbstractSet. This set should not support the add or remove methods, and its iterator should not support the remove method. To implement a modifiable map, the programmer must additionally override this class's put method (which otherwise throws an UnsupportedOperationException), and the iterator returned by entrySet().iterator() must additionally implement its remove method. The programmer should generally provide a void (no argument) and map constructor, as per the recommendation in the Map interface specification. The documentation for each non-abstract method in this class describes its implementation in detail. Each of these methods may be overridden if the map being implemented admits a more efficient implementation. This class is a member of the  Java Collections Framework.
java.util.AbstractMap.AbstractMap	(	): Sole constructor. (For invocation by subclass constructors, typically implicit.)
java.util.AbstractMap.SimpleEntry: An Entry maintaining a key and a value. The value may be changed using the setValue method. This class facilitates the process of building custom map implementations. For example, it may be convenient to return arrays of SimpleEntry instances in method Map.entrySet().toArray.
java.util.AbstractMap.SimpleEntry.SimpleEntry	(	Entry	): Creates an entry representing the same mapping as the specified entry.
java.util.AbstractMap.SimpleEntry.SimpleEntry	(	K	V	): Creates an entry representing a mapping from the specified key to the specified value.
java.util.AbstractMap.SimpleEntry.equals	(	Object	): Compares the specified object with this entry for equality. Returns true if the given object is also a map entry and the two entries represent the same mapping. More formally, two entries e1 and e2 represent the same mapping if (e1.getKey()==null ? e2.getKey()==null : e1.getKey().equals(e2.getKey())) && (e1.getValue()==null ? e2.getValue()==null : e1.getValue().equals(e2.getValue())) This ensures that the equals method works properly across different implementations of the Map.Entry interface.
java.util.AbstractMap.SimpleEntry.getKey	(	): Returns the key corresponding to this entry.
java.util.AbstractMap.SimpleEntry.getValue	(	): Returns the value corresponding to this entry.
java.util.AbstractMap.SimpleEntry.hashCode	(	): Returns the hash code value for this map entry. The hash code of a map entry e is defined to be:  (e.getKey()==null ? 0 : e.getKey().hashCode()) ^ (e.getValue()==null ? 0 : e.getValue().hashCode()) This ensures that e1.equals(e2) implies that e1.hashCode()==e2.hashCode() for any two Entries e1 and e2, as required by the general contract of hashCode.
java.util.AbstractMap.SimpleEntry.setValue	(	V	): Replaces the value corresponding to this entry with the specified value.
java.util.AbstractMap.SimpleEntry.toString	(	): Returns a String representation of this map entry. This implementation returns the string representation of this entry's key followed by the equals character ("=") followed by the string representation of this entry's value.
java.util.AbstractMap.SimpleImmutableEntry: An Entry maintaining an immutable key and value. This class does not support method setValue. This class may be convenient in methods that return thread-safe snapshots of key-value mappings.
java.util.AbstractMap.SimpleImmutableEntry.SimpleImmutableEntry	(	Entry	): Creates an entry representing the same mapping as the specified entry.
java.util.AbstractMap.SimpleImmutableEntry.SimpleImmutableEntry	(	K	V	): Creates an entry representing a mapping from the specified key to the specified value.
java.util.AbstractMap.SimpleImmutableEntry.equals	(	Object	): Compares the specified object with this entry for equality. Returns true if the given object is also a map entry and the two entries represent the same mapping. More formally, two entries e1 and e2 represent the same mapping if (e1.getKey()==null ? e2.getKey()==null : e1.getKey().equals(e2.getKey())) && (e1.getValue()==null ? e2.getValue()==null : e1.getValue().equals(e2.getValue())) This ensures that the equals method works properly across different implementations of the Map.Entry interface.
java.util.AbstractMap.SimpleImmutableEntry.getKey	(	): Returns the key corresponding to this entry.
java.util.AbstractMap.SimpleImmutableEntry.getValue	(	): Returns the value corresponding to this entry.
java.util.AbstractMap.SimpleImmutableEntry.hashCode	(	): Returns the hash code value for this map entry. The hash code of a map entry e is defined to be:  (e.getKey()==null ? 0 : e.getKey().hashCode()) ^ (e.getValue()==null ? 0 : e.getValue().hashCode()) This ensures that e1.equals(e2) implies that e1.hashCode()==e2.hashCode() for any two Entries e1 and e2, as required by the general contract of hashCode.
java.util.AbstractMap.SimpleImmutableEntry.setValue	(	V	): Replaces the value corresponding to this entry with the specified value (optional operation). This implementation simply throws UnsupportedOperationException, as this class implements an immutable map entry.
java.util.AbstractMap.SimpleImmutableEntry.toString	(	): Returns a String representation of this map entry. This implementation returns the string representation of this entry's key followed by the equals character ("=") followed by the string representation of this entry's value.
java.util.AbstractMap.clear	(	): Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.
java.util.AbstractMap.clone	(	): Returns a shallow copy of this AbstractMap instance: the keys and values themselves are not cloned.
java.util.AbstractMap.containsKey	(	Object	): Returns true if this map contains a mapping for the specified key. More formally, returns true if and only if this map contains a mapping for a key k such that (key==null ? k==null : key.equals(k)). (There can be at most one such mapping.)
java.util.AbstractMap.containsValue	(	Object	): Returns true if this map maps one or more keys to the specified value. More formally, returns true if and only if this map contains at least one mapping to a value v such that (value==null ? v==null : value.equals(v)). This operation will probably require time linear in the map size for most implementations of the Map interface.
java.util.AbstractMap.eq	(	Object	Object	): Utility method for SimpleEntry and SimpleImmutableEntry. Test for equality, checking for nulls. NB: Do not replace with Object.equals until JDK-8015417 is resolved.
java.util.AbstractMap.equals	(	Object	): Compares the specified object with this map for equality. Returns true if the given object is also a map and the two maps represent the same mappings. More formally, two maps m1 and m2 represent the same mappings if m1.entrySet().equals(m2.entrySet()). This ensures that the equals method works properly across different implementations of the Map interface.
java.util.AbstractMap.get	(	Object	): Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that (key==null ? k==null : key.equals(k)), then this method returns v; otherwise it returns null. (There can be at most one such mapping.) If this map permits null values, then a return value of null does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to null. The containsKey operation may be used to distinguish these two cases.
java.util.AbstractMap.hashCode	(	): Returns the hash code value for this map. The hash code of a map is defined to be the sum of the hash codes of each entry in the map's entrySet() view. This ensures that m1.equals(m2) implies that m1.hashCode()==m2.hashCode() for any two maps m1 and m2, as required by the general contract of hashCode.
java.util.AbstractMap.isEmpty	(	): Returns true if this map contains no key-value mappings.
java.util.AbstractMap.keySet	(	): Returns a Set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.AbstractMap.put	(	K	V	): Associates the specified value with the specified key in this map (optional operation). If the map previously contained a mapping for the key, the old value is replaced by the specified value. (A map m is said to contain a mapping for a key k if and only if containsKey() m.containsKey(k) would return true.)
java.util.AbstractMap.putAll	(	Map	): Copies all of the mappings from the specified map to this map (optional operation). The effect of this call is equivalent to that of calling put() put(k, v) on this map once for each mapping from key k to value v in the specified map. The behavior of this operation is undefined if the specified map is modified while the operation is in progress.
java.util.AbstractMap.remove	(	Object	): Removes the mapping for a key from this map if it is present (optional operation). More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. If this map permits null values, then a return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.
java.util.AbstractMap.size	(	): Returns the number of key-value mappings in this map. If the map contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
java.util.AbstractMap.toString	(	): Returns a string representation of this map. The string representation consists of a list of key-value mappings in the order returned by the map's entrySet view's iterator, enclosed in braces ("{}"). Adjacent mappings are separated by the characters ", " (comma and space). Each key-value mapping is rendered as the key followed by an equals sign ("=") followed by the associated value. Keys and values are converted to strings as by valueOf().
java.util.AbstractMap.values	(	): Returns a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.AbstractQueue: This class provides skeletal implementations of some Queue operations. The implementations in this class are appropriate when the base implementation does not allow null elements. Methods add, remove, and element are based on offer, poll, and peek, respectively, but throw exceptions instead of indicating failure via false or null returns. A Queue implementation that extends this class must minimally define a method offer which does not permit insertion of null elements, along with methods peek, poll, size, and iterator. Typically, additional methods will be overridden as well. If these requirements cannot be met, consider instead subclassing AbstractCollection. This class is a member of the  Java Collections Framework.
java.util.AbstractQueue.AbstractQueue	(	): Constructor for use by subclasses.
java.util.AbstractQueue.add	(	E	): Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an IllegalStateException if no space is currently available. This implementation returns true if offer succeeds, else throws an IllegalStateException.
java.util.AbstractQueue.addAll	(	Collection	): Adds all of the elements in the specified collection to this queue. Attempts to addAll of a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress. This implementation iterates over the specified collection, and adds each element returned by the iterator to this queue, in turn. A runtime exception encountered while trying to add an element (including, in particular, a null element) may result in only some of the elements having been successfully added when the associated exception is thrown.
java.util.AbstractQueue.clear	(	): Removes all of the elements from this queue. The queue will be empty after this call returns. This implementation repeatedly invokes poll until it returns null.
java.util.AbstractQueue.element	(	): Retrieves, but does not remove, the head of this queue. This method differs from peek only in that it throws an exception if this queue is empty. This implementation returns the result of peek unless the queue is empty.
java.util.AbstractQueue.remove	(	): Retrieves and removes the head of this queue. This method differs from poll only in that it throws an exception if this queue is empty. This implementation returns the result of poll unless the queue is empty.
java.util.AbstractSequentialList: This class provides a skeletal implementation of the List interface to minimize the effort required to implement this interface backed by a "sequential access" data store (such as a linked list). For random access data (such as an array), AbstractList should be used in preference to this class. This class is the opposite of the AbstractList class in the sense that it implements the "random access" methods (get(int index), set(int index, E element), add(int index, E element) and remove(int index)) on top of the list's list iterator, instead of the other way around. To implement a list the programmer needs only to extend this class and provide implementations for the listIterator and size methods. For an unmodifiable list, the programmer need only implement the list iterator's hasNext, next, hasPrevious, previous and index methods. For a modifiable list the programmer should additionally implement the list iterator's set method. For a variable-size list the programmer should additionally implement the list iterator's remove and add methods. The programmer should generally provide a void (no argument) and collection constructor, as per the recommendation in the Collection interface specification. This class is a member of the  Java Collections Framework.
java.util.AbstractSequentialList.AbstractSequentialList	(	): Sole constructor. (For invocation by subclass constructors, typically implicit.)
java.util.AbstractSequentialList.add	(	int	E	): Inserts the specified element at the specified position in this list (optional operation). Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices). This implementation first gets a list iterator pointing to the indexed element (with listIterator(index)). Then, it inserts the specified element with ListIterator.add. Note that this implementation will throw an UnsupportedOperationException if the list iterator does not implement the add operation.
java.util.AbstractSequentialList.addAll	(	int	Collection	): Inserts all of the elements in the specified collection into this list at the specified position (optional operation). Shifts the element currently at that position (if any) and any subsequent elements to the right (increases their indices). The new elements will appear in this list in the order that they are returned by the specified collection's iterator. The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (Note that this will occur if the specified collection is this list, and it's nonempty.) This implementation gets an iterator over the specified collection and a list iterator over this list pointing to the indexed element (with listIterator(index)). Then, it iterates over the specified collection, inserting the elements obtained from the iterator into this list, one at a time, using ListIterator.add followed by ListIterator.next (to skip over the added element). Note that this implementation will throw an UnsupportedOperationException if the list iterator returned by the listIterator method does not implement the add operation.
java.util.AbstractSequentialList.get	(	int	): Returns the element at the specified position in this list. This implementation first gets a list iterator pointing to the indexed element (with listIterator(index)). Then, it gets the element using ListIterator.next and returns it.
java.util.AbstractSequentialList.iterator	(	): Returns an iterator over the elements in this list (in proper sequence). This implementation merely returns a list iterator over the list.
java.util.AbstractSequentialList.listIterator	(	int	): Returns a list iterator over the elements in this list (in proper sequence).
java.util.AbstractSequentialList.remove	(	int	): Removes the element at the specified position in this list (optional operation). Shifts any subsequent elements to the left (subtracts one from their indices). Returns the element that was removed from the list. This implementation first gets a list iterator pointing to the indexed element (with listIterator(index)). Then, it removes the element with ListIterator.remove. Note that this implementation will throw an UnsupportedOperationException if the list iterator does not implement the remove operation.
java.util.AbstractSequentialList.set	(	int	E	): Replaces the element at the specified position in this list with the specified element (optional operation). This implementation first gets a list iterator pointing to the indexed element (with listIterator(index)). Then, it gets the current element using ListIterator.next and replaces it with ListIterator.set. Note that this implementation will throw an UnsupportedOperationException if the list iterator does not implement the set operation.
java.util.AbstractSet: This class provides a skeletal implementation of the Set interface to minimize the effort required to implement this interface.  The process of implementing a set by extending this class is identical to that of implementing a Collection by extending AbstractCollection, except that all of the methods and constructors in subclasses of this class must obey the additional constraints imposed by the Set interface (for instance, the add method must not permit addition of multiple instances of an object to a set). Note that this class does not override any of the implementations from the AbstractCollection class. It merely adds implementations for equals and hashCode. This class is a member of the  Java Collections Framework.
java.util.AbstractSet.AbstractSet	(	): Sole constructor. (For invocation by subclass constructors, typically implicit.)
java.util.AbstractSet.equals	(	Object	): Compares the specified object with this set for equality. Returns true if the given object is also a set, the two sets have the same size, and every member of the given set is contained in this set. This ensures that the equals method works properly across different implementations of the Set interface. This implementation first checks if the specified object is this set; if so it returns true. Then, it checks if the specified object is a set whose size is identical to the size of this set; if not, it returns false. If so, it returns containsAll((Collection) o).
java.util.AbstractSet.hashCode	(	): Returns the hash code value for this set. The hash code of a set is defined to be the sum of the hash codes of the elements in the set, where the hash code of a null element is defined to be zero. This ensures that s1.equals(s2) implies that s1.hashCode()==s2.hashCode() for any two sets s1 and s2, as required by the general contract of hashCode. This implementation iterates over the set, calling the hashCode method on each element in the set, and adding up the results.
java.util.AbstractSet.removeAll	(	Collection	): Removes from this set all of its elements that are contained in the specified collection (optional operation). If the specified collection is also a set, this operation effectively modifies this set so that its value is the asymmetric set difference of the two sets. This implementation determines which is the smaller of this set and the specified collection, by invoking the size method on each. If this set has fewer elements, then the implementation iterates over this set, checking each element returned by the iterator in turn to see if it is contained in the specified collection. If it is so contained, it is removed from this set with the iterator's remove method. If the specified collection has fewer elements, then the implementation iterates over the specified collection, removing from this set each element returned by the iterator, using this set's remove method. Note that this implementation will throw an UnsupportedOperationException if the iterator returned by the iterator method does not implement the remove method.
java.util.ArrayDeque: Resizable-array implementation of the Deque interface. Array deques have no capacity restrictions; they grow as necessary to support usage. They are not thread-safe; in the absence of external synchronization, they do not support concurrent access by multiple threads. Null elements are prohibited. This class is likely to be faster than Stack when used as a stack, and faster than LinkedList when used as a queue. Most ArrayDeque operations run in amortized constant time. Exceptions include remove(), removeFirstOccurrence, removeLastOccurrence , contains, iterator iterator.remove(), and the bulk operations, all of which run in linear time. The iterators returned by this class's iterator method are fail-fast: If the deque is modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will generally throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces. This class is a member of the  Java Collections Framework.
java.util.ArrayDeque.ArrayDeque	(	): Constructs an empty array deque with an initial capacity sufficient to hold 16 elements.
java.util.ArrayDeque.ArrayDeque	(	Collection	): Constructs a deque containing the elements of the specified collection, in the order they are returned by the collection's iterator. (The first element returned by the collection's iterator becomes the first element, or front of the deque.)
java.util.ArrayDeque.ArrayDeque	(	int	): Constructs an empty array deque with an initial capacity sufficient to hold the specified number of elements.
java.util.ArrayDeque.DeqSpliterator.DeqSpliterator	(	ArrayDeque	int	int	): Creates new spliterator covering the given array and range 
java.util.ArrayDeque.add	(	E	): Inserts the specified element at the end of this deque. This method is equivalent to addLast.
java.util.ArrayDeque.addFirst	(	E	): Inserts the specified element at the front of this deque.
java.util.ArrayDeque.addLast	(	E	): Inserts the specified element at the end of this deque. This method is equivalent to add.
java.util.ArrayDeque.allocateElements	(	int	): Allocates empty array to hold the given number of elements.
java.util.ArrayDeque.clear	(	): Removes all of the elements from this deque. The deque will be empty after this call returns.
java.util.ArrayDeque.clone	(	): Returns a copy of this deque.
java.util.ArrayDeque.contains	(	Object	): Returns true if this deque contains the specified element. More formally, returns true if and only if this deque contains at least one element e such that o.equals(e).
java.util.ArrayDeque.copyElements	(	T[]	): Copies the elements from our element array into the specified array, in order (from first to last element in the deque). It is assumed that the array is large enough to hold all elements in the deque.
java.util.ArrayDeque.delete	(	int	): Removes the element at the specified position in the elements array, adjusting head and tail as necessary. This can result in motion of elements backwards or forwards in the array. This method is called delete rather than remove to emphasize that its semantics differ from those of remove().
java.util.ArrayDeque.doubleCapacity	(	): Doubles the capacity of this deque. Call only when full, i.e., when head and tail have wrapped around to become equal.
java.util.ArrayDeque.element	(	): Retrieves, but does not remove, the head of the queue represented by this deque. This method differs from peek only in that it throws an exception if this deque is empty. This method is equivalent to getFirst.
java.util.ArrayDeque.getFirst	(	): Retrieves, but does not remove, the first element of this deque. This method differs from peekFirst only in that it throws an exception if this deque is empty.
java.util.ArrayDeque.getLast	(	): Retrieves, but does not remove, the last element of this deque. This method differs from peekLast only in that it throws an exception if this deque is empty.
java.util.ArrayDeque.isEmpty	(	): Returns true if this deque contains no elements.
java.util.ArrayDeque.iterator	(	): Returns an iterator over the elements in this deque. The elements will be ordered from first (head) to last (tail). This is the same order that elements would be dequeued (via successive calls to remove or popped (via successive calls to pop).
java.util.ArrayDeque.offer	(	E	): Inserts the specified element at the end of this deque. This method is equivalent to offerLast.
java.util.ArrayDeque.offerFirst	(	E	): Inserts the specified element at the front of this deque.
java.util.ArrayDeque.offerLast	(	E	): Inserts the specified element at the end of this deque.
java.util.ArrayDeque.peek	(	): Retrieves, but does not remove, the head of the queue represented by this deque, or returns null if this deque is empty. This method is equivalent to peekFirst.
java.util.ArrayDeque.poll	(	): Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque), or returns null if this deque is empty. This method is equivalent to pollFirst.
java.util.ArrayDeque.pop	(	): Pops an element from the stack represented by this deque. In other words, removes and returns the first element of this deque. This method is equivalent to removeFirst().
java.util.ArrayDeque.push	(	E	): Pushes an element onto the stack represented by this deque. In other words, inserts the element at the front of this deque. This method is equivalent to addFirst.
java.util.ArrayDeque.readObject	(	java.io.ObjectInputStream	): Reconstitutes this deque from a stream (that is, deserializes it).
java.util.ArrayDeque.remove	(	): Retrieves and removes the head of the queue represented by this deque. This method differs from poll only in that it throws an exception if this deque is empty. This method is equivalent to removeFirst.
java.util.ArrayDeque.remove	(	Object	): Removes a single instance of the specified element from this deque. If the deque does not contain the element, it is unchanged. More formally, removes the first element e such that o.equals(e) (if such an element exists). Returns true if this deque contained the specified element (or equivalently, if this deque changed as a result of the call). This method is equivalent to removeFirstOccurrence().
java.util.ArrayDeque.removeFirst	(	): Retrieves and removes the first element of this deque. This method differs from pollFirst only in that it throws an exception if this deque is empty.
java.util.ArrayDeque.removeFirstOccurrence	(	Object	): Removes the first occurrence of the specified element in this deque (when traversing the deque from head to tail). If the deque does not contain the element, it is unchanged. More formally, removes the first element e such that o.equals(e) (if such an element exists). Returns true if this deque contained the specified element (or equivalently, if this deque changed as a result of the call).
java.util.ArrayDeque.removeLast	(	): Retrieves and removes the last element of this deque. This method differs from pollLast only in that it throws an exception if this deque is empty.
java.util.ArrayDeque.removeLastOccurrence	(	Object	): Removes the last occurrence of the specified element in this deque (when traversing the deque from head to tail). If the deque does not contain the element, it is unchanged. More formally, removes the last element e such that o.equals(e) (if such an element exists). Returns true if this deque contained the specified element (or equivalently, if this deque changed as a result of the call).
java.util.ArrayDeque.size	(	): Returns the number of elements in this deque.
java.util.ArrayDeque.spliterator	(	): Creates a late-binding and fail-fast Spliterator over the elements in this deque. The Spliterator reports SIZED, SUBSIZED, ORDERED, and NONNULL. Overriding implementations should document the reporting of additional characteristic values.
java.util.ArrayDeque.toArray	(	): Returns an array containing all of the elements in this deque in proper sequence (from first to last element). The returned array will be "safe" in that no references to it are maintained by this deque. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.ArrayDeque.toArray	(	T[]	): Returns an array containing all of the elements in this deque in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array. If the deque fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this deque. If this deque fits in the specified array with room to spare (i.e., the array has more elements than this deque), the element in the array immediately following the end of the deque is set to null. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a deque known to contain only strings. The following code can be used to dump the deque into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.ArrayDeque.writeObject	(	java.io.ObjectOutputStream	): Saves this deque to a stream (that is, serializes it).
java.util.ArrayList: Resizable-array implementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to Vector, except that it is unsynchronized.) The size, isEmpty, get, set, iterator, and listIterator operations run in constant time. The add operation runs in amortized constant time, that is, adding n elements requires O(n) time. All of the other operations run in linear time (roughly speaking). The constant factor is low compared to that for the LinkedList implementation. Each ArrayList instance has a capacity. The capacity is the size of the array used to store the elements in the list. It is always at least as large as the list size. As elements are added to an ArrayList, its capacity grows automatically. The details of the growth policy are not specified beyond the fact that adding an element has constant amortized time cost. An application can increase the capacity of an ArrayList instance before adding a large number of elements using the ensureCapacity operation. This may reduce the amount of incremental reallocation. Note that this implementation is not synchronized. If multiple threads access an ArrayList instance concurrently, and at least one of the threads modifies the list structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more elements, or explicitly resizes the backing array; merely setting the value of an element is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the list. If no such object exists, the list should be "wrapped" using the synchronizedList Collections.synchronizedList method. This is best done at creation time, to prevent accidental unsynchronized access to the list: List list = Collections.synchronizedList(new ArrayList(...));  The iterators returned by this class's iterator() and listIterator() methods are fail-fast: if the list is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove() or add() methods, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. This class is a member of the  Java Collections Framework.
java.util.ArrayList.ArrayList	(	): Constructs an empty list with an initial capacity of ten.
java.util.ArrayList.ArrayList	(	Collection	): Constructs a list containing the elements of the specified collection, in the order they are returned by the collection's iterator.
java.util.ArrayList.ArrayList	(	int	): Constructs an empty list with the specified initial capacity.
java.util.ArrayList.ArrayListSpliterator: Index-based split-by-two, lazily initialized Spliterator 
java.util.ArrayList.ArrayListSpliterator.ArrayListSpliterator	(	ArrayList	int	int	int	): Create new spliterator covering the given range 
java.util.ArrayList.Itr: An optimized version of AbstractList.Itr
java.util.ArrayList.ListItr: An optimized version of AbstractList.ListItr
java.util.ArrayList.add	(	E	): Appends the specified element to the end of this list.
java.util.ArrayList.add	(	int	E	): Inserts the specified element at the specified position in this list. Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices).
java.util.ArrayList.addAll	(	Collection	): Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's Iterator. The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (This implies that the behavior of this call is undefined if the specified collection is this list, and this list is nonempty.)
java.util.ArrayList.addAll	(	int	Collection	): Inserts all of the elements in the specified collection into this list, starting at the specified position. Shifts the element currently at that position (if any) and any subsequent elements to the right (increases their indices). The new elements will appear in the list in the order that they are returned by the specified collection's iterator.
java.util.ArrayList.clear	(	): Removes all of the elements from this list. The list will be empty after this call returns.
java.util.ArrayList.clone	(	): Returns a shallow copy of this ArrayList instance. (The elements themselves are not copied.)
java.util.ArrayList.contains	(	Object	): Returns true if this list contains the specified element. More formally, returns true if and only if this list contains at least one element e such that (o==null ? e==null : o.equals(e)).
java.util.ArrayList.ensureCapacity	(	int	): Increases the capacity of this ArrayList instance, if necessary, to ensure that it can hold at least the number of elements specified by the minimum capacity argument.
java.util.ArrayList.get	(	int	): Returns the element at the specified position in this list.
java.util.ArrayList.grow	(	int	): Increases the capacity to ensure that it can hold at least the number of elements specified by the minimum capacity argument.
java.util.ArrayList.indexOf	(	Object	): Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.
java.util.ArrayList.isEmpty	(	): Returns true if this list contains no elements.
java.util.ArrayList.iterator	(	): Returns an iterator over the elements in this list in proper sequence. The returned iterator is fail-fast.
java.util.ArrayList.lastIndexOf	(	Object	): Returns the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the highest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.
java.util.ArrayList.listIterator	(	): Returns a list iterator over the elements in this list (in proper sequence). The returned list iterator is fail-fast.
java.util.ArrayList.listIterator	(	int	): Returns a list iterator over the elements in this list (in proper sequence), starting at the specified position in the list. The specified index indicates the first element that would be returned by an initial call to next. An initial call to previous would return the element with the specified index minus one. The returned list iterator is fail-fast.
java.util.ArrayList.outOfBoundsMsg	(	int	): Constructs an IndexOutOfBoundsException detail message. Of the many possible refactorings of the error handling code, this "outlining" performs best with both server and client VMs.
java.util.ArrayList.rangeCheck	(	int	): Checks if the given index is in range. If not, throws an appropriate runtime exception. This method does *not* check if the index is negative: It is always used immediately prior to an array access, which throws an ArrayIndexOutOfBoundsException if index is negative.
java.util.ArrayList.rangeCheckForAdd	(	int	): A version of rangeCheck used by add and addAll.
java.util.ArrayList.readObject	(	java.io.ObjectInputStream	): Reconstitute the ArrayList instance from a stream (that is, deserialize it).
java.util.ArrayList.remove	(	Object	): Removes the first occurrence of the specified element from this list, if it is present. If the list does not contain the element, it is unchanged. More formally, removes the element with the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))) (if such an element exists). Returns true if this list contained the specified element (or equivalently, if this list changed as a result of the call).
java.util.ArrayList.remove	(	int	): Removes the element at the specified position in this list. Shifts any subsequent elements to the left (subtracts one from their indices).
java.util.ArrayList.removeAll	(	Collection	): Removes from this list all of its elements that are contained in the specified collection.
java.util.ArrayList.removeRange	(	int	int	): Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive. Shifts any succeeding elements to the left (reduces their index). This call shortens the list by (toIndex - fromIndex) elements. (If toIndex==fromIndex, this operation has no effect.)
java.util.ArrayList.retainAll	(	Collection	): Retains only the elements in this list that are contained in the specified collection. In other words, removes from this list all of its elements that are not contained in the specified collection.
java.util.ArrayList.set	(	int	E	): Replaces the element at the specified position in this list with the specified element.
java.util.ArrayList.size	(	): Returns the number of elements in this list.
java.util.ArrayList.spliterator	(	): Creates a late-binding and fail-fast Spliterator over the elements in this list. The Spliterator reports SIZED, SUBSIZED, and ORDERED. Overriding implementations should document the reporting of additional characteristic values.
java.util.ArrayList.subList	(	int	int	): Returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive. (If fromIndex and toIndex are equal, the returned list is empty.) The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa. The returned list supports all of the optional list operations. This method eliminates the need for explicit range operations (of the sort that commonly exist for arrays). Any operation that expects a list can be used as a range operation by passing a subList view instead of a whole list. For example, the following idiom removes a range of elements from a list:  list.subList(from, to).clear();  Similar idioms may be constructed for indexOf() and lastIndexOf(), and all of the algorithms in the Collections class can be applied to a subList. The semantics of the list returned by this method become undefined if the backing list (i.e., this list) is structurally modified in any way other than via the returned list. (Structural modifications are those that change the size of this list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.)
java.util.ArrayList.toArray	(	): Returns an array containing all of the elements in this list in proper sequence (from first to last element). The returned array will be "safe" in that no references to it are maintained by this list. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.ArrayList.toArray	(	T[]	): Returns an array containing all of the elements in this list in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array. If the list fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this list. If the list fits in the specified array with room to spare (i.e., the array has more elements than the list), the element in the array immediately following the end of the collection is set to null. (This is useful in determining the length of the list only if the caller knows that the list does not contain any null elements.)
java.util.ArrayList.trimToSize	(	): Trims the capacity of this ArrayList instance to be the list's current size. An application can use this operation to minimize the storage of an ArrayList instance.
java.util.ArrayList.writeObject	(	java.io.ObjectOutputStream	): Save the state of the ArrayList instance to a stream (that is, serialize it).
java.util.ArrayPrefixHelpers: ForkJoin tasks to perform Arrays.parallelPrefix operations.
java.util.ArrayPrefixHelpers.CumulateTask.CumulateTask	(	CumulateTask	BinaryOperator	T[]	int	int	): Root task constructor 
java.util.ArrayPrefixHelpers.CumulateTask.CumulateTask	(	CumulateTask	BinaryOperator	T[]	int	int	int	int	int	): Subtask constructor 
java.util.ArrayPrefixHelpers.DoubleCumulateTask.DoubleCumulateTask	(	DoubleCumulateTask	DoubleBinaryOperator	double[]	int	int	): Root task constructor 
java.util.ArrayPrefixHelpers.DoubleCumulateTask.DoubleCumulateTask	(	DoubleCumulateTask	DoubleBinaryOperator	double[]	int	int	int	int	int	): Subtask constructor 
java.util.ArrayPrefixHelpers.IntCumulateTask.IntCumulateTask	(	IntCumulateTask	IntBinaryOperator	int[]	int	int	): Root task constructor 
java.util.ArrayPrefixHelpers.IntCumulateTask.IntCumulateTask	(	IntCumulateTask	IntBinaryOperator	int[]	int	int	int	int	int	): Subtask constructor 
java.util.ArrayPrefixHelpers.LongCumulateTask.LongCumulateTask	(	LongCumulateTask	LongBinaryOperator	long[]	int	int	): Root task constructor 
java.util.ArrayPrefixHelpers.LongCumulateTask.LongCumulateTask	(	LongCumulateTask	LongBinaryOperator	long[]	int	int	int	int	int	): Subtask constructor 
java.util.Arrays: This class contains various methods for manipulating arrays (such as sorting and searching). This class also contains a static factory that allows arrays to be viewed as lists. The methods in this class all throw a NullPointerException, if the specified array reference is null, except where noted. The documentation for the methods contained in this class includes briefs description of the implementations. Such descriptions should be regarded as implementation notes, rather than parts of the specification. Implementors should feel free to substitute other algorithms, so long as the specification itself is adhered to. (For example, the algorithm used by sort(Object[]) does not have to be a MergeSort, but it does have to be stable.) This class is a member of the  Java Collections Framework.
java.util.Arrays.LegacyMergeSort: Old merge sort implementation can be selected (for compatibility with broken comparators) using a system property. Cannot be a static boolean in the enclosing class due to circular dependencies. To be removed in a future release.
java.util.Arrays.NaturalOrder: A comparator that implements the natural ordering of a group of mutually comparable elements. May be used when a supplied comparator is null. To simplify code-sharing within underlying implementations, the compare method only declares type Object for its second argument. Arrays class implementor's note: It is an empirical matter whether ComparableTimSort offers any performance benefit over TimSort used with this comparator. If not, you are better off deleting or bypassing ComparableTimSort. There is currently no empirical case for separating them for parallel sorting, so all public Object parallelSort methods use the same comparator based implementation.
java.util.Arrays.asList	(	T	): Returns a fixed-size list backed by the specified array. (Changes to the returned list "write through" to the array.) This method acts as bridge between array-based and collection-based APIs, in combination with toArray. The returned list is serializable and implements RandomAccess. This method also provides a convenient way to create a fixed-size list initialized to contain several elements:  List<String> stooges = Arrays.asList("Larry", "Moe", "Curly"); 
java.util.Arrays.binarySearch	(	Object[]	Object	): Searches the specified array for the specified object using the binary search algorithm. The array must be sorted into ascending order according to the Comparable natural ordering of its elements (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. (If the array contains elements that are not mutually comparable (for example, strings and integers), it cannot be sorted according to the natural ordering of its elements, hence results are undefined.) If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found.
java.util.Arrays.binarySearch	(	Object[]	int	int	Object	): Searches a range of the specified array for the specified object using the binary search algorithm. The range must be sorted into ascending order according to the Comparable natural ordering of its elements (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. (If the range contains elements that are not mutually comparable (for example, strings and integers), it cannot be sorted according to the natural ordering of its elements, hence results are undefined.) If the range contains multiple elements equal to the specified object, there is no guarantee which one will be found.
java.util.Arrays.binarySearch	(	T[]	T	Comparator	): Searches the specified array for the specified object using the binary search algorithm. The array must be sorted into ascending order according to the specified comparator (as by the sort() sort(T[], Comparator) method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements equal to the specified object, there is no guarantee which one will be found.
java.util.Arrays.binarySearch	(	T[]	int	int	T	Comparator	): Searches a range of the specified array for the specified object using the binary search algorithm. The range must be sorted into ascending order according to the specified comparator (as by the sort() sort(T[], int, int, Comparator) method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements equal to the specified object, there is no guarantee which one will be found.
java.util.Arrays.binarySearch	(	byte[]	byte	): Searches the specified array of bytes for the specified value using the binary search algorithm. The array must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.
java.util.Arrays.binarySearch	(	byte[]	int	int	byte	): Searches a range of the specified array of bytes for the specified value using the binary search algorithm. The range must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.
java.util.Arrays.binarySearch	(	char[]	char	): Searches the specified array of chars for the specified value using the binary search algorithm. The array must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.
java.util.Arrays.binarySearch	(	char[]	int	int	char	): Searches a range of the specified array of chars for the specified value using the binary search algorithm. The range must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.
java.util.Arrays.binarySearch	(	double[]	double	): Searches the specified array of doubles for the specified value using the binary search algorithm. The array must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.
java.util.Arrays.binarySearch	(	double[]	int	int	double	): Searches a range of the specified array of doubles for the specified value using the binary search algorithm. The range must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.
java.util.Arrays.binarySearch	(	float[]	float	): Searches the specified array of floats for the specified value using the binary search algorithm. The array must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.
java.util.Arrays.binarySearch	(	float[]	int	int	float	): Searches a range of the specified array of floats for the specified value using the binary search algorithm. The range must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found. This method considers all NaN values to be equivalent and equal.
java.util.Arrays.binarySearch	(	int[]	int	): Searches the specified array of ints for the specified value using the binary search algorithm. The array must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.
java.util.Arrays.binarySearch	(	int[]	int	int	int	): Searches a range of the specified array of ints for the specified value using the binary search algorithm. The range must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.
java.util.Arrays.binarySearch	(	long[]	int	int	long	): Searches a range of the specified array of longs for the specified value using the binary search algorithm. The range must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.
java.util.Arrays.binarySearch	(	long[]	long	): Searches the specified array of longs for the specified value using the binary search algorithm. The array must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.
java.util.Arrays.binarySearch	(	short[]	int	int	short	): Searches a range of the specified array of shorts for the specified value using the binary search algorithm. The range must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the range contains multiple elements with the specified value, there is no guarantee which one will be found.
java.util.Arrays.binarySearch	(	short[]	short	): Searches the specified array of shorts for the specified value using the binary search algorithm. The array must be sorted (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the array contains multiple elements with the specified value, there is no guarantee which one will be found.
java.util.Arrays.copyOf	(	T[]	int	): Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain null. Such indices will exist if and only if the specified length is greater than that of the original array. The resulting array is of exactly the same class as the original array.
java.util.Arrays.copyOf	(	U[]	int	Class	): Copies the specified array, truncating or padding with nulls (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain null. Such indices will exist if and only if the specified length is greater than that of the original array. The resulting array is of the class newType.
java.util.Arrays.copyOf	(	boolean[]	int	): Copies the specified array, truncating or padding with false (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain false. Such indices will exist if and only if the specified length is greater than that of the original array.
java.util.Arrays.copyOf	(	byte[]	int	): Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain (byte)0. Such indices will exist if and only if the specified length is greater than that of the original array.
java.util.Arrays.copyOf	(	char[]	int	): Copies the specified array, truncating or padding with null characters (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain '\\u000'. Such indices will exist if and only if the specified length is greater than that of the original array.
java.util.Arrays.copyOf	(	double[]	int	): Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain 0d. Such indices will exist if and only if the specified length is greater than that of the original array.
java.util.Arrays.copyOf	(	float[]	int	): Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain 0f. Such indices will exist if and only if the specified length is greater than that of the original array.
java.util.Arrays.copyOf	(	int[]	int	): Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain 0. Such indices will exist if and only if the specified length is greater than that of the original array.
java.util.Arrays.copyOf	(	long[]	int	): Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain 0L. Such indices will exist if and only if the specified length is greater than that of the original array.
java.util.Arrays.copyOf	(	short[]	int	): Copies the specified array, truncating or padding with zeros (if necessary) so the copy has the specified length. For all indices that are valid in both the original array and the copy, the two arrays will contain identical values. For any indices that are valid in the copy but not the original, the copy will contain (short)0. Such indices will exist if and only if the specified length is greater than that of the original array.
java.util.Arrays.copyOfRange	(	T[]	int	int	): Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case null is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.  The resulting array is of exactly the same class as the original array.
java.util.Arrays.copyOfRange	(	U[]	int	int	Class	): Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case null is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from. The resulting array is of the class newType.
java.util.Arrays.copyOfRange	(	boolean[]	int	int	): Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case false is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.
java.util.Arrays.copyOfRange	(	byte[]	int	int	): Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case (byte)0 is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.
java.util.Arrays.copyOfRange	(	char[]	int	int	): Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case '\\u000' is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.
java.util.Arrays.copyOfRange	(	double[]	int	int	): Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case 0d is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.
java.util.Arrays.copyOfRange	(	float[]	int	int	): Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case 0f is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.
java.util.Arrays.copyOfRange	(	int[]	int	int	): Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case 0 is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.
java.util.Arrays.copyOfRange	(	long[]	int	int	): Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case 0L is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.
java.util.Arrays.copyOfRange	(	short[]	int	int	): Copies the specified range of the specified array into a new array. The initial index of the range (from) must lie between zero and original.length, inclusive. The value at original[from] is placed into the initial element of the copy (unless from == original.length or from == to). Values from subsequent elements in the original array are placed into subsequent elements in the copy. The final index of the range (to), which must be greater than or equal to from, may be greater than original.length, in which case (short)0 is placed in all elements of the copy whose index is greater than or equal to original.length - from. The length of the returned array will be to - from.
java.util.Arrays.deepEquals	(	Object[]	Object[]	): Returns true if the two specified arrays are deeply equal to one another. Unlike the equals() method, this method is appropriate for use with nested arrays of arbitrary depth. Two array references are considered deeply equal if both are null, or if they refer to arrays that contain the same number of elements and all corresponding pairs of elements in the two arrays are deeply equal. Two possibly null elements e1 and e2 are deeply equal if any of the following conditions hold:   e1 and e2 are both arrays of object reference types, and Arrays.deepEquals(e1, e2) would return true  e1 and e2 are arrays of the same primitive type, and the appropriate overloading of Arrays.equals(e1, e2) would return true.  e1 == e2  e1.equals(e2) would return true.  Note that this definition permits null elements at any depth. If either of the specified arrays contain themselves as elements either directly or indirectly through one or more levels of arrays, the behavior of this method is undefined.
java.util.Arrays.deepHashCode	(	Object	): Returns a hash code based on the "deep contents" of the specified array. If the array contains other arrays as elements, the hash code is based on their contents and so on, ad infinitum. It is therefore unacceptable to invoke this method on an array that contains itself as an element, either directly or indirectly through one or more levels of arrays. The behavior of such an invocation is undefined. For any two arrays a and b such that Arrays.deepEquals(a, b), it is also the case that Arrays.deepHashCode(a) == Arrays.deepHashCode(b). The computation of the value returned by this method is similar to that of the value returned by hashCode() on a list containing the same elements as a in the same order, with one difference: If an element e of a is itself an array, its hash code is computed not by calling e.hashCode(), but as by calling the appropriate overloading of Arrays.hashCode(e) if e is an array of a primitive type, or as by calling Arrays.deepHashCode(e) recursively if e is an array of a reference type. If a is null, this method returns 0.
java.util.Arrays.deepToString	(	Object[]	): Returns a string representation of the "deep contents" of the specified array. If the array contains other arrays as elements, the string representation contains their contents and so on. This method is designed for converting multidimensional arrays to strings. The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Elements are converted to strings as by String.valueOf(Object), unless they are themselves arrays. If an element e is an array of a primitive type, it is converted to a string as by invoking the appropriate overloading of Arrays.toString(e). If an element e is an array of a reference type, it is converted to a string as by invoking this method recursively. To avoid infinite recursion, if the specified array contains itself as an element, or contains an indirect reference to itself through one or more levels of arrays, the self-reference is converted to the string "[...]". For example, an array containing only a reference to itself would be rendered as "[[...]]". This method returns "null" if the specified array is null.
java.util.Arrays.equals	(	Object[]	Object[]	): Returns true if the two specified arrays of Objects are equal to one another. The two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. Two objects e1 and e2 are considered equal if (e1==null ? e2==null : e1.equals(e2)). In other words, the two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.
java.util.Arrays.equals	(	boolean[]	boolean[]	): Returns true if the two specified arrays of booleans are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.
java.util.Arrays.equals	(	byte[]	byte[]	): Returns true if the two specified arrays of bytes are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.
java.util.Arrays.equals	(	char[]	char[]	): Returns true if the two specified arrays of chars are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.
java.util.Arrays.equals	(	double[]	double[]	): Returns true if the two specified arrays of doubles are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null. Two doubles d1 and d2 are considered equal if:  new Double(d1).equals(new Double(d2)) (Unlike the == operator, this method considers NaN equals to itself, and 0.0d unequal to -0.0d.)
java.util.Arrays.equals	(	float[]	float[]	): Returns true if the two specified arrays of floats are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null. Two floats f1 and f2 are considered equal if:  new Float(f1).equals(new Float(f2)) (Unlike the == operator, this method considers NaN equals to itself, and 0.0f unequal to -0.0f.)
java.util.Arrays.equals	(	int[]	int[]	): Returns true if the two specified arrays of ints are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.
java.util.Arrays.equals	(	long[]	long[]	): Returns true if the two specified arrays of longs are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.
java.util.Arrays.equals	(	short[]	short	): Returns true if the two specified arrays of shorts are equal to one another. Two arrays are considered equal if both arrays contain the same number of elements, and all corresponding pairs of elements in the two arrays are equal. In other words, two arrays are equal if they contain the same elements in the same order. Also, two array references are considered equal if both are null.
java.util.Arrays.fill	(	Object[]	Object	): Assigns the specified Object reference to each element of the specified array of Objects.
java.util.Arrays.fill	(	Object[]	int	int	Object	): Assigns the specified Object reference to each element of the specified range of the specified array of Objects. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)
java.util.Arrays.fill	(	boolean[]	boolean	): Assigns the specified boolean value to each element of the specified array of booleans.
java.util.Arrays.fill	(	boolean[]	int	int	boolean	): Assigns the specified boolean value to each element of the specified range of the specified array of booleans. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)
java.util.Arrays.fill	(	byte[]	byte	): Assigns the specified byte value to each element of the specified array of bytes.
java.util.Arrays.fill	(	byte[]	int	int	byte	): Assigns the specified byte value to each element of the specified range of the specified array of bytes. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)
java.util.Arrays.fill	(	char[]	char	): Assigns the specified char value to each element of the specified array of chars.
java.util.Arrays.fill	(	char[]	int	int	char	): Assigns the specified char value to each element of the specified range of the specified array of chars. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)
java.util.Arrays.fill	(	double[]	double	): Assigns the specified double value to each element of the specified array of doubles.
java.util.Arrays.fill	(	double[]	int	int	double	): Assigns the specified double value to each element of the specified range of the specified array of doubles. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)
java.util.Arrays.fill	(	float[]	float	): Assigns the specified float value to each element of the specified array of floats.
java.util.Arrays.fill	(	float[]	int	int	float	): Assigns the specified float value to each element of the specified range of the specified array of floats. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)
java.util.Arrays.fill	(	int[]	int	): Assigns the specified int value to each element of the specified array of ints.
java.util.Arrays.fill	(	int[]	int	int	int	): Assigns the specified int value to each element of the specified range of the specified array of ints. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)
java.util.Arrays.fill	(	long[]	int	int	long	): Assigns the specified long value to each element of the specified range of the specified array of longs. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)
java.util.Arrays.fill	(	long[]	long	): Assigns the specified long value to each element of the specified array of longs.
java.util.Arrays.fill	(	short[]	int	int	short	): Assigns the specified short value to each element of the specified range of the specified array of shorts. The range to be filled extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be filled is empty.)
java.util.Arrays.fill	(	short[]	short	): Assigns the specified short value to each element of the specified array of shorts.
java.util.Arrays.hashCode	(	Object	): Returns a hash code based on the contents of the specified array. If the array contains other arrays as elements, the hash code is based on their identities rather than their contents. It is therefore acceptable to invoke this method on an array that contains itself as an element, either directly or indirectly through one or more levels of arrays. For any two arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b). The value returned by this method is equal to the value that would be returned by Arrays.asList(a).hashCode(), unless a is null, in which case 0 is returned.
java.util.Arrays.hashCode	(	boolean	): Returns a hash code based on the contents of the specified array. For any two boolean arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode() hashCode method on a List containing a sequence of Boolean instances representing the elements of a in the same order. If a is null, this method returns 0.
java.util.Arrays.hashCode	(	byte	): Returns a hash code based on the contents of the specified array. For any two byte arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode() hashCode method on a List containing a sequence of Byte instances representing the elements of a in the same order. If a is null, this method returns 0.
java.util.Arrays.hashCode	(	char	): Returns a hash code based on the contents of the specified array. For any two char arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode() hashCode method on a List containing a sequence of Character instances representing the elements of a in the same order. If a is null, this method returns 0.
java.util.Arrays.hashCode	(	double	): Returns a hash code based on the contents of the specified array. For any two double arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode() hashCode method on a List containing a sequence of Double instances representing the elements of a in the same order. If a is null, this method returns 0.
java.util.Arrays.hashCode	(	float	): Returns a hash code based on the contents of the specified array. For any two float arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode() hashCode method on a List containing a sequence of Float instances representing the elements of a in the same order. If a is null, this method returns 0.
java.util.Arrays.hashCode	(	int	): Returns a hash code based on the contents of the specified array. For any two non-null int arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode() hashCode method on a List containing a sequence of Integer instances representing the elements of a in the same order. If a is null, this method returns 0.
java.util.Arrays.hashCode	(	long	): Returns a hash code based on the contents of the specified array. For any two long arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode() hashCode method on a List containing a sequence of Long instances representing the elements of a in the same order. If a is null, this method returns 0.
java.util.Arrays.hashCode	(	short	): Returns a hash code based on the contents of the specified array. For any two short arrays a and b such that Arrays.equals(a, b), it is also the case that Arrays.hashCode(a) == Arrays.hashCode(b). The value returned by this method is the same value that would be obtained by invoking the hashCode() hashCode method on a List containing a sequence of Short instances representing the elements of a in the same order. If a is null, this method returns 0.
java.util.Arrays.legacyMergeSort	(	Object[]	): To be removed in a future release. 
java.util.Arrays.legacyMergeSort	(	Object[]	int	int	): To be removed in a future release. 
java.util.Arrays.legacyMergeSort	(	T[]	Comparator	): To be removed in a future release. 
java.util.Arrays.legacyMergeSort	(	T[]	int	int	Comparator	): To be removed in a future release. 
java.util.Arrays.mergeSort	(	Object[]	Object[]	int	int	int	): Src is the source array that starts at index 0 Dest is the (possibly larger) array destination with a possible offset low is the index in dest to start sorting high is the end index in dest to end sorting off is the offset to generate corresponding low, high in src To be removed in a future release.
java.util.Arrays.mergeSort	(	Object[]	Object[]	int	int	int	Comparator	): Src is the source array that starts at index 0 Dest is the (possibly larger) array destination with a possible offset low is the index in dest to start sorting high is the end index in dest to end sorting off is the offset into src corresponding to low in dest To be removed in a future release.
java.util.Arrays.parallelPrefix	(	T[]	BinaryOperator	): Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds [2, 1, 0, 3] and the operation performs addition, then upon return the array holds [2, 3, 3, 6]. Parallel prefix computation is usually more efficient than sequential loops for large arrays.
java.util.Arrays.parallelPrefix	(	T[]	int	int	BinaryOperator	): Performs parallelPrefix() for the given subrange of the array.
java.util.Arrays.parallelPrefix	(	double[]	DoubleBinaryOperator	): Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds [2.0, 1.0, 0.0, 3.0] and the operation performs addition, then upon return the array holds [2.0, 3.0, 3.0, 6.0]. Parallel prefix computation is usually more efficient than sequential loops for large arrays.  Because floating-point operations may not be strictly associative, the returned result may not be identical to the value that would be obtained if the operation was performed sequentially.
java.util.Arrays.parallelPrefix	(	double[]	int	int	DoubleBinaryOperator	): Performs parallelPrefix() for the given subrange of the array.
java.util.Arrays.parallelPrefix	(	int[]	IntBinaryOperator	): Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds [2, 1, 0, 3] and the operation performs addition, then upon return the array holds [2, 3, 3, 6]. Parallel prefix computation is usually more efficient than sequential loops for large arrays.
java.util.Arrays.parallelPrefix	(	int[]	int	int	IntBinaryOperator	): Performs parallelPrefix() for the given subrange of the array.
java.util.Arrays.parallelPrefix	(	long[]	LongBinaryOperator	): Cumulates, in parallel, each element of the given array in place, using the supplied function. For example if the array initially holds [2, 1, 0, 3] and the operation performs addition, then upon return the array holds [2, 3, 3, 6]. Parallel prefix computation is usually more efficient than sequential loops for large arrays.
java.util.Arrays.parallelPrefix	(	long[]	int	int	LongBinaryOperator	): Performs parallelPrefix() for the given subrange of the array.
java.util.Arrays.parallelSetAll	(	T[]	IntFunction	): Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from parallelSetAll and the array is left in an indeterminate state.
java.util.Arrays.parallelSetAll	(	double[]	IntToDoubleFunction	): Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from parallelSetAll and the array is left in an indeterminate state.
java.util.Arrays.parallelSetAll	(	int[]	IntUnaryOperator	): Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from parallelSetAll and the array is left in an indeterminate state.
java.util.Arrays.parallelSetAll	(	long[]	IntToLongFunction	): Set all elements of the specified array, in parallel, using the provided generator function to compute each element. If the generator function throws an exception, an unchecked exception is thrown from parallelSetAll and the array is left in an indeterminate state.
java.util.Arrays.parallelSort	(	T[]	): Sorts the specified array of objects into ascending order, according to the Comparable natural ordering of its elements. All elements in the array must implement the Comparable interface. Furthermore, all elements in the array must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort.
java.util.Arrays.parallelSort	(	T[]	Comparator	): Sorts the specified array of objects according to the order induced by the specified comparator. All elements in the array must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort.
java.util.Arrays.parallelSort	(	T[]	int	int	): Sorts the specified range of the specified array of objects into ascending order, according to the Comparable natural ordering of its elements. The range to be sorted extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be sorted is empty.) All elements in this range must implement the Comparable interface. Furthermore, all elements in this range must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort.
java.util.Arrays.parallelSort	(	T[]	int	int	Comparator	): Sorts the specified range of the specified array of objects according to the order induced by the specified comparator. The range to be sorted extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be sorted is empty.) All elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the range). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort.
java.util.Arrays.parallelSort	(	byte[]	): Sorts the specified array into ascending numerical order.
java.util.Arrays.parallelSort	(	byte[]	int	int	): Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty.
java.util.Arrays.parallelSort	(	char[]	): Sorts the specified array into ascending numerical order.
java.util.Arrays.parallelSort	(	char[]	int	int	): Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty.
java.util.Arrays.parallelSort	(	double[]	): Sorts the specified array into ascending numerical order. The < relation does not provide a total order on all double values: -0.0d == 0.0d is true and a Double.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method compareTo: -0.0d is treated as less than value 0.0d and Double.NaN is considered greater than any other value and all Double.NaN values are considered equal.
java.util.Arrays.parallelSort	(	double[]	int	int	): Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. The < relation does not provide a total order on all double values: -0.0d == 0.0d is true and a Double.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method compareTo: -0.0d is treated as less than value 0.0d and Double.NaN is considered greater than any other value and all Double.NaN values are considered equal.
java.util.Arrays.parallelSort	(	float[]	): Sorts the specified array into ascending numerical order. The < relation does not provide a total order on all float values: -0.0f == 0.0f is true and a Float.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method compareTo: -0.0f is treated as less than value 0.0f and Float.NaN is considered greater than any other value and all Float.NaN values are considered equal.
java.util.Arrays.parallelSort	(	float[]	int	int	): Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. The < relation does not provide a total order on all float values: -0.0f == 0.0f is true and a Float.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method compareTo: -0.0f is treated as less than value 0.0f and Float.NaN is considered greater than any other value and all Float.NaN values are considered equal.
java.util.Arrays.parallelSort	(	int[]	): Sorts the specified array into ascending numerical order.
java.util.Arrays.parallelSort	(	int[]	int	int	): Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty.
java.util.Arrays.parallelSort	(	long[]	): Sorts the specified array into ascending numerical order.
java.util.Arrays.parallelSort	(	long[]	int	int	): Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty.
java.util.Arrays.parallelSort	(	short[]	): Sorts the specified array into ascending numerical order.
java.util.Arrays.parallelSort	(	short[]	int	int	): Sorts the specified range of the array into ascending numerical order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty.
java.util.Arrays.rangeCheck	(	int	int	int	): Checks that fromIndex and toIndex are in the range and throws an exception if they aren't.
java.util.Arrays.setAll	(	T[]	IntFunction	): Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state.
java.util.Arrays.setAll	(	double[]	IntToDoubleFunction	): Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state.
java.util.Arrays.setAll	(	int[]	IntUnaryOperator	): Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state.
java.util.Arrays.setAll	(	long[]	IntToLongFunction	): Set all elements of the specified array, using the provided generator function to compute each element. If the generator function throws an exception, it is relayed to the caller and the array is left in an indeterminate state.
java.util.Arrays.sort	(	Object[]	): Sorts the specified array of objects into ascending order, according to the Comparable natural ordering of its elements. All elements in the array must implement the Comparable interface. Furthermore, all elements in the array must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's "Optimistic Sorting and Information Theoretic Complexity", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993.
java.util.Arrays.sort	(	Object[]	int	int	): Sorts the specified range of the specified array of objects into ascending order, according to the Comparable natural ordering of its elements. The range to be sorted extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be sorted is empty.) All elements in this range must implement the Comparable interface. Furthermore, all elements in this range must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's "Optimistic Sorting and Information Theoretic Complexity", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993.
java.util.Arrays.sort	(	T[]	Comparator	): Sorts the specified array of objects according to the order induced by the specified comparator. All elements in the array must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the array). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's "Optimistic Sorting and Information Theoretic Complexity", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993.
java.util.Arrays.sort	(	T[]	int	int	Comparator	): Sorts the specified range of the specified array of objects according to the order induced by the specified comparator. The range to be sorted extends from index fromIndex, inclusive, to index toIndex, exclusive. (If fromIndex==toIndex, the range to be sorted is empty.) All elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the range). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. Implementation note: This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays. The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array. The implementation was adapted from Tim Peters's list sort for Python ( TimSort). It uses techniques from Peter McIlroy's "Optimistic Sorting and Information Theoretic Complexity", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993.
java.util.Arrays.sort	(	byte[]	): Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays.sort	(	byte[]	int	int	): Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays.sort	(	char[]	): Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays.sort	(	char[]	int	int	): Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays.sort	(	double[]	): Sorts the specified array into ascending numerical order. The < relation does not provide a total order on all double values: -0.0d == 0.0d is true and a Double.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method compareTo: -0.0d is treated as less than value 0.0d and Double.NaN is considered greater than any other value and all Double.NaN values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays.sort	(	double[]	int	int	): Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. The < relation does not provide a total order on all double values: -0.0d == 0.0d is true and a Double.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method compareTo: -0.0d is treated as less than value 0.0d and Double.NaN is considered greater than any other value and all Double.NaN values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays.sort	(	float[]	): Sorts the specified array into ascending numerical order. The < relation does not provide a total order on all float values: -0.0f == 0.0f is true and a Float.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method compareTo: -0.0f is treated as less than value 0.0f and Float.NaN is considered greater than any other value and all Float.NaN values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays.sort	(	float[]	int	int	): Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. The < relation does not provide a total order on all float values: -0.0f == 0.0f is true and a Float.NaN value compares neither less than, greater than, nor equal to any value, even itself. This method uses the total order imposed by the method compareTo: -0.0f is treated as less than value 0.0f and Float.NaN is considered greater than any other value and all Float.NaN values are considered equal. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays.sort	(	int[]	): Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays.sort	(	int[]	int	int	): Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays.sort	(	long[]	): Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays.sort	(	long[]	int	int	): Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays.sort	(	short[]	): Sorts the specified array into ascending numerical order. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays.sort	(	short[]	int	int	): Sorts the specified range of the array into ascending order. The range to be sorted extends from the index fromIndex, inclusive, to the index toIndex, exclusive. If fromIndex == toIndex, the range to be sorted is empty. Implementation note: The sorting algorithm is a Dual-Pivot Quicksort by Vladimir Yaroslavskiy, Jon Bentley, and Joshua Bloch. This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations.
java.util.Arrays.spliterator	(	T[]	): Returns a Spliterator covering all of the specified array. The spliterator reports SIZED, SUBSIZED, ORDERED, and IMMUTABLE.
java.util.Arrays.spliterator	(	T[]	int	int	): Returns a Spliterator covering the specified range of the specified array. The spliterator reports SIZED, SUBSIZED, ORDERED, and IMMUTABLE.
java.util.Arrays.spliterator	(	double[]	): Returns a Spliterator.OfDouble covering all of the specified array. The spliterator reports SIZED, SUBSIZED, ORDERED, and IMMUTABLE.
java.util.Arrays.spliterator	(	double[]	int	int	): Returns a Spliterator.OfDouble covering the specified range of the specified array. The spliterator reports SIZED, SUBSIZED, ORDERED, and IMMUTABLE.
java.util.Arrays.spliterator	(	int[]	): Returns a Spliterator.OfInt covering all of the specified array. The spliterator reports SIZED, SUBSIZED, ORDERED, and IMMUTABLE.
java.util.Arrays.spliterator	(	int[]	int	int	): Returns a Spliterator.OfInt covering the specified range of the specified array. The spliterator reports SIZED, SUBSIZED, ORDERED, and IMMUTABLE.
java.util.Arrays.spliterator	(	long[]	): Returns a Spliterator.OfLong covering all of the specified array. The spliterator reports SIZED, SUBSIZED, ORDERED, and IMMUTABLE.
java.util.Arrays.spliterator	(	long[]	int	int	): Returns a Spliterator.OfLong covering the specified range of the specified array. The spliterator reports SIZED, SUBSIZED, ORDERED, and IMMUTABLE.
java.util.Arrays.stream	(	T[]	): Returns a sequential Stream with the specified array as its source.
java.util.Arrays.stream	(	T[]	int	int	): Returns a sequential Stream with the specified range of the specified array as its source.
java.util.Arrays.stream	(	double[]	): Returns a sequential DoubleStream with the specified array as its source.
java.util.Arrays.stream	(	double[]	int	int	): Returns a sequential DoubleStream with the specified range of the specified array as its source.
java.util.Arrays.stream	(	int[]	): Returns a sequential IntStream with the specified array as its source.
java.util.Arrays.stream	(	int[]	int	int	): Returns a sequential IntStream with the specified range of the specified array as its source.
java.util.Arrays.stream	(	long[]	): Returns a sequential LongStream with the specified array as its source.
java.util.Arrays.stream	(	long[]	int	int	): Returns a sequential LongStream with the specified range of the specified array as its source.
java.util.Arrays.swap	(	Object[]	int	int	): Swaps x[a] with x[b].
java.util.Arrays.toString	(	Object[]	): Returns a string representation of the contents of the specified array. If the array contains other arrays as elements, they are converted to strings by the toString method inherited from Object, which describes their identities rather than their contents. The value returned by this method is equal to the value that would be returned by Arrays.asList(a).toString(), unless a is null, in which case "null" is returned.
java.util.Arrays.toString	(	boolean[]	): Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Elements are converted to strings as by String.valueOf(boolean). Returns "null" if a is null.
java.util.Arrays.toString	(	byte[]	): Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Elements are converted to strings as by String.valueOf(byte). Returns "null" if a is null.
java.util.Arrays.toString	(	char[]	): Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Elements are converted to strings as by String.valueOf(char). Returns "null" if a is null.
java.util.Arrays.toString	(	double[]	): Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Elements are converted to strings as by String.valueOf(double). Returns "null" if a is null.
java.util.Arrays.toString	(	float[]	): Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Elements are converted to strings as by String.valueOf(float). Returns "null" if a is null.
java.util.Arrays.toString	(	int[]	): Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Elements are converted to strings as by String.valueOf(int). Returns "null" if a is null.
java.util.Arrays.toString	(	long[]	): Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Elements are converted to strings as by String.valueOf(long). Returns "null" if a is null.
java.util.Arrays.toString	(	short[]	): Returns a string representation of the contents of the specified array. The string representation consists of a list of the array's elements, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (a comma followed by a space). Elements are converted to strings as by String.valueOf(short). Returns "null" if a is null.
java.util.ArraysParallelSortHelpers: Helper utilities for the parallel sort methods in Arrays.parallelSort. For each primitive type, plus Object, we define a static class to contain the Sorter and Merger implementations for that type: Sorter classes based mainly on CilkSort  Cilk: Basic algorithm: if array size is small, just use a sequential quicksort (via Arrays.sort) Otherwise: 1. Break array in half. 2. For each half, a. break the half in half (i.e., quarters), b. sort the quarters c. merge them together 3. merge together the two halves. One reason for splitting in quarters is that this guarantees that the final sort is in the main array, not the workspace array. (workspace and main swap roles on each subsort step.) Leaf-level sorts use the associated sequential sort. Merger classes perform merging for Sorter. They are structured such that if the underlying sort is stable (as is true for TimSort), then so is the full sort. If big enough, they split the largest of the two partitions in half, find the greatest point in smaller partition less than the beginning of the second half of larger via binary search; and then merge in parallel the two partitions. In part to ensure tasks are triggered in stability-preserving order, the current CountedCompleter design requires some little tasks to serve as place holders for triggering completion tasks. These classes (EmptyCompleter and Relay) don't need to keep track of the arrays, and are never themselves forked, so don't hold any task state. The primitive class versions (FJByte... FJDouble) are identical to each other except for type declarations. The base sequential sorts rely on non-public versions of TimSort, ComparableTimSort, and DualPivotQuicksort sort methods that accept temp workspace array slices that we will have already allocated, so avoids redundant allocation. (Except for DualPivotQuicksort byte[] sort, that does not ever use a workspace array.)
java.util.ArraysParallelSortHelpers.EmptyCompleter: A placeholder task for Sorters, used for the lowest quartile task, that does not need to maintain array state.
java.util.ArraysParallelSortHelpers.FJByte: byte support class 
java.util.ArraysParallelSortHelpers.FJChar: char support class 
java.util.ArraysParallelSortHelpers.FJDouble: double support class 
java.util.ArraysParallelSortHelpers.FJFloat: float support class 
java.util.ArraysParallelSortHelpers.FJInt: int support class 
java.util.ArraysParallelSortHelpers.FJLong: long support class 
java.util.ArraysParallelSortHelpers.FJObject: Object + Comparator support class 
java.util.ArraysParallelSortHelpers.FJShort: short support class 
java.util.ArraysParallelSortHelpers.Relay: A trigger for secondary merge of two merges
java.util.Base64: This class consists exclusively of static methods for obtaining encoders and decoders for the Base64 encoding scheme. The implementation of this class supports the following types of Base64 as specified in RFC 4648 and RFC 2045.  Basic  Uses "The Base64 Alphabet" as specified in Table 1 of RFC 4648 and RFC 2045 for encoding and decoding operation. The encoder does not add any line feed (line separator) character. The decoder rejects data that contains characters outside the base64 alphabet. URL and Filename safe  Uses the "URL and Filename safe Base64 Alphabet" as specified in Table 2 of RFC 4648 for encoding and decoding. The encoder does not add any line feed (line separator) character. The decoder rejects data that contains characters outside the base64 alphabet. MIME  Uses the "The Base64 Alphabet" as specified in Table 1 of RFC 2045 for encoding and decoding operation. The encoded output must be represented in lines of no more than 76 characters each and uses a carriage return '\r' followed immediately by a linefeed '\n' as the line separator. No line separator is added to the end of the encoded output. All line separators or other characters not found in the base64 alphabet table are ignored in decoding operation.   Unless otherwise noted, passing a null argument to a method of this class will cause a java.lang.NullPointerException NullPointerException to be thrown.
java.util.Base64.Decoder: This class implements a decoder for decoding byte data using the Base64 encoding scheme as specified in RFC 4648 and RFC 2045.  The Base64 padding character '=' is accepted and interpreted as the end of the encoded byte data, but is not required. So if the final unit of the encoded byte data only has two or three Base64 characters (without the corresponding padding character(s) padded), they are decoded as if followed by padding character(s). If there is a padding character present in the final unit, the correct number of padding character(s) must be present, otherwise IllegalArgumentException ( IOException when reading from a Base64 stream) is thrown during decoding.  Instances of Decoder class are safe for use by multiple concurrent threads.  Unless otherwise noted, passing a null argument to a method of this class will cause a java.lang.NullPointerException NullPointerException to be thrown.
java.util.Base64.Decoder.decode	(	ByteBuffer	): Decodes all bytes from the input byte buffer using the Base64 encoding scheme, writing the results into a newly-allocated ByteBuffer.  Upon return, the source buffer's position will be updated to its limit; its limit will not have been changed. The returned output buffer's position will be zero and its limit will be the number of resulting decoded bytes  IllegalArgumentException is thrown if the input buffer is not in valid Base64 encoding scheme. The position of the input buffer will not be advanced in this case.
java.util.Base64.Decoder.decode	(	String	): Decodes a Base64 encoded String into a newly-allocated byte array using the Base64 encoding scheme.  An invocation of this method has exactly the same effect as invoking decode(src.getBytes(StandardCharsets.ISO_8859_1))
java.util.Base64.Decoder.decode	(	byte[]	): Decodes all bytes from the input byte array using the Base64 encoding scheme, writing the results into a newly-allocated output byte array. The returned byte array is of the length of the resulting bytes.
java.util.Base64.Decoder.decode	(	byte[]	byte[]	): Decodes all bytes from the input byte array using the Base64 encoding scheme, writing the results into the given output byte array, starting at offset 0.  It is the responsibility of the invoker of this method to make sure the output byte array dst has enough space for decoding all bytes from the input byte array. No bytes will be be written to the output byte array if the output byte array is not big enough.  If the input byte array is not in valid Base64 encoding scheme then some bytes may have been written to the output byte array before IllegalargumentException is thrown.
java.util.Base64.Decoder.wrap	(	InputStream	): Returns an input stream for decoding Base64 encoded byte stream.  The read methods of the returned InputStream will throw IOException when reading bytes that cannot be decoded.  Closing the returned input stream will close the underlying input stream.
java.util.Base64.Encoder: This class implements an encoder for encoding byte data using the Base64 encoding scheme as specified in RFC 4648 and RFC 2045.  Instances of Encoder class are safe for use by multiple concurrent threads.  Unless otherwise noted, passing a null argument to a method of this class will cause a java.lang.NullPointerException NullPointerException to be thrown.
java.util.Base64.Encoder.encode	(	ByteBuffer	): Encodes all remaining bytes from the specified byte buffer into a newly-allocated ByteBuffer using the Base64 encoding scheme. Upon return, the source buffer's position will be updated to its limit; its limit will not have been changed. The returned output buffer's position will be zero and its limit will be the number of resulting encoded bytes.
java.util.Base64.Encoder.encode	(	byte[]	): Encodes all bytes from the specified byte array into a newly-allocated byte array using the Base64 encoding scheme. The returned byte array is of the length of the resulting bytes.
java.util.Base64.Encoder.encode	(	byte[]	byte[]	): Encodes all bytes from the specified byte array using the Base64 encoding scheme, writing the resulting bytes to the given output byte array, starting at offset 0.  It is the responsibility of the invoker of this method to make sure the output byte array dst has enough space for encoding all bytes from the input byte array. No bytes will be written to the output byte array if the output byte array is not big enough.
java.util.Base64.Encoder.encodeToString	(	byte[]	): Encodes the specified byte array into a String using the Base64 encoding scheme.  This method first encodes all input bytes into a base64 encoded byte array and then constructs a new String by using the encoded byte array and the ISO_8859_1 ISO-8859-1 charset.  In other words, an invocation of this method has exactly the same effect as invoking new String(encode(src), StandardCharsets.ISO_8859_1).
java.util.Base64.Encoder.withoutPadding	(	): Returns an encoder instance that encodes equivalently to this one, but without adding any padding character at the end of the encoded byte data.  The encoding scheme of this encoder instance is unaffected by this invocation. The returned encoder instance should be used for non-padding encoding operation.
java.util.Base64.Encoder.wrap	(	OutputStream	): Wraps an output stream for encoding byte data using the Base64 encoding scheme.  It is recommended to promptly close the returned output stream after use, during which it will flush all possible leftover bytes to the underlying output stream. Closing the returned output stream will close the underlying output stream.
java.util.Base64.getDecoder	(	): Returns a Decoder that decodes using the Basic type base64 encoding scheme.
java.util.Base64.getEncoder	(	): Returns a Encoder that encodes using the Basic type base64 encoding scheme.
java.util.Base64.getMimeDecoder	(	): Returns a Decoder that decodes using the MIME type base64 decoding scheme.
java.util.Base64.getMimeEncoder	(	): Returns a Encoder that encodes using the MIME type base64 encoding scheme.
java.util.Base64.getMimeEncoder	(	int	byte[]	): Returns a Encoder that encodes using the MIME type base64 encoding scheme with specified line length and line separators.
java.util.Base64.getUrlDecoder	(	): Returns a Decoder that decodes using the URL and Filename safe type base64 encoding scheme.
java.util.Base64.getUrlEncoder	(	): Returns a Encoder that encodes using the URL and Filename safe type base64 encoding scheme.
java.util.BitSet: This class implements a vector of bits that grows as needed. Each component of the bit set has a boolean value. The bits of a BitSet are indexed by nonnegative integers. Individual indexed bits can be examined, set, or cleared. One BitSet may be used to modify the contents of another BitSet through logical AND, logical inclusive OR, and logical exclusive OR operations. By default, all bits in the set initially have the value false. Every bit set has a current size, which is the number of bits of space currently in use by the bit set. Note that the size is related to the implementation of a bit set, so it may change with implementation. The length of a bit set relates to logical length of a bit set and is defined independently of implementation. Unless otherwise noted, passing a null parameter to any of the methods in a BitSet will result in a NullPointerException. A BitSet is not safe for multithreaded use without external synchronization.
java.util.BitSet.BitSet	(	): Creates a new bit set. All bits are initially false.
java.util.BitSet.BitSet	(	int	): Creates a bit set whose initial size is large enough to explicitly represent bits with indices in the range 0 through nbits-1. All bits are initially false.
java.util.BitSet.BitSet	(	long[]	): Creates a bit set using words as the internal representation. The last word (if there is one) must be non-zero.
java.util.BitSet.and	(	BitSet	): Performs a logical AND of this target bit set with the argument bit set. This bit set is modified so that each bit in it has the value true if and only if it both initially had the value true and the corresponding bit in the bit set argument also had the value true.
java.util.BitSet.andNot	(	BitSet	): Clears all of the bits in this BitSet whose corresponding bit is set in the specified BitSet.
java.util.BitSet.cardinality	(	): Returns the number of bits set to true in this BitSet.
java.util.BitSet.checkInvariants	(	): Every public method must preserve these invariants.
java.util.BitSet.checkRange	(	int	int	): Checks that fromIndex ... toIndex is a valid range of bit indices.
java.util.BitSet.clear	(	): Sets all of the bits in this BitSet to false.
java.util.BitSet.clear	(	int	): Sets the bit specified by the index to false.
java.util.BitSet.clear	(	int	int	): Sets the bits from the specified fromIndex (inclusive) to the specified toIndex (exclusive) to false.
java.util.BitSet.clone	(	): Cloning this BitSet produces a new BitSet that is equal to it. The clone of the bit set is another bit set that has exactly the same bits set to true as this bit set.
java.util.BitSet.ensureCapacity	(	int	): Ensures that the BitSet can hold enough words.
java.util.BitSet.equals	(	Object	): Compares this object against the specified object. The result is true if and only if the argument is not null and is a Bitset object that has exactly the same set of bits set to true as this bit set. That is, for every nonnegative int index k, ((BitSet)obj).get(k) == this.get(k) must be true. The current sizes of the two bit sets are not compared.
java.util.BitSet.expandTo	(	int	): Ensures that the BitSet can accommodate a given wordIndex, temporarily violating the invariants. The caller must restore the invariants before returning to the user, possibly using recalculateWordsInUse().
java.util.BitSet.flip	(	int	): Sets the bit at the specified index to the complement of its current value.
java.util.BitSet.flip	(	int	int	): Sets each bit from the specified fromIndex (inclusive) to the specified toIndex (exclusive) to the complement of its current value.
java.util.BitSet.get	(	int	): Returns the value of the bit with the specified index. The value is true if the bit with the index bitIndex is currently set in this BitSet; otherwise, the result is false.
java.util.BitSet.get	(	int	int	): Returns a new BitSet composed of bits from this BitSet from fromIndex (inclusive) to toIndex (exclusive).
java.util.BitSet.hashCode	(	): Returns the hash code value for this bit set. The hash code depends only on which bits are set within this BitSet. The hash code is defined to be the result of the following calculation:  public int hashCode() long h = 1234; long[] words = toLongArray(); for (int i = words.length; --i >= 0; ) h ^= words[i] * (i + 1); return (int)((h >> 32) ^ h); }} Note that the hash code changes if the set of bits is altered.
java.util.BitSet.intersects	(	BitSet	): Returns true if the specified BitSet has any bits set to true that are also set to true in this BitSet.
java.util.BitSet.isEmpty	(	): Returns true if this BitSet contains no bits that are set to true.
java.util.BitSet.length	(	): Returns the "logical size" of this BitSet: the index of the highest set bit in the BitSet plus one. Returns zero if the BitSet contains no set bits.
java.util.BitSet.nextClearBit	(	int	): Returns the index of the first bit that is set to false that occurs on or after the specified starting index.
java.util.BitSet.nextSetBit	(	int	): Returns the index of the first bit that is set to true that occurs on or after the specified starting index. If no such bit exists then -1 is returned. To iterate over the true bits in a BitSet, use the following loop:  for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i+1)) // operate on index i here if (i == Integer.MAX_VALUE) { break; // or (i+1) would overflow } }}
java.util.BitSet.or	(	BitSet	): Performs a logical OR of this bit set with the bit set argument. This bit set is modified so that a bit in it has the value true if and only if it either already had the value true or the corresponding bit in the bit set argument has the value true.
java.util.BitSet.previousClearBit	(	int	): Returns the index of the nearest bit that is set to false that occurs on or before the specified starting index. If no such bit exists, or if -1 is given as the starting index, then -1 is returned.
java.util.BitSet.previousSetBit	(	int	): Returns the index of the nearest bit that is set to true that occurs on or before the specified starting index. If no such bit exists, or if -1 is given as the starting index, then -1 is returned. To iterate over the true bits in a BitSet, use the following loop:  for (int i = bs.length(); (i = bs.previousSetBit(i-1)) >= 0; ) // operate on index i here }}
java.util.BitSet.readObject	(	ObjectInputStream	): Reconstitute the BitSet instance from a stream (i.e., deserialize it).
java.util.BitSet.recalculateWordsInUse	(	): Sets the field wordsInUse to the logical size in words of the bit set. WARNING:This method assumes that the number of words actually in use is less than or equal to the current value of wordsInUse!
java.util.BitSet.set	(	int	): Sets the bit at the specified index to true.
java.util.BitSet.set	(	int	boolean	): Sets the bit at the specified index to the specified value.
java.util.BitSet.set	(	int	int	): Sets the bits from the specified fromIndex (inclusive) to the specified toIndex (exclusive) to true.
java.util.BitSet.set	(	int	int	boolean	): Sets the bits from the specified fromIndex (inclusive) to the specified toIndex (exclusive) to the specified value.
java.util.BitSet.size	(	): Returns the number of bits of space actually in use by this BitSet to represent bit values. The maximum element in the set is the size - 1st element.
java.util.BitSet.stream	(	): Returns a stream of indices for which this BitSet contains a bit in the set state. The indices are returned in order, from lowest to highest. The size of the stream is the number of bits in the set state, equal to the value returned by the cardinality() method. The bit set must remain constant during the execution of the terminal stream operation. Otherwise, the result of the terminal stream operation is undefined.
java.util.BitSet.toByteArray	(	): Returns a new byte array containing all the bits in this bit set. More precisely, if byte[] bytes = s.toByteArray(); then bytes.length == (s.length()+7)/8 and s.get(n) == ((bytes[n/8] & (1<<(n%8))) != 0) for all n < 8 * bytes.length.
java.util.BitSet.toLongArray	(	): Returns a new long array containing all the bits in this bit set. More precisely, if long[] longs = s.toLongArray(); then longs.length == (s.length()+63)/64 and s.get(n) == ((longs[n/64] & (1L<<(n%64))) != 0) for all n < 64 * longs.length.
java.util.BitSet.toString	(	): Returns a string representation of this bit set. For every index for which this BitSet contains a bit in the set state, the decimal representation of that index is included in the result. Such indices are listed in order from lowest to highest, separated by ", " (a comma and a space) and surrounded by braces, resulting in the usual mathematical notation for a set of integers. Example:  BitSet drPepper = new BitSet(); Now drPepper.toString() returns " ".  drPepper.set(2); Now drPepper.toString() returns "{2}".  drPepper.set(4); drPepper.set(10); Now drPepper.toString() returns "{2, 4, 10}".
java.util.BitSet.trimToSize	(	): Attempts to reduce internal storage used for the bits in this bit set. Calling this method may, but is not required to, affect the value returned by a subsequent call to the size() method.
java.util.BitSet.valueOf	(	ByteBuffer	): Returns a new bit set containing all the bits in the given byte buffer between its position and limit. More precisely, BitSet.valueOf(bb).get(n) == ((bb.get(bb.position()+n/8) & (1<<(n%8))) != 0) for all n < 8 * bb.remaining(). The byte buffer is not modified by this method, and no reference to the buffer is retained by the bit set.
java.util.BitSet.valueOf	(	LongBuffer	): Returns a new bit set containing all the bits in the given long buffer between its position and limit. More precisely, BitSet.valueOf(lb).get(n) == ((lb.get(lb.position()+n/64) & (1L<<(n%64))) != 0) for all n < 64 * lb.remaining(). The long buffer is not modified by this method, and no reference to the buffer is retained by the bit set.
java.util.BitSet.valueOf	(	byte[]	): Returns a new bit set containing all the bits in the given byte array. More precisely, BitSet.valueOf(bytes).get(n) == ((bytes[n/8] & (1<<(n%8))) != 0) for all n < 8 * bytes.length. This method is equivalent to BitSet.valueOf(ByteBuffer.wrap(bytes)).
java.util.BitSet.valueOf	(	long[]	): Returns a new bit set containing all the bits in the given long array. More precisely, BitSet.valueOf(longs).get(n) == ((longs[n/64] & (1L<<(n%64))) != 0) for all n < 64 * longs.length. This method is equivalent to BitSet.valueOf(LongBuffer.wrap(longs)).
java.util.BitSet.wordIndex	(	int	): Given a bit index, return word index containing it.
java.util.BitSet.writeObject	(	ObjectOutputStream	): Save the state of the BitSet instance to a stream (i.e., serialize it).
java.util.BitSet.xor	(	BitSet	): Performs a logical XOR of this bit set with the bit set argument. This bit set is modified so that a bit in it has the value true if and only if one of the following statements holds:  The bit initially has the value true, and the corresponding bit in the argument has the value false. The bit initially has the value false, and the corresponding bit in the argument has the value true. 
java.util.Calendar: The Calendar class is an abstract class that provides methods for converting between a specific instant in time and a set of fields calendar fields such as YEAR, MONTH, DAY_OF_MONTH, HOUR, and so on, and for manipulating the calendar fields, such as getting the date of the next week. An instant in time can be represented by a millisecond value that is an offset from the Epoch, January 1, 1970 00:00:00.000 GMT (Gregorian). The class also provides additional fields and methods for implementing a concrete calendar system outside the package. Those fields and methods are defined as protected.  Like other locale-sensitive classes, Calendar provides a class method, getInstance, for getting a generally useful object of this type. Calendar's getInstance method returns a Calendar object whose calendar fields have been initialized with the current date and time:   Calendar rightNow = Calendar.getInstance();   A Calendar object can produce all the calendar field values needed to implement the date-time formatting for a particular language and calendar style (for example, Japanese-Gregorian, Japanese-Traditional). Calendar defines the range of values returned by certain calendar fields, as well as their meaning. For example, the first month of the calendar system has value MONTH == JANUARY for all calendars. Other values are defined by the concrete subclass, such as ERA. See individual field documentation and subclass documentation for details. Getting and Setting Calendar Field Values The calendar field values can be set by calling the set methods. Any field values set in a Calendar will not be interpreted until it needs to calculate its time value (milliseconds from the Epoch) or values of the calendar fields. Calling the get, getTimeInMillis, getTime, add and roll involves such calculation. Leniency Calendar has two modes for interpreting the calendar fields, lenient and non-lenient. When a Calendar is in lenient mode, it accepts a wider range of calendar field values than it produces. When a Calendar recomputes calendar field values for return by get(), all of the calendar fields are normalized. For example, a lenient GregorianCalendar interprets MONTH == JANUARY, DAY_OF_MONTH == 32 as February 1. When a Calendar is in non-lenient mode, it throws an exception if there is any inconsistency in its calendar fields. For example, a GregorianCalendar always produces DAY_OF_MONTH values between 1 and the length of the month. A non-lenient GregorianCalendar throws an exception upon calculating its time or calendar field values if any out-of-range field value has been set. First Week Calendar defines a locale-specific seven day week using two parameters: the first day of the week and the minimal days in first week (from 1 to 7). These numbers are taken from the locale resource data when a Calendar is constructed. They may also be specified explicitly through the methods for setting their values. When setting or getting the WEEK_OF_MONTH or WEEK_OF_YEAR fields, Calendar must determine the first week of the month or year as a reference point. The first week of a month or year is defined as the earliest seven day period beginning on getFirstDayOfWeek() and containing at least getMinimalDaysInFirstWeek() days of that month or year. Weeks numbered ..., -1, 0 precede the first week; weeks numbered 2, 3,... follow it. Note that the normalized numbering returned by get() may be different. For example, a specific Calendar subclass may designate the week before week 1 of a year as week n of the previous year. Calendar Fields Resolution When computing a date and time from the calendar fields, there may be insufficient information for the computation (such as only year and month with no day of month), or there may be inconsistent information (such as Tuesday, July 15, 1996 (Gregorian) -- July 15, 1996 is actually a Monday). Calendar will resolve calendar field values to determine the date and time in the following way. If there is any conflict in calendar field values, Calendar gives priorities to calendar fields that have been set more recently. The following are the default combinations of the calendar fields. The most recent combination, as determined by the most recently set single field, will be used. For the date fields:   YEAR + MONTH + DAY_OF_MONTH YEAR + MONTH + WEEK_OF_MONTH + DAY_OF_WEEK YEAR + MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK YEAR + DAY_OF_YEAR YEAR + DAY_OF_WEEK + WEEK_OF_YEAR  For the time of day fields:   HOUR_OF_DAY AM_PM + HOUR  If there are any calendar fields whose values haven't been set in the selected field combination, Calendar uses their default values. The default value of each field may vary by concrete calendar systems. For example, in GregorianCalendar, the default of a field is the same as that of the start of the Epoch: i.e., YEAR = 1970, MONTH = JANUARY, DAY_OF_MONTH = 1, etc.  Note: There are certain possible ambiguities in interpretation of certain singular times, which are resolved in the following ways:   23:59 is the last minute of the day and 00:00 is the first minute of the next day. Thus, 23:59 on Dec 31, 1999 < 00:00 on Jan 1, 2000 < 00:01 on Jan 1, 2000.  Although historically not precise, midnight also belongs to "am", and noon belongs to "pm", so on the same day, 12:00 am (midnight) < 12:01 am, and 12:00 pm (noon) < 12:01 pm   The date or time format strings are not part of the definition of a calendar, as those must be modifiable or overridable by the user at runtime. Use DateFormat to format dates. Field Manipulation The calendar fields can be changed using three methods: set(), add(), and roll(). set(f, value) changes calendar field f to value. In addition, it sets an internal member variable to indicate that calendar field f has been changed. Although calendar field f is changed immediately, the calendar's time value in milliseconds is not recomputed until the next call to get(), getTime(), getTimeInMillis(), add(), or roll() is made. Thus, multiple calls to set() do not trigger multiple, unnecessary computations. As a result of changing a calendar field using set(), other calendar fields may also change, depending on the calendar field, the calendar field value, and the calendar system. In addition, get(f) will not necessarily return value set by the call to the set method after the calendar fields have been recomputed. The specifics are determined by the concrete calendar class. Example: Consider a GregorianCalendar originally set to August 31, 1999. Calling set(Calendar.MONTH, Calendar.SEPTEMBER) sets the date to September 31, 1999. This is a temporary internal representation that resolves to October 1, 1999 if getTime()is then called. However, a call to set(Calendar.DAY_OF_MONTH, 30) before the call to getTime() sets the date to September 30, 1999, since no recomputation occurs after set() itself. add(f, delta) adds delta to field f. This is equivalent to calling set(f, get(f) + delta) with two adjustments:  Add rule 1. The value of field f after the call minus the value of field f before the call is delta, modulo any overflow that has occurred in field f. Overflow occurs when a field value exceeds its range and, as a result, the next larger field is incremented or decremented and the field value is adjusted back into its range. Add rule 2. If a smaller field is expected to be invariant, but it is impossible for it to be equal to its prior value because of changes in its minimum or maximum after field f is changed or other constraints, such as time zone offset changes, then its value is adjusted to be as close as possible to its expected value. A smaller field represents a smaller unit of time. HOUR is a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that are not expected to be invariant. The calendar system determines what fields are expected to be invariant.  In addition, unlike set(), add() forces an immediate recomputation of the calendar's milliseconds and all fields. Example: Consider a GregorianCalendar originally set to August 31, 1999. Calling add(Calendar.MONTH, 13) sets the calendar to September 30, 2000. Add rule 1 sets the MONTH field to September, since adding 13 months to August gives September of the next year. Since DAY_OF_MONTH cannot be 31 in September in a GregorianCalendar, add rule 2 sets the DAY_OF_MONTH to 30, the closest possible value. Although it is a smaller field, DAY_OF_WEEK is not adjusted by rule 2, since it is expected to change when the month changes in a GregorianCalendar. roll(f, delta) adds delta to field f without changing larger fields. This is equivalent to calling add(f, delta) with the following adjustment:  Roll rule. Larger fields are unchanged after the call. A larger field represents a larger unit of time. DAY_OF_MONTH is a larger field than HOUR.  Example: See roll(). Usage model. To motivate the behavior of add() and roll(), consider a user interface component with increment and decrement buttons for the month, day, and year, and an underlying GregorianCalendar. If the interface reads January 31, 1999 and the user presses the month increment button, what should it read? If the underlying implementation uses set(), it might read March 3, 1999. A better result would be February 28, 1999. Furthermore, if the user presses the month increment button again, it should read March 31, 1999, not March 28, 1999. By saving the original date and using either add() or roll(), depending on whether larger fields should be affected, the user interface can behave as most users will intuitively expect.
java.util.Calendar.Builder: Calendar.Builder is used for creating a Calendar from various date-time parameters. There are two ways to set a Calendar to a date-time value. One is to set the instant parameter to a millisecond offset from the Epoch. The other is to set individual field parameters, such as YEAR, to their desired values. These two ways can't be mixed. Trying to set both the instant and individual fields will cause an IllegalStateException to be thrown. However, it is permitted to override previous values of the instant or field parameters. If no enough field parameters are given for determining date and/or time, calendar specific default values are used when building a Calendar. For example, if the YEAR value isn't given for the Gregorian calendar, 1970 will be used. If there are any conflicts among field parameters, the  resolution rules are applied. Therefore, the order of field setting matters. In addition to the date-time parameters, the setLocale() locale, setTimeZone() time zone, setWeekDefinition() week definition, and setLenient() leniency mode parameters can be set. Examples The following are sample usages. Sample code assumes that the Calendar constants are statically imported. The following code produces a Calendar with date 2012-12-31 (Gregorian) because Monday is the first day of a week with the  ISO 8601 compatible week parameters.  Calendar cal = new Calendar.Builder().setCalendarType("iso8601") .setWeekDate(2013, 1, MONDAY).build(); The following code produces a Japanese Calendar with date 1989-01-08 (Gregorian), assuming that the default ERA is Heisei that started on that day.  Calendar cal = new Calendar.Builder().setCalendarType("japanese") .setFields(YEAR, 1, DAY_OF_YEAR, 1).build();
java.util.Calendar.Builder.Builder	(	): Constructs a Calendar.Builder.
java.util.Calendar.Builder.build	(	): Returns a Calendar built from the parameters set by the setter methods. The calendar type given by the setCalendarType() method or the setLocale() locale is used to determine what Calendar to be created. If no explicit calendar type is given, the locale's default calendar is created. If the calendar type is "iso8601", the setGregorianChange() Gregorian change date of a GregorianCalendar is set to Date(Long.MIN_VALUE) to be the proleptic Gregorian calendar. Its week definition parameters are also set to be compatible with the ISO 8601 standard. Note that the getCalendarType() method of a GregorianCalendar created with "iso8601" returns "gregory". The default values are used for locale and time zone if these parameters haven't been given explicitly. Any out of range field values are either normalized in lenient mode or detected as an invalid value in non-lenient mode.
java.util.Calendar.Builder.set	(	int	int	): Sets the field parameter to the given value. field is an index to the fields, such as DAY_OF_MONTH. Field value validation is not performed in this method. Any out of range values are either normalized in lenient mode or detected as an invalid value in non-lenient mode when building a Calendar.
java.util.Calendar.Builder.setCalendarType	(	String	): Sets the calendar type parameter to the given type. The calendar type given by this method has precedence over any explicit or implicit calendar type given by the setLocale() locale. In addition to the available calendar types returned by the getAvailableCalendarTypes() Calendar.getAvailableCalendarTypes method, "gregorian" and "iso8601" as aliases of "gregory" can be used with this method.
java.util.Calendar.Builder.setDate	(	int	int	int	): Sets the date field parameters to the values given by year, month, and dayOfMonth. This method is equivalent to a call to:  setFields(Calendar.YEAR, year, Calendar.MONTH, month, Calendar.DAY_OF_MONTH, dayOfMonth);
java.util.Calendar.Builder.setFields	(	int	): Sets field parameters to their values given by fieldValuePairs that are pairs of a field and its value. For example,  setFeilds(Calendar.YEAR, 2013, Calendar.MONTH, Calendar.DECEMBER, Calendar.DAY_OF_MONTH, 23); is equivalent to the sequence of the following set() calls:  set(Calendar.YEAR, 2013) .set(Calendar.MONTH, Calendar.DECEMBER) .set(Calendar.DAY_OF_MONTH, 23);
java.util.Calendar.Builder.setInstant	(	Date	): Sets the instant parameter to the instant value given by a Date. This method is equivalent to a call to setInstant() setInstant(instant.getTime()).
java.util.Calendar.Builder.setInstant	(	long	): Sets the instant parameter to the given instant value that is a millisecond offset from the Epoch.
java.util.Calendar.Builder.setLenient	(	boolean	): Sets the lenient mode parameter to the value given by lenient. If no lenient parameter is given to this Calendar.Builder, lenient mode will be used in the build() method.
java.util.Calendar.Builder.setLocale	(	Locale	): Sets the locale parameter to the given locale. If no locale is given to this Calendar.Builder, the getDefault() default Locale for FORMAT will be used. If no calendar type is explicitly given by a call to the setCalendarType() method, the Locale value is used to determine what type of Calendar to be built. If no week definition parameters are explicitly given by a call to the setWeekDefinition() method, the Locale's default values are used.
java.util.Calendar.Builder.setTimeOfDay	(	int	int	int	): Sets the time of day field parameters to the values given by hourOfDay, minute, and second. This method is equivalent to a call to:  setTimeOfDay(hourOfDay, minute, second, 0);
java.util.Calendar.Builder.setTimeOfDay	(	int	int	int	int	): Sets the time of day field parameters to the values given by hourOfDay, minute, second, and millis. This method is equivalent to a call to:  setFields(Calendar.HOUR_OF_DAY, hourOfDay, Calendar.MINUTE, minute, Calendar.SECOND, second, Calendar.MILLISECOND, millis);
java.util.Calendar.Builder.setTimeZone	(	TimeZone	): Sets the time zone parameter to the given zone. If no time zone parameter is given to this Caledar.Builder, the getDefault() default TimeZone will be used in the build() method.
java.util.Calendar.Builder.setWeekDate	(	int	int	int	): Sets the week-based date parameters to the values with the given date specifiers - week year, week of year, and day of week. If the specified calendar doesn't support week dates, the build() method will throw an IllegalArgumentException.
java.util.Calendar.Builder.setWeekDefinition	(	int	int	): Sets the week definition parameters to the values given by firstDayOfWeek and minimalDaysInFirstWeek that are used to determine the first week of a year. The parameters given by this method have precedence over the default values given by the setLocale() locale.
java.util.Calendar.Calendar	(	): Constructs a Calendar with the default time zone and the default FORMAT locale.
java.util.Calendar.Calendar	(	TimeZone	Locale	): Constructs a calendar with the specified time zone and locale.
java.util.Calendar.add	(	int	int	): Adds or subtracts the specified amount of time to the given calendar field, based on the calendar's rules. For example, to subtract 5 days from the current time of the calendar, you can achieve it by calling: add(Calendar.DAY_OF_MONTH, -5).
java.util.Calendar.adjustStamp	(	): Adjusts the stamp[] values before nextStamp overflow. nextStamp is set to the next stamp value upon the return.
java.util.Calendar.after	(	Object	): Returns whether this Calendar represents a time after the time represented by the specified Object. This method is equivalent to: compareTo(when) > 0 if and only if when is a Calendar instance. Otherwise, the method returns false.
java.util.Calendar.aggregateStamp	(	int	int	): Returns the pseudo-time-stamp for two fields, given their individual pseudo-time-stamps. If either of the fields is unset, then the aggregate is unset. Otherwise, the aggregate is the later of the two stamps.
java.util.Calendar.before	(	Object	): Returns whether this Calendar represents a time before the time represented by the specified Object. This method is equivalent to: compareTo(when) < 0 if and only if when is a Calendar instance. Otherwise, the method returns false.
java.util.Calendar.clear	(	): Sets all the calendar field values and the time value (millisecond offset from the Epoch) of this Calendar undefined. This means that isSet() isSet() will return false for all the calendar fields, and the date and time calculations will treat the fields as if they had never been set. A Calendar implementation class may use its specific default field values for date/time calculations. For example, GregorianCalendar uses 1970 if the YEAR field value is undefined.
java.util.Calendar.clear	(	int	): Sets the given calendar field value and the time value (millisecond offset from the Epoch) of this Calendar undefined. This means that isSet() isSet(field) will return false, and the date and time calculations will treat the field as if it had never been set. A Calendar implementation class may use the field's specific default value for date and time calculations. The HOUR_OF_DAY, HOUR and AM_PM fields are handled independently and the the resolution rule for the time of day is applied. Clearing one of the fields doesn't reset the hour of day value of this Calendar. Use set() set(Calendar.HOUR_OF_DAY, 0) to reset the hour value.
java.util.Calendar.clone	(	): Creates and returns a copy of this object.
java.util.Calendar.compareTo	(	Calendar	): Compares the time values (millisecond offsets from the Epoch) represented by two Calendar objects.
java.util.Calendar.complete	(	): Fills in any unset fields in the calendar fields. First, the computeTime() method is called if the time value (millisecond offset from the Epoch) has not been calculated from calendar field values. Then, the computeFields() method is called to calculate all calendar field values.
java.util.Calendar.computeFields	(	): Converts the current millisecond time value time to calendar field values in fields fields[]. This allows you to sync up the calendar field values with a new time that is set for the calendar. The time is not recomputed first; to recompute the time, then the fields, call the complete() method.
java.util.Calendar.computeTime	(	): Converts the current calendar field values in fields fields[] to the millisecond time value time.
java.util.Calendar.equals	(	Object	): Compares this Calendar to the specified Object. The result is true if and only if the argument is a Calendar object of the same calendar system that represents the same time value (millisecond offset from the Epoch) under the same Calendar parameters as this object. The Calendar parameters are the values represented by the isLenient, getFirstDayOfWeek, getMinimalDaysInFirstWeek and getTimeZone methods. If there is any difference in those parameters between the two Calendars, this method returns false. Use the compareTo() method to compare only the time values.
java.util.Calendar.get	(	int	): Returns the value of the given calendar field. In lenient mode, all calendar fields are normalized. In non-lenient mode, all calendar fields are validated and this method throws an exception if any calendar fields have out-of-range values. The normalization and validation are handled by the complete() method, which process is calendar system dependent.
java.util.Calendar.getActualMaximum	(	int	): Returns the maximum value that the specified calendar field could have, given the time value of this Calendar. For example, the actual maximum value of the MONTH field is 12 in some years, and 13 in other years in the Hebrew calendar system. The default implementation of this method uses an iterative algorithm to determine the actual maximum value for the calendar field. Subclasses should, if possible, override this with a more efficient implementation.
java.util.Calendar.getActualMinimum	(	int	): Returns the minimum value that the specified calendar field could have, given the time value of this Calendar. The default implementation of this method uses an iterative algorithm to determine the actual minimum value for the calendar field. Subclasses should, if possible, override this with a more efficient implementation - in many cases, they can simply return getMinimum().
java.util.Calendar.getAvailableCalendarTypes	(	): Returns an unmodifiable Set containing all calendar types supported by Calendar in the runtime environment. The available calendar types can be used for the Unicode locale extensions. The Set returned contains at least "gregory". The calendar types don't include aliases, such as "gregorian" for "gregory".
java.util.Calendar.getAvailableLocales	(	): Returns an array of all locales for which the getInstance methods of this class can return localized instances. The array returned must contain at least a Locale instance equal to US Locale.US.
java.util.Calendar.getCalendarType	(	): Returns the calendar type of this Calendar. Calendar types are defined by the Unicode Locale Data Markup Language (LDML) specification. The default implementation of this method returns the class name of this Calendar instance. Any subclasses that implement LDML-defined calendar systems should override this method to return appropriate calendar types.
java.util.Calendar.getDisplayName	(	int	int	Locale	): Returns the string representation of the calendar field value in the given style and locale. If no string representation is applicable, null is returned. This method calls get() get(field) to get the calendar field value if the string representation is applicable to the given calendar field. For example, if this Calendar is a GregorianCalendar and its date is 2005-01-01, then the string representation of the MONTH field would be "January" in the long style in an English locale or "Jan" in the short style. However, no string representation would be available for the DAY_OF_MONTH field, and this method would return null. The default implementation supports the calendar fields for which a DateFormatSymbols has names in the given locale.
java.util.Calendar.getDisplayNames	(	int	int	Locale	): Returns a Map containing all names of the calendar field in the given style and locale and their corresponding field values. For example, if this Calendar is a GregorianCalendar, the returned map would contain "Jan" to JANUARY, "Feb" to FEBRUARY, and so on, in the SHORT short style in an English locale. Narrow names may not be unique due to use of single characters, such as "S" for Sunday and Saturday. In that case narrow names are not included in the returned Map. The values of other calendar fields may be taken into account to determine a set of display names. For example, if this Calendar is a lunisolar calendar system and the year value given by the YEAR field has a leap month, this method would return month names containing the leap month name, and month names are mapped to their values specific for the year. The default implementation supports display names contained in a DateFormatSymbols. For example, if field is MONTH and style is ALL_STYLES, this method returns a Map containing all strings returned by getShortMonths() and getMonths().
java.util.Calendar.getFieldName	(	int	): Returns the name of the specified calendar field.
java.util.Calendar.getFirstDayOfWeek	(	): Gets what the first day of the week is; e.g., SUNDAY in the U.S., MONDAY in France.
java.util.Calendar.getGreatestMinimum	(	int	): Returns the highest minimum value for the given calendar field of this Calendar instance. The highest minimum value is defined as the largest value returned by getActualMinimum() for any possible time value. The greatest minimum value depends on calendar system specific parameters of the instance.
java.util.Calendar.getInstance	(	): Gets a calendar using the default time zone and locale. The Calendar returned is based on the current time in the default time zone with the default FORMAT locale.
java.util.Calendar.getInstance	(	Locale	): Gets a calendar using the default time zone and specified locale. The Calendar returned is based on the current time in the default time zone with the given locale.
java.util.Calendar.getInstance	(	TimeZone	): Gets a calendar using the specified time zone and default locale. The Calendar returned is based on the current time in the given time zone with the default FORMAT locale.
java.util.Calendar.getInstance	(	TimeZone	Locale	): Gets a calendar with the specified time zone and locale. The Calendar returned is based on the current time in the given time zone with the given locale.
java.util.Calendar.getLeastMaximum	(	int	): Returns the lowest maximum value for the given calendar field of this Calendar instance. The lowest maximum value is defined as the smallest value returned by getActualMaximum() for any possible time value. The least maximum value depends on calendar system specific parameters of the instance. For example, a Calendar for the Gregorian calendar system returns 28 for the DAY_OF_MONTH field, because the 28th is the last day of the shortest month of this calendar, February in a common year.
java.util.Calendar.getMaximum	(	int	): Returns the maximum value for the given calendar field of this Calendar instance. The maximum value is defined as the largest value returned by the get() method for any possible time value. The maximum value depends on calendar system specific parameters of the instance.
java.util.Calendar.getMinimalDaysInFirstWeek	(	): Gets what the minimal days required in the first week of the year are; e.g., if the first week is defined as one that contains the first day of the first month of a year, this method returns 1. If the minimal days required must be a full week, this method returns 7.
java.util.Calendar.getMinimum	(	int	): Returns the minimum value for the given calendar field of this Calendar instance. The minimum value is defined as the smallest value returned by the get() method for any possible time value. The minimum value depends on calendar system specific parameters of the instance.
java.util.Calendar.getSetStateFields	(	): Returns a field mask (bit mask) indicating all calendar fields that have the state of externally or internally set.
java.util.Calendar.getTime	(	): Returns a Date object representing this Calendar's time value (millisecond offset from the Epoch").
java.util.Calendar.getTimeInMillis	(	): Returns this Calendar's time value in milliseconds.
java.util.Calendar.getTimeZone	(	): Gets the time zone.
java.util.Calendar.getWeekYear	(	): Returns the week year represented by this Calendar. The week year is in sync with the week cycle. The getFirstDayOfWeek() first day of the first week is the first day of the week year. The default implementation of this method throws an UnsupportedOperationException.
java.util.Calendar.getWeeksInWeekYear	(	): Returns the number of weeks in the week year represented by this Calendar. The default implementation of this method throws an UnsupportedOperationException.
java.util.Calendar.getZone	(	): Returns the time zone (without cloning).
java.util.Calendar.hashCode	(	): Returns a hash code for this calendar.
java.util.Calendar.internalGet	(	int	): Returns the value of the given calendar field. This method does not involve normalization or validation of the field value.
java.util.Calendar.internalSet	(	int	int	): Sets the value of the given calendar field. This method does not affect any setting state of the field in this Calendar instance.
java.util.Calendar.invalidateWeekFields	(	): Sets the WEEK_OF_MONTH and WEEK_OF_YEAR fields to new values with the new parameter value if they have been calculated internally.
java.util.Calendar.isExternallySet	(	int	): Returns whether the value of the specified calendar field has been set externally by calling one of the setter methods rather than by the internal time calculation.
java.util.Calendar.isFieldSet	(	int	int	): Returns whether the specified field is on in the fieldMask.
java.util.Calendar.isFullyNormalized	(	): Returns whether the calendar fields are fully in sync with the time value.
java.util.Calendar.isLenient	(	): Tells whether date/time interpretation is to be lenient.
java.util.Calendar.isPartiallyNormalized	(	): Returns whether the calendar fields are partially in sync with the time value or fully in sync but not stamp values are not normalized yet.
java.util.Calendar.isSet	(	int	): Determines if the given calendar field has a value set, including cases that the value has been set by internal fields calculations triggered by a get method call.
java.util.Calendar.isWeekDateSupported	(	): Returns whether this Calendar supports week dates. The default implementation of this method returns false.
java.util.Calendar.readObject	(	ObjectInputStream	): Reconstitutes this object from a stream (i.e., deserialize it).
java.util.Calendar.roll	(	int	boolean	): Adds or subtracts (up/down) a single unit of time on the given time field without changing larger fields. For example, to roll the current date up by one day, you can achieve it by calling: roll(Calendar.DATE, true). When rolling on the year or Calendar.YEAR field, it will roll the year value in the range between 1 and the value returned by calling getMaximum(Calendar.YEAR). When rolling on the month or Calendar.MONTH field, other fields like date might conflict and, need to be changed. For instance, rolling the month on the date 01/31/96 will result in 02/29/96. When rolling on the hour-in-day or Calendar.HOUR_OF_DAY field, it will roll the hour value in the range between 0 and 23, which is zero-based.
java.util.Calendar.roll	(	int	int	): Adds the specified (signed) amount to the specified calendar field without changing larger fields. A negative amount means to roll down. NOTE: This default implementation on Calendar just repeatedly calls the version of roll() roll() that rolls by one unit. This may not always do the right thing. For example, if the DAY_OF_MONTH field is 31, rolling through February will leave it set to 28. The GregorianCalendar version of this function takes care of this problem. Other subclasses should also provide overrides of this function that do the right thing.
java.util.Calendar.selectFields	(	): Returns a field mask indicating which calendar field values to be used to calculate the time value. The calendar fields are returned as a bit mask, each bit of which corresponds to a field, i.e., the mask value of field is (1 << field). For example, 0x26 represents the YEAR, MONTH, and DAY_OF_MONTH fields (i.e., 0x26 is equal to (1<<YEAR)|(1<<MONTH)|(1<<DAY_OF_MONTH)). This method supports the calendar fields resolution as described in the class description. If the bit mask for a given field is on and its field has not been set (i.e., isSet(field) is false), then the default value of the field has to be used, which case means that the field has been selected because the selected combination involves the field.
java.util.Calendar.set	(	int	int	): Sets the given calendar field to the given value. The value is not interpreted by this method regardless of the leniency mode.
java.util.Calendar.set	(	int	int	int	): Sets the values for the calendar fields YEAR, MONTH, and DAY_OF_MONTH. Previous values of other calendar fields are retained. If this is not desired, call clear() first.
java.util.Calendar.set	(	int	int	int	int	int	): Sets the values for the calendar fields YEAR, MONTH, DAY_OF_MONTH, HOUR_OF_DAY, and MINUTE. Previous values of other fields are retained. If this is not desired, call clear() first.
java.util.Calendar.set	(	int	int	int	int	int	int	): Sets the values for the fields YEAR, MONTH, DAY_OF_MONTH, HOUR_OF_DAY, MINUTE, and SECOND. Previous values of other fields are retained. If this is not desired, call clear() first.
java.util.Calendar.setFieldsComputed	(	int	): Sets the state of the specified calendar fields to computed. This state means that the specified calendar fields have valid values that have been set by internal time calculation rather than by calling one of the setter methods.
java.util.Calendar.setFieldsNormalized	(	int	): Sets the state of the calendar fields that are not specified by fieldMask to unset. If fieldMask specifies all the calendar fields, then the state of this Calendar becomes that all the calendar fields are in sync with the time value (millisecond offset from the Epoch).
java.util.Calendar.setFirstDayOfWeek	(	int	): Sets what the first day of the week is; e.g., SUNDAY in the U.S., MONDAY in France.
java.util.Calendar.setLenient	(	boolean	): Specifies whether or not date/time interpretation is to be lenient. With lenient interpretation, a date such as "February 942, 1996" will be treated as being equivalent to the 941st day after February 1, 1996. With strict (non-lenient) interpretation, such dates will cause an exception to be thrown. The default is lenient.
java.util.Calendar.setMinimalDaysInFirstWeek	(	int	): Sets what the minimal days required in the first week of the year are; For example, if the first week is defined as one that contains the first day of the first month of a year, call this method with value 1. If it must be a full week, use value 7.
java.util.Calendar.setTime	(	Date	): Sets this Calendar's time with the given Date.  Note: Calling setTime() with Date(Long.MAX_VALUE) or Date(Long.MIN_VALUE) may yield incorrect field values from get().
java.util.Calendar.setTimeInMillis	(	long	): Sets this Calendar's current time from the given long value.
java.util.Calendar.setTimeZone	(	TimeZone	): Sets the time zone with the given time zone value.
java.util.Calendar.setUnnormalized	(	): Marks this Calendar as not sync'd.
java.util.Calendar.setWeekCountData	(	Locale	): Both firstDayOfWeek and minimalDaysInFirstWeek are locale-dependent. They are used to figure out the week count for a specific date for a given locale. These must be set when a Calendar is constructed.
java.util.Calendar.setWeekDate	(	int	int	int	): Sets the date of this Calendar with the the given date specifiers - week year, week of year, and day of week. Unlike the set method, all of the calendar fields and time values are calculated upon return. If weekOfYear is out of the valid week-of-year range in weekYear, the weekYear and weekOfYear values are adjusted in lenient mode, or an IllegalArgumentException is thrown in non-lenient mode. The default implementation of this method throws an UnsupportedOperationException.
java.util.Calendar.setZoneShared	(	boolean	): Sets the sharedZone flag to shared.
java.util.Calendar.toInstant	(	): Converts this object to an Instant.  The conversion creates an Instant that represents the same point on the time-line as this Calendar.
java.util.Calendar.toString	(	): Return a string representation of this calendar. This method is intended to be used only for debugging purposes, and the format of the returned string may vary between implementations. The returned string may be empty but may not be null.
java.util.Calendar.updateTime	(	): Recomputes the time and updates the status fields isTimeSet and areFieldsSet. Callers should check isTimeSet and only call this method if isTimeSet is false.
java.util.Calendar.writeObject	(	ObjectOutputStream	): Save the state of this object to a stream (i.e., serialize it). Ideally, Calendar would only write out its state data and the current time, and not write any field data out, such as fields[], isTimeSet, areFieldsSet, and isSet[]. nextStamp also should not be part of the persistent state. Unfortunately, this didn't happen before JDK 1.1 shipped. To be compatible with JDK 1.1, we will always have to write out the field values and state flags. However, nextStamp can be removed from the serialization stream; this will probably happen in the near future.
java.util.Collection: The root interface in the collection hierarchy. A collection represents a group of objects, known as its elements. Some collections allow duplicate elements and others do not. Some are ordered and others unordered. The JDK does not provide any direct implementations of this interface: it provides implementations of more specific subinterfaces like Set and List. This interface is typically used to pass collections around and manipulate them where maximum generality is desired. Bags or multisets (unordered collections that may contain duplicate elements) should implement this interface directly. All general-purpose Collection implementation classes (which typically implement Collection indirectly through one of its subinterfaces) should provide two "standard" constructors: a void (no arguments) constructor, which creates an empty collection, and a constructor with a single argument of type Collection, which creates a new collection with the same elements as its argument. In effect, the latter constructor allows the user to copy any collection, producing an equivalent collection of the desired implementation type. There is no way to enforce this convention (as interfaces cannot contain constructors) but all of the general-purpose Collection implementations in the Java platform libraries comply. The "destructive" methods contained in this interface, that is, the methods that modify the collection on which they operate, are specified to throw UnsupportedOperationException if this collection does not support the operation. If this is the case, these methods may, but are not required to, throw an UnsupportedOperationException if the invocation would have no effect on the collection. For example, invoking the addAll() method on an unmodifiable collection may, but is not required to, throw the exception if the collection to be added is empty.  Some collection implementations have restrictions on the elements that they may contain. For example, some implementations prohibit null elements, and some have restrictions on the types of their elements. Attempting to add an ineligible element throws an unchecked exception, typically NullPointerException or ClassCastException. Attempting to query the presence of an ineligible element may throw an exception, or it may simply return false; some implementations will exhibit the former behavior and some will exhibit the latter. More generally, attempting an operation on an ineligible element whose completion would not result in the insertion of an ineligible element into the collection may throw an exception or it may succeed, at the option of the implementation. Such exceptions are marked as "optional" in the specification for this interface. It is up to each collection to determine its own synchronization policy. In the absence of a stronger guarantee by the implementation, undefined behavior may result from the invocation of any method on a collection that is being mutated by another thread; this includes direct invocations, passing the collection to a method that might perform invocations, and using an existing iterator to examine the collection. Many methods in Collections Framework interfaces are defined in terms of the equals() method. For example, the specification for the contains() contains(Object o) method says: "returns true if and only if this collection contains at least one element e such that (o==null ? e==null : o.equals(e))." This specification should not be construed to imply that invoking Collection.contains with a non-null argument o will cause o.equals(e) to be invoked for any element e. Implementations are free to implement optimizations whereby the equals invocation is avoided, for example, by first comparing the hash codes of the two elements. (The hashCode() specification guarantees that two objects with unequal hash codes cannot be equal.) More generally, implementations of the various Collections Framework interfaces are free to take advantage of the specified behavior of underlying Object methods wherever the implementor deems it appropriate. Some collection operations which perform recursive traversal of the collection may fail with an exception for self-referential instances where the collection directly or indirectly contains itself. This includes the clone(), equals(), hashCode() and toString() methods. Implementations may optionally handle the self-referential scenario, however most current implementations do not do so. This interface is a member of the  Java Collections Framework.
java.util.Collection.add	(	E	): Ensures that this collection contains the specified element (optional operation). Returns true if this collection changed as a result of the call. (Returns false if this collection does not permit duplicates and already contains the specified element.) Collections that support this operation may place limitations on what elements may be added to this collection. In particular, some collections will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. Collection classes should clearly specify in their documentation any restrictions on what elements may be added. If a collection refuses to add a particular element for any reason other than that it already contains the element, it must throw an exception (rather than returning false). This preserves the invariant that a collection always contains the specified element after this call returns.
java.util.Collection.addAll	(	Collection	): Adds all of the elements in the specified collection to this collection (optional operation). The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (This implies that the behavior of this call is undefined if the specified collection is this collection, and this collection is nonempty.)
java.util.Collection.clear	(	): Removes all of the elements from this collection (optional operation). The collection will be empty after this method returns.
java.util.Collection.contains	(	Object	): Returns true if this collection contains the specified element. More formally, returns true if and only if this collection contains at least one element e such that (o==null ? e==null : o.equals(e)).
java.util.Collection.containsAll	(	Collection	): Returns true if this collection contains all of the elements in the specified collection.
java.util.Collection.equals	(	Object	): Compares the specified object with this collection for equality.  While the Collection interface adds no stipulations to the general contract for the Object.equals, programmers who implement the Collection interface "directly" (in other words, create a class that is a Collection but is not a Set or a List) must exercise care if they choose to override the Object.equals. It is not necessary to do so, and the simplest course of action is to rely on Object's implementation, but the implementor may wish to implement a "value comparison" in place of the default "reference comparison." (The List and Set interfaces mandate such value comparisons.) The general contract for the Object.equals method states that equals must be symmetric (in other words, a.equals(b) if and only if b.equals(a)). The contracts for List.equals and Set.equals state that lists are only equal to other lists, and sets to other sets. Thus, a custom equals method for a collection class that implements neither the List nor Set interface must return false when this collection is compared to any list or set. (By the same logic, it is not possible to write a class that correctly implements both the Set and List interfaces.)
java.util.Collection.hashCode	(	): Returns the hash code value for this collection. While the Collection interface adds no stipulations to the general contract for the Object.hashCode method, programmers should take note that any class that overrides the Object.equals method must also override the Object.hashCode method in order to satisfy the general contract for the Object.hashCode method. In particular, c1.equals(c2) implies that c1.hashCode()==c2.hashCode().
java.util.Collection.isEmpty	(	): Returns true if this collection contains no elements.
java.util.Collection.iterator	(	): Returns an iterator over the elements in this collection. There are no guarantees concerning the order in which the elements are returned (unless this collection is an instance of some class that provides a guarantee).
java.util.Collection.parallelStream	(	): Returns a possibly parallel Stream with this collection as its source. It is allowable for this method to return a sequential stream. This method should be overridden when the spliterator() method cannot return a spliterator that is IMMUTABLE, CONCURRENT, or late-binding. (See spliterator() for details.)
java.util.Collection.remove	(	Object	): Removes a single instance of the specified element from this collection, if it is present (optional operation). More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this collection contains one or more such elements. Returns true if this collection contained the specified element (or equivalently, if this collection changed as a result of the call).
java.util.Collection.removeAll	(	Collection	): Removes all of this collection's elements that are also contained in the specified collection (optional operation). After this call returns, this collection will contain no elements in common with the specified collection.
java.util.Collection.removeIf	(	Predicate	): Removes all of the elements of this collection that satisfy the given predicate. Errors or runtime exceptions thrown during iteration or by the predicate are relayed to the caller.
java.util.Collection.retainAll	(	Collection	): Retains only the elements in this collection that are contained in the specified collection (optional operation). In other words, removes from this collection all of its elements that are not contained in the specified collection.
java.util.Collection.size	(	): Returns the number of elements in this collection. If this collection contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
java.util.Collection.spliterator	(	): Creates a Spliterator over the elements in this collection. Implementations should document characteristic values reported by the spliterator. Such characteristic values are not required to be reported if the spliterator reports SIZED and this collection contains no elements. The default implementation should be overridden by subclasses that can return a more efficient spliterator. In order to preserve expected laziness behavior for the stream() and parallelStream()} methods, spliterators should either have the characteristic of IMMUTABLE or CONCURRENT, or be late-binding. If none of these is practical, the overriding class should describe the spliterator's documented policy of binding and structural interference, and should override the stream() and parallelStream() methods to create streams using a Supplier of the spliterator, as in: Stream s = StreamSupport.stream(() -> spliterator(), spliteratorCharacteristics) These requirements ensure that streams produced by the stream() and parallelStream() methods will reflect the contents of the collection as of initiation of the terminal stream operation.
java.util.Collection.stream	(	): Returns a sequential Stream with this collection as its source. This method should be overridden when the spliterator() method cannot return a spliterator that is IMMUTABLE, CONCURRENT, or late-binding. (See spliterator() for details.)
java.util.Collection.toArray	(	): Returns an array containing all of the elements in this collection. If this collection makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. The returned array will be "safe" in that no references to it are maintained by this collection. (In other words, this method must allocate a new array even if this collection is backed by an array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.Collection.toArray	(	T[]	): Returns an array containing all of the elements in this collection; the runtime type of the returned array is that of the specified array. If the collection fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this collection. If this collection fits in the specified array with room to spare (i.e., the array has more elements than this collection), the element in the array immediately following the end of the collection is set to null. (This is useful in determining the length of this collection only if the caller knows that this collection does not contain any null elements.) If this collection makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a collection known to contain only strings. The following code can be used to dump the collection into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.Collections: This class consists exclusively of static methods that operate on or return collections. It contains polymorphic algorithms that operate on collections, "wrappers", which return a new collection backed by a specified collection, and a few other odds and ends. The methods of this class all throw a NullPointerException if the collections or class objects provided to them are null. The documentation for the polymorphic algorithms contained in this class generally includes a brief description of the implementation. Such descriptions should be regarded as implementation notes, rather than parts of the specification. Implementors should feel free to substitute other algorithms, so long as the specification itself is adhered to. (For example, the algorithm used by sort does not have to be a mergesort, but it does have to be stable.) The "destructive" algorithms contained in this class, that is, the algorithms that modify the collection on which they operate, are specified to throw UnsupportedOperationException if the collection does not support the appropriate mutation primitive(s), such as the set method. These algorithms may, but are not required to, throw this exception if an invocation would have no effect on the collection. For example, invoking the sort method on an unmodifiable list that is already sorted may or may not throw UnsupportedOperationException. This class is a member of the  Java Collections Framework.
java.util.Collections.CheckedList.replaceAll	(	UnaryOperator	): Replaces each element of this list with the result of applying the operator to that element. Errors or runtime exceptions thrown by the operator are relayed to the caller.
java.util.Collections.CheckedMap.CheckedEntrySet: We need this class in addition to CheckedSet as Map.Entry permits modification of the backing Map via the setValue operation. This class is subtle: there are many possible attacks that must be thwarted.
java.util.Collections.CheckedMap.CheckedEntrySet.CheckedEntry: This "wrapper class" serves two purposes: it prevents the client from modifying the backing Map, by short-circuiting the setValue method, and it protects the backing Map against an ill-behaved Map.Entry that attempts to modify another Map.Entry when asked to perform an equality check.
java.util.Collections.CheckedMap.CheckedEntrySet.contains	(	Object	): This method is overridden to protect the backing set against an object with a nefarious equals function that senses that the equality-candidate is Map.Entry and calls its setValue method.
java.util.Collections.CheckedMap.CheckedEntrySet.containsAll	(	Collection	): The bulk collection methods are overridden to protect against an unscrupulous collection whose contains(Object o) method senses when o is a Map.Entry, and calls o.setValue.
java.util.Collections.SynchronizedList.readResolve	(	): SynchronizedRandomAccessList instances are serialized as SynchronizedList instances to allow them to be deserialized in pre-1.4 JREs (which do not have SynchronizedRandomAccessList). This method inverts the transformation. As a beneficial side-effect, it also grafts the RandomAccess marker onto SynchronizedList instances that were serialized in pre-1.4 JREs. Note: Unfortunately, SynchronizedRandomAccessList instances serialized in 1.4.1 and deserialized in 1.4 will become SynchronizedList instances, as this method was missing in 1.4.
java.util.Collections.SynchronizedNavigableMap: A synchronized NavigableMap.
java.util.Collections.SynchronizedRandomAccessList.writeReplace	(	): Allows instances to be deserialized in pre-1.4 JREs (which do not have SynchronizedRandomAccessList). SynchronizedList has a readResolve method that inverts this transformation upon deserialization.
java.util.Collections.UnmodifiableList.readResolve	(	): UnmodifiableRandomAccessList instances are serialized as UnmodifiableList instances to allow them to be deserialized in pre-1.4 JREs (which do not have UnmodifiableRandomAccessList). This method inverts the transformation. As a beneficial side-effect, it also grafts the RandomAccess marker onto UnmodifiableList instances that were serialized in pre-1.4 JREs. Note: Unfortunately, UnmodifiableRandomAccessList instances serialized in 1.4.1 and deserialized in 1.4 will become UnmodifiableList instances, as this method was missing in 1.4.
java.util.Collections.UnmodifiableMap.UnmodifiableEntrySet: We need this class in addition to UnmodifiableSet as Map.Entries themselves permit modification of the backing Map via their setValue operation. This class is subtle: there are many possible attacks that must be thwarted.
java.util.Collections.UnmodifiableMap.UnmodifiableEntrySet.UnmodifiableEntry: This "wrapper class" serves two purposes: it prevents the client from modifying the backing Map, by short-circuiting the setValue method, and it protects the backing Map against an ill-behaved Map.Entry that attempts to modify another Map Entry when asked to perform an equality check.
java.util.Collections.UnmodifiableMap.UnmodifiableEntrySet.contains	(	Object	): This method is overridden to protect the backing set against an object with a nefarious equals function that senses that the equality-candidate is Map.Entry and calls its setValue method.
java.util.Collections.UnmodifiableMap.UnmodifiableEntrySet.containsAll	(	Collection	): The next two methods are overridden to protect against an unscrupulous List whose contains(Object o) method senses when o is a Map.Entry, and calls o.setValue.
java.util.Collections.UnmodifiableNavigableMap.EmptyNavigableMap: A class for the EMPTY_NAVIGABLE_MAP which needs readResolve to preserve singleton property.
java.util.Collections.UnmodifiableNavigableSet: Wraps a navigable set and disables all of the mutative operations.
java.util.Collections.UnmodifiableNavigableSet.EmptyNavigableSet: A singleton empty unmodifiable navigable set used for emptyNavigableSet().
java.util.Collections.UnmodifiableRandomAccessList.writeReplace	(	): Allows instances to be deserialized in pre-1.4 JREs (which do not have UnmodifiableRandomAccessList). UnmodifiableList has a readResolve method that inverts this transformation upon deserialization.
java.util.Collections.addAll	(	Collection	T	): Adds all of the specified elements to the specified collection. Elements to be added may be specified individually or as an array. The behavior of this convenience method is identical to that of c.addAll(Arrays.asList(elements)), but this method is likely to run significantly faster under most implementations. When elements are specified individually, this method provides a convenient way to add a few elements to an existing collection:  Collections.addAll(flavors, "Peaches 'n Plutonium", "Rocky Racoon"); 
java.util.Collections.asLifoQueue	(	Deque	): Returns a view of a Deque as a Last-in-first-out (Lifo) Queue. Method add is mapped to push, remove is mapped to pop and so on. This view can be useful when you would like to use a method requiring a Queue but you need Lifo ordering. Each method invocation on the queue returned by this method results in exactly one method invocation on the backing deque, with one exception. The addAll method is implemented as a sequence of addFirst invocations on the backing deque.
java.util.Collections.binarySearch	(	List	T	): Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the Comparable natural ordering of its elements (as by the sort() method) prior to making this call. If it is not sorted, the results are undefined. If the list contains multiple elements equal to the specified object, there is no guarantee which one will be found. This method runs in log(n) time for a "random access" list (which provides near-constant-time positional access). If the specified list does not implement the RandomAccess interface and is large, this method will do an iterator-based binary search that performs O(n) link traversals and O(log n) element comparisons.
java.util.Collections.binarySearch	(	List	T	Comparator	): Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the specified comparator (as by the sort() sort(List, Comparator) method), prior to making this call. If it is not sorted, the results are undefined. If the list contains multiple elements equal to the specified object, there is no guarantee which one will be found. This method runs in log(n) time for a "random access" list (which provides near-constant-time positional access). If the specified list does not implement the RandomAccess interface and is large, this method will do an iterator-based binary search that performs O(n) link traversals and O(log n) element comparisons.
java.util.Collections.checkedCollection	(	Collection	Class	): Returns a dynamically typesafe view of the specified collection. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a collection contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the collection takes place through the view, it is guaranteed that the collection cannot contain an incorrectly typed element. The generics mechanism in the language provides compile-time (static) type checking, but it is possible to defeat this mechanism with unchecked casts. Usually this is not a problem, as the compiler issues warnings on all such unchecked operations. There are, however, times when static type checking alone is not sufficient. For example, suppose a collection is passed to a third-party library and it is imperative that the library code not corrupt the collection by inserting an element of the wrong type. Another use of dynamically typesafe views is debugging. Suppose a program fails with a ClassCastException, indicating that an incorrectly typed element was put into a parameterized collection. Unfortunately, the exception can occur at any time after the erroneous element is inserted, so it typically provides little or no information as to the real source of the problem. If the problem is reproducible, one can quickly determine its source by temporarily modifying the program to wrap the collection with a dynamically typesafe view. For example, this declaration:  Collection c = new HashSet<>(); may be replaced temporarily by this one:  Collection c = Collections.checkedCollection( new HashSet<>(), String.class); Running the program again will cause it to fail at the point where an incorrectly typed element is inserted into the collection, clearly identifying the source of the problem. Once the problem is fixed, the modified declaration may be reverted back to the original. The returned collection does not pass the hashCode and equals operations through to the backing collection, but relies on Object's equals and hashCode methods. This is necessary to preserve the contracts of these operations in the case that the backing collection is a set or a list. The returned collection will be serializable if the specified collection is serializable. Since null is considered to be a value of any reference type, the returned collection permits insertion of null elements whenever the backing collection does.
java.util.Collections.checkedList	(	List	Class	): Returns a dynamically typesafe view of the specified list. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a list contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the list takes place through the view, it is guaranteed that the list cannot contain an incorrectly typed element. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned list will be serializable if the specified list is serializable. Since null is considered to be a value of any reference type, the returned list permits insertion of null elements whenever the backing list does.
java.util.Collections.checkedMap	(	Map	Class	Class	): Returns a dynamically typesafe view of the specified map. Any attempt to insert a mapping whose key or value have the wrong type will result in an immediate ClassCastException. Similarly, any attempt to modify the value currently associated with a key will result in an immediate ClassCastException, whether the modification is attempted directly through the map itself, or through a Map.Entry instance obtained from the map's entrySet() entry set view. Assuming a map contains no incorrectly typed keys or values prior to the time a dynamically typesafe view is generated, and that all subsequent access to the map takes place through the view (or one of its collection views), it is guaranteed that the map cannot contain an incorrectly typed key or value. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned map will be serializable if the specified map is serializable. Since null is considered to be a value of any reference type, the returned map permits insertion of null keys or values whenever the backing map does.
java.util.Collections.checkedNavigableMap	(	NavigableMap	Class	Class	): Returns a dynamically typesafe view of the specified navigable map. Any attempt to insert a mapping whose key or value have the wrong type will result in an immediate ClassCastException. Similarly, any attempt to modify the value currently associated with a key will result in an immediate ClassCastException, whether the modification is attempted directly through the map itself, or through a Map.Entry instance obtained from the map's entrySet() entry set view. Assuming a map contains no incorrectly typed keys or values prior to the time a dynamically typesafe view is generated, and that all subsequent access to the map takes place through the view (or one of its collection views), it is guaranteed that the map cannot contain an incorrectly typed key or value. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned map will be serializable if the specified map is serializable. Since null is considered to be a value of any reference type, the returned map permits insertion of null keys or values whenever the backing map does.
java.util.Collections.checkedNavigableSet	(	NavigableSet	Class	): Returns a dynamically typesafe view of the specified navigable set. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a navigable set contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the navigable set takes place through the view, it is guaranteed that the navigable set cannot contain an incorrectly typed element. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned navigable set will be serializable if the specified navigable set is serializable. Since null is considered to be a value of any reference type, the returned navigable set permits insertion of null elements whenever the backing sorted set does.
java.util.Collections.checkedQueue	(	Queue	Class	): Returns a dynamically typesafe view of the specified queue. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a queue contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the queue takes place through the view, it is guaranteed that the queue cannot contain an incorrectly typed element. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned queue will be serializable if the specified queue is serializable. Since null is considered to be a value of any reference type, the returned queue permits insertion of null elements whenever the backing queue does.
java.util.Collections.checkedSet	(	Set	Class	): Returns a dynamically typesafe view of the specified set. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a set contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the set takes place through the view, it is guaranteed that the set cannot contain an incorrectly typed element. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned set will be serializable if the specified set is serializable. Since null is considered to be a value of any reference type, the returned set permits insertion of null elements whenever the backing set does.
java.util.Collections.checkedSortedMap	(	SortedMap	Class	Class	): Returns a dynamically typesafe view of the specified sorted map. Any attempt to insert a mapping whose key or value have the wrong type will result in an immediate ClassCastException. Similarly, any attempt to modify the value currently associated with a key will result in an immediate ClassCastException, whether the modification is attempted directly through the map itself, or through a Map.Entry instance obtained from the map's entrySet() entry set view. Assuming a map contains no incorrectly typed keys or values prior to the time a dynamically typesafe view is generated, and that all subsequent access to the map takes place through the view (or one of its collection views), it is guaranteed that the map cannot contain an incorrectly typed key or value. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned map will be serializable if the specified map is serializable. Since null is considered to be a value of any reference type, the returned map permits insertion of null keys or values whenever the backing map does.
java.util.Collections.checkedSortedSet	(	SortedSet	Class	): Returns a dynamically typesafe view of the specified sorted set. Any attempt to insert an element of the wrong type will result in an immediate ClassCastException. Assuming a sorted set contains no incorrectly typed elements prior to the time a dynamically typesafe view is generated, and that all subsequent access to the sorted set takes place through the view, it is guaranteed that the sorted set cannot contain an incorrectly typed element. A discussion of the use of dynamically typesafe views may be found in the documentation for the checkedCollection method. The returned sorted set will be serializable if the specified sorted set is serializable. Since null is considered to be a value of any reference type, the returned sorted set permits insertion of null elements whenever the backing sorted set does.
java.util.Collections.copy	(	List	List	): Copies all of the elements from one list into another. After the operation, the index of each copied element in the destination list will be identical to its index in the source list. The destination list must be at least as long as the source list. If it is longer, the remaining elements in the destination list are unaffected.  This method runs in linear time.
java.util.Collections.disjoint	(	Collection	Collection	): Returns true if the two specified collections have no elements in common. Care must be exercised if this method is used on collections that do not comply with the general contract for Collection. Implementations may elect to iterate over either collection and test for containment in the other collection (or to perform any equivalent computation). If either collection uses a nonstandard equality test (as does a SortedSet whose ordering is not compatible with equals, or the key set of an IdentityHashMap), both collections must use the same nonstandard equality test, or the result of this method is undefined. Care must also be exercised when using collections that have restrictions on the elements that they may contain. Collection implementations are allowed to throw exceptions for any operation involving elements they deem ineligible. For absolute safety the specified collections should contain only elements which are eligible elements for both collections. Note that it is permissible to pass the same collection in both parameters, in which case the method will return true if and only if the collection is empty.
java.util.Collections.emptyEnumeration	(	): Returns an enumeration that has no elements. More precisely,  hasMoreElements always returns false.  nextElement always throws NoSuchElementException.  Implementations of this method are permitted, but not required, to return the same object from multiple invocations.
java.util.Collections.emptyIterator	(	): Returns an iterator that has no elements. More precisely,  hasNext always returns false. next always throws NoSuchElementException. remove always throws IllegalStateException.  Implementations of this method are permitted, but not required, to return the same object from multiple invocations.
java.util.Collections.emptyList	(	): Returns an empty list (immutable). This list is serializable. This example illustrates the type-safe way to obtain an empty list:  List<String> s = Collections.emptyList(); 
java.util.Collections.emptyListIterator	(	): Returns a list iterator that has no elements. More precisely,  hasNext and hasPrevious always return false. next and previous always throw NoSuchElementException. remove and set always throw IllegalStateException. add always throws UnsupportedOperationException. nextIndex always returns 0. previousIndex always returns -1.  Implementations of this method are permitted, but not required, to return the same object from multiple invocations.
java.util.Collections.emptyMap	(	): Returns an empty map (immutable). This map is serializable. This example illustrates the type-safe way to obtain an empty map:  Map<String, Date> s = Collections.emptyMap(); 
java.util.Collections.emptyNavigableMap	(	): Returns an empty navigable map (immutable). This map is serializable. This example illustrates the type-safe way to obtain an empty map:  NavigableMap s = Collections.emptyNavigableMap();
java.util.Collections.emptyNavigableSet	(	): Returns an empty navigable set (immutable). This set is serializable. This example illustrates the type-safe way to obtain an empty navigable set:  NavigableSet s = Collections.emptyNavigableSet();
java.util.Collections.emptySet	(	): Returns an empty set (immutable). This set is serializable. Unlike the like-named field, this method is parameterized. This example illustrates the type-safe way to obtain an empty set:  Set<String> s = Collections.emptySet(); 
java.util.Collections.emptySortedMap	(	): Returns an empty sorted map (immutable). This map is serializable. This example illustrates the type-safe way to obtain an empty map:  SortedMap s = Collections.emptySortedMap();
java.util.Collections.emptySortedSet	(	): Returns an empty sorted set (immutable). This set is serializable. This example illustrates the type-safe way to obtain an empty sorted set:  SortedSet s = Collections.emptySortedSet();
java.util.Collections.enumeration	(	Collection	): Returns an enumeration over the specified collection. This provides interoperability with legacy APIs that require an enumeration as input.
java.util.Collections.eq	(	Object	Object	): Returns true if the specified arguments are equal, or both null. NB: Do not replace with Object.equals until JDK-8015417 is resolved.
java.util.Collections.fill	(	List	T	): Replaces all of the elements of the specified list with the specified element.  This method runs in linear time.
java.util.Collections.frequency	(	Collection	Object	): Returns the number of elements in the specified collection equal to the specified object. More formally, returns the number of elements e in the collection such that (o == null ? e == null : o.equals(e)).
java.util.Collections.get	(	ListIterator	int	): Gets the ith element from the given list by repositioning the specified list listIterator.
java.util.Collections.indexOfSubList	(	List	List	): Returns the starting position of the first occurrence of the specified target list within the specified source list, or -1 if there is no such occurrence. More formally, returns the lowest index i such that source.subList(i, i+target.size()).equals(target), or -1 if there is no such index. (Returns -1 if target.size() > source.size()) This implementation uses the "brute force" technique of scanning over the source list, looking for a match with the target at each location in turn.
java.util.Collections.lastIndexOfSubList	(	List	List	): Returns the starting position of the last occurrence of the specified target list within the specified source list, or -1 if there is no such occurrence. More formally, returns the highest index i such that source.subList(i, i+target.size()).equals(target), or -1 if there is no such index. (Returns -1 if target.size() > source.size()) This implementation uses the "brute force" technique of iterating over the source list, looking for a match with the target at each location in turn.
java.util.Collections.list	(	Enumeration	): Returns an array list containing the elements returned by the specified enumeration in the order they are returned by the enumeration. This method provides interoperability between legacy APIs that return enumerations and new APIs that require collections.
java.util.Collections.max	(	Collection	): Returns the maximum element of the given collection, according to the natural ordering of its elements. All elements in the collection must implement the Comparable interface. Furthermore, all elements in the collection must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the collection). This method iterates over the entire collection, hence it requires time proportional to the size of the collection.
java.util.Collections.max	(	Collection	Comparator	): Returns the maximum element of the given collection, according to the order induced by the specified comparator. All elements in the collection must be mutually comparable by the specified comparator (that is, comp.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the collection). This method iterates over the entire collection, hence it requires time proportional to the size of the collection.
java.util.Collections.min	(	Collection	): Returns the minimum element of the given collection, according to the natural ordering of its elements. All elements in the collection must implement the Comparable interface. Furthermore, all elements in the collection must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the collection). This method iterates over the entire collection, hence it requires time proportional to the size of the collection.
java.util.Collections.min	(	Collection	Comparator	): Returns the minimum element of the given collection, according to the order induced by the specified comparator. All elements in the collection must be mutually comparable by the specified comparator (that is, comp.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the collection). This method iterates over the entire collection, hence it requires time proportional to the size of the collection.
java.util.Collections.nCopies	(	int	T	): Returns an immutable list consisting of n copies of the specified object. The newly allocated data object is tiny (it contains a single reference to the data object). This method is useful in combination with the List.addAll method to grow lists. The returned list is serializable.
java.util.Collections.newSetFromMap	(	Map	): Returns a set backed by the specified map. The resulting set displays the same ordering, concurrency, and performance characteristics as the backing map. In essence, this factory method provides a Set implementation corresponding to any Map implementation. There is no need to use this method on a Map implementation that already has a corresponding Set implementation (such as HashMap or TreeMap). Each method invocation on the set returned by this method results in exactly one method invocation on the backing map or its keySet view, with one exception. The addAll method is implemented as a sequence of put invocations on the backing map. The specified map must be empty at the time this method is invoked, and should not be accessed directly after this method returns. These conditions are ensured if the map is created empty, passed directly to this method, and no reference to the map is retained, as illustrated in the following code fragment:  Set<Object> weakHashSet = Collections.newSetFromMap( new WeakHashMap<Object, Boolean>()); 
java.util.Collections.replaceAll	(	List	T	T	): Replaces all occurrences of one specified value in a list with another. More formally, replaces with newVal each element e in list such that (oldVal==null ? e==null : oldVal.equals(e)). (This method has no effect on the size of the list.)
java.util.Collections.reverse	(	List	): Reverses the order of the elements in the specified list. This method runs in linear time.
java.util.Collections.reverseOrder	(	): Returns a comparator that imposes the reverse of the natural ordering on a collection of objects that implement the Comparable interface. (The natural ordering is the ordering imposed by the objects' own compareTo method.) This enables a simple idiom for sorting (or maintaining) collections (or arrays) of objects that implement the Comparable interface in reverse-natural-order. For example, suppose a is an array of strings. Then:  Arrays.sort(a, Collections.reverseOrder());  sorts the array in reverse-lexicographic (alphabetical) order. The returned comparator is serializable.
java.util.Collections.reverseOrder	(	Comparator	): Returns a comparator that imposes the reverse ordering of the specified comparator. If the specified comparator is null, this method is equivalent to reverseOrder() (in other words, it returns a comparator that imposes the reverse of the natural ordering on a collection of objects that implement the Comparable interface). The returned comparator is serializable (assuming the specified comparator is also serializable or null).
java.util.Collections.rotate	(	List	int	): Rotates the elements in the specified list by the specified distance. After calling this method, the element at index i will be the element previously at index (i - distance) mod list.size(), for all values of i between 0 and list.size()-1, inclusive. (This method has no effect on the size of the list.) For example, suppose list comprises [t, a, n, k, s]. After invoking Collections.rotate(list, 1) (or Collections.rotate(list, -4)), list will comprise [s, t, a, n, k]. Note that this method can usefully be applied to sublists to move one or more elements within a list while preserving the order of the remaining elements. For example, the following idiom moves the element at index j forward to position k (which must be greater than or equal to j):  Collections.rotate(list.subList(j, k+1), -1);  To make this concrete, suppose list comprises [a, b, c, d, e]. To move the element at index 1 (b) forward two positions, perform the following invocation:  Collections.rotate(l.subList(1, 4), -1);  The resulting list is [a, c, d, b, e]. To move more than one element forward, increase the absolute value of the rotation distance. To move elements backward, use a positive shift distance. If the specified list is small or implements the RandomAccess interface, this implementation exchanges the first element into the location it should go, and then repeatedly exchanges the displaced element into the location it should go until a displaced element is swapped into the first element. If necessary, the process is repeated on the second and successive elements, until the rotation is complete. If the specified list is large and doesn't implement the RandomAccess interface, this implementation breaks the list into two sublist views around index -distance mod size. Then the reverse() method is invoked on each sublist view, and finally it is invoked on the entire list. For a more complete description of both algorithms, see Section 2.3 of Jon Bentley's Programming Pearls (Addison-Wesley, 1986).
java.util.Collections.shuffle	(	List	): Randomly permutes the specified list using a default source of randomness. All permutations occur with approximately equal likelihood. The hedge "approximately" is used in the foregoing description because default source of randomness is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm would choose permutations with perfect uniformity. This implementation traverses the list backwards, from the last element up to the second, repeatedly swapping a randomly selected element into the "current position". Elements are randomly selected from the portion of the list that runs from the first element to the current position, inclusive. This method runs in linear time. If the specified list does not implement the RandomAccess interface and is large, this implementation dumps the specified list into an array before shuffling it, and dumps the shuffled array back into the list. This avoids the quadratic behavior that would result from shuffling a "sequential access" list in place.
java.util.Collections.shuffle	(	List	Random	): Randomly permute the specified list using the specified source of randomness. All permutations occur with equal likelihood assuming that the source of randomness is fair. This implementation traverses the list backwards, from the last element up to the second, repeatedly swapping a randomly selected element into the "current position". Elements are randomly selected from the portion of the list that runs from the first element to the current position, inclusive. This method runs in linear time. If the specified list does not implement the RandomAccess interface and is large, this implementation dumps the specified list into an array before shuffling it, and dumps the shuffled array back into the list. This avoids the quadratic behavior that would result from shuffling a "sequential access" list in place.
java.util.Collections.singleton	(	T	): Returns an immutable set containing only the specified object. The returned set is serializable.
java.util.Collections.singletonList	(	T	): Returns an immutable list containing only the specified object. The returned list is serializable.
java.util.Collections.singletonMap	(	K	V	): Returns an immutable map, mapping only the specified key to the specified value. The returned map is serializable.
java.util.Collections.singletonSpliterator	(	T	): Creates a Spliterator with only the specified element
java.util.Collections.sort	(	List	): Sorts the specified list into ascending order, according to the Comparable natural ordering of its elements. All elements in the list must implement the Comparable interface. Furthermore, all elements in the list must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the list). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The specified list must be modifiable, but need not be resizable.
java.util.Collections.sort	(	List	Comparator	): Sorts the specified list according to the order induced by the specified comparator. All elements in the list must be mutually comparable using the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the list). This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. The specified list must be modifiable, but need not be resizable.
java.util.Collections.swap	(	List	int	int	): Swaps the elements at the specified positions in the specified list. (If the specified positions are equal, invoking this method leaves the list unchanged.)
java.util.Collections.swap	(	Object[]	int	int	): Swaps the two specified elements in the specified array.
java.util.Collections.synchronizedCollection	(	Collection	): Returns a synchronized (thread-safe) collection backed by the specified collection. In order to guarantee serial access, it is critical that all access to the backing collection is accomplished through the returned collection. It is imperative that the user manually synchronize on the returned collection when traversing it via Iterator, Spliterator or Stream:  Collection c = Collections.synchronizedCollection(myCollection); ... synchronized (c) { Iterator i = c.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned collection does not pass the hashCode and equals operations through to the backing collection, but relies on Object's equals and hashCode methods. This is necessary to preserve the contracts of these operations in the case that the backing collection is a set or a list. The returned collection will be serializable if the specified collection is serializable.
java.util.Collections.synchronizedList	(	List	): Returns a synchronized (thread-safe) list backed by the specified list. In order to guarantee serial access, it is critical that all access to the backing list is accomplished through the returned list. It is imperative that the user manually synchronize on the returned list when iterating over it:  List list = Collections.synchronizedList(new ArrayList()); ... synchronized (list) { Iterator i = list.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned list will be serializable if the specified list is serializable.
java.util.Collections.synchronizedMap	(	Map	): Returns a synchronized (thread-safe) map backed by the specified map. In order to guarantee serial access, it is critical that all access to the backing map is accomplished through the returned map. It is imperative that the user manually synchronize on the returned map when iterating over any of its collection views:  Map m = Collections.synchronizedMap(new HashMap()); ... Set s = m.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not s! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned map will be serializable if the specified map is serializable.
java.util.Collections.synchronizedNavigableMap	(	NavigableMap	): Returns a synchronized (thread-safe) navigable map backed by the specified navigable map. In order to guarantee serial access, it is critical that all access to the backing navigable map is accomplished through the returned navigable map (or its views). It is imperative that the user manually synchronize on the returned navigable map when iterating over any of its collection views, or the collections views of any of its subMap, headMap or tailMap views.  NavigableMap m = Collections.synchronizedNavigableMap(new TreeMap()); ... Set s = m.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not s! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  or:  NavigableMap m = Collections.synchronizedNavigableMap(new TreeMap()); NavigableMap m2 = m.subMap(foo, true, bar, false); ... Set s2 = m2.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not m2 or s2! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned navigable map will be serializable if the specified navigable map is serializable.
java.util.Collections.synchronizedNavigableSet	(	NavigableSet	): Returns a synchronized (thread-safe) navigable set backed by the specified navigable set. In order to guarantee serial access, it is critical that all access to the backing navigable set is accomplished through the returned navigable set (or its views). It is imperative that the user manually synchronize on the returned navigable set when iterating over it or any of its subSet, headSet, or tailSet views.  NavigableSet s = Collections.synchronizedNavigableSet(new TreeSet()); ... synchronized (s) { Iterator i = s.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  or:  NavigableSet s = Collections.synchronizedNavigableSet(new TreeSet()); NavigableSet s2 = s.headSet(foo, true); ... synchronized (s) { // Note: s, not s2!!! Iterator i = s2.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned navigable set will be serializable if the specified navigable set is serializable.
java.util.Collections.synchronizedSet	(	Set	): Returns a synchronized (thread-safe) set backed by the specified set. In order to guarantee serial access, it is critical that all access to the backing set is accomplished through the returned set. It is imperative that the user manually synchronize on the returned set when iterating over it:  Set s = Collections.synchronizedSet(new HashSet()); ... synchronized (s) { Iterator i = s.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned set will be serializable if the specified set is serializable.
java.util.Collections.synchronizedSortedMap	(	SortedMap	): Returns a synchronized (thread-safe) sorted map backed by the specified sorted map. In order to guarantee serial access, it is critical that all access to the backing sorted map is accomplished through the returned sorted map (or its views). It is imperative that the user manually synchronize on the returned sorted map when iterating over any of its collection views, or the collections views of any of its subMap, headMap or tailMap views.  SortedMap m = Collections.synchronizedSortedMap(new TreeMap()); ... Set s = m.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not s! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  or:  SortedMap m = Collections.synchronizedSortedMap(new TreeMap()); SortedMap m2 = m.subMap(foo, bar); ... Set s2 = m2.keySet(); // Needn't be in synchronized block ... synchronized (m) { // Synchronizing on m, not m2 or s2! Iterator i = s.iterator(); // Must be in synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned sorted map will be serializable if the specified sorted map is serializable.
java.util.Collections.synchronizedSortedSet	(	SortedSet	): Returns a synchronized (thread-safe) sorted set backed by the specified sorted set. In order to guarantee serial access, it is critical that all access to the backing sorted set is accomplished through the returned sorted set (or its views). It is imperative that the user manually synchronize on the returned sorted set when iterating over it or any of its subSet, headSet, or tailSet views.  SortedSet s = Collections.synchronizedSortedSet(new TreeSet()); ... synchronized (s) { Iterator i = s.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  or:  SortedSet s = Collections.synchronizedSortedSet(new TreeSet()); SortedSet s2 = s.headSet(foo); ... synchronized (s) { // Note: s, not s2!!! Iterator i = s2.iterator(); // Must be in the synchronized block while (i.hasNext()) foo(i.next()); }  Failure to follow this advice may result in non-deterministic behavior. The returned sorted set will be serializable if the specified sorted set is serializable.
java.util.Collections.unmodifiableCollection	(	Collection	): Returns an unmodifiable view of the specified collection. This method allows modules to provide users with "read-only" access to internal collections. Query operations on the returned collection "read through" to the specified collection, and attempts to modify the returned collection, whether direct or via its iterator, result in an UnsupportedOperationException. The returned collection does not pass the hashCode and equals operations through to the backing collection, but relies on Object's equals and hashCode methods. This is necessary to preserve the contracts of these operations in the case that the backing collection is a set or a list. The returned collection will be serializable if the specified collection is serializable.
java.util.Collections.unmodifiableList	(	List	): Returns an unmodifiable view of the specified list. This method allows modules to provide users with "read-only" access to internal lists. Query operations on the returned list "read through" to the specified list, and attempts to modify the returned list, whether direct or via its iterator, result in an UnsupportedOperationException. The returned list will be serializable if the specified list is serializable. Similarly, the returned list will implement RandomAccess if the specified list does.
java.util.Collections.unmodifiableMap	(	Map	): Returns an unmodifiable view of the specified map. This method allows modules to provide users with "read-only" access to internal maps. Query operations on the returned map "read through" to the specified map, and attempts to modify the returned map, whether direct or via its collection views, result in an UnsupportedOperationException. The returned map will be serializable if the specified map is serializable.
java.util.Collections.unmodifiableNavigableMap	(	NavigableMap	): Returns an unmodifiable view of the specified navigable map. This method allows modules to provide users with "read-only" access to internal navigable maps. Query operations on the returned navigable map "read through" to the specified navigable map. Attempts to modify the returned navigable map, whether direct, via its collection views, or via its subMap, headMap, or tailMap views, result in an UnsupportedOperationException. The returned navigable map will be serializable if the specified navigable map is serializable.
java.util.Collections.unmodifiableNavigableSet	(	NavigableSet	): Returns an unmodifiable view of the specified navigable set. This method allows modules to provide users with "read-only" access to internal navigable sets. Query operations on the returned navigable set "read through" to the specified navigable set. Attempts to modify the returned navigable set, whether direct, via its iterator, or via its subSet, headSet, or tailSet views, result in an UnsupportedOperationException. The returned navigable set will be serializable if the specified navigable set is serializable.
java.util.Collections.unmodifiableSet	(	Set	): Returns an unmodifiable view of the specified set. This method allows modules to provide users with "read-only" access to internal sets. Query operations on the returned set "read through" to the specified set, and attempts to modify the returned set, whether direct or via its iterator, result in an UnsupportedOperationException. The returned set will be serializable if the specified set is serializable.
java.util.Collections.unmodifiableSortedMap	(	SortedMap	): Returns an unmodifiable view of the specified sorted map. This method allows modules to provide users with "read-only" access to internal sorted maps. Query operations on the returned sorted map "read through" to the specified sorted map. Attempts to modify the returned sorted map, whether direct, via its collection views, or via its subMap, headMap, or tailMap views, result in an UnsupportedOperationException. The returned sorted map will be serializable if the specified sorted map is serializable.
java.util.Collections.unmodifiableSortedSet	(	SortedSet	): Returns an unmodifiable view of the specified sorted set. This method allows modules to provide users with "read-only" access to internal sorted sets. Query operations on the returned sorted set "read through" to the specified sorted set. Attempts to modify the returned sorted set, whether direct, via its iterator, or via its subSet, headSet, or tailSet views, result in an UnsupportedOperationException. The returned sorted set will be serializable if the specified sorted set is serializable.
java.util.ComparableTimSort: This is a near duplicate of TimSort, modified for use with arrays of objects that implement Comparable, instead of using explicit comparators. If you are using an optimizing VM, you may find that ComparableTimSort offers no performance benefit over TimSort in conjunction with a comparator that simply returns ((Comparable)first).compareTo(Second). If this is the case, you are better off deleting ComparableTimSort to eliminate the code duplication. (See Arrays.java for details.)
java.util.ComparableTimSort.ComparableTimSort	(	Object[]	Object[]	int	int	): Creates a TimSort instance to maintain the state of an ongoing sort.
java.util.ComparableTimSort.binarySort	(	Object[]	int	int	int	): Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case). If the initial part of the specified range is already sorted, this method can take advantage of it: the method assumes that the elements from index lo, inclusive, to start, exclusive are already sorted.
java.util.ComparableTimSort.countRunAndMakeAscending	(	Object[]	int	int	): Returns the length of the run beginning at the specified position in the specified array and reverses the run if it is descending (ensuring that the run will always be ascending when the method returns). A run is the longest ascending sequence with: a[lo] <= a[lo + 1] <= a[lo + 2] <= ... or the longest descending sequence with: a[lo] > a[lo + 1] > a[lo + 2] > ... For its intended use in a stable mergesort, the strictness of the definition of "descending" is needed so that the call can safely reverse a descending sequence without violating stability.
java.util.ComparableTimSort.ensureCapacity	(	int	): Ensures that the external array tmp has at least the specified number of elements, increasing its size if necessary. The size increases exponentially to ensure amortized linear time complexity.
java.util.ComparableTimSort.gallopLeft	(	Comparable	Object[]	int	int	int	): Locates the position at which to insert the specified key into the specified sorted range; if the range contains an element equal to key, returns the index of the leftmost equal element.
java.util.ComparableTimSort.gallopRight	(	Comparable	Object[]	int	int	int	): Like gallopLeft, except that if the range contains an element equal to key, gallopRight returns the index after the rightmost equal element.
java.util.ComparableTimSort.mergeAt	(	int	): Merges the two runs at stack indices i and i+1. Run i must be the penultimate or antepenultimate run on the stack. In other words, i must be equal to stackSize-2 or stackSize-3.
java.util.ComparableTimSort.mergeCollapse	(	): Examines the stack of runs waiting to be merged and merges adjacent runs until the stack invariants are reestablished: 1. runLen[i - 3] > runLen[i - 2] + runLen[i - 1] 2. runLen[i - 2] > runLen[i - 1] This method is called each time a new run is pushed onto the stack, so the invariants are guaranteed to hold for i < stackSize upon entry to the method.
java.util.ComparableTimSort.mergeForceCollapse	(	): Merges all runs on the stack until only one remains. This method is called once, to complete the sort.
java.util.ComparableTimSort.mergeHi	(	int	int	int	int	): Like mergeLo, except that this method should be called only if len1 >= len2; mergeLo should be called if len1 <= len2. (Either method may be called if len1 == len2.)
java.util.ComparableTimSort.mergeLo	(	int	int	int	int	): Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than the first element of the second run (a[base1] > a[base2]), and the last element of the first run (a[base1 + len1-1]) must be greater than all elements of the second run. For performance, this method should be called only when len1 <= len2; its twin, mergeHi should be called if len1 >= len2. (Either method may be called if len1 == len2.)
java.util.ComparableTimSort.minRunLength	(	int	): Returns the minimum acceptable run length for an array of the specified length. Natural runs shorter than this will be extended with binarySort. Roughly speaking, the computation is: If n < MIN_MERGE, return n (it's too small to bother with fancy stuff). Else if n is an exact power of 2, return MIN_MERGE/2. Else return an int k, MIN_MERGE/2 <= k <= MIN_MERGE, such that n/k is close to, but strictly less than, an exact power of 2. For the rationale, see listsort.txt.
java.util.ComparableTimSort.pushRun	(	int	int	): Pushes the specified run onto the pending-run stack.
java.util.ComparableTimSort.reverseRange	(	Object[]	int	int	): Reverse the specified range of the specified array.
java.util.ComparableTimSort.sort	(	Object[]	int	int	Object[]	int	int	): Sorts the given range, using the given workspace array slice for temp storage when possible. This method is designed to be invoked from public methods (in class Arrays) after performing any necessary array bounds checks and expanding parameters into the required forms.
java.util.Comparator: A comparison function, which imposes a total ordering on some collection of objects. Comparators can be passed to a sort method (such as sort() Collections.sort or sort() Arrays.sort) to allow precise control over the sort order. Comparators can also be used to control the order of certain data structures (such as SortedSet sorted sets or SortedMap sorted maps), or to provide an ordering for collections of objects that don't have a Comparable natural ordering. The ordering imposed by a comparator c on a set of elements S is said to be consistent with equals if and only if c.compare(e1, e2)==0 has the same boolean value as e1.equals(e2) for every e1 and e2 in S. Caution should be exercised when using a comparator capable of imposing an ordering inconsistent with equals to order a sorted set (or sorted map). Suppose a sorted set (or sorted map) with an explicit comparator c is used with elements (or keys) drawn from a set S. If the ordering imposed by c on S is inconsistent with equals, the sorted set (or sorted map) will behave "strangely." In particular the sorted set (or sorted map) will violate the general contract for set (or map), which is defined in terms of equals. For example, suppose one adds two elements a and b such that (a.equals(b) && c.compare(a, b) != 0) to an empty TreeSet with comparator c. The second add operation will return true (and the size of the tree set will increase) because a and b are not equivalent from the tree set's perspective, even though this is contrary to the specification of the add Set.add method. Note: It is generally a good idea for comparators to also implement java.io.Serializable, as they may be used as ordering methods in serializable data structures (like TreeSet, TreeMap). In order for the data structure to serialize successfully, the comparator (if provided) must implement Serializable. For the mathematically inclined, the relation that defines the imposed ordering that a given comparator c imposes on a given set of objects S is: {(x, y) such that c.compare(x, y) <= 0}.  The quotient for this total order is: {(x, y) such that c.compare(x, y) == 0}.  It follows immediately from the contract for compare that the quotient is an equivalence relation on S, and that the imposed ordering is a total order on S. When we say that the ordering imposed by c on S is consistent with equals, we mean that the quotient for the ordering is the equivalence relation defined by the objects' equals() equals(Object) method(s): {(x, y) such that x.equals(y)}.  Unlike Comparable, a comparator may optionally permit comparison of null arguments, while maintaining the requirements for an equivalence relation. This interface is a member of the  Java Collections Framework.
java.util.Comparator.compare	(	T	T	): Compares its two arguments for order. Returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. In the foregoing description, the notation sgn(expression) designates the mathematical signum function, which is defined to return one of -1, 0, or 1 according to whether the value of expression is negative, zero or positive. The implementor must ensure that sgn(compare(x, y)) == -sgn(compare(y, x)) for all x and y. (This implies that compare(x, y) must throw an exception if and only if compare(y, x) throws an exception.) The implementor must also ensure that the relation is transitive: ((compare(x, y)>0) && (compare(y, z)>0)) implies compare(x, z)>0. Finally, the implementor must ensure that compare(x, y)==0 implies that sgn(compare(x, z))==sgn(compare(y, z)) for all z. It is generally the case, but not strictly required that (compare(x, y)==0) == (x.equals(y)). Generally speaking, any comparator that violates this condition should clearly indicate this fact. The recommended language is "Note: this comparator imposes orderings that are inconsistent with equals."
java.util.Comparator.comparing	(	Function	): Accepts a function that extracts a java.lang.Comparable Comparable sort key from a type T, and returns a Comparator that compares by that sort key. The returned comparator is serializable if the specified function is also serializable.
java.util.Comparator.comparing	(	Function	Comparator	): Accepts a function that extracts a sort key from a type T, and returns a Comparator that compares by that sort key using the specified Comparator. The returned comparator is serializable if the specified function and comparator are both serializable.
java.util.Comparator.comparingDouble	(	ToDoubleFunction	): Accepts a function that extracts a double sort key from a type T, and returns a Comparator that compares by that sort key. The returned comparator is serializable if the specified function is also serializable.
java.util.Comparator.comparingInt	(	ToIntFunction	): Accepts a function that extracts an int sort key from a type T, and returns a Comparator that compares by that sort key. The returned comparator is serializable if the specified function is also serializable.
java.util.Comparator.comparingLong	(	ToLongFunction	): Accepts a function that extracts a long sort key from a type T, and returns a Comparator that compares by that sort key. The returned comparator is serializable if the specified function is also serializable.
java.util.Comparator.equals	(	Object	): Indicates whether some other object is "equal to" this comparator. This method must obey the general contract of equals(). Additionally, this method can return true only if the specified object is also a comparator and it imposes the same ordering as this comparator. Thus, comp1.equals(comp2) implies that sgn(comp1.compare(o1, o2))==sgn(comp2.compare(o1, o2)) for every object reference o1 and o2. Note that it is always safe not to override Object.equals(Object). However, overriding this method may, in some cases, improve performance by allowing programs to determine that two distinct comparators impose the same order.
java.util.Comparator.naturalOrder	(	): Returns a comparator that compares Comparable objects in natural order. The returned comparator is serializable and throws NullPointerException when comparing null.
java.util.Comparator.nullsFirst	(	Comparator	): Returns a null-friendly comparator that considers null to be less than non-null. When both are null, they are considered equal. If both are non-null, the specified Comparator is used to determine the order. If the specified comparator is null, then the returned comparator considers all non-null values to be equal. The returned comparator is serializable if the specified comparator is serializable.
java.util.Comparator.nullsLast	(	Comparator	): Returns a null-friendly comparator that considers null to be greater than non-null. When both are null, they are considered equal. If both are non-null, the specified Comparator is used to determine the order. If the specified comparator is null, then the returned comparator considers all non-null values to be equal. The returned comparator is serializable if the specified comparator is serializable.
java.util.Comparator.reverseOrder	(	): Returns a comparator that imposes the reverse of the natural ordering. The returned comparator is serializable and throws NullPointerException when comparing null.
java.util.Comparator.reversed	(	): Returns a comparator that imposes the reverse ordering of this comparator.
java.util.Comparator.thenComparing	(	Comparator	): Returns a lexicographic-order comparator with another comparator. If this Comparator considers two elements equal, i.e. compare(a, b) == 0, other is used to determine the order. The returned comparator is serializable if the specified comparator is also serializable.
java.util.Comparator.thenComparing	(	Function	): Returns a lexicographic-order comparator with a function that extracts a Comparable sort key.
java.util.Comparator.thenComparing	(	Function	Comparator	): Returns a lexicographic-order comparator with a function that extracts a key to be compared with the given Comparator.
java.util.Comparator.thenComparingDouble	(	ToDoubleFunction	): Returns a lexicographic-order comparator with a function that extracts a double sort key.
java.util.Comparator.thenComparingInt	(	ToIntFunction	): Returns a lexicographic-order comparator with a function that extracts a int sort key.
java.util.Comparator.thenComparingLong	(	ToLongFunction	): Returns a lexicographic-order comparator with a function that extracts a long sort key.
java.util.Comparators: Package private supporting class for Comparator.
java.util.Comparators.NullComparator: Null-friendly comparators
java.util.ConcurrentModificationException: This exception may be thrown by methods that have detected concurrent modification of an object when such modification is not permissible.  For example, it is not generally permissible for one thread to modify a Collection while another thread is iterating over it. In general, the results of the iteration are undefined under these circumstances. Some Iterator implementations (including those of all the general purpose collection implementations provided by the JRE) may choose to throw this exception if this behavior is detected. Iterators that do this are known as fail-fast iterators, as they fail quickly and cleanly, rather that risking arbitrary, non-deterministic behavior at an undetermined time in the future.  Note that this exception does not always indicate that an object has been concurrently modified by a different thread. If a single thread issues a sequence of method invocations that violates the contract of an object, the object may throw this exception. For example, if a thread modifies a collection directly while it is iterating over the collection with a fail-fast iterator, the iterator will throw this exception. Note that fail-fast behavior cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast operations throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: ConcurrentModificationException should be used only to detect bugs.
java.util.ConcurrentModificationException.ConcurrentModificationException	(	): Constructs a ConcurrentModificationException with no detail message.
java.util.ConcurrentModificationException.ConcurrentModificationException	(	String	): Constructs a ConcurrentModificationException with the specified detail message.
java.util.ConcurrentModificationException.ConcurrentModificationException	(	String	Throwable	): Constructs a new exception with the specified detail message and cause. Note that the detail message associated with cause is not automatically incorporated in this exception's detail message.
java.util.ConcurrentModificationException.ConcurrentModificationException	(	Throwable	): Constructs a new exception with the specified cause and a detail message of (cause==null ? null : cause.toString()) (which typically contains the class and detail message of cause.
java.util.Currency: Represents a currency. Currencies are identified by their ISO 4217 currency codes. Visit the  ISO web site for more information.  The class is designed so that there's never more than one Currency instance for any given currency. Therefore, there's no public constructor. You obtain a Currency instance using the getInstance methods.  Users can supersede the Java runtime currency data by means of the system property java.util.currency.data. If this system property is defined then its value is the location of a properties file, the contents of which are key/value pairs of the ISO 3166 country codes and the ISO 4217 currency data respectively. The value part consists of three ISO 4217 values of a currency, i.e., an alphabetic code, a numeric code, and a minor unit. Those three ISO 4217 values are separated by commas. The lines which start with '#'s are considered comment lines. An optional UTC timestamp may be specified per currency entry if users need to specify a cutover date indicating when the new data comes into effect. The timestamp is appended to the end of the currency properties and uses a comma as a separator. If a UTC datestamp is present and valid, the JRE will only use the new currency properties if the current UTC date is later than the date specified at class loading time. The format of the timestamp must be of ISO 8601 format : 'yyyy-MM-dd'T'HH:mm:ss'. For example,   #Sample currency properties JP=JPZ,999,0   will supersede the currency data for Japan.   #Sample currency properties with cutover date JP=JPZ,999,0,2014-01-01T00:00:00   will supersede the currency data for Japan if Currency class is loaded after 1st January 2014 00:00:00 GMT.  Where syntactically malformed entries are encountered, the entry is ignored and the remainder of entries in file are processed. For instances where duplicate country code entries exist, the behavior of the Currency information for that Currency is undefined and the remainder of entries in file are processed.
java.util.Currency.Currency	(	String	int	int	): Constructs a Currency instance. The constructor is private so that we can insure that there's never more than one instance for a given currency.
java.util.Currency.CurrencyNameGetter: Obtains a localized currency names from a CurrencyNameProvider implementation.
java.util.Currency.getAvailableCurrencies	(	): Gets the set of available currencies. The returned set of currencies contains all of the available currencies, which may include currencies that represent obsolete ISO 4217 codes. The set can be modified without affecting the available currencies in the runtime.
java.util.Currency.getCurrencyCode	(	): Gets the ISO 4217 currency code of this currency.
java.util.Currency.getDefaultFractionDigits	(	): Gets the default number of fraction digits used with this currency. For example, the default number of fraction digits for the Euro is 2, while for the Japanese Yen it's 0. In the case of pseudo-currencies, such as IMF Special Drawing Rights, -1 is returned.
java.util.Currency.getDisplayName	(	): Gets the name that is suitable for displaying this currency for the default DISPLAY locale. If there is no suitable display name found for the default locale, the ISO 4217 currency code is returned.  This is equivalent to calling getDisplayName() getDisplayName(Locale.getDefault(Locale.Category.DISPLAY)).
java.util.Currency.getDisplayName	(	Locale	): Gets the name that is suitable for displaying this currency for the specified locale. If there is no suitable display name found for the specified locale, the ISO 4217 currency code is returned.
java.util.Currency.getInstance	(	Locale	): Returns the Currency instance for the country of the given locale. The language and variant components of the locale are ignored. The result may vary over time, as countries change their currencies. For example, for the original member countries of the European Monetary Union, the method returns the old national currencies until December 31, 2001, and the Euro from January 1, 2002, local time of the respective countries.  The method returns null for territories that don't have a currency, such as Antarctica.
java.util.Currency.getInstance	(	String	): Returns the Currency instance for the given currency code.
java.util.Currency.getMainTableEntry	(	char	char	): Gets the main table entry for the country whose country code consists of char1 and char2.
java.util.Currency.getNumericCode	(	): Returns the ISO 4217 numeric code of this currency.
java.util.Currency.getSymbol	(	): Gets the symbol of this currency for the default DISPLAY locale. For example, for the US Dollar, the symbol is "$" if the default locale is the US, while for other locales it may be "US$". If no symbol can be determined, the ISO 4217 currency code is returned.  This is equivalent to calling getSymbol() getSymbol(Locale.getDefault(Locale.Category.DISPLAY)).
java.util.Currency.getSymbol	(	Locale	): Gets the symbol of this currency for the specified locale. For example, for the US Dollar, the symbol is "$" if the specified locale is the US, while for other locales it may be "US$". If no symbol can be determined, the ISO 4217 currency code is returned.
java.util.Currency.readResolve	(	): Resolves instances being deserialized to a single instance per currency.
java.util.Currency.replaceCurrencyData	(	Pattern	String	String	): Replaces currency data found in the currencydata.properties file
java.util.Currency.setMainTableEntry	(	char	char	int	): Sets the main table entry for the country whose country code consists of char1 and char2.
java.util.Currency.toString	(	): Returns the ISO 4217 currency code of this currency.
java.util.Date: The class Date represents a specific instant in time, with millisecond precision.  Prior to JDK 1.1, the class Date had two additional functions. It allowed the interpretation of dates as year, month, day, hour, minute, and second values. It also allowed the formatting and parsing of date strings. Unfortunately, the API for these functions was not amenable to internationalization. As of JDK 1.1, the Calendar class should be used to convert between dates and time fields and the DateFormat class should be used to format and parse date strings. The corresponding methods in Date are deprecated.  Although the Date class is intended to reflect coordinated universal time (UTC), it may not do so exactly, depending on the host environment of the Java Virtual Machine. Nearly all modern operating systems assume that 1 day = 24 × 60 × 60 = 86400 seconds in all cases. In UTC, however, about once every year or two there is an extra second, called a "leap second." The leap second is always added as the last second of the day, and always on December 31 or June 30. For example, the last minute of the year 1995 was 61 seconds long, thanks to an added leap second. Most computer clocks are not accurate enough to be able to reflect the leap-second distinction.  Some computer standards are defined in terms of Greenwich mean time (GMT), which is equivalent to universal time (UT). GMT is the "civil" name for the standard; UT is the "scientific" name for the same standard. The distinction between UTC and UT is that UTC is based on an atomic clock and UT is based on astronomical observations, which for all practical purposes is an invisibly fine hair to split. Because the earth's rotation is not uniform (it slows down and speeds up in complicated ways), UT does not always flow uniformly. Leap seconds are introduced as needed into UTC so as to keep UTC within 0.9 seconds of UT1, which is a version of UT with certain corrections applied. There are other time and date systems as well; for example, the time scale used by the satellite-based global positioning system (GPS) is synchronized to UTC but is not adjusted for leap seconds. An interesting source of further information is the U.S. Naval Observatory, particularly the Directorate of Time at:  http://tycho.usno.navy.mil   and their definitions of "Systems of Time" at:  http://tycho.usno.navy.mil/systime.html   In all methods of class Date that accept or return year, month, date, hours, minutes, and seconds values, the following representations are used:  A year y is represented by the integer y - 1900. A month is represented by an integer from 0 to 11; 0 is January, 1 is February, and so forth; thus 11 is December. A date (day of month) is represented by an integer from 1 to 31 in the usual manner. An hour is represented by an integer from 0 to 23. Thus, the hour from midnight to 1 a.m. is hour 0, and the hour from noon to 1 p.m. is hour 12. A minute is represented by an integer from 0 to 59 in the usual manner. A second is represented by an integer from 0 to 61; the values 60 and 61 occur only for leap seconds and even then only in Java implementations that actually track leap seconds correctly. Because of the manner in which leap seconds are currently introduced, it is extremely unlikely that two leap seconds will occur in the same minute, but this specification follows the date and time conventions for ISO C.   In all cases, arguments given to methods for these purposes need not fall within the indicated ranges; for example, a date may be specified as January 32 and is interpreted as meaning February 1.
java.util.Date.Date	(	): Allocates a Date object and initializes it so that it represents the time at which it was allocated, measured to the nearest millisecond.
java.util.Date.Date	(	String	): Allocates a Date object and initializes it so that it represents the date and time indicated by the string s, which is interpreted as if by the parse method.
java.util.Date.Date	(	int	int	int	): Allocates a Date object and initializes it so that it represents midnight, local time, at the beginning of the day specified by the year, month, and date arguments.
java.util.Date.Date	(	int	int	int	int	int	): Allocates a Date object and initializes it so that it represents the instant at the start of the minute specified by the year, month, date, hrs, and min arguments, in the local time zone.
java.util.Date.Date	(	int	int	int	int	int	int	): Allocates a Date object and initializes it so that it represents the instant at the start of the second specified by the year, month, date, hrs, min, and sec arguments, in the local time zone.
java.util.Date.Date	(	long	): Allocates a Date object and initializes it to represent the specified number of milliseconds since the standard base time known as "the epoch", namely January 1, 1970, 00:00:00 GMT.
java.util.Date.UTC	(	int	int	int	int	int	int	): Determines the date and time based on the arguments. The arguments are interpreted as a year, month, day of the month, hour of the day, minute within the hour, and second within the minute, exactly as for the Date constructor with six arguments, except that the arguments are interpreted relative to UTC rather than to the local time zone. The time indicated is returned represented as the distance, measured in milliseconds, of that time from the epoch (00:00:00 GMT on January 1, 1970).
java.util.Date.after	(	Date	): Tests if this date is after the specified date.
java.util.Date.before	(	Date	): Tests if this date is before the specified date.
java.util.Date.clone	(	): Return a copy of this object.
java.util.Date.compareTo	(	Date	): Compares two Dates for ordering.
java.util.Date.convertToAbbr	(	StringBuilder	String	): Converts the given name to its 3-letter abbreviation (e.g., "monday" -> "Mon") and stored the abbreviation in the given StringBuilder.
java.util.Date.equals	(	Object	): Compares two dates for equality. The result is true if and only if the argument is not null and is a Date object that represents the same point in time, to the millisecond, as this object.  Thus, two Date objects are equal if and only if the getTime method returns the same long value for both.
java.util.Date.from	(	Instant	): Obtains an instance of Date from an Instant object.  Instant uses a precision of nanoseconds, whereas Date uses a precision of milliseconds. The conversion will trancate any excess precision information as though the amount in nanoseconds was subject to integer division by one million.  Instant can store points on the time-line further in the future and further in the past than Date. In this scenario, this method will throw an exception.
java.util.Date.getCalendarSystem	(	int	): Returns the Gregorian or Julian calendar system to use with the given date. Use Gregorian from October 15, 1582.
java.util.Date.getDate	(	): Returns the day of the month represented by this Date object. The value returned is between 1 and 31 representing the day of the month that contains or begins with the instant in time represented by this Date object, as interpreted in the local time zone.
java.util.Date.getDay	(	): Returns the day of the week represented by this date. The returned value (0 = Sunday, 1 = Monday, 2 = Tuesday, 3 = Wednesday, 4 = Thursday, 5 = Friday, 6 = Saturday) represents the day of the week that contains or begins with the instant in time represented by this Date object, as interpreted in the local time zone.
java.util.Date.getHours	(	): Returns the hour represented by this Date object. The returned value is a number (0 through 23) representing the hour within the day that contains or begins with the instant in time represented by this Date object, as interpreted in the local time zone.
java.util.Date.getMillisOf	(	Date	): Returns the millisecond value of this Date object without affecting its internal state.
java.util.Date.getMinutes	(	): Returns the number of minutes past the hour represented by this date, as interpreted in the local time zone. The value returned is between 0 and 59.
java.util.Date.getMonth	(	): Returns a number representing the month that contains or begins with the instant in time represented by this Date object. The value returned is between 0 and 11, with the value 0 representing January.
java.util.Date.getSeconds	(	): Returns the number of seconds past the minute represented by this date. The value returned is between 0 and 61. The values 60 and 61 can only occur on those Java Virtual Machines that take leap seconds into account.
java.util.Date.getTime	(	): Returns the number of milliseconds since January 1, 1970, 00:00:00 GMT represented by this Date object.
java.util.Date.getTimezoneOffset	(	): Returns the offset, measured in minutes, for the local time zone relative to UTC that is appropriate for the time represented by this Date object.  For example, in Massachusetts, five time zones west of Greenwich:  new Date(96, 1, 14).getTimezoneOffset() returns 300 because on February 14, 1996, standard time (Eastern Standard Time) is in use, which is offset five hours from UTC; but:  new Date(96, 5, 1).getTimezoneOffset() returns 240 because on June 1, 1996, daylight saving time (Eastern Daylight Time) is in use, which is offset only four hours from UTC. This method produces the same result as if it computed:  (this.getTime() - UTC(this.getYear(), this.getMonth(), this.getDate(), this.getHours(), this.getMinutes(), this.getSeconds())) / (60 * 1000) 
java.util.Date.getYear	(	): Returns a value that is the result of subtracting 1900 from the year that contains or begins with the instant in time represented by this Date object, as interpreted in the local time zone.
java.util.Date.hashCode	(	): Returns a hash code value for this object. The result is the exclusive OR of the two halves of the primitive long value returned by the getTime method. That is, the hash code is the value of the expression: (int)(this.getTime()^(this.getTime() >>> 32))
java.util.Date.parse	(	String	): Attempts to interpret the string s as a representation of a date and time. If the attempt is successful, the time indicated is returned represented as the distance, measured in milliseconds, of that time from the epoch (00:00:00 GMT on January 1, 1970). If the attempt fails, an IllegalArgumentException is thrown.  It accepts many syntaxes; in particular, it recognizes the IETF standard date syntax: "Sat, 12 Aug 1995 13:30:00 GMT". It also understands the continental U.S. time-zone abbreviations, but for general use, a time-zone offset should be used: "Sat, 12 Aug 1995 13:30:00 GMT+0430" (4 hours, 30 minutes west of the Greenwich meridian). If no time zone is specified, the local time zone is assumed. GMT and UTC are considered equivalent.  The string s is processed from left to right, looking for data of interest. Any material in s that is within the ASCII parenthesis characters ( and ) is ignored. Parentheses may be nested. Otherwise, the only characters permitted within s are these ASCII characters:  abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789,+-:/ and whitespace characters. A consecutive sequence of decimal digits is treated as a decimal number: If a number is preceded by + or - and a year has already been recognized, then the number is a time-zone offset. If the number is less than 24, it is an offset measured in hours. Otherwise, it is regarded as an offset in minutes, expressed in 24-hour time format without punctuation. A preceding - means a westward offset. Time zone offsets are always relative to UTC (Greenwich). Thus, for example, -5 occurring in the string would mean "five hours west of Greenwich" and +0430 would mean "four hours and thirty minutes east of Greenwich." It is permitted for the string to specify GMT, UT, or UTC redundantly-for example, GMT-5 or utc+0430. The number is regarded as a year number if one of the following conditions is true:  The number is equal to or greater than 70 and followed by a space, comma, slash, or end of string The number is less than 70, and both a month and a day of the month have already been recognized  If the recognized year number is less than 100, it is interpreted as an abbreviated year relative to a century of which dates are within 80 years before and 19 years after the time when the Date class is initialized. After adjusting the year number, 1900 is subtracted from it. For example, if the current year is 1999 then years in the range 19 to 99 are assumed to mean 1919 to 1999, while years from 0 to 18 are assumed to mean 2000 to 2018. Note that this is slightly different from the interpretation of years less than 100 that is used in java.text.SimpleDateFormat. If the number is followed by a colon, it is regarded as an hour, unless an hour has already been recognized, in which case it is regarded as a minute. If the number is followed by a slash, it is regarded as a month (it is decreased by 1 to produce a number in the range 0 to 11), unless a month has already been recognized, in which case it is regarded as a day of the month. If the number is followed by whitespace, a comma, a hyphen, or end of string, then if an hour has been recognized but not a minute, it is regarded as a minute; otherwise, if a minute has been recognized but not a second, it is regarded as a second; otherwise, it is regarded as a day of the month.  A consecutive sequence of letters is regarded as a word and treated as follows: A word that matches AM, ignoring case, is ignored (but the parse fails if an hour has not been recognized or is less than 1 or greater than 12). A word that matches PM, ignoring case, adds 12 to the hour (but the parse fails if an hour has not been recognized or is less than 1 or greater than 12). Any word that matches any prefix of SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, or SATURDAY, ignoring case, is ignored. For example, sat, Friday, TUE, and Thurs are ignored. Otherwise, any word that matches any prefix of JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, or DECEMBER, ignoring case, and considering them in the order given here, is recognized as specifying a month and is converted to a number (0 to 11). For example, aug, Sept, april, and NOV are recognized as months. So is Ma, which is recognized as MARCH, not MAY. Any word that matches GMT, UT, or UTC, ignoring case, is treated as referring to UTC. Any word that matches EST, CST, MST, or PST, ignoring case, is recognized as referring to the time zone in North America that is five, six, seven, or eight hours west of Greenwich, respectively. Any word that matches EDT, CDT, MDT, or PDT, ignoring case, is recognized as referring to the same time zone, respectively, during daylight saving time. Once the entire string s has been scanned, it is converted to a time result in one of two ways. If a time zone or time-zone offset has been recognized, then the year, month, day of month, hour, minute, and second are interpreted in UTC and then the time-zone offset is applied. Otherwise, the year, month, day of month, hour, minute, and second are interpreted in the local time zone.
java.util.Date.readObject	(	ObjectInputStream	): Reconstitute this object from a stream (i.e., deserialize it).
java.util.Date.setDate	(	int	): Sets the day of the month of this Date object to the specified value. This Date object is modified so that it represents a point in time within the specified day of the month, with the year, month, hour, minute, and second the same as before, as interpreted in the local time zone. If the date was April 30, for example, and the date is set to 31, then it will be treated as if it were on May 1, because April has only 30 days.
java.util.Date.setHours	(	int	): Sets the hour of this Date object to the specified value. This Date object is modified so that it represents a point in time within the specified hour of the day, with the year, month, date, minute, and second the same as before, as interpreted in the local time zone.
java.util.Date.setMinutes	(	int	): Sets the minutes of this Date object to the specified value. This Date object is modified so that it represents a point in time within the specified minute of the hour, with the year, month, date, hour, and second the same as before, as interpreted in the local time zone.
java.util.Date.setMonth	(	int	): Sets the month of this date to the specified value. This Date object is modified so that it represents a point in time within the specified month, with the year, date, hour, minute, and second the same as before, as interpreted in the local time zone. If the date was October 31, for example, and the month is set to June, then the new date will be treated as if it were on July 1, because June has only 30 days.
java.util.Date.setSeconds	(	int	): Sets the seconds of this Date to the specified value. This Date object is modified so that it represents a point in time within the specified second of the minute, with the year, month, date, hour, and minute the same as before, as interpreted in the local time zone.
java.util.Date.setTime	(	long	): Sets this Date object to represent a point in time that is time milliseconds after January 1, 1970 00:00:00 GMT.
java.util.Date.setYear	(	int	): Sets the year of this Date object to be the specified value plus 1900. This Date object is modified so that it represents a point in time within the specified year, with the month, date, hour, minute, and second the same as before, as interpreted in the local time zone. (Of course, if the date was February 29, for example, and the year is set to a non-leap year, then the new date will be treated as if it were on March 1.)
java.util.Date.toGMTString	(	): Creates a string representation of this Date object of the form:  d mon yyyy hh:mm:ss GMT where: d is the day of the month (1 through 31), as one or two decimal digits. mon is the month (Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec). yyyy is the year, as four decimal digits. hh is the hour of the day (00 through 23), as two decimal digits. mm is the minute within the hour (00 through 59), as two decimal digits. ss is the second within the minute (00 through 61), as two decimal digits. GMT is exactly the ASCII letters "GMT" to indicate Greenwich Mean Time.  The result does not depend on the local time zone.
java.util.Date.toInstant	(	): Converts this Date object to an Instant.  The conversion creates an Instant that represents the same point on the time-line as this Date.
java.util.Date.toLocaleString	(	): Creates a string representation of this Date object in an implementation-dependent form. The intent is that the form should be familiar to the user of the Java application, wherever it may happen to be running. The intent is comparable to that of the "%c" format supported by the strftime() function of ISO C.
java.util.Date.toString	(	): Converts this Date object to a String of the form:  dow mon dd hh:mm:ss zzz yyyy where: dow is the day of the week (Sun, Mon, Tue, Wed, Thu, Fri, Sat). mon is the month (Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec). dd is the day of the month (01 through 31), as two decimal digits. hh is the hour of the day (00 through 23), as two decimal digits. mm is the minute within the hour (00 through 59), as two decimal digits. ss is the second within the minute (00 through 61, as two decimal digits. zzz is the time zone (and may reflect daylight saving time). Standard time zone abbreviations include those recognized by the method parse. If time zone information is not available, then zzz is empty - that is, it consists of no characters at all. yyyy is the year, as four decimal digits. 
java.util.Date.writeObject	(	ObjectOutputStream	): Save the state of this object to a stream (i.e., serialize it).
java.util.Deque: A linear collection that supports element insertion and removal at both ends. The name deque is short for "double ended queue" and is usually pronounced "deck". Most Deque implementations place no fixed limits on the number of elements they may contain, but this interface supports capacity-restricted deques as well as those with no fixed size limit. This interface defines methods to access the elements at both ends of the deque. Methods are provided to insert, remove, and examine the element. Each of these methods exists in two forms: one throws an exception if the operation fails, the other returns a special value (either null or false, depending on the operation). The latter form of the insert operation is designed specifically for use with capacity-restricted Deque implementations; in most implementations, insert operations cannot fail. The twelve methods described above are summarized in the following table:  Summary of Deque methods    First Element (Head)  Last Element (Tail)    Throws exception Special value Throws exception Special value   Insert addFirst addFirst(e) offerFirst offerFirst(e) addLast addLast(e) offerLast offerLast(e)   Remove removeFirst removeFirst() pollFirst pollFirst() removeLast removeLast() pollLast pollLast()   Examine getFirst getFirst() peekFirst peekFirst() getLast getLast() peekLast peekLast()   This interface extends the Queue interface. When a deque is used as a queue, FIFO (First-In-First-Out) behavior results. Elements are added at the end of the deque and removed from the beginning. The methods inherited from the Queue interface are precisely equivalent to Deque methods as indicated in the following table:  Comparison of Queue and Deque methods   Queue Method  Equivalent Deque Method   add add(e) addLast addLast(e)   offer offer(e) offerLast offerLast(e)   remove remove() removeFirst removeFirst()   poll poll() pollFirst pollFirst()   element element() getFirst getFirst()   peek peek() peek peekFirst()   Deques can also be used as LIFO (Last-In-First-Out) stacks. This interface should be used in preference to the legacy Stack class. When a deque is used as a stack, elements are pushed and popped from the beginning of the deque. Stack methods are precisely equivalent to Deque methods as indicated in the table below:  Comparison of Stack and Deque methods   Stack Method  Equivalent Deque Method   push push(e) addFirst addFirst(e)   pop pop() removeFirst removeFirst()   peek peek() peekFirst peekFirst()   Note that the peek method works equally well when a deque is used as a queue or a stack; in either case, elements are drawn from the beginning of the deque. This interface provides two methods to remove interior elements, removeFirstOccurrence and removeLastOccurrence. Unlike the List interface, this interface does not provide support for indexed access to elements. While Deque implementations are not strictly required to prohibit the insertion of null elements, they are strongly encouraged to do so. Users of any Deque implementations that do allow null elements are strongly encouraged not to take advantage of the ability to insert nulls. This is so because null is used as a special return value by various methods to indicated that the deque is empty. Deque implementations generally do not define element-based versions of the equals and hashCode methods, but instead inherit the identity-based versions from class Object. This interface is a member of the  Java Collections Framework.
java.util.Deque.add	(	E	): Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque) if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an IllegalStateException if no space is currently available. When using a capacity-restricted deque, it is generally preferable to use offer(). This method is equivalent to addLast.
java.util.Deque.addFirst	(	E	): Inserts the specified element at the front of this deque if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available. When using a capacity-restricted deque, it is generally preferable to use method offerFirst.
java.util.Deque.addLast	(	E	): Inserts the specified element at the end of this deque if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available. When using a capacity-restricted deque, it is generally preferable to use method offerLast. This method is equivalent to add.
java.util.Deque.contains	(	Object	): Returns true if this deque contains the specified element. More formally, returns true if and only if this deque contains at least one element e such that (o==null ? e==null : o.equals(e)).
java.util.Deque.descendingIterator	(	): Returns an iterator over the elements in this deque in reverse sequential order. The elements will be returned in order from last (tail) to first (head).
java.util.Deque.element	(	): Retrieves, but does not remove, the head of the queue represented by this deque (in other words, the first element of this deque). This method differs from peek only in that it throws an exception if this deque is empty. This method is equivalent to getFirst().
java.util.Deque.getFirst	(	): Retrieves, but does not remove, the first element of this deque. This method differs from peekFirst only in that it throws an exception if this deque is empty.
java.util.Deque.getLast	(	): Retrieves, but does not remove, the last element of this deque. This method differs from peekLast only in that it throws an exception if this deque is empty.
java.util.Deque.iterator	(	): Returns an iterator over the elements in this deque in proper sequence. The elements will be returned in order from first (head) to last (tail).
java.util.Deque.offer	(	E	): Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque) if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available. When using a capacity-restricted deque, this method is generally preferable to the add method, which can fail to insert an element only by throwing an exception. This method is equivalent to offerLast.
java.util.Deque.offerFirst	(	E	): Inserts the specified element at the front of this deque unless it would violate capacity restrictions. When using a capacity-restricted deque, this method is generally preferable to the addFirst method, which can fail to insert an element only by throwing an exception.
java.util.Deque.offerLast	(	E	): Inserts the specified element at the end of this deque unless it would violate capacity restrictions. When using a capacity-restricted deque, this method is generally preferable to the addLast method, which can fail to insert an element only by throwing an exception.
java.util.Deque.peek	(	): Retrieves, but does not remove, the head of the queue represented by this deque (in other words, the first element of this deque), or returns null if this deque is empty. This method is equivalent to peekFirst().
java.util.Deque.peekFirst	(	): Retrieves, but does not remove, the first element of this deque, or returns null if this deque is empty.
java.util.Deque.peekLast	(	): Retrieves, but does not remove, the last element of this deque, or returns null if this deque is empty.
java.util.Deque.poll	(	): Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque), or returns null if this deque is empty. This method is equivalent to pollFirst().
java.util.Deque.pollFirst	(	): Retrieves and removes the first element of this deque, or returns null if this deque is empty.
java.util.Deque.pollLast	(	): Retrieves and removes the last element of this deque, or returns null if this deque is empty.
java.util.Deque.pop	(	): Pops an element from the stack represented by this deque. In other words, removes and returns the first element of this deque. This method is equivalent to removeFirst().
java.util.Deque.push	(	E	): Pushes an element onto the stack represented by this deque (in other words, at the head of this deque) if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available. This method is equivalent to addFirst.
java.util.Deque.remove	(	): Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque). This method differs from poll only in that it throws an exception if this deque is empty. This method is equivalent to removeFirst().
java.util.Deque.remove	(	Object	): Removes the first occurrence of the specified element from this deque. If the deque does not contain the element, it is unchanged. More formally, removes the first element e such that (o==null ? e==null : o.equals(e)) (if such an element exists). Returns true if this deque contained the specified element (or equivalently, if this deque changed as a result of the call). This method is equivalent to removeFirstOccurrence().
java.util.Deque.removeFirst	(	): Retrieves and removes the first element of this deque. This method differs from pollFirst only in that it throws an exception if this deque is empty.
java.util.Deque.removeFirstOccurrence	(	Object	): Removes the first occurrence of the specified element from this deque. If the deque does not contain the element, it is unchanged. More formally, removes the first element e such that (o==null ? e==null : o.equals(e)) (if such an element exists). Returns true if this deque contained the specified element (or equivalently, if this deque changed as a result of the call).
java.util.Deque.removeLast	(	): Retrieves and removes the last element of this deque. This method differs from pollLast only in that it throws an exception if this deque is empty.
java.util.Deque.removeLastOccurrence	(	Object	): Removes the last occurrence of the specified element from this deque. If the deque does not contain the element, it is unchanged. More formally, removes the last element e such that (o==null ? e==null : o.equals(e)) (if such an element exists). Returns true if this deque contained the specified element (or equivalently, if this deque changed as a result of the call).
java.util.Deque.size	(	): Returns the number of elements in this deque.
java.util.Dictionary: The Dictionary class is the abstract parent of any class, such as Hashtable, which maps keys to values. Every key and every value is an object. In any one Dictionary object, every key is associated with at most one value. Given a Dictionary and a key, the associated element can be looked up. Any non-null object can be used as a key and as a value.  As a rule, the equals method should be used by implementations of this class to decide if two keys are the same.  NOTE: This class is obsolete. New implementations should implement the Map interface, rather than extending this class.
java.util.Dictionary.Dictionary	(	): Sole constructor. (For invocation by subclass constructors, typically implicit.)
java.util.Dictionary.elements	(	): Returns an enumeration of the values in this dictionary. The general contract for the elements method is that an Enumeration is returned that will generate all the elements contained in entries in this dictionary.
java.util.Dictionary.get	(	Object	): Returns the value to which the key is mapped in this dictionary. The general contract for the isEmpty method is that if this dictionary contains an entry for the specified key, the associated value is returned; otherwise, null is returned.
java.util.Dictionary.isEmpty	(	): Tests if this dictionary maps no keys to value. The general contract for the isEmpty method is that the result is true if and only if this dictionary contains no entries.
java.util.Dictionary.keys	(	): Returns an enumeration of the keys in this dictionary. The general contract for the keys method is that an Enumeration object is returned that will generate all the keys for which this dictionary contains entries.
java.util.Dictionary.put	(	K	V	): Maps the specified key to the specified value in this dictionary. Neither the key nor the value can be null.  If this dictionary already contains an entry for the specified key, the value already in this dictionary for that key is returned, after modifying the entry to contain the new element. If this dictionary does not already have an entry for the specified key, an entry is created for the specified key and value, and null is returned.  The value can be retrieved by calling the get method with a key that is equal to the original key.
java.util.Dictionary.remove	(	Object	): Removes the key (and its corresponding value) from this dictionary. This method does nothing if the key is not in this dictionary.
java.util.Dictionary.size	(	): Returns the number of entries (distinct keys) in this dictionary.
java.util.DoubleSummaryStatistics: A state object for collecting statistics such as count, min, max, sum, and average. This class is designed to work with (though does not require) java.util.stream streams. For example, you can compute summary statistics on a stream of doubles with:  DoubleSummaryStatistics stats = doubleStream.collect(DoubleSummaryStatistics::new, DoubleSummaryStatistics::accept, DoubleSummaryStatistics::combine); DoubleSummaryStatistics can be used as a collect() reduction target for a java.util.stream.Stream stream. For example:  DoubleSummaryStatistics stats = people.stream() .collect(Collectors.summarizingDouble(Person::getWeight)); This computes, in a single pass, the count of people, as well as the minimum, maximum, sum, and average of their weights.
java.util.DoubleSummaryStatistics.DoubleSummaryStatistics	(	): Construct an empty instance with zero count, zero sum, Double.POSITIVE_INFINITY min, Double.NEGATIVE_INFINITY max and zero average.
java.util.DoubleSummaryStatistics.accept	(	double	): Records another value into the summary information.
java.util.DoubleSummaryStatistics.combine	(	DoubleSummaryStatistics	): Combines the state of another DoubleSummaryStatistics into this one.
java.util.DoubleSummaryStatistics.getAverage	(	): Returns the arithmetic mean of values recorded, or zero if no values have been recorded. If any recorded value is a NaN or the sum is at any point a NaN then the average will be code NaN. The average returned can vary depending upon the order in which values are recorded. This method may be implemented using compensated summation or other technique to reduce the error bound in the getSum numerical sum used to compute the average.
java.util.DoubleSummaryStatistics.getCount	(	): Return the count of values recorded.
java.util.DoubleSummaryStatistics.getMax	(	): Returns the maximum recorded value, Double.NaN if any recorded value was NaN or Double.NEGATIVE_INFINITY if no values were recorded. Unlike the numerical comparison operators, this method considers negative zero to be strictly smaller than positive zero.
java.util.DoubleSummaryStatistics.getMin	(	): Returns the minimum recorded value, Double.NaN if any recorded value was NaN or Double.POSITIVE_INFINITY if no values were recorded. Unlike the numerical comparison operators, this method considers negative zero to be strictly smaller than positive zero.
java.util.DoubleSummaryStatistics.getSum	(	): Returns the sum of values recorded, or zero if no values have been recorded. If any recorded value is a NaN or the sum is at any point a NaN then the sum will be NaN.  The value of a floating-point sum is a function both of the input values as well as the order of addition operations. The order of addition operations of this method is intentionally not defined to allow for implementation flexibility to improve the speed and accuracy of the computed result. In particular, this method may be implemented using compensated summation or other technique to reduce the error bound in the numerical sum compared to a simple summation of double values.
java.util.DoubleSummaryStatistics.sumWithCompensation	(	double	): Incorporate a new double value using Kahan summation / compensated summation.
java.util.DoubleSummaryStatistics.toString	(	):  Returns a non-empty string representation of this object suitable for debugging. The exact presentation format is unspecified and may vary between implementations and versions.
java.util.DualPivotQuicksort: This class implements the Dual-Pivot Quicksort algorithm by Vladimir Yaroslavskiy, Jon Bentley, and Josh Bloch. The algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. All exposed methods are package-private, designed to be invoked from public methods (in class Arrays) after performing any necessary array bounds checks and expanding parameters into the required forms.
java.util.DualPivotQuicksort.DualPivotQuicksort	(	): Prevents instantiation.
java.util.DualPivotQuicksort.doSort	(	char[]	int	int	char[]	int	int	): Sorts the specified range of the array.
java.util.DualPivotQuicksort.doSort	(	double[]	int	int	double[]	int	int	): Sorts the specified range of the array.
java.util.DualPivotQuicksort.doSort	(	float[]	int	int	float[]	int	int	): Sorts the specified range of the array.
java.util.DualPivotQuicksort.doSort	(	short[]	int	int	short[]	int	int	): Sorts the specified range of the array.
java.util.DualPivotQuicksort.sort	(	byte[]	int	int	): Sorts the specified range of the array.
java.util.DualPivotQuicksort.sort	(	char[]	int	int	boolean	): Sorts the specified range of the array by Dual-Pivot Quicksort.
java.util.DualPivotQuicksort.sort	(	char[]	int	int	char[]	int	int	): Sorts the specified range of the array using the given workspace array slice if possible for merging
java.util.DualPivotQuicksort.sort	(	double[]	int	int	boolean	): Sorts the specified range of the array by Dual-Pivot Quicksort.
java.util.DualPivotQuicksort.sort	(	double[]	int	int	double[]	int	int	): Sorts the specified range of the array using the given workspace array slice if possible for merging
java.util.DualPivotQuicksort.sort	(	float[]	int	int	boolean	): Sorts the specified range of the array by Dual-Pivot Quicksort.
java.util.DualPivotQuicksort.sort	(	float[]	int	int	float[]	int	int	): Sorts the specified range of the array using the given workspace array slice if possible for merging
java.util.DualPivotQuicksort.sort	(	int[]	int	int	boolean	): Sorts the specified range of the array by Dual-Pivot Quicksort.
java.util.DualPivotQuicksort.sort	(	int[]	int	int	int[]	int	int	): Sorts the specified range of the array using the given workspace array slice if possible for merging
java.util.DualPivotQuicksort.sort	(	long[]	int	int	boolean	): Sorts the specified range of the array by Dual-Pivot Quicksort.
java.util.DualPivotQuicksort.sort	(	long[]	int	int	long[]	int	int	): Sorts the specified range of the array using the given workspace array slice if possible for merging
java.util.DualPivotQuicksort.sort	(	short[]	int	int	boolean	): Sorts the specified range of the array by Dual-Pivot Quicksort.
java.util.DualPivotQuicksort.sort	(	short[]	int	int	short[]	int	int	): Sorts the specified range of the array using the given workspace array slice if possible for merging
java.util.DuplicateFormatFlagsException: Unchecked exception thrown when duplicate flags are provided in the format specifier.  Unless otherwise specified, passing a null argument to any method or constructor in this class will cause a NullPointerException to be thrown.
java.util.DuplicateFormatFlagsException.DuplicateFormatFlagsException	(	String	): Constructs an instance of this class with the specified flags.
java.util.DuplicateFormatFlagsException.getFlags	(	): Returns the set of flags which contains a duplicate flag.
java.util.EmptyStackException: Thrown by methods in the Stack class to indicate that the stack is empty.
java.util.EmptyStackException.EmptyStackException	(	): Constructs a new EmptyStackException with null as its error message string.
java.util.EnumMap: A specialized Map implementation for use with enum type keys. All of the keys in an enum map must come from a single enum type that is specified, explicitly or implicitly, when the map is created. Enum maps are represented internally as arrays. This representation is extremely compact and efficient. Enum maps are maintained in the natural order of their keys (the order in which the enum constants are declared). This is reflected in the iterators returned by the collections views (keySet(), entrySet(), and values()). Iterators returned by the collection views are weakly consistent: they will never throw ConcurrentModificationException and they may or may not show the effects of any modifications to the map that occur while the iteration is in progress. Null keys are not permitted. Attempts to insert a null key will throw NullPointerException. Attempts to test for the presence of a null key or to remove one will, however, function properly. Null values are permitted. Like most collection implementations EnumMap is not synchronized. If multiple threads access an enum map concurrently, and at least one of the threads modifies the map, it should be synchronized externally. This is typically accomplished by synchronizing on some object that naturally encapsulates the enum map. If no such object exists, the map should be "wrapped" using the synchronizedMap method. This is best done at creation time, to prevent accidental unsynchronized access:  Map<EnumKey, V> m = Collections.synchronizedMap(new EnumMap<EnumKey, V>(...));  Implementation note: All basic operations execute in constant time. They are likely (though not guaranteed) to be faster than their HashMap counterparts. This class is a member of the  Java Collections Framework.
java.util.EnumMap.EnumMap	(	Class	): Creates an empty enum map with the specified key type.
java.util.EnumMap.EnumMap	(	EnumMap	): Creates an enum map with the same key type as the specified enum map, initially containing the same mappings (if any).
java.util.EnumMap.EnumMap	(	Map	): Creates an enum map initialized from the specified map. If the specified map is an EnumMap instance, this constructor behaves identically to EnumMap(). Otherwise, the specified map must contain at least one mapping (in order to determine the new enum map's key type).
java.util.EnumMap.clear	(	): Removes all mappings from this map.
java.util.EnumMap.clone	(	): Returns a shallow copy of this enum map. (The values themselves are not cloned.
java.util.EnumMap.containsKey	(	Object	): Returns true if this map contains a mapping for the specified key.
java.util.EnumMap.containsValue	(	Object	): Returns true if this map maps one or more keys to the specified value.
java.util.EnumMap.entrySet	(	): Returns a Set view of the mappings contained in this map. The returned set obeys the general contract outlined in keySet(). The set's iterator will return the mappings in the order their keys appear in map, which is their natural order (the order in which the enum constants are declared).
java.util.EnumMap.equals	(	Object	): Compares the specified object with this map for equality. Returns true if the given object is also a map and the two maps represent the same mappings, as specified in the equals() contract.
java.util.EnumMap.get	(	Object	): Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that (key == k), then this method returns v; otherwise it returns null. (There can be at most one such mapping.) A return value of null does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to null. The containsKey operation may be used to distinguish these two cases.
java.util.EnumMap.getKeyUniverse	(	Class	): Returns all of the values comprising K. The result is uncloned, cached, and shared by all callers.
java.util.EnumMap.hashCode	(	): Returns the hash code value for this map. The hash code of a map is defined to be the sum of the hash codes of each entry in the map.
java.util.EnumMap.isValidKey	(	Object	): Returns true if key is of the proper type to be a key in this enum map.
java.util.EnumMap.keySet	(	): Returns a Set view of the keys contained in this map. The returned set obeys the general contract outlined in keySet(). The set's iterator will return the keys in their natural order (the order in which the enum constants are declared).
java.util.EnumMap.put	(	K	V	): Associates the specified value with the specified key in this map. If the map previously contained a mapping for this key, the old value is replaced.
java.util.EnumMap.putAll	(	Map	): Copies all of the mappings from the specified map to this map. These mappings will replace any mappings that this map had for any of the keys currently in the specified map.
java.util.EnumMap.readObject	(	java.io.ObjectInputStream	): Reconstitute the EnumMap instance from a stream (i.e., deserialize it).
java.util.EnumMap.remove	(	Object	): Removes the mapping for this key from this map if present.
java.util.EnumMap.size	(	): Returns the number of key-value mappings in this map.
java.util.EnumMap.typeCheck	(	K	): Throws an exception if e is not of the correct type for this enum set.
java.util.EnumMap.values	(	): Returns a Collection view of the values contained in this map. The returned collection obeys the general contract outlined in values(). The collection's iterator will return the values in the order their corresponding keys appear in map, which is their natural order (the order in which the enum constants are declared).
java.util.EnumMap.writeObject	(	java.io.ObjectOutputStream	): Save the state of the EnumMap instance to a stream (i.e., serialize it).
java.util.EnumSet: A specialized Set implementation for use with enum types. All of the elements in an enum set must come from a single enum type that is specified, explicitly or implicitly, when the set is created. Enum sets are represented internally as bit vectors. This representation is extremely compact and efficient. The space and time performance of this class should be good enough to allow its use as a high-quality, typesafe alternative to traditional int-based "bit flags." Even bulk operations (such as containsAll and retainAll) should run very quickly if their argument is also an enum set. The iterator returned by the iterator method traverses the elements in their natural order (the order in which the enum constants are declared). The returned iterator is weakly consistent: it will never throw ConcurrentModificationException and it may or may not show the effects of any modifications to the set that occur while the iteration is in progress. Null elements are not permitted. Attempts to insert a null element will throw NullPointerException. Attempts to test for the presence of a null element or to remove one will, however, function properly. Like most collection implementations, EnumSet is not synchronized. If multiple threads access an enum set concurrently, and at least one of the threads modifies the set, it should be synchronized externally. This is typically accomplished by synchronizing on some object that naturally encapsulates the enum set. If no such object exists, the set should be "wrapped" using the synchronizedSet method. This is best done at creation time, to prevent accidental unsynchronized access:  Set<MyEnum> s = Collections.synchronizedSet(EnumSet.noneOf(MyEnum.class));  Implementation note: All basic operations execute in constant time. They are likely (though not guaranteed) to be much faster than their HashSet counterparts. Even bulk operations execute in constant time if their argument is also an enum set. This class is a member of the  Java Collections Framework.
java.util.EnumSet.SerializationProxy: This class is used to serialize all EnumSet instances, regardless of implementation type. It captures their "logical contents" and they are reconstructed using public static factories. This is necessary to ensure that the existence of a particular implementation type is an implementation detail.
java.util.EnumSet.addAll	(	): Adds all of the elements from the appropriate enum type to this enum set, which is empty prior to the call.
java.util.EnumSet.addRange	(	E	E	): Adds the specified range to this enum set, which is empty prior to the call.
java.util.EnumSet.allOf	(	Class	): Creates an enum set containing all of the elements in the specified element type.
java.util.EnumSet.clone	(	): Returns a copy of this set.
java.util.EnumSet.complement	(	): Complements the contents of this enum set.
java.util.EnumSet.complementOf	(	EnumSet	): Creates an enum set with the same element type as the specified enum set, initially containing all the elements of this type that are not contained in the specified set.
java.util.EnumSet.copyOf	(	Collection	): Creates an enum set initialized from the specified collection. If the specified collection is an EnumSet instance, this static factory method behaves identically to copyOf(). Otherwise, the specified collection must contain at least one element (in order to determine the new enum set's element type).
java.util.EnumSet.copyOf	(	EnumSet	): Creates an enum set with the same element type as the specified enum set, initially containing the same elements (if any).
java.util.EnumSet.getUniverse	(	Class	): Returns all of the values comprising E. The result is uncloned, cached, and shared by all callers.
java.util.EnumSet.noneOf	(	Class	): Creates an empty enum set with the specified element type.
java.util.EnumSet.of	(	E	): Creates an enum set initially containing the specified element. Overloadings of this method exist to initialize an enum set with one through five elements. A sixth overloading is provided that uses the varargs feature. This overloading may be used to create an enum set initially containing an arbitrary number of elements, but is likely to run slower than the overloadings that do not use varargs.
java.util.EnumSet.of	(	E	E	): Creates an enum set initially containing the specified elements. This factory, whose parameter list uses the varargs feature, may be used to create an enum set initially containing an arbitrary number of elements, but it is likely to run slower than the overloadings that do not use varargs.
java.util.EnumSet.of	(	E	E	E	): Creates an enum set initially containing the specified elements. Overloadings of this method exist to initialize an enum set with one through five elements. A sixth overloading is provided that uses the varargs feature. This overloading may be used to create an enum set initially containing an arbitrary number of elements, but is likely to run slower than the overloadings that do not use varargs.
java.util.EnumSet.of	(	E	E	E	E	): Creates an enum set initially containing the specified elements. Overloadings of this method exist to initialize an enum set with one through five elements. A sixth overloading is provided that uses the varargs feature. This overloading may be used to create an enum set initially containing an arbitrary number of elements, but is likely to run slower than the overloadings that do not use varargs.
java.util.EnumSet.of	(	E	E	E	E	E	): Creates an enum set initially containing the specified elements. Overloadings of this method exist to initialize an enum set with one through five elements. A sixth overloading is provided that uses the varargs feature. This overloading may be used to create an enum set initially containing an arbitrary number of elements, but is likely to run slower than the overloadings that do not use varargs.
java.util.EnumSet.range	(	E	E	): Creates an enum set initially containing all of the elements in the range defined by the two specified endpoints. The returned set will contain the endpoints themselves, which may be identical but must not be out of order.
java.util.EnumSet.typeCheck	(	E	): Throws an exception if e is not of the correct type for this enum set.
java.util.Enumeration: An object that implements the Enumeration interface generates a series of elements, one at a time. Successive calls to the nextElement method return successive elements of the series.  For example, to print all elements of a Vector<E> v:  for (Enumeration<E> e = v.elements(); e.hasMoreElements();) System.out.println(e.nextElement());  Methods are provided to enumerate through the elements of a vector, the keys of a hashtable, and the values in a hashtable. Enumerations are also used to specify the input streams to a SequenceInputStream.  NOTE: The functionality of this interface is duplicated by the Iterator interface. In addition, Iterator adds an optional remove operation, and has shorter method names. New implementations should consider using Iterator in preference to Enumeration.
java.util.Enumeration.hasMoreElements	(	): Tests if this enumeration contains more elements.
java.util.Enumeration.nextElement	(	): Returns the next element of this enumeration if this enumeration object has at least one more element to provide.
java.util.EventListener: A tagging interface that all event listener interfaces must extend.
java.util.EventListenerProxy: An abstract wrapper class for an EventListener class which associates a set of additional parameters with the listener. Subclasses must provide the storage and accessor methods for the additional arguments or parameters.  For example, a bean which supports named properties would have a two argument method signature for adding a PropertyChangeListener for a property:  public void addPropertyChangeListener(String propertyName, PropertyChangeListener listener)  If the bean also implemented the zero argument get listener method:  public PropertyChangeListener[] getPropertyChangeListeners()  then the array may contain inner PropertyChangeListeners which are also PropertyChangeListenerProxy objects.  If the calling method is interested in retrieving the named property then it would have to test the element to see if it is a proxy class.
java.util.EventListenerProxy.EventListenerProxy	(	T	): Creates a proxy for the specified listener.
java.util.EventListenerProxy.getListener	(	): Returns the listener associated with the proxy.
java.util.EventObject:  The root class from which all event state objects shall be derived.  All Events are constructed with a reference to the object, the "source", that is logically deemed to be the object upon which the Event in question initially occurred upon.
java.util.EventObject.EventObject	(	Object	): Constructs a prototypical Event.
java.util.EventObject.getSource	(	): The object on which the Event initially occurred.
java.util.EventObject.toString	(	): Returns a String representation of this EventObject.
java.util.FormatFlagsConversionMismatchException: Unchecked exception thrown when a conversion and flag are incompatible.  Unless otherwise specified, passing a null argument to any method or constructor in this class will cause a NullPointerException to be thrown.
java.util.FormatFlagsConversionMismatchException.FormatFlagsConversionMismatchException	(	String	char	): Constructs an instance of this class with the specified flag and conversion.
java.util.FormatFlagsConversionMismatchException.getConversion	(	): Returns the incompatible conversion.
java.util.FormatFlagsConversionMismatchException.getFlags	(	): Returns the incompatible flag.
java.util.Formattable: The Formattable interface must be implemented by any class that needs to perform custom formatting using the 's' conversion specifier of java.util.Formatter. This interface allows basic control for formatting arbitrary objects. For example, the following class prints out different representations of a stock's name depending on the flags and length constraints: import java.nio.CharBuffer; import java.util.Formatter; import java.util.Formattable; import java.util.Locale; import static java.util.FormattableFlags.*; ... public class StockName implements Formattable private String symbol, companyName, frenchCompanyName; public StockName(String symbol, String companyName, String frenchCompanyName) { ... } ... public void formatTo(Formatter fmt, int f, int width, int precision) { StringBuilder sb = new StringBuilder(); // decide form of name String name = companyName; if (fmt.locale().equals(Locale.FRANCE)) name = frenchCompanyName; boolean alternate = (f & ALTERNATE) == ALTERNATE; boolean usesymbol = alternate || (precision != -1 && precision < 10); String out = (usesymbol ? symbol : name); // apply precision if (precision == -1 || out.length() < precision) { // write it all sb.append(out); } else { sb.append(out.substring(0, precision - 1)).append('*'); } // apply width and justification int len = sb.length(); if (len < width) for (int i = 0; i < width - len; i++) if ((f & LEFT_JUSTIFY) == LEFT_JUSTIFY) sb.append(' '); else sb.insert(0, ' '); fmt.format(sb.toString()); } public String toString() { return String.format("%s - %s", symbol, companyName); } } }  When used in conjunction with the java.util.Formatter, the above class produces the following output for various format strings. Formatter fmt = new Formatter(); StockName sn = new StockName("HUGE", "Huge Fruit, Inc.", "Fruit Titanesque, Inc."); fmt.format("%s", sn); // -> "Huge Fruit, Inc." fmt.format("%s", sn.toString()); // -> "HUGE - Huge Fruit, Inc." fmt.format("%#s", sn); // -> "HUGE" fmt.format("%-10.8s", sn); // -> "HUGE " fmt.format("%.12s", sn); // -> "Huge Fruit,*" fmt.format(Locale.FRANCE, "%25s", sn); // -> " Fruit Titanesque, Inc."  Formattables are not necessarily safe for multithreaded access. Thread safety is optional and may be enforced by classes that extend and implement this interface.  Unless otherwise specified, passing a null argument to any method in this interface will cause a NullPointerException to be thrown.
java.util.Formattable.formatTo	(	Formatter	int	int	int	): Formats the object using the provided Formatter formatter.
java.util.FormattableFlags: FomattableFlags are passed to the formatTo Formattable.formatTo() method and modify the output format for Formattable Formattables. Implementations of Formattable are responsible for interpreting and validating any flags.
java.util.Formatter: An interpreter for printf-style format strings. This class provides support for layout justification and alignment, common formats for numeric, string, and date/time data, and locale-specific output. Common Java types such as byte, java.math.BigDecimal BigDecimal, and Calendar are supported. Limited formatting customization for arbitrary user types is provided through the Formattable interface.  Formatters are not necessarily safe for multithreaded access. Thread safety is optional and is the responsibility of users of methods in this class.  Formatted printing for the Java language is heavily inspired by C's printf. Although the format strings are similar to C, some customizations have been made to accommodate the Java language and exploit some of its features. Also, Java formatting is more strict than C's; for example, if a conversion is incompatible with a flag, an exception will be thrown. In C inapplicable flags are silently ignored. The format strings are thus intended to be recognizable to C programmers but not necessarily completely compatible with those in C.  Examples of expected usage:  StringBuilder sb = new StringBuilder(); // Send all output to the Appendable object sb Formatter formatter = new Formatter(sb, Locale.US); // Explicit argument indices may be used to re-order output. formatter.format("%4$2s %3$2s %2$2s %1$2s", "a", "b", "c", "d") // -> " d c b a" // Optional locale as the first argument can be used to get // locale-specific formatting of numbers. The precision and width can be // given to round and align the value. formatter.format(Locale.FRANCE, "e = %+10.4f", Math.E); // -> "e = +2,7183" // The '(' numeric flag may be used to format negative numbers with // parentheses rather than a minus sign. Group separators are // automatically inserted. formatter.format("Amount gained or lost since last statement: $ %(,.2f", balanceDelta); // -> "Amount gained or lost since last statement: $ (6,217.58)"   Convenience methods for common formatting requests exist as illustrated by the following invocations:  // Writes a formatted string to System.out. System.out.format("Local time: %tT", Calendar.getInstance()); // -> "Local time: 13:34:18" // Writes formatted output to System.err. System.err.printf("Unable to open file '%1$s': %2$s", fileName, exception.getMessage()); // -> "Unable to open file 'food': No such file or directory"   Like C's sprintf(3), Strings may be formatted using the static method format() String.format:  // Format a string containing a date. import java.util.Calendar; import java.util.GregorianCalendar; import static java.util.Calendar.*; Calendar c = new GregorianCalendar(1995, MAY, 23); String s = String.format("Duke's Birthday: %1$tb %1$te, %1$tY", c); // -> s == "Duke's Birthday: May 23, 1995"  Organization  This specification is divided into two sections. The first section, Summary, covers the basic formatting concepts. This section is intended for users who want to get started quickly and are familiar with formatted printing in other programming languages. The second section, Details, covers the specific implementation details. It is intended for users who want more precise specification of formatting behavior. Summary  This section is intended to provide a brief overview of formatting concepts. For precise behavioral details, refer to the Details section. Format String Syntax  Every method which produces formatted output requires a format string and an argument list. The format string is a String which may contain fixed text and one or more embedded format specifiers. Consider the following example:  Calendar c = ...; String s = String.format("Duke's Birthday: %1$tm %1$te,%1$tY", c);  This format string is the first argument to the format method. It contains three format specifiers "%1$tm", "%1$te", and "%1$tY" which indicate how the arguments should be processed and where they should be inserted in the text. The remaining portions of the format string are fixed text including "Dukes Birthday: " and any other spaces or punctuation. The argument list consists of all arguments passed to the method after the format string. In the above example, the argument list is of size one and consists of the java.util.Calendar Calendar object c.   The format specifiers for general, character, and numeric types have the following syntax:  %[argument_index$][flags][width][.precision]conversion   The optional argument_index is a decimal integer indicating the position of the argument in the argument list. The first argument is referenced by "1$", the second by "2$", etc.  The optional flags is a set of characters that modify the output format. The set of valid flags depends on the conversion.  The optional width is a positive decimal integer indicating the minimum number of characters to be written to the output.  The optional precision is a non-negative decimal integer usually used to restrict the number of characters. The specific behavior depends on the conversion.  The required conversion is a character indicating how the argument should be formatted. The set of valid conversions for a given argument depends on the argument's data type.  The format specifiers for types which are used to represents dates and times have the following syntax:  %[argument_index$][flags][width]conversion   The optional argument_index, flags and width are defined as above.  The required conversion is a two character sequence. The first character is 't' or 'T'. The second character indicates the format to be used. These characters are similar to but not completely identical to those defined by GNU date and POSIX strftime(3c).  The format specifiers which do not correspond to arguments have the following syntax:  %[flags][width]conversion   The optional flags and width is defined as above.  The required conversion is a character indicating content to be inserted in the output.   Conversions   Conversions are divided into the following categories:   General - may be applied to any argument type  Character - may be applied to basic types which represent Unicode characters: char, Character, byte, Byte, short, and Short. This conversion may also be applied to the types int and Integer when isValidCodePoint returns true  Numeric   Integral - may be applied to Java integral types: byte, Byte, short, Short, int and Integer, long, Long, and java.math.BigInteger BigInteger (but not char or Character) Floating Point - may be applied to Java floating-point types: float, Float, double, Double, and java.math.BigDecimal BigDecimal   Date/Time - may be applied to Java types which are capable of encoding a date or time: long, Long, Calendar, Date and TemporalAccessor TemporalAccessor  Percent - produces a literal '%' ('\u0025')  Line Separator - produces the platform-specific line separator   The following table summarizes the supported conversions. Conversions denoted by an upper-case character (i.e. 'B', 'H', 'S', 'C', 'X', 'E', 'G', 'A', and 'T') are the same as those for the corresponding lower-case conversion characters except that the result is converted to upper case according to the rules of the prevailing java.util.Locale Locale. The result is equivalent to the following invocation of toUpperCase()  out.toUpperCase()    Conversion  Argument Category  Description  'b', 'B'  general  If the argument arg is null, then the result is "false". If arg is a boolean or Boolean, then the result is the string returned by valueOf() String.valueOf(arg). Otherwise, the result is "true".  'h', 'H'  general  If the argument arg is null, then the result is "null". Otherwise, the result is obtained by invoking Integer.toHexString(arg.hashCode()).  's', 'S'  general  If the argument arg is null, then the result is "null". If arg implements Formattable, then formatTo arg.formatTo is invoked. Otherwise, the result is obtained by invoking arg.toString(). 'c', 'C'  character  The result is a Unicode character 'd'  integral  The result is formatted as a decimal integer 'o'  integral  The result is formatted as an octal integer 'x', 'X'  integral  The result is formatted as a hexadecimal integer 'e', 'E'  floating point  The result is formatted as a decimal number in computerized scientific notation 'f'  floating point  The result is formatted as a decimal number 'g', 'G'  floating point  The result is formatted using computerized scientific notation or decimal format, depending on the precision and the value after rounding. 'a', 'A'  floating point  The result is formatted as a hexadecimal floating-point number with a significand and an exponent. This conversion is not supported for the BigDecimal type despite the latter's being in the floating point argument category. 't', 'T'  date/time  Prefix for date and time conversion characters. See Date/Time Conversions. '%'  percent  The result is a literal '%' ('\u0025') 'n'  line separator  The result is the platform-specific line separator   Any characters not explicitly defined as conversions are illegal and are reserved for future extensions. Date/Time Conversions  The following date and time conversion suffix characters are defined for the 't' and 'T' conversions. The types are similar to but not completely identical to those defined by GNU date and POSIX strftime(3c). Additional conversion types are provided to access Java-specific functionality (e.g. 'L' for milliseconds within the second).  The following conversion characters are used for formatting times:   'H'  Hour of the day for the 24-hour clock, formatted as two digits with a leading zero as necessary i.e. 00 - 23. 'I'  Hour for the 12-hour clock, formatted as two digits with a leading zero as necessary, i.e. 01 - 12. 'k'  Hour of the day for the 24-hour clock, i.e. 0 - 23. 'l'  Hour for the 12-hour clock, i.e. 1 - 12. 'M'  Minute within the hour formatted as two digits with a leading zero as necessary, i.e. 00 - 59. 'S'  Seconds within the minute, formatted as two digits with a leading zero as necessary, i.e. 00 - 60 ("60" is a special value required to support leap seconds). 'L'  Millisecond within the second formatted as three digits with leading zeros as necessary, i.e. 000 - 999. 'N'  Nanosecond within the second, formatted as nine digits with leading zeros as necessary, i.e. 000000000 - 999999999. 'p'  Locale-specific getAmPmStrings morning or afternoon marker in lower case, e.g."am" or "pm". Use of the conversion prefix 'T' forces this output to upper case. 'z'  RFC 822 style numeric time zone offset from GMT, e.g. -0800. This value will be adjusted as necessary for Daylight Saving Time. For long, Long, and Date the time zone used is the getDefault() default time zone for this instance of the Java virtual machine. 'Z'  A string representing the abbreviation for the time zone. This value will be adjusted as necessary for Daylight Saving Time. For long, Long, and Date the time zone used is the getDefault() default time zone for this instance of the Java virtual machine. The Formatter's locale will supersede the locale of the argument (if any). 's'  Seconds since the beginning of the epoch starting at 1 January 1970 00:00:00 UTC, i.e. Long.MIN_VALUE/1000 to Long.MAX_VALUE/1000. 'Q'  Milliseconds since the beginning of the epoch starting at 1 January 1970 00:00:00 UTC, i.e. Long.MIN_VALUE to Long.MAX_VALUE.   The following conversion characters are used for formatting dates:  'B'  Locale-specific getMonths full month name, e.g. "January", "February". 'b'  Locale-specific getShortMonths abbreviated month name, e.g. "Jan", "Feb". 'h'  Same as 'b'. 'A'  Locale-specific full name of the getWeekdays day of the week, e.g. "Sunday", "Monday" 'a'  Locale-specific short name of the getShortWeekdays day of the week, e.g. "Sun", "Mon" 'C'  Four-digit year divided by 100, formatted as two digits with leading zero as necessary, i.e. 00 - 99 'Y'  Year, formatted as at least four digits with leading zeros as necessary, e.g. 0092 equals 92 CE for the Gregorian calendar. 'y'  Last two digits of the year, formatted with leading zeros as necessary, i.e. 00 - 99. 'j'  Day of year, formatted as three digits with leading zeros as necessary, e.g. 001 - 366 for the Gregorian calendar. 'm'  Month, formatted as two digits with leading zeros as necessary, i.e. 01 - 13. 'd'  Day of month, formatted as two digits with leading zeros as necessary, i.e. 01 - 31 'e'  Day of month, formatted as two digits, i.e. 1 - 31.   The following conversion characters are used for formatting common date/time compositions.  'R'  Time formatted for the 24-hour clock as "%tH:%tM" 'T'  Time formatted for the 24-hour clock as "%tH:%tM:%tS". 'r'  Time formatted for the 12-hour clock as "%tI:%tM:%tS %Tp". The location of the morning or afternoon marker ('%Tp') may be locale-dependent. 'D'  Date formatted as "%tm/%td/%ty". 'F'  ISO 8601 complete date formatted as "%tY-%tm-%td". 'c'  Date and time formatted as "%ta %tb %td %tT %tZ %tY", e.g. "Sun Jul 20 16:17:00 EDT 1969".   Any characters not explicitly defined as date/time conversion suffixes are illegal and are reserved for future extensions.  Flags   The following table summarizes the supported flags. y means the flag is supported for the indicated argument types.   Flag  General  Character  Integral  Floating Point  Date/Time  Description  '-'  y  y  y  y  y  The result will be left-justified.  '#'  y1  -  y3  y  -  The result should use a conversion-dependent alternate form  '+'  -  -  y4  y  -  The result will always include a sign  '  '  -  -  y4  y  -  The result will include a leading space for positive values  '0'  -  -  y  y  -  The result will be zero-padded  ','  -  -  y2  y5  -  The result will include locale-specific getGroupingSeparator grouping separators  '('  -  -  y4  y5  -  The result will enclose negative numbers in parentheses   1 Depends on the definition of Formattable.  2 For 'd' conversion only.  3 For 'o', 'x', and 'X' conversions only.  4 For 'd', 'o', 'x', and 'X' conversions applied to java.math.BigInteger BigInteger or 'd' applied to byte, Byte, short, Short, int and Integer, long, and Long.  5 For 'e', 'E', 'f', 'g', and 'G' conversions only.  Any characters not explicitly defined as flags are illegal and are reserved for future extensions.  Width   The width is the minimum number of characters to be written to the output. For the line separator conversion, width is not applicable; if it is provided, an exception will be thrown.  Precision   For general argument types, the precision is the maximum number of characters to be written to the output.  For the floating-point conversions 'a', 'A', 'e', 'E', and 'f' the precision is the number of digits after the radix point. If the conversion is 'g' or 'G', then the precision is the total number of digits in the resulting magnitude after rounding.  For character, integral, and date/time argument types and the percent and line separator conversions, the precision is not applicable; if a precision is provided, an exception will be thrown.  Argument Index   The argument index is a decimal integer indicating the position of the argument in the argument list. The first argument is referenced by "1$", the second by "2$", etc.  Another way to reference arguments by position is to use the '<' ('\u003c') flag, which causes the argument for the previous format specifier to be re-used. For example, the following two statements would produce identical strings:  Calendar c = ...; String s1 = String.format("Duke's Birthday: %1$tm %1$te,%1$tY", c); String s2 = String.format("Duke's Birthday: %1$tm %<te,%<tY", c);   Details  This section is intended to provide behavioral details for formatting, including conditions and exceptions, supported data types, localization, and interactions between flags, conversions, and data types. For an overview of formatting concepts, refer to the Summary  Any characters not explicitly defined as conversions, date/time conversion suffixes, or flags are illegal and are reserved for future extensions. Use of such a character in a format string will cause an UnknownFormatConversionException or UnknownFormatFlagsException to be thrown.  If the format specifier contains a width or precision with an invalid value or which is otherwise unsupported, then a IllegalFormatWidthException or IllegalFormatPrecisionException respectively will be thrown.  If a format specifier contains a conversion character that is not applicable to the corresponding argument, then an IllegalFormatConversionException will be thrown.  All specified exceptions may be thrown by any of the format methods of Formatter as well as by any format convenience methods such as format() String.format and printf() PrintStream.printf.  Conversions denoted by an upper-case character (i.e. 'B', 'H', 'S', 'C', 'X', 'E', 'G', 'A', and 'T') are the same as those for the corresponding lower-case conversion characters except that the result is converted to upper case according to the rules of the prevailing java.util.Locale Locale. The result is equivalent to the following invocation of toUpperCase()  out.toUpperCase()  General  The following general conversions may be applied to any argument type:   'b'  '\u0062'  Produces either "true" or "false" as returned by toString().  If the argument is null, then the result is "false". If the argument is a boolean or Boolean, then the result is the string returned by valueOf() String.valueOf(). Otherwise, the result is "true".  If the '#' flag is given, then a FormatFlagsConversionMismatchException will be thrown.  'B'  '\u0042'  The upper-case variant of 'b'.  'h'  '\u0068'  Produces a string representing the hash code value of the object.  If the argument, arg is null, then the result is "null". Otherwise, the result is obtained by invoking Integer.toHexString(arg.hashCode()).  If the '#' flag is given, then a FormatFlagsConversionMismatchException will be thrown.  'H'  '\u0048'  The upper-case variant of 'h'.  's'  '\u0073'  Produces a string.  If the argument is null, then the result is "null". If the argument implements Formattable, then its formatTo method is invoked. Otherwise, the result is obtained by invoking the argument's toString() method.  If the '#' flag is given and the argument is not a Formattable , then a FormatFlagsConversionMismatchException will be thrown.  'S'  '\u0053'  The upper-case variant of 's'.   The following flags apply to general conversions:   '-'  '\u002d'  Left justifies the output. Spaces ('\u0020') will be added at the end of the converted value as required to fill the minimum width of the field. If the width is not provided, then a MissingFormatWidthException will be thrown. If this flag is not given then the output will be right-justified.  '#'  '\u0023'  Requires the output use an alternate form. The definition of the form is specified by the conversion.   The width is the minimum number of characters to be written to the output. If the length of the converted value is less than the width then the output will be padded by '  ' ('\u0020') until the total number of characters equals the width. The padding is on the left by default. If the '-' flag is given, then the padding will be on the right. If the width is not specified then there is no minimum.  The precision is the maximum number of characters to be written to the output. The precision is applied before the width, thus the output will be truncated to precision characters even if the width is greater than the precision. If the precision is not specified then there is no explicit limit on the number of characters. Character This conversion may be applied to char and Character. It may also be applied to the types byte, Byte, short, and Short, int and Integer when isValidCodePoint returns true. If it returns false then an IllegalFormatCodePointException will be thrown.   'c'  '\u0063'  Formats the argument as a Unicode character as described in Unicode Character Representation. This may be more than one 16-bit char in the case where the argument represents a supplementary character.  If the '#' flag is given, then a FormatFlagsConversionMismatchException will be thrown.  'C'  '\u0043'  The upper-case variant of 'c'.   The '-' flag defined for General conversions applies. If the '#' flag is given, then a FormatFlagsConversionMismatchException will be thrown.  The width is defined as for General conversions.  The precision is not applicable. If the precision is specified then an IllegalFormatPrecisionException will be thrown. Numeric  Numeric conversions are divided into the following categories:   Byte, Short, Integer, and Long  BigInteger  Float and Double  BigDecimal   Numeric types will be formatted according to the following algorithm:  Number Localization Algorithm  After digits are obtained for the integer part, fractional part, and exponent (as appropriate for the data type), the following transformation is applied:   Each digit character d in the string is replaced by a locale-specific digit computed relative to the current locale's getZeroDigit() zero digit z; that is d -  '0'  + z.  If a decimal separator is present, a locale-specific getDecimalSeparator decimal separator is substituted.  If the ',' ('\u002c') flag is given, then the locale-specific getGroupingSeparator grouping separator is inserted by scanning the integer part of the string from least significant to most significant digits and inserting a separator at intervals defined by the locale's getGroupingSize() grouping size.  If the '0' flag is given, then the locale-specific getZeroDigit() zero digits are inserted after the sign character, if any, and before the first non-zero digit, until the length of the string is equal to the requested field width.  If the value is negative and the '(' flag is given, then a '(' ('\u0028') is prepended and a ')' ('\u0029') is appended.  If the value is negative (or floating-point negative zero) and '(' flag is not given, then a '-' ('\u002d') is prepended.  If the '+' flag is given and the value is positive or zero (or floating-point positive zero), then a '+' ('\u002b') will be prepended.   If the value is NaN or positive infinity the literal strings "NaN" or "Infinity" respectively, will be output. If the value is negative infinity, then the output will be "(Infinity)" if the '(' flag is given otherwise the output will be "-Infinity". These values are not localized.  Byte, Short, Integer, and Long   The following conversions may be applied to byte, Byte, short, Short, int and Integer, long, and Long.   'd'  '\u0064'  Formats the argument as a decimal integer. The localization algorithm is applied.  If the '0' flag is given and the value is negative, then the zero padding will occur after the sign.  If the '#' flag is given then a FormatFlagsConversionMismatchException will be thrown.  'o'  '\u006f'  Formats the argument as an integer in base eight. No localization is applied.  If x is negative then the result will be an unsigned value generated by adding 2n to the value where n is the number of bits in the type as returned by the static SIZE field in the SIZE Byte, SIZE Short, SIZE Integer, or SIZE Long classes as appropriate.  If the '#' flag is given then the output will always begin with the radix indicator '0'.  If the '0' flag is given then the output will be padded with leading zeros to the field width following any indication of sign.  If '(', '+', '  ', or ',' flags are given then a FormatFlagsConversionMismatchException will be thrown.  'x'  '\u0078'  Formats the argument as an integer in base sixteen. No localization is applied.  If x is negative then the result will be an unsigned value generated by adding 2n to the value where n is the number of bits in the type as returned by the static SIZE field in the SIZE Byte, SIZE Short, SIZE Integer, or SIZE Long classes as appropriate.  If the '#' flag is given then the output will always begin with the radix indicator "0x".  If the '0' flag is given then the output will be padded to the field width with leading zeros after the radix indicator or sign (if present).  If '(', '  ', '+', or ',' flags are given then a FormatFlagsConversionMismatchException will be thrown.  'X'  '\u0058'  The upper-case variant of 'x'. The entire string representing the number will be converted to toUpperCase upper case including the 'x' (if any) and all hexadecimal digits 'a' - 'f' ('\u0061' - '\u0066').   If the conversion is 'o', 'x', or 'X' and both the '#' and the '0' flags are given, then result will contain the radix indicator ('0' for octal and "0x" or "0X" for hexadecimal), some number of zeros (based on the width), and the value.  If the '-' flag is not given, then the space padding will occur before the sign.  The following flags apply to numeric integral conversions:   '+'  '\u002b'  Requires the output to include a positive sign for all positive numbers. If this flag is not given then only negative values will include a sign.  If both the '+' and '  ' flags are given then an IllegalFormatFlagsException will be thrown.  '  '  '\u0020'  Requires the output to include a single extra space ('\u0020') for non-negative values.  If both the '+' and '  ' flags are given then an IllegalFormatFlagsException will be thrown.  '0'  '\u0030'  Requires the output to be padded with leading getZeroDigit zeros to the minimum field width following any sign or radix indicator except when converting NaN or infinity. If the width is not provided, then a MissingFormatWidthException will be thrown.  If both the '-' and '0' flags are given then an IllegalFormatFlagsException will be thrown.  ','  '\u002c'  Requires the output to include the locale-specific getGroupingSeparator group separators as described in the "group" section of the localization algorithm.  '('  '\u0028'  Requires the output to prepend a '(' ('\u0028') and append a ')' ('\u0029') to negative values.   If no flags are given the default formatting is as follows:   The output is right-justified within the width  Negative numbers begin with a '-' ('\u002d')  Positive numbers and zero do not include a sign or extra leading space  No grouping separators are included   The width is the minimum number of characters to be written to the output. This includes any signs, digits, grouping separators, radix indicator, and parentheses. If the length of the converted value is less than the width then the output will be padded by spaces ('\u0020') until the total number of characters equals width. The padding is on the left by default. If '-' flag is given then the padding will be on the right. If width is not specified then there is no minimum.  The precision is not applicable. If precision is specified then an IllegalFormatPrecisionException will be thrown.  BigInteger   The following conversions may be applied to java.math.BigInteger.   'd'  '\u0064'  Requires the output to be formatted as a decimal integer. The localization algorithm is applied.  If the '#' flag is given FormatFlagsConversionMismatchException will be thrown.  'o'  '\u006f'  Requires the output to be formatted as an integer in base eight. No localization is applied.  If x is negative then the result will be a signed value beginning with '-' ('\u002d'). Signed output is allowed for this type because unlike the primitive types it is not possible to create an unsigned equivalent without assuming an explicit data-type size.  If x is positive or zero and the '+' flag is given then the result will begin with '+' ('\u002b').  If the '#' flag is given then the output will always begin with '0' prefix.  If the '0' flag is given then the output will be padded with leading zeros to the field width following any indication of sign.  If the ',' flag is given then a FormatFlagsConversionMismatchException will be thrown.  'x'  '\u0078'  Requires the output to be formatted as an integer in base sixteen. No localization is applied.  If x is negative then the result will be a signed value beginning with '-' ('\u002d'). Signed output is allowed for this type because unlike the primitive types it is not possible to create an unsigned equivalent without assuming an explicit data-type size.  If x is positive or zero and the '+' flag is given then the result will begin with '+' ('\u002b').  If the '#' flag is given then the output will always begin with the radix indicator "0x".  If the '0' flag is given then the output will be padded to the field width with leading zeros after the radix indicator or sign (if present).  If the ',' flag is given then a FormatFlagsConversionMismatchException will be thrown.  'X'  '\u0058'  The upper-case variant of 'x'. The entire string representing the number will be converted to toUpperCase upper case including the 'x' (if any) and all hexadecimal digits 'a' - 'f' ('\u0061' - '\u0066').   If the conversion is 'o', 'x', or 'X' and both the '#' and the '0' flags are given, then result will contain the base indicator ('0' for octal and "0x" or "0X" for hexadecimal), some number of zeros (based on the width), and the value.  If the '0' flag is given and the value is negative, then the zero padding will occur after the sign.  If the '-' flag is not given, then the space padding will occur before the sign.  All flags defined for Byte, Short, Integer, and Long apply. The default behavior when no flags are given is the same as for Byte, Short, Integer, and Long.  The specification of width is the same as defined for Byte, Short, Integer, and Long.  The precision is not applicable. If precision is specified then an IllegalFormatPrecisionException will be thrown.  Float and Double  The following conversions may be applied to float, Float, double and Double.   'e'  '\u0065'  Requires the output to be formatted using computerized scientific notation. The localization algorithm is applied.  The formatting of the magnitude m depends upon its value.  If m is NaN or infinite, the literal strings "NaN" or "Infinity", respectively, will be output. These values are not localized.  If m is positive-zero or negative-zero, then the exponent will be "+00".  Otherwise, the result is a string that represents the sign and magnitude (absolute value) of the argument. The formatting of the sign is described in the localization algorithm. The formatting of the magnitude m depends upon its value.  Let n be the unique integer such that 10n <= m < 10n+1; then let a be the mathematically exact quotient of m and 10n so that 1 <= a < 10. The magnitude is then represented as the integer part of a, as a single decimal digit, followed by the decimal separator followed by decimal digits representing the fractional part of a, followed by the exponent symbol 'e' ('\u0065'), followed by the sign of the exponent, followed by a representation of n as a decimal integer, as produced by the method toString(), and zero-padded to include at least two digits.  The number of digits in the result for the fractional part of m or a is equal to the precision. If the precision is not specified then the default value is 6. If the precision is less than the number of digits which would appear after the decimal point in the string returned by toString() or toString() respectively, then the value will be rounded using the ROUND_HALF_UP round half up algorithm. Otherwise, zeros may be appended to reach the precision. For a canonical representation of the value, use toString() or toString() as appropriate. If the ',' flag is given, then an FormatFlagsConversionMismatchException will be thrown.  'E'  '\u0045'  The upper-case variant of 'e'. The exponent symbol will be 'E' ('\u0045').  'g'  '\u0067'  Requires the output to be formatted in general scientific notation as described below. The localization algorithm is applied.  After rounding for the precision, the formatting of the resulting magnitude m depends on its value.  If m is greater than or equal to 10-4 but less than 10precision then it is represented in decimal format.  If m is less than 10-4 or greater than or equal to 10precision, then it is represented in computerized scientific notation.  The total number of significant digits in m is equal to the precision. If the precision is not specified, then the default value is 6. If the precision is 0, then it is taken to be 1.  If the '#' flag is given then an FormatFlagsConversionMismatchException will be thrown.  'G'  '\u0047'  The upper-case variant of 'g'.  'f'  '\u0066'  Requires the output to be formatted using decimal format. The localization algorithm is applied.  The result is a string that represents the sign and magnitude (absolute value) of the argument. The formatting of the sign is described in the localization algorithm. The formatting of the magnitude m depends upon its value.  If m NaN or infinite, the literal strings "NaN" or "Infinity", respectively, will be output. These values are not localized.  The magnitude is formatted as the integer part of m, with no leading zeroes, followed by the decimal separator followed by one or more decimal digits representing the fractional part of m.  The number of digits in the result for the fractional part of m or a is equal to the precision. If the precision is not specified then the default value is 6. If the precision is less than the number of digits which would appear after the decimal point in the string returned by toString() or toString() respectively, then the value will be rounded using the ROUND_HALF_UP round half up algorithm. Otherwise, zeros may be appended to reach the precision. For a canonical representation of the value, use toString() or toString() as appropriate.  'a'  '\u0061'  Requires the output to be formatted in hexadecimal exponential form. No localization is applied.  The result is a string that represents the sign and magnitude (absolute value) of the argument x.  If x is negative or a negative-zero value then the result will begin with '-' ('\u002d').  If x is positive or a positive-zero value and the '+' flag is given then the result will begin with '+' ('\u002b').  The formatting of the magnitude m depends upon its value.   If the value is NaN or infinite, the literal strings "NaN" or "Infinity", respectively, will be output.  If m is zero then it is represented by the string "0x0.0p0".  If m is a double value with a normalized representation then substrings are used to represent the significand and exponent fields. The significand is represented by the characters "0x1." followed by the hexadecimal representation of the rest of the significand as a fraction. The exponent is represented by 'p' ('\u0070') followed by a decimal string of the unbiased exponent as if produced by invoking toString() Integer.toString on the exponent value. If the precision is specified, the value is rounded to the given number of hexadecimal digits.  If m is a double value with a subnormal representation then, unless the precision is specified to be in the range 1 through 12, inclusive, the significand is represented by the characters '0x0.' followed by the hexadecimal representation of the rest of the significand as a fraction, and the exponent represented by 'p-1022'. If the precision is in the interval [1, 12], the subnormal value is normalized such that it begins with the characters '0x1.', rounded to the number of hexadecimal digits of precision, and the exponent adjusted accordingly. Note that there must be at least one nonzero digit in a subnormal significand.   If the '(' or ',' flags are given, then a FormatFlagsConversionMismatchException will be thrown.  'A'  '\u0041'  The upper-case variant of 'a'. The entire string representing the number will be converted to upper case including the 'x' ('\u0078') and 'p' ('\u0070' and all hexadecimal digits 'a' - 'f' ('\u0061' - '\u0066').   All flags defined for Byte, Short, Integer, and Long apply.  If the '#' flag is given, then the decimal separator will always be present.  If no flags are given the default formatting is as follows:   The output is right-justified within the width  Negative numbers begin with a '-'  Positive numbers and positive zero do not include a sign or extra leading space  No grouping separators are included  The decimal separator will only appear if a digit follows it   The width is the minimum number of characters to be written to the output. This includes any signs, digits, grouping separators, decimal separators, exponential symbol, radix indicator, parentheses, and strings representing infinity and NaN as applicable. If the length of the converted value is less than the width then the output will be padded by spaces ('\u0020') until the total number of characters equals width. The padding is on the left by default. If the '-' flag is given then the padding will be on the right. If width is not specified then there is no minimum.  If the conversion is 'e', 'E' or 'f', then the precision is the number of digits after the decimal separator. If the precision is not specified, then it is assumed to be 6.  If the conversion is 'g' or 'G', then the precision is the total number of significant digits in the resulting magnitude after rounding. If the precision is not specified, then the default value is 6. If the precision is 0, then it is taken to be 1.  If the conversion is 'a' or 'A', then the precision is the number of hexadecimal digits after the radix point. If the precision is not provided, then all of the digits as returned by toHexString() will be output.  BigDecimal   The following conversions may be applied java.math.BigDecimal BigDecimal.   'e'  '\u0065'  Requires the output to be formatted using computerized scientific notation. The localization algorithm is applied.  The formatting of the magnitude m depends upon its value.  If m is positive-zero or negative-zero, then the exponent will be "+00".  Otherwise, the result is a string that represents the sign and magnitude (absolute value) of the argument. The formatting of the sign is described in the localization algorithm. The formatting of the magnitude m depends upon its value.  Let n be the unique integer such that 10n <= m < 10n+1; then let a be the mathematically exact quotient of m and 10n so that 1 <= a < 10. The magnitude is then represented as the integer part of a, as a single decimal digit, followed by the decimal separator followed by decimal digits representing the fractional part of a, followed by the exponent symbol 'e' ('\u0065'), followed by the sign of the exponent, followed by a representation of n as a decimal integer, as produced by the method toString(), and zero-padded to include at least two digits.  The number of digits in the result for the fractional part of m or a is equal to the precision. If the precision is not specified then the default value is 6. If the precision is less than the number of digits to the right of the decimal point then the value will be rounded using the ROUND_HALF_UP round half up algorithm. Otherwise, zeros may be appended to reach the precision. For a canonical representation of the value, use toString().  If the ',' flag is given, then an FormatFlagsConversionMismatchException will be thrown.  'E'  '\u0045'  The upper-case variant of 'e'. The exponent symbol will be 'E' ('\u0045').  'g'  '\u0067'  Requires the output to be formatted in general scientific notation as described below. The localization algorithm is applied.  After rounding for the precision, the formatting of the resulting magnitude m depends on its value.  If m is greater than or equal to 10-4 but less than 10precision then it is represented in decimal format.  If m is less than 10-4 or greater than or equal to 10precision, then it is represented in computerized scientific notation.  The total number of significant digits in m is equal to the precision. If the precision is not specified, then the default value is 6. If the precision is 0, then it is taken to be 1.  If the '#' flag is given then an FormatFlagsConversionMismatchException will be thrown.  'G'  '\u0047'  The upper-case variant of 'g'.  'f'  '\u0066'  Requires the output to be formatted using decimal format. The localization algorithm is applied.  The result is a string that represents the sign and magnitude (absolute value) of the argument. The formatting of the sign is described in the localization algorithm. The formatting of the magnitude m depends upon its value.  The magnitude is formatted as the integer part of m, with no leading zeroes, followed by the decimal separator followed by one or more decimal digits representing the fractional part of m.  The number of digits in the result for the fractional part of m or a is equal to the precision. If the precision is not specified then the default value is 6. If the precision is less than the number of digits to the right of the decimal point then the value will be rounded using the ROUND_HALF_UP round half up algorithm. Otherwise, zeros may be appended to reach the precision. For a canonical representation of the value, use toString().   All flags defined for Byte, Short, Integer, and Long apply.  If the '#' flag is given, then the decimal separator will always be present.  The default behavior when no flags are given is the same as for Float and Double.  The specification of width and precision is the same as defined for Float and Double. Date/Time  This conversion may be applied to long, Long, Calendar, Date and TemporalAccessor TemporalAccessor   't'  '\u0074'  Prefix for date and time conversion characters.  'T'  '\u0054'  The upper-case variant of 't'.   The following date and time conversion character suffixes are defined for the 't' and 'T' conversions. The types are similar to but not completely identical to those defined by GNU date and POSIX strftime(3c). Additional conversion types are provided to access Java-specific functionality (e.g. 'L' for milliseconds within the second).  The following conversion characters are used for formatting times:   'H'  '\u0048'  Hour of the day for the 24-hour clock, formatted as two digits with a leading zero as necessary i.e. 00 - 23. 00 corresponds to midnight. 'I'  '\u0049'  Hour for the 12-hour clock, formatted as two digits with a leading zero as necessary, i.e. 01 - 12. 01 corresponds to one o'clock (either morning or afternoon). 'k'  '\u006b'  Hour of the day for the 24-hour clock, i.e. 0 - 23. 0 corresponds to midnight. 'l'  '\u006c'  Hour for the 12-hour clock, i.e. 1 - 12. 1 corresponds to one o'clock (either morning or afternoon). 'M'  '\u004d'  Minute within the hour formatted as two digits with a leading zero as necessary, i.e. 00 - 59. 'S'  '\u0053'  Seconds within the minute, formatted as two digits with a leading zero as necessary, i.e. 00 - 60 ("60" is a special value required to support leap seconds). 'L'  '\u004c'  Millisecond within the second formatted as three digits with leading zeros as necessary, i.e. 000 - 999. 'N'  '\u004e'  Nanosecond within the second, formatted as nine digits with leading zeros as necessary, i.e. 000000000 - 999999999. The precision of this value is limited by the resolution of the underlying operating system or hardware. 'p'  '\u0070'  Locale-specific getAmPmStrings morning or afternoon marker in lower case, e.g."am" or "pm". Use of the conversion prefix 'T' forces this output to upper case. (Note that 'p' produces lower-case output. This is different from GNU date and POSIX strftime(3c) which produce upper-case output.) 'z'  '\u007a'  RFC 822 style numeric time zone offset from GMT, e.g. -0800. This value will be adjusted as necessary for Daylight Saving Time. For long, Long, and Date the time zone used is the getDefault() default time zone for this instance of the Java virtual machine. 'Z'  '\u005a'  A string representing the abbreviation for the time zone. This value will be adjusted as necessary for Daylight Saving Time. For long, Long, and Date the time zone used is the getDefault() default time zone for this instance of the Java virtual machine. The Formatter's locale will supersede the locale of the argument (if any). 's'  '\u0073'  Seconds since the beginning of the epoch starting at 1 January 1970 00:00:00 UTC, i.e. Long.MIN_VALUE/1000 to Long.MAX_VALUE/1000. 'Q'  '\u004f'  Milliseconds since the beginning of the epoch starting at 1 January 1970 00:00:00 UTC, i.e. Long.MIN_VALUE to Long.MAX_VALUE. The precision of this value is limited by the resolution of the underlying operating system or hardware.   The following conversion characters are used for formatting dates:  'B'  '\u0042'  Locale-specific getMonths full month name, e.g. "January", "February". 'b'  '\u0062'  Locale-specific getShortMonths abbreviated month name, e.g. "Jan", "Feb". 'h'  '\u0068'  Same as 'b'. 'A'  '\u0041'  Locale-specific full name of the getWeekdays day of the week, e.g. "Sunday", "Monday" 'a'  '\u0061'  Locale-specific short name of the getShortWeekdays day of the week, e.g. "Sun", "Mon" 'C'  '\u0043'  Four-digit year divided by 100, formatted as two digits with leading zero as necessary, i.e. 00 - 99 'Y'  '\u0059'  Year, formatted to at least four digits with leading zeros as necessary, e.g. 0092 equals 92 CE for the Gregorian calendar. 'y'  '\u0079'  Last two digits of the year, formatted with leading zeros as necessary, i.e. 00 - 99. 'j'  '\u006a'  Day of year, formatted as three digits with leading zeros as necessary, e.g. 001 - 366 for the Gregorian calendar. 001 corresponds to the first day of the year. 'm'  '\u006d'  Month, formatted as two digits with leading zeros as necessary, i.e. 01 - 13, where "01" is the first month of the year and ("13" is a special value required to support lunar calendars). 'd'  '\u0064'  Day of month, formatted as two digits with leading zeros as necessary, i.e. 01 - 31, where "01" is the first day of the month. 'e'  '\u0065'  Day of month, formatted as two digits, i.e. 1 - 31 where "1" is the first day of the month.   The following conversion characters are used for formatting common date/time compositions.  'R'  '\u0052'  Time formatted for the 24-hour clock as "%tH:%tM" 'T'  '\u0054'  Time formatted for the 24-hour clock as "%tH:%tM:%tS". 'r'  '\u0072'  Time formatted for the 12-hour clock as "%tI:%tM:%tS %Tp". The location of the morning or afternoon marker ('%Tp') may be locale-dependent. 'D'  '\u0044'  Date formatted as "%tm/%td/%ty". 'F'  '\u0046'  ISO 8601 complete date formatted as "%tY-%tm-%td". 'c'  '\u0063'  Date and time formatted as "%ta %tb %td %tT %tZ %tY", e.g. "Sun Jul 20 16:17:00 EDT 1969".   The '-' flag defined for General conversions applies. If the '#' flag is given, then a FormatFlagsConversionMismatchException will be thrown.  The width is the minimum number of characters to be written to the output. If the length of the converted value is less than the width then the output will be padded by spaces ('\u0020') until the total number of characters equals width. The padding is on the left by default. If the '-' flag is given then the padding will be on the right. If width is not specified then there is no minimum.  The precision is not applicable. If the precision is specified then an IllegalFormatPrecisionException will be thrown. Percent  The conversion does not correspond to any argument.  '%'  The result is a literal '%' ('\u0025')  The width is the minimum number of characters to be written to the output including the '%'. If the length of the converted value is less than the width then the output will be padded by spaces ('\u0020') until the total number of characters equals width. The padding is on the left. If width is not specified then just the '%' is output.  The '-' flag defined for General conversions applies. If any other flags are provided, then a FormatFlagsConversionMismatchException will be thrown.  The precision is not applicable. If the precision is specified an IllegalFormatPrecisionException will be thrown.  Line Separator  The conversion does not correspond to any argument.  'n'  the platform-specific line separator as returned by getProperty System.getProperty("line.separator").   Flags, width, and precision are not applicable. If any are provided an IllegalFormatFlagsException, IllegalFormatWidthException, and IllegalFormatPrecisionException, respectively will be thrown. Argument Index  Format specifiers can reference arguments in three ways:   Explicit indexing is used when the format specifier contains an argument index. The argument index is a decimal integer indicating the position of the argument in the argument list. The first argument is referenced by "1$", the second by "2$", etc. An argument may be referenced more than once.  For example:  formatter.format("%4$s %3$s %2$s %1$s %4$s %3$s %2$s %1$s", "a", "b", "c", "d") // -> "d c b a d c b a"   Relative indexing is used when the format specifier contains a '<' ('\u003c') flag which causes the argument for the previous format specifier to be re-used. If there is no previous argument, then a MissingFormatArgumentException is thrown.  formatter.format("%s %s %<s %<s", "a", "b", "c", "d") // -> "a b b b" // "c" and "d" are ignored because they are not referenced   Ordinary indexing is used when the format specifier contains neither an argument index nor a '<' flag. Each format specifier which uses ordinary indexing is assigned a sequential implicit index into argument list which is independent of the indices used by explicit or relative indexing.  formatter.format("%s %s %s %s", "a", "b", "c", "d") // -> "a b c d"    It is possible to have a format string which uses all forms of indexing, for example:  formatter.format("%2$s %s %<s %s", "a", "b", "c", "d") // -> "b a a b" // "c" and "d" are ignored because they are not referenced   The maximum number of arguments is limited by the maximum dimension of a Java array as defined by The Java Virtual Machine Specification. If the argument index is does not correspond to an available argument, then a MissingFormatArgumentException is thrown.  If there are more arguments than format specifiers, the extra arguments are ignored.  Unless otherwise specified, passing a null argument to any method or constructor in this class will cause a NullPointerException to be thrown.
java.util.Formatter.Formatter	(	): Constructs a new formatter.  The destination of the formatted output is a StringBuilder which may be retrieved by invoking out out() and whose current content may be converted into a string by invoking toString toString(). The locale used is the getDefault() default locale for FORMAT formatting for this instance of the Java virtual machine.
java.util.Formatter.Formatter	(	Appendable	): Constructs a new formatter with the specified destination.  The locale used is the getDefault() default locale for FORMAT formatting for this instance of the Java virtual machine.
java.util.Formatter.Formatter	(	Appendable	Locale	): Constructs a new formatter with the specified destination and locale.
java.util.Formatter.Formatter	(	File	): Constructs a new formatter with the specified file.  The charset used is the defaultCharset() default charset for this instance of the Java virtual machine.  The locale used is the getDefault() default locale for FORMAT formatting for this instance of the Java virtual machine.
java.util.Formatter.Formatter	(	File	String	): Constructs a new formatter with the specified file and charset.  The locale used is the getDefault() default locale for FORMAT formatting for this instance of the Java virtual machine.
java.util.Formatter.Formatter	(	File	String	Locale	): Constructs a new formatter with the specified file, charset, and locale.
java.util.Formatter.Formatter	(	Locale	): Constructs a new formatter with the specified locale.  The destination of the formatted output is a StringBuilder which may be retrieved by invoking out out() and whose current content may be converted into a string by invoking toString toString().
java.util.Formatter.Formatter	(	OutputStream	): Constructs a new formatter with the specified output stream.  The charset used is the defaultCharset() default charset for this instance of the Java virtual machine.  The locale used is the getDefault() default locale for FORMAT formatting for this instance of the Java virtual machine.
java.util.Formatter.Formatter	(	OutputStream	String	): Constructs a new formatter with the specified output stream and charset.  The locale used is the getDefault() default locale for FORMAT formatting for this instance of the Java virtual machine.
java.util.Formatter.Formatter	(	OutputStream	String	Locale	): Constructs a new formatter with the specified output stream, charset, and locale.
java.util.Formatter.Formatter	(	PrintStream	): Constructs a new formatter with the specified print stream.  The locale used is the getDefault() default locale for FORMAT formatting for this instance of the Java virtual machine.  Characters are written to the given java.io.PrintStream PrintStream object and are therefore encoded using that object's charset.
java.util.Formatter.Formatter	(	String	): Constructs a new formatter with the specified file name.  The charset used is the defaultCharset() default charset for this instance of the Java virtual machine.  The locale used is the getDefault() default locale for FORMAT formatting for this instance of the Java virtual machine.
java.util.Formatter.Formatter	(	String	String	): Constructs a new formatter with the specified file name and charset.  The locale used is the getDefault() default locale for FORMAT formatting for this instance of the Java virtual machine.
java.util.Formatter.Formatter	(	String	String	Locale	): Constructs a new formatter with the specified file name, charset, and locale.
java.util.Formatter.close	(	): Closes this formatter. If the destination implements the java.io.Closeable interface, its close method will be invoked.  Closing a formatter allows it to release resources it may be holding (such as open files). If the formatter is already closed, then invoking this method has no effect.  Attempting to invoke any methods except ioException() in this formatter after it has been closed will result in a FormatterClosedException.
java.util.Formatter.flush	(	): Flushes this formatter. If the destination implements the java.io.Flushable interface, its flush method will be invoked.  Flushing a formatter writes any buffered output in the destination to the underlying stream.
java.util.Formatter.format	(	Locale	String	Object	): Writes a formatted string to this object's destination using the specified locale, format string, and arguments.
java.util.Formatter.format	(	String	Object	): Writes a formatted string to this object's destination using the specified format string and arguments. The locale used is the one defined during the construction of this formatter.
java.util.Formatter.ioException	(	): Returns the IOException last thrown by this formatter's Appendable.  If the destination's append() method never throws IOException, then this method will always return null.
java.util.Formatter.locale	(	): Returns the locale set by the construction of this formatter.  The format() method for this object which has a locale argument does not change this value.
java.util.Formatter.out	(	): Returns the destination for the output.
java.util.Formatter.parse	(	String	): Finds format specifiers in the format string.
java.util.Formatter.toCharset	(	String	): Returns a charset object for the given charset name.
java.util.Formatter.toString	(	): Returns the result of invoking toString() on the destination for the output. For example, the following code formats text into a StringBuilder then retrieves the resultant string:  Formatter f = new Formatter(); f.format("Last reboot at %tc", lastRebootDate); String s = f.toString(); // -> s == "Last reboot at Sat Jan 01 00:00:00 PST 2000"   An invocation of this method behaves in exactly the same way as the invocation  out().toString()   Depending on the specification of toString for the Appendable, the returned string may or may not contain the characters written to the destination. For instance, buffers typically return their contents in toString(), but streams cannot since the data is discarded.
java.util.FormatterClosedException: Unchecked exception thrown when the formatter has been closed.  Unless otherwise specified, passing a null argument to any method or constructor in this class will cause a NullPointerException to be thrown.
java.util.FormatterClosedException.FormatterClosedException	(	): Constructs an instance of this class.
java.util.GregorianCalendar: GregorianCalendar is a concrete subclass of Calendar and provides the standard calendar system used by most of the world.  GregorianCalendar is a hybrid calendar that supports both the Julian and Gregorian calendar systems with the support of a single discontinuity, which corresponds by default to the Gregorian date when the Gregorian calendar was instituted (October 15, 1582 in some countries, later in others). The cutover date may be changed by the caller by calling setGregorianChange() setGregorianChange().  Historically, in those countries which adopted the Gregorian calendar first, October 4, 1582 (Julian) was thus followed by October 15, 1582 (Gregorian). This calendar models this correctly. Before the Gregorian cutover, GregorianCalendar implements the Julian calendar. The only difference between the Gregorian and the Julian calendar is the leap year rule. The Julian calendar specifies leap years every four years, whereas the Gregorian calendar omits century years which are not divisible by 400.  GregorianCalendar implements proleptic Gregorian and Julian calendars. That is, dates are computed by extrapolating the current rules indefinitely far backward and forward in time. As a result, GregorianCalendar may be used for all years to generate meaningful and consistent results. However, dates obtained using GregorianCalendar are historically accurate only from March 1, 4 AD onward, when modern Julian calendar rules were adopted. Before this date, leap year rules were applied irregularly, and before 45 BC the Julian calendar did not even exist.  Prior to the institution of the Gregorian calendar, New Year's Day was March 25. To avoid confusion, this calendar always uses January 1. A manual adjustment may be made if desired for dates that are prior to the Gregorian changeover and which fall between January 1 and March 24. Week Of Year and Week Year Values calculated for the WEEK_OF_YEAR field range from 1 to 53. The first week of a calendar year is the earliest seven day period starting on getFirstDayOfWeek() getFirstDayOfWeek() that contains at least getMinimalDaysInFirstWeek() getMinimalDaysInFirstWeek() days from that year. It thus depends on the values of getMinimalDaysInFirstWeek(), getFirstDayOfWeek(), and the day of the week of January 1. Weeks between week 1 of one year and week 1 of the following year (exclusive) are numbered sequentially from 2 to 52 or 53 (except for year(s) involved in the Julian-Gregorian transition). The getFirstDayOfWeek() and getMinimalDaysInFirstWeek() values are initialized using locale-dependent resources when constructing a GregorianCalendar. The week determination is compatible with the ISO 8601 standard when getFirstDayOfWeek() is MONDAY and getMinimalDaysInFirstWeek() is 4, which values are used in locales where the standard is preferred. These values can explicitly be set by calling setFirstDayOfWeek() setFirstDayOfWeek() and setMinimalDaysInFirstWeek() setMinimalDaysInFirstWeek(). A week year is in sync with a WEEK_OF_YEAR cycle. All weeks between the first and last weeks (inclusive) have the same week year value. Therefore, the first and last days of a week year may have different calendar year values. For example, January 1, 1998 is a Thursday. If getFirstDayOfWeek() is MONDAY and getMinimalDaysInFirstWeek() is 4 (ISO 8601 standard compatible setting), then week 1 of 1998 starts on December 29, 1997, and ends on January 4, 1998. The week year is 1998 for the last three days of calendar year 1997. If, however, getFirstDayOfWeek() is SUNDAY, then week 1 of 1998 starts on January 4, 1998, and ends on January 10, 1998; the first three days of 1998 then are part of week 53 of 1997 and their week year is 1997. Week Of Month Values calculated for the WEEK_OF_MONTH field range from 0 to 6. Week 1 of a month (the days with WEEK_OF_MONTH = 1) is the earliest set of at least getMinimalDaysInFirstWeek() contiguous days in that month, ending on the day before getFirstDayOfWeek(). Unlike week 1 of a year, week 1 of a month may be shorter than 7 days, need not start on getFirstDayOfWeek(), and will not include days of the previous month. Days of a month before week 1 have a WEEK_OF_MONTH of 0. For example, if getFirstDayOfWeek() is SUNDAY and getMinimalDaysInFirstWeek() is 4, then the first week of January 1998 is Sunday, January 4 through Saturday, January 10. These days have a WEEK_OF_MONTH of 1. Thursday, January 1 through Saturday, January 3 have a WEEK_OF_MONTH of 0. If getMinimalDaysInFirstWeek() is changed to 3, then January 1 through January 3 have a WEEK_OF_MONTH of 1. Default Fields Values The clear method sets calendar field(s) undefined. GregorianCalendar uses the following default value for each calendar field if its value is undefined.    Field  Default Value     ERA   AD     YEAR   1970     MONTH   JANUARY     DAY_OF_MONTH   1     DAY_OF_WEEK   the first day of week     WEEK_OF_MONTH   0     DAY_OF_WEEK_IN_MONTH   1     AM_PM   AM     HOUR, HOUR_OF_DAY, MINUTE, SECOND, MILLISECOND   0     Default values are not applicable for the fields not listed above.  Example:   // get the supported ids for GMT-08:00 (Pacific Standard Time) String[] ids = TimeZone.getAvailableIDs(-8 * 60 * 60 * 1000); // if no ids were returned, something is wrong. get out. if (ids.length == 0) System.exit(0); // begin output System.out.println("Current Time"); // create a Pacific Standard Time time zone SimpleTimeZone pdt = new SimpleTimeZone(-8 * 60 * 60 * 1000, ids[0]); // set up rules for Daylight Saving Time pdt.setStartRule(Calendar.APRIL, 1, Calendar.SUNDAY, 2 * 60 * 60 * 1000); pdt.setEndRule(Calendar.OCTOBER, -1, Calendar.SUNDAY, 2 * 60 * 60 * 1000); // create a GregorianCalendar with the Pacific Daylight time zone // and the current date and time Calendar calendar = new GregorianCalendar(pdt); Date trialTime = new Date(); calendar.setTime(trialTime); // print out a bunch of interesting things System.out.println("ERA: " + calendar.get(Calendar.ERA)); System.out.println("YEAR: " + calendar.get(Calendar.YEAR)); System.out.println("MONTH: " + calendar.get(Calendar.MONTH)); System.out.println("WEEK_OF_YEAR: " + calendar.get(Calendar.WEEK_OF_YEAR)); System.out.println("WEEK_OF_MONTH: " + calendar.get(Calendar.WEEK_OF_MONTH)); System.out.println("DATE: " + calendar.get(Calendar.DATE)); System.out.println("DAY_OF_MONTH: " + calendar.get(Calendar.DAY_OF_MONTH)); System.out.println("DAY_OF_YEAR: " + calendar.get(Calendar.DAY_OF_YEAR)); System.out.println("DAY_OF_WEEK: " + calendar.get(Calendar.DAY_OF_WEEK)); System.out.println("DAY_OF_WEEK_IN_MONTH: " + calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH)); System.out.println("AM_PM: " + calendar.get(Calendar.AM_PM)); System.out.println("HOUR: " + calendar.get(Calendar.HOUR)); System.out.println("HOUR_OF_DAY: " + calendar.get(Calendar.HOUR_OF_DAY)); System.out.println("MINUTE: " + calendar.get(Calendar.MINUTE)); System.out.println("SECOND: " + calendar.get(Calendar.SECOND)); System.out.println("MILLISECOND: " + calendar.get(Calendar.MILLISECOND)); System.out.println("ZONE_OFFSET: " + (calendar.get(Calendar.ZONE_OFFSET)/(60*60*1000))); System.out.println("DST_OFFSET: " + (calendar.get(Calendar.DST_OFFSET)/(60*60*1000))); System.out.println("Current Time, with hour reset to 3"); calendar.clear(Calendar.HOUR_OF_DAY); // so doesn't override calendar.set(Calendar.HOUR, 3); System.out.println("ERA: " + calendar.get(Calendar.ERA)); System.out.println("YEAR: " + calendar.get(Calendar.YEAR)); System.out.println("MONTH: " + calendar.get(Calendar.MONTH)); System.out.println("WEEK_OF_YEAR: " + calendar.get(Calendar.WEEK_OF_YEAR)); System.out.println("WEEK_OF_MONTH: " + calendar.get(Calendar.WEEK_OF_MONTH)); System.out.println("DATE: " + calendar.get(Calendar.DATE)); System.out.println("DAY_OF_MONTH: " + calendar.get(Calendar.DAY_OF_MONTH)); System.out.println("DAY_OF_YEAR: " + calendar.get(Calendar.DAY_OF_YEAR)); System.out.println("DAY_OF_WEEK: " + calendar.get(Calendar.DAY_OF_WEEK)); System.out.println("DAY_OF_WEEK_IN_MONTH: " + calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH)); System.out.println("AM_PM: " + calendar.get(Calendar.AM_PM)); System.out.println("HOUR: " + calendar.get(Calendar.HOUR)); System.out.println("HOUR_OF_DAY: " + calendar.get(Calendar.HOUR_OF_DAY)); System.out.println("MINUTE: " + calendar.get(Calendar.MINUTE)); System.out.println("SECOND: " + calendar.get(Calendar.SECOND)); System.out.println("MILLISECOND: " + calendar.get(Calendar.MILLISECOND)); System.out.println("ZONE_OFFSET: " + (calendar.get(Calendar.ZONE_OFFSET)/(60*60*1000))); // in hours System.out.println("DST_OFFSET: " + (calendar.get(Calendar.DST_OFFSET)/(60*60*1000))); // in hours  
java.util.GregorianCalendar.GregorianCalendar	(	): Constructs a default GregorianCalendar using the current time in the default time zone with the default FORMAT locale.
java.util.GregorianCalendar.GregorianCalendar	(	Locale	): Constructs a GregorianCalendar based on the current time in the default time zone with the given locale.
java.util.GregorianCalendar.GregorianCalendar	(	TimeZone	): Constructs a GregorianCalendar based on the current time in the given time zone with the default FORMAT locale.
java.util.GregorianCalendar.GregorianCalendar	(	TimeZone	Locale	): Constructs a GregorianCalendar based on the current time in the given time zone with the given locale.
java.util.GregorianCalendar.GregorianCalendar	(	TimeZone	Locale	boolean	): Constructs an empty GregorianCalendar.
java.util.GregorianCalendar.GregorianCalendar	(	int	int	int	): Constructs a GregorianCalendar with the given date set in the default time zone with the default locale.
java.util.GregorianCalendar.GregorianCalendar	(	int	int	int	int	int	): Constructs a GregorianCalendar with the given date and time set for the default time zone with the default locale.
java.util.GregorianCalendar.GregorianCalendar	(	int	int	int	int	int	int	): Constructs a GregorianCalendar with the given date and time set for the default time zone with the default locale.
java.util.GregorianCalendar.GregorianCalendar	(	int	int	int	int	int	int	int	): Constructs a GregorianCalendar with the given date and time set for the default time zone with the default locale.
java.util.GregorianCalendar.add	(	int	int	): Adds the specified (signed) amount of time to the given calendar field, based on the calendar's rules. Add rule 1. The value of field after the call minus the value of field before the call is amount, modulo any overflow that has occurred in field. Overflow occurs when a field value exceeds its range and, as a result, the next larger field is incremented or decremented and the field value is adjusted back into its range. Add rule 2. If a smaller field is expected to be invariant, but it is impossible for it to be equal to its prior value because of changes in its minimum or maximum after field is changed, then its value is adjusted to be as close as possible to its expected value. A smaller field represents a smaller unit of time. HOUR is a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that are not expected to be invariant. The calendar system determines what fields are expected to be invariant.
java.util.GregorianCalendar.computeFields	(	): Converts the time value (millisecond offset from the Epoch) to calendar field values. The time is not recomputed first; to recompute the time, then the fields, call the complete method.
java.util.GregorianCalendar.computeFields	(	int	int	): This computeFields implements the conversion from UTC (millisecond offset from the Epoch) to calendar field values. fieldMask specifies which fields to change the setting state to COMPUTED, although all fields are set to the correct values. This is required to fix 4685354.
java.util.GregorianCalendar.computeTime	(	): Converts calendar field values to the time value (millisecond offset from the Epoch).
java.util.GregorianCalendar.equals	(	Object	): Compares this GregorianCalendar to the specified Object. The result is true if and only if the argument is a GregorianCalendar object that represents the same time value (millisecond offset from the Epoch) under the same Calendar parameters and Gregorian change date as this object.
java.util.GregorianCalendar.from	(	ZonedDateTime	): Obtains an instance of GregorianCalendar with the default locale from a ZonedDateTime object.  Since ZonedDateTime does not support a Julian-Gregorian cutover date and uses ISO calendar system, the return GregorianCalendar is a pure Gregorian calendar and uses ISO 8601 standard for week definitions, which has MONDAY as the getFirstDayOfWeek() FirstDayOfWeek and 4 as the value of the getMinimalDaysInFirstWeek() MinimalDaysInFirstWeek.  ZoneDateTime can store points on the time-line further in the future and further in the past than GregorianCalendar. In this scenario, this method will throw an IllegalArgumentException exception.
java.util.GregorianCalendar.getActualMaximum	(	int	): Returns the maximum value that this calendar field could have, taking into consideration the given time value and the current values of the getFirstDayOfWeek(), getMinimalDaysInFirstWeek(), getGregorianChange() and getTimeZone() methods. For example, if the date of this instance is February 1, 2004, the actual maximum value of the DAY_OF_MONTH field is 29 because 2004 is a leap year, and if the date of this instance is February 1, 2005, it's 28. This method calculates the maximum value of WEEK_OF_YEAR based on the YEAR (calendar year) value, not the week year. Call getWeeksInWeekYear() to get the maximum value of WEEK_OF_YEAR in the week year of this GregorianCalendar.
java.util.GregorianCalendar.getActualMinimum	(	int	): Returns the minimum value that this calendar field could have, taking into consideration the given time value and the current values of the getFirstDayOfWeek(), getMinimalDaysInFirstWeek(), getGregorianChange() and getTimeZone() methods. For example, if the Gregorian change date is January 10, 1970 and the date of this GregorianCalendar is January 20, 1970, the actual minimum value of the DAY_OF_MONTH field is 10 because the previous date of January 10, 1970 is December 27, 1996 (in the Julian calendar). Therefore, December 28, 1969 to January 9, 1970 don't exist.
java.util.GregorianCalendar.getCalendarDate	(	long	): Returns a CalendarDate produced from the specified fixed date.
java.util.GregorianCalendar.getCalendarType	(	): Returns "gregory" as the calendar type.
java.util.GregorianCalendar.getCurrentFixedDate	(	): Returns the fixed date value of this object. The time value and calendar fields must be in synch.
java.util.GregorianCalendar.getCutoverCalendarSystem	(	): Returns the calendar system for dates before the cutover date in the cutover year. If the cutover date is January 1, the method returns Gregorian. Otherwise, Julian.
java.util.GregorianCalendar.getFixedDate	(	BaseCalendar	int	int	): Computes the fixed date under either the Gregorian or the Julian calendar, using the given year and the specified calendar fields.
java.util.GregorianCalendar.getFixedDateJan1	(	BaseCalendar.Date	long	): Returns the fixed date of the first day of the year (usually January 1) before the specified date.
java.util.GregorianCalendar.getFixedDateMonth1	(	BaseCalendar.Date	long	): Returns the fixed date of the first date of the month (usually the 1st of the month) before the specified date.
java.util.GregorianCalendar.getGreatestMinimum	(	int	): Returns the highest minimum value for the given calendar field of this GregorianCalendar instance. The highest minimum value is defined as the largest value returned by getActualMinimum() for any possible time value, taking into consideration the current values of the getFirstDayOfWeek(), getMinimalDaysInFirstWeek(), getGregorianChange() and getTimeZone() methods.
java.util.GregorianCalendar.getGregorianChange	(	): Gets the Gregorian Calendar change date. This is the point when the switch from Julian dates to Gregorian dates occurred. Default is October 15, 1582 (Gregorian). Previous to this, dates will be in the Julian calendar.
java.util.GregorianCalendar.getGregorianCutoverDate	(	): Returns the Gregorian cutover date as a BaseCalendar.Date. The date is a Gregorian date.
java.util.GregorianCalendar.getJulianCalendarSystem	(	): Returns the Julian calendar system instance (singleton). 'jcal' and 'jeras' are set upon the return.
java.util.GregorianCalendar.getLastJulianDate	(	): Returns the day before the Gregorian cutover date as a BaseCalendar.Date. The date is a Julian date.
java.util.GregorianCalendar.getLeastMaximum	(	int	): Returns the lowest maximum value for the given calendar field of this GregorianCalendar instance. The lowest maximum value is defined as the smallest value returned by getActualMaximum() for any possible time value, taking into consideration the current values of the getFirstDayOfWeek(), getMinimalDaysInFirstWeek(), getGregorianChange() and getTimeZone() methods.
java.util.GregorianCalendar.getMaximum	(	int	): Returns the maximum value for the given calendar field of this GregorianCalendar instance. The maximum value is defined as the largest value returned by the get() method for any possible time value, taking into consideration the current values of the getFirstDayOfWeek(), getMinimalDaysInFirstWeek(), getGregorianChange() and getTimeZone() methods.
java.util.GregorianCalendar.getMinimum	(	int	): Returns the minimum value for the given calendar field of this GregorianCalendar instance. The minimum value is defined as the smallest value returned by the get() method for any possible time value, taking into consideration the current values of the getFirstDayOfWeek(), getMinimalDaysInFirstWeek(), getGregorianChange() and getTimeZone() methods.
java.util.GregorianCalendar.getNormalizedCalendar	(	): Returns this object if it's normalized (all fields and time are in sync). Otherwise, a cloned object is returned after calling complete() in lenient mode.
java.util.GregorianCalendar.getRolledValue	(	int	int	int	int	): Returns the new value after 'roll'ing the specified value and amount.
java.util.GregorianCalendar.getWeekNumber	(	long	long	): Returns the number of weeks in a period between fixedDay1 and fixedDate. The getFirstDayOfWeek-getMinimalDaysInFirstWeek rule is applied to calculate the number of weeks.
java.util.GregorianCalendar.getWeekYear	(	): Returns the week year represented by this GregorianCalendar. The dates in the weeks between 1 and the maximum week number of the week year have the same week year value that may be one year before or after the YEAR (calendar year) value. This method calls complete() before calculating the week year.
java.util.GregorianCalendar.getWeeksInWeekYear	(	): Returns the number of weeks in the week year represented by this GregorianCalendar. For example, if this GregorianCalendar's date is December 31, 2008 with the ISO 8601 compatible setting, this method will return 53 for the period: December 29, 2008 to January 3, 2010 while getActualMaximum() getActualMaximum(WEEK_OF_YEAR) will return 52 for the period: December 31, 2007 to December 28, 2008.
java.util.GregorianCalendar.getYearOffsetInMillis	(	): Returns the millisecond offset from the beginning of this year. This Calendar object must have been normalized.
java.util.GregorianCalendar.hashCode	(	): Generates the hash code for this GregorianCalendar object.
java.util.GregorianCalendar.internalGetEra	(	): Returns the ERA. We need a special method for this because the default ERA is CE, but a zero (unset) ERA is BCE.
java.util.GregorianCalendar.isCutoverYear	(	int	): Determines if the specified year (normalized) is the Gregorian cutover year. This object must have been normalized.
java.util.GregorianCalendar.isLeapYear	(	int	): Determines if the given year is a leap year. Returns true if the given year is a leap year. To specify BC year numbers, 1 - year number must be given. For example, year BC 4 is specified as -3.
java.util.GregorianCalendar.isWeekDateSupported	(	): Returns true indicating this GregorianCalendar supports week dates.
java.util.GregorianCalendar.monthLength	(	int	): Returns the length of the specified month in the year provided by internalGet(YEAR).
java.util.GregorianCalendar.monthLength	(	int	int	): Returns the length of the specified month in the specified year. The year number must be normalized.
java.util.GregorianCalendar.pinDayOfMonth	(	): After adjustments such as add(MONTH), add(YEAR), we don't want the month to jump around. E.g., we don't want Jan 31 + 1 month to go to Mar 3, we want it to go to Feb 28. Adjustments which might run into this problem call this method to retain the proper month.
java.util.GregorianCalendar.readObject	(	ObjectInputStream	): Updates internal state.
java.util.GregorianCalendar.roll	(	int	boolean	): Adds or subtracts (up/down) a single unit of time on the given time field without changing larger fields.  Example: Consider a GregorianCalendar originally set to December 31, 1999. Calling roll() roll(Calendar.MONTH, true) sets the calendar to January 31, 1999. The YEAR field is unchanged because it is a larger field than MONTH.
java.util.GregorianCalendar.roll	(	int	int	): Adds a signed amount to the specified calendar field without changing larger fields. A negative roll amount means to subtract from field without changing larger fields. If the specified amount is 0, this method performs nothing. This method calls complete() before adding the amount so that all the calendar fields are normalized. If there is any calendar field having an out-of-range value in non-lenient mode, then an IllegalArgumentException is thrown.  Example: Consider a GregorianCalendar originally set to August 31, 1999. Calling roll(Calendar.MONTH, 8) sets the calendar to April 30, 1999. Using a GregorianCalendar, the DAY_OF_MONTH field cannot be 31 in the month April. DAY_OF_MONTH is set to the closest possible value, 30. The YEAR field maintains the value of 1999 because it is a larger field than MONTH.  Example: Consider a GregorianCalendar originally set to Sunday June 6, 1999. Calling roll(Calendar.WEEK_OF_MONTH, -1) sets the calendar to Tuesday June 1, 1999, whereas calling add(Calendar.WEEK_OF_MONTH, -1) sets the calendar to Sunday May 30, 1999. This is because the roll rule imposes an additional constraint: The MONTH must not change when the WEEK_OF_MONTH is rolled. Taken together with add rule 1, the resultant date must be between Tuesday June 1 and Saturday June 5. According to add rule 2, the DAY_OF_WEEK, an invariant when changing the WEEK_OF_MONTH, is set to Tuesday, the closest possible value to Sunday (where Sunday is the first day of the week).
java.util.GregorianCalendar.setGregorianChange	(	Date	): Sets the GregorianCalendar change date. This is the point when the switch from Julian dates to Gregorian dates occurred. Default is October 15, 1582 (Gregorian). Previous to this, dates will be in the Julian calendar.  To obtain a pure Julian calendar, set the change date to Date(Long.MAX_VALUE). To obtain a pure Gregorian calendar, set the change date to Date(Long.MIN_VALUE).
java.util.GregorianCalendar.setWeekDate	(	int	int	int	): Sets this GregorianCalendar to the date given by the date specifiers - weekYear, weekOfYear, and dayOfWeek. weekOfYear follows the WEEK_OF_YEAR numbering. The dayOfWeek value must be one of the DAY_OF_WEEK values: SUNDAY to SATURDAY. Note that the numeric day-of-week representation differs from the ISO 8601 standard, and that the weekOfYear numbering is compatible with the standard when getFirstDayOfWeek() is MONDAY and getMinimalDaysInFirstWeek() is 4. Unlike the set method, all of the calendar fields and the instant of time value are calculated upon return. If weekOfYear is out of the valid week-of-year range in weekYear, the weekYear and weekOfYear values are adjusted in lenient mode, or an IllegalArgumentException is thrown in non-lenient mode.
java.util.GregorianCalendar.toZonedDateTime	(	): Converts this object to a ZonedDateTime that represents the same point on the time-line as this GregorianCalendar.  Since this object supports a Julian-Gregorian cutover date and ZonedDateTime does not, it is possible that the resulting year, month and day will have different values. The result will represent the correct date in the ISO calendar system, which will also be the same value for Modified Julian Days.
java.util.GregorianCalendar.yearLength	(	): Returns the length (in days) of the year provided by internalGet(YEAR).
java.util.GregorianCalendar.yearLength	(	int	): Returns the length (in days) of the specified year. The year must be normalized.
java.util.HashMap: Hash table based implementation of the Map interface. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time. This implementation provides constant-time performance for the basic operations (get and put), assuming the hash function disperses the elements properly among the buckets. Iteration over collection views requires time proportional to the "capacity" of the HashMap instance (the number of buckets) plus its size (the number of key-value mappings). Thus, it's very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important. An instance of HashMap has two parameters that affect its performance: initial capacity and load factor. The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased. When the number of entries in the hash table exceeds the product of the load factor and the current capacity, the hash table is rehashed (that is, internal data structures are rebuilt) so that the hash table has approximately twice the number of buckets. As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the HashMap class, including get and put). The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations. If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur. If many mappings are to be stored in a HashMap instance, creating it with a sufficiently large capacity will allow the mappings to be stored more efficiently than letting it perform automatic rehashing as needed to grow the table. Note that using many keys with the same hashCode() is a sure way to slow down performance of any hash table. To ameliorate impact, when keys are Comparable, this class may use comparison order among keys to help break ties. Note that this implementation is not synchronized. If multiple threads access a hash map concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more mappings; merely changing the value associated with a key that an instance already contains is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the map. If no such object exists, the map should be "wrapped" using the synchronizedMap Collections.synchronizedMap method. This is best done at creation time, to prevent accidental unsynchronized access to the map: Map m = Collections.synchronizedMap(new HashMap(...)); The iterators returned by all of this class's "collection view methods" are fail-fast: if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. This class is a member of the  Java Collections Framework.
java.util.HashMap.HashMap	(	): Constructs an empty HashMap with the default initial capacity (16) and the default load factor (0.75).
java.util.HashMap.HashMap	(	Map	): Constructs a new HashMap with the same mappings as the specified Map. The HashMap is created with default load factor (0.75) and an initial capacity sufficient to hold the mappings in the specified Map.
java.util.HashMap.HashMap	(	int	): Constructs an empty HashMap with the specified initial capacity and the default load factor (0.75).
java.util.HashMap.HashMap	(	int	float	): Constructs an empty HashMap with the specified initial capacity and load factor.
java.util.HashMap.Node: Basic hash bin node, used for most entries. (See below for TreeNode subclass, and in LinkedHashMap for its Entry subclass.)
java.util.HashMap.TreeNode: Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn extends Node) so can be used as extension of either regular or linked node.
java.util.HashMap.TreeNode.checkInvariants	(	TreeNode	): Recursive invariant check
java.util.HashMap.TreeNode.find	(	int	Object	Class	): Finds the node starting at root p with the given hash and key. The kc argument caches comparableClassFor(key) upon first use comparing keys.
java.util.HashMap.TreeNode.getTreeNode	(	int	Object	): Calls find for root node.
java.util.HashMap.TreeNode.moveRootToFront	(	Node[]	TreeNode	): Ensures that the given root is the first node of its bin.
java.util.HashMap.TreeNode.putTreeVal	(	HashMap	Node[]	int	K	V	): Tree version of putVal.
java.util.HashMap.TreeNode.removeTreeNode	(	HashMap	Node[]	boolean	): Removes the given node, that must be present before this call. This is messier than typical red-black deletion code because we cannot swap the contents of an interior node with a leaf successor that is pinned by "next" pointers that are accessible independently during traversal. So instead we swap the tree linkages. If the current tree appears to have too few nodes, the bin is converted back to a plain bin. (The test triggers somewhere between 2 and 6 nodes, depending on tree structure).
java.util.HashMap.TreeNode.root	(	): Returns root of tree containing this node.
java.util.HashMap.TreeNode.split	(	HashMap	Node[]	int	int	): Splits nodes in a tree bin into lower and upper tree bins, or untreeifies if now too small. Called only from resize; see above discussion about split bits and indices.
java.util.HashMap.TreeNode.tieBreakOrder	(	Object	Object	): Tie-breaking utility for ordering insertions when equal hashCodes and non-comparable. We don't require a total order, just a consistent insertion rule to maintain equivalence across rebalancings. Tie-breaking further than necessary simplifies testing a bit.
java.util.HashMap.TreeNode.treeify	(	Node[]	): Forms tree of the nodes linked from this node.
java.util.HashMap.TreeNode.untreeify	(	HashMap	): Returns a list of non-TreeNodes replacing those linked from this node.
java.util.HashMap.clear	(	): Removes all of the mappings from this map. The map will be empty after this call returns.
java.util.HashMap.clone	(	): Returns a shallow copy of this HashMap instance: the keys and values themselves are not cloned.
java.util.HashMap.comparableClassFor	(	Object	): Returns x's Class if it is of the form "class C implements Comparable", else null.
java.util.HashMap.compareComparables	(	Class	Object	Object	): Returns k.compareTo(x) if x matches kc (k's screened comparable class), else 0.
java.util.HashMap.containsKey	(	Object	): Returns true if this map contains a mapping for the specified key.
java.util.HashMap.containsValue	(	Object	): Returns true if this map maps one or more keys to the specified value.
java.util.HashMap.entrySet	(	): Returns a Set view of the mappings contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation, or through the setValue operation on a map entry returned by the iterator) the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.HashMap.get	(	Object	): Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that (key==null ? k==null : key.equals(k)), then this method returns v; otherwise it returns null. (There can be at most one such mapping.) A return value of null does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to null. The containsKey operation may be used to distinguish these two cases.
java.util.HashMap.getNode	(	int	Object	): Implements Map.get and related methods
java.util.HashMap.hash	(	Object	): Computes key.hashCode() and spreads (XORs) higher bits of hash to lower. Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.) So we apply a transform that spreads the impact of higher bits downward. There is a tradeoff between speed, utility, and quality of bit-spreading. Because many common sets of hashes are already reasonably distributed (so don't benefit from spreading), and because we use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds.
java.util.HashMap.isEmpty	(	): Returns true if this map contains no key-value mappings.
java.util.HashMap.keySet	(	): Returns a Set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.HashMap.put	(	K	V	): Associates the specified value with the specified key in this map. If the map previously contained a mapping for the key, the old value is replaced.
java.util.HashMap.putAll	(	Map	): Copies all of the mappings from the specified map to this map. These mappings will replace any mappings that this map had for any of the keys currently in the specified map.
java.util.HashMap.putMapEntries	(	Map	boolean	): Implements Map.putAll and Map constructor
java.util.HashMap.putVal	(	int	K	V	boolean	boolean	): Implements Map.put and related methods
java.util.HashMap.readObject	(	java.io.ObjectInputStream	): Reconstitute the HashMap instance from a stream (i.e., deserialize it).
java.util.HashMap.reinitialize	(	): Reset to initial default state. Called by clone and readObject.
java.util.HashMap.remove	(	Object	): Removes the mapping for the specified key from this map if present.
java.util.HashMap.removeNode	(	int	Object	Object	boolean	boolean	): Implements Map.remove and related methods
java.util.HashMap.resize	(	): Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must either stay at same index, or move with a power of two offset in the new table.
java.util.HashMap.size	(	): Returns the number of key-value mappings in this map.
java.util.HashMap.tableSizeFor	(	int	): Returns a power of two size for the given target capacity.
java.util.HashMap.treeifyBin	(	Node[]	int	): Replaces all linked nodes in bin at index for given hash unless table is too small, in which case resizes instead.
java.util.HashMap.values	(	): Returns a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.HashMap.writeObject	(	java.io.ObjectOutputStream	): Save the state of the HashMap instance to a stream (i.e., serialize it).
java.util.HashSet: This class implements the Set interface, backed by a hash table (actually a HashMap instance). It makes no guarantees as to the iteration order of the set; in particular, it does not guarantee that the order will remain constant over time. This class permits the null element. This class offers constant time performance for the basic operations (add, remove, contains and size), assuming the hash function disperses the elements properly among the buckets. Iterating over this set requires time proportional to the sum of the HashSet instance's size (the number of elements) plus the "capacity" of the backing HashMap instance (the number of buckets). Thus, it's very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important. Note that this implementation is not synchronized. If multiple threads access a hash set concurrently, and at least one of the threads modifies the set, it must be synchronized externally. This is typically accomplished by synchronizing on some object that naturally encapsulates the set. If no such object exists, the set should be "wrapped" using the synchronizedSet Collections.synchronizedSet method. This is best done at creation time, to prevent accidental unsynchronized access to the set: Set s = Collections.synchronizedSet(new HashSet(...)); The iterators returned by this class's iterator method are fail-fast: if the set is modified at any time after the iterator is created, in any way except through the iterator's own remove method, the Iterator throws a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. This class is a member of the  Java Collections Framework.
java.util.HashSet.HashSet	(	): Constructs a new, empty set; the backing HashMap instance has default initial capacity (16) and load factor (0.75).
java.util.HashSet.HashSet	(	Collection	): Constructs a new set containing the elements in the specified collection. The HashMap is created with default load factor (0.75) and an initial capacity sufficient to contain the elements in the specified collection.
java.util.HashSet.HashSet	(	int	): Constructs a new, empty set; the backing HashMap instance has the specified initial capacity and default load factor (0.75).
java.util.HashSet.HashSet	(	int	float	): Constructs a new, empty set; the backing HashMap instance has the specified initial capacity and the specified load factor.
java.util.HashSet.HashSet	(	int	float	boolean	): Constructs a new, empty linked hash set. (This package private constructor is only used by LinkedHashSet.) The backing HashMap instance is a LinkedHashMap with the specified initial capacity and the specified load factor.
java.util.HashSet.add	(	E	): Adds the specified element to this set if it is not already present. More formally, adds the specified element e to this set if this set contains no element e2 such that (e==null ? e2==null : e.equals(e2)). If this set already contains the element, the call leaves the set unchanged and returns false.
java.util.HashSet.clear	(	): Removes all of the elements from this set. The set will be empty after this call returns.
java.util.HashSet.clone	(	): Returns a shallow copy of this HashSet instance: the elements themselves are not cloned.
java.util.HashSet.contains	(	Object	): Returns true if this set contains the specified element. More formally, returns true if and only if this set contains an element e such that (o==null ? e==null : o.equals(e)).
java.util.HashSet.isEmpty	(	): Returns true if this set contains no elements.
java.util.HashSet.iterator	(	): Returns an iterator over the elements in this set. The elements are returned in no particular order.
java.util.HashSet.readObject	(	java.io.ObjectInputStream	): Reconstitute the HashSet instance from a stream (that is, deserialize it).
java.util.HashSet.remove	(	Object	): Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)
java.util.HashSet.size	(	): Returns the number of elements in this set (its cardinality).
java.util.HashSet.spliterator	(	): Creates a late-binding and fail-fast Spliterator over the elements in this set. The Spliterator reports SIZED and DISTINCT. Overriding implementations should document the reporting of additional characteristic values.
java.util.HashSet.writeObject	(	java.io.ObjectOutputStream	): Save the state of this HashSet instance to a stream (that is, serialize it).
java.util.Hashtable: This class implements a hash table, which maps keys to values. Any non-null object can be used as a key or as a value.  To successfully store and retrieve objects from a hashtable, the objects used as keys must implement the hashCode method and the equals method.  An instance of Hashtable has two parameters that affect its performance: initial capacity and load factor. The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. Note that the hash table is open: in the case of a "hash collision", a single bucket stores multiple entries, which must be searched sequentially. The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased. The initial capacity and load factor parameters are merely hints to the implementation. The exact details as to when and whether the rehash method is invoked are implementation-dependent. Generally, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the time cost to look up an entry (which is reflected in most Hashtable operations, including get and put). The initial capacity controls a tradeoff between wasted space and the need for rehash operations, which are time-consuming. No rehash operations will ever occur if the initial capacity is greater than the maximum number of entries the Hashtable will contain divided by its load factor. However, setting the initial capacity too high can waste space. If many entries are to be made into a Hashtable, creating it with a sufficiently large capacity may allow the entries to be inserted more efficiently than letting it perform automatic rehashing as needed to grow the table.  This example creates a hashtable of numbers. It uses the names of the numbers as keys:  Hashtable numbers = new Hashtable(); numbers.put("one", 1); numbers.put("two", 2); numbers.put("three", 3); To retrieve a number, use the following code:  Integer n = numbers.get("two"); if (n != null) System.out.println("two = " + n); }} The iterators returned by the iterator method of the collections returned by all of this class's "collection view methods" are fail-fast: if the Hashtable is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. The Enumerations returned by Hashtable's keys and elements methods are not fail-fast. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. As of the Java 2 platform v1.2, this class was retrofitted to implement the Map interface, making it a member of the  Java Collections Framework. Unlike the new collection implementations, Hashtable is synchronized. If a thread-safe implementation is not needed, it is recommended to use HashMap in place of Hashtable. If a thread-safe highly-concurrent implementation is desired, then it is recommended to use java.util.concurrent.ConcurrentHashMap in place of Hashtable.
java.util.Hashtable.Entry: Hashtable bucket collision list entry
java.util.Hashtable.Enumerator: A hashtable enumerator class. This class implements both the Enumeration and Iterator interfaces, but individual instances can be created with the Iterator methods disabled. This is necessary to avoid unintentionally increasing the capabilities granted a user by passing an Enumeration.
java.util.Hashtable.Hashtable	(	): Constructs a new, empty hashtable with a default initial capacity (11) and load factor (0.75).
java.util.Hashtable.Hashtable	(	Map	): Constructs a new hashtable with the same mappings as the given Map. The hashtable is created with an initial capacity sufficient to hold the mappings in the given Map and a default load factor (0.75).
java.util.Hashtable.Hashtable	(	int	): Constructs a new, empty hashtable with the specified initial capacity and default load factor (0.75).
java.util.Hashtable.Hashtable	(	int	float	): Constructs a new, empty hashtable with the specified initial capacity and the specified load factor.
java.util.Hashtable.clear	(	): Clears this hashtable so that it contains no keys.
java.util.Hashtable.clone	(	): Creates a shallow copy of this hashtable. All the structure of the hashtable itself is copied, but the keys and values are not cloned. This is a relatively expensive operation.
java.util.Hashtable.contains	(	Object	): Tests if some key maps into the specified value in this hashtable. This operation is more expensive than the containsKey method. Note that this method is identical in functionality to containsValue, (which is part of the Map interface in the collections framework).
java.util.Hashtable.containsKey	(	Object	): Tests if the specified object is a key in this hashtable.
java.util.Hashtable.containsValue	(	Object	): Returns true if this hashtable maps one or more keys to this value. Note that this method is identical in functionality to contains (which predates the Map interface).
java.util.Hashtable.elements	(	): Returns an enumeration of the values in this hashtable. Use the Enumeration methods on the returned object to fetch the elements sequentially.
java.util.Hashtable.entrySet	(	): Returns a Set view of the mappings contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation, or through the setValue operation on a map entry returned by the iterator) the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.Hashtable.equals	(	Object	): Compares the specified Object with this Map for equality, as per the definition in the Map interface.
java.util.Hashtable.get	(	Object	): Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that (key.equals(k)), then this method returns v; otherwise it returns null. (There can be at most one such mapping.)
java.util.Hashtable.hashCode	(	): Returns the hash code value for this Map as per the definition in the Map interface.
java.util.Hashtable.isEmpty	(	): Tests if this hashtable maps no keys to values.
java.util.Hashtable.keySet	(	): Returns a Set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.Hashtable.keys	(	): Returns an enumeration of the keys in this hashtable.
java.util.Hashtable.put	(	K	V	): Maps the specified key to the specified value in this hashtable. Neither the key nor the value can be null.  The value can be retrieved by calling the get method with a key that is equal to the original key.
java.util.Hashtable.putAll	(	Map	): Copies all of the mappings from the specified map to this hashtable. These mappings will replace any mappings that this hashtable had for any of the keys currently in the specified map.
java.util.Hashtable.readObject	(	java.io.ObjectInputStream	): Reconstitute the Hashtable from a stream (i.e., deserialize it).
java.util.Hashtable.reconstitutionPut	(	Entry[]	K	V	): The put method used by readObject. This is provided because put is overridable and should not be called in readObject since the subclass will not yet be initialized. This differs from the regular put method in several ways. No checking for rehashing is necessary since the number of elements initially in the table is known. The modCount is not incremented because we are creating a new instance. Also, no return value is needed.
java.util.Hashtable.rehash	(	): Increases the capacity of and internally reorganizes this hashtable, in order to accommodate and access its entries more efficiently. This method is called automatically when the number of keys in the hashtable exceeds this hashtable's capacity and load factor.
java.util.Hashtable.remove	(	Object	): Removes the key (and its corresponding value) from this hashtable. This method does nothing if the key is not in the hashtable.
java.util.Hashtable.size	(	): Returns the number of keys in this hashtable.
java.util.Hashtable.toString	(	): Returns a string representation of this Hashtable object in the form of a set of entries, enclosed in braces and separated by the ASCII characters ", " (comma and space). Each entry is rendered as the key, an equals sign =, and the associated element, where the toString method is used to convert the key and element to strings.
java.util.Hashtable.values	(	): Returns a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.Hashtable.writeObject	(	java.io.ObjectOutputStream	): Save the state of the Hashtable to a stream (i.e., serialize it).
java.util.IdentityHashMap: This class implements the Map interface with a hash table, using reference-equality in place of object-equality when comparing keys (and values). In other words, in an IdentityHashMap, two keys k1 and k2 are considered equal if and only if (k1==k2). (In normal Map implementations (like HashMap) two keys k1 and k2 are considered equal if and only if (k1==null ? k2==null : k1.equals(k2)).) This class is not a general-purpose Map implementation! While this class implements the Map interface, it intentionally violates Map's general contract, which mandates the use of the equals method when comparing objects. This class is designed for use only in the rare cases wherein reference-equality semantics are required. A typical use of this class is topology-preserving object graph transformations, such as serialization or deep-copying. To perform such a transformation, a program must maintain a "node table" that keeps track of all the object references that have already been processed. The node table must not equate distinct objects even if they happen to be equal. Another typical use of this class is to maintain proxy objects. For example, a debugging facility might wish to maintain a proxy object for each object in the program being debugged. This class provides all of the optional map operations, and permits null values and the null key. This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time. This class provides constant-time performance for the basic operations (get and put), assuming the system identity hash function (identityHashCode()) disperses elements properly among the buckets. This class has one tuning parameter (which affects performance but not semantics): expected maximum size. This parameter is the maximum number of key-value mappings that the map is expected to hold. Internally, this parameter is used to determine the number of buckets initially comprising the hash table. The precise relationship between the expected maximum size and the number of buckets is unspecified. If the size of the map (the number of key-value mappings) sufficiently exceeds the expected maximum size, the number of buckets is increased. Increasing the number of buckets ("rehashing") may be fairly expensive, so it pays to create identity hash maps with a sufficiently large expected maximum size. On the other hand, iteration over collection views requires time proportional to the number of buckets in the hash table, so it pays not to set the expected maximum size too high if you are especially concerned with iteration performance or memory usage. Note that this implementation is not synchronized. If multiple threads access an identity hash map concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more mappings; merely changing the value associated with a key that an instance already contains is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the map. If no such object exists, the map should be "wrapped" using the synchronizedMap Collections.synchronizedMap method. This is best done at creation time, to prevent accidental unsynchronized access to the map: Map m = Collections.synchronizedMap(new IdentityHashMap(...)); The iterators returned by the iterator method of the collections returned by all of this class's "collection view methods" are fail-fast: if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: fail-fast iterators should be used only to detect bugs. Implementation note: This is a simple linear-probe hash table, as described for example in texts by Sedgewick and Knuth. The array alternates holding keys and values. (This has better locality for large tables than does using separate arrays.) For many JRE implementations and operation mixes, this class will yield better performance than HashMap (which uses chaining rather than linear-probing). This class is a member of the  Java Collections Framework.
java.util.IdentityHashMap.IdentityHashMap	(	): Constructs a new, empty identity hash map with a default expected maximum size (21).
java.util.IdentityHashMap.IdentityHashMap	(	Map	): Constructs a new identity hash map containing the keys-value mappings in the specified map.
java.util.IdentityHashMap.IdentityHashMap	(	int	): Constructs a new, empty map with the specified expected maximum size. Putting more than the expected number of key-value mappings into the map may cause the internal data structure to grow, which may be somewhat time-consuming.
java.util.IdentityHashMap.IdentityHashMapSpliterator: Similar form as array-based Spliterators, but skips blank elements, and guestimates size as decreasing by half per split.
java.util.IdentityHashMap.capacity	(	int	): Returns the appropriate capacity for the given expected maximum size. Returns the smallest power of two between MINIMUM_CAPACITY and MAXIMUM_CAPACITY, inclusive, that is greater than (3 expectedMaxSize)/2, if such a number exists. Otherwise returns MAXIMUM_CAPACITY.
java.util.IdentityHashMap.clear	(	): Removes all of the mappings from this map. The map will be empty after this call returns.
java.util.IdentityHashMap.clone	(	): Returns a shallow copy of this identity hash map: the keys and values themselves are not cloned.
java.util.IdentityHashMap.closeDeletion	(	int	): Rehash all possibly-colliding entries following a deletion. This preserves the linear-probe collision properties required by get, put, etc.
java.util.IdentityHashMap.containsKey	(	Object	): Tests whether the specified object reference is a key in this identity hash map.
java.util.IdentityHashMap.containsMapping	(	Object	Object	): Tests if the specified key-value mapping is in the map.
java.util.IdentityHashMap.containsValue	(	Object	): Tests whether the specified object reference is a value in this identity hash map.
java.util.IdentityHashMap.entrySet	(	): Returns a Set view of the mappings contained in this map. Each element in the returned set is a reference-equality-based Map.Entry. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress, the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll and clear methods. It does not support the add or addAll methods. Like the backing map, the Map.Entry objects in the set returned by this method define key and value equality as reference-equality rather than object-equality. This affects the behavior of the equals and hashCode methods of these Map.Entry objects. A reference-equality based Map.Entry e is equal to an object o if and only if o is a Map.Entry and e.getKey()==o.getKey() && e.getValue()==o.getValue(). To accommodate these equals semantics, the hashCode method returns System.identityHashCode(e.getKey()) ^ System.identityHashCode(e.getValue()). Owing to the reference-equality-based semantics of the Map.Entry instances in the set returned by this method, it is possible that the symmetry and transitivity requirements of the equals() contract may be violated if any of the entries in the set is compared to a normal map entry, or if the set returned by this method is compared to a set of normal map entries (such as would be returned by a call to this method on a normal map). However, the Object.equals contract is guaranteed to hold among identity-based map entries, and among sets of such entries. 
java.util.IdentityHashMap.equals	(	Object	): Compares the specified object with this map for equality. Returns true if the given object is also a map and the two maps represent identical object-reference mappings. More formally, this map is equal to another map m if and only if this.entrySet().equals(m.entrySet()). Owing to the reference-equality-based semantics of this map it is possible that the symmetry and transitivity requirements of the Object.equals contract may be violated if this map is compared to a normal map. However, the Object.equals contract is guaranteed to hold among IdentityHashMap instances.
java.util.IdentityHashMap.get	(	Object	): Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that (key == k), then this method returns v; otherwise it returns null. (There can be at most one such mapping.) A return value of null does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to null. The containsKey operation may be used to distinguish these two cases.
java.util.IdentityHashMap.hash	(	Object	int	): Returns index for Object x.
java.util.IdentityHashMap.hashCode	(	): Returns the hash code value for this map. The hash code of a map is defined to be the sum of the hash codes of each entry in the map's entrySet() view. This ensures that m1.equals(m2) implies that m1.hashCode()==m2.hashCode() for any two IdentityHashMap instances m1 and m2, as required by the general contract of hashCode. Owing to the reference-equality-based semantics of the Map.Entry instances in the set returned by this map's entrySet method, it is possible that the contractual requirement of Object.hashCode mentioned in the previous paragraph will be violated if one of the two objects being compared is an IdentityHashMap instance and the other is a normal map.
java.util.IdentityHashMap.init	(	int	): Initializes object to be an empty map with the specified initial capacity, which is assumed to be a power of two between MINIMUM_CAPACITY and MAXIMUM_CAPACITY inclusive.
java.util.IdentityHashMap.isEmpty	(	): Returns true if this identity hash map contains no key-value mappings.
java.util.IdentityHashMap.keySet	(	): Returns an identity-based set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress, the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear methods. It does not support the add or addAll methods. While the object returned by this method implements the Set interface, it does not obey Set's general contract. Like its backing map, the set returned by this method defines element equality as reference-equality rather than object-equality. This affects the behavior of its contains, remove, containsAll, equals, and hashCode methods. The equals method of the returned set returns true only if the specified object is a set containing exactly the same object references as the returned set. The symmetry and transitivity requirements of the Object.equals contract may be violated if the set returned by this method is compared to a normal set. However, the Object.equals contract is guaranteed to hold among sets returned by this method. The hashCode method of the returned set returns the sum of the identity hashcodes of the elements in the set, rather than the sum of their hashcodes. This is mandated by the change in the semantics of the equals method, in order to enforce the general contract of the Object.hashCode method among sets returned by this method.
java.util.IdentityHashMap.maskNull	(	Object	): Use NULL_KEY for key if it is null.
java.util.IdentityHashMap.nextKeyIndex	(	int	int	): Circularly traverses table of size len.
java.util.IdentityHashMap.put	(	K	V	): Associates the specified value with the specified key in this identity hash map. If the map previously contained a mapping for the key, the old value is replaced.
java.util.IdentityHashMap.putAll	(	Map	): Copies all of the mappings from the specified map to this map. These mappings will replace any mappings that this map had for any of the keys currently in the specified map.
java.util.IdentityHashMap.putForCreate	(	K	V	): The put method for readObject. It does not resize the table, update modCount, etc.
java.util.IdentityHashMap.readObject	(	java.io.ObjectInputStream	): Reconstitutes the IdentityHashMap instance from a stream (i.e., deserializes it).
java.util.IdentityHashMap.remove	(	Object	): Removes the mapping for this key from this map if present.
java.util.IdentityHashMap.removeMapping	(	Object	Object	): Removes the specified key-value mapping from the map if it is present.
java.util.IdentityHashMap.resize	(	int	): Resizes the table if necessary to hold given capacity.
java.util.IdentityHashMap.size	(	): Returns the number of key-value mappings in this identity hash map.
java.util.IdentityHashMap.unmaskNull	(	Object	): Returns internal representation of null key back to caller as null.
java.util.IdentityHashMap.values	(	): Returns a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress, the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear methods. It does not support the add or addAll methods. While the object returned by this method implements the Collection interface, it does not obey Collection's general contract. Like its backing map, the collection returned by this method defines element equality as reference-equality rather than object-equality. This affects the behavior of its contains, remove and containsAll methods.
java.util.IdentityHashMap.writeObject	(	java.io.ObjectOutputStream	): Saves the state of the IdentityHashMap instance to a stream (i.e., serializes it).
java.util.IllegalFormatCodePointException: Unchecked exception thrown when a character with an invalid Unicode code point as defined by isValidCodePoint is passed to the Formatter.  Unless otherwise specified, passing a null argument to any method or constructor in this class will cause a NullPointerException to be thrown.
java.util.IllegalFormatCodePointException.IllegalFormatCodePointException	(	int	): Constructs an instance of this class with the specified illegal code point as defined by isValidCodePoint.
java.util.IllegalFormatCodePointException.getCodePoint	(	): Returns the illegal code point as defined by isValidCodePoint.
java.util.IllegalFormatConversionException: Unchecked exception thrown when the argument corresponding to the format specifier is of an incompatible type.  Unless otherwise specified, passing a null argument to any method or constructor in this class will cause a NullPointerException to be thrown.
java.util.IllegalFormatConversionException.IllegalFormatConversionException	(	char	Class	): Constructs an instance of this class with the mismatched conversion and the corresponding argument class.
java.util.IllegalFormatConversionException.getArgumentClass	(	): Returns the class of the mismatched argument.
java.util.IllegalFormatConversionException.getConversion	(	): Returns the inapplicable conversion.
java.util.IllegalFormatException: Unchecked exception thrown when a format string contains an illegal syntax or a format specifier that is incompatible with the given arguments. Only explicit subtypes of this exception which correspond to specific errors should be instantiated.
java.util.IllegalFormatFlagsException: Unchecked exception thrown when an illegal combination flags is given.  Unless otherwise specified, passing a null argument to any method or constructor in this class will cause a NullPointerException to be thrown.
java.util.IllegalFormatFlagsException.IllegalFormatFlagsException	(	String	): Constructs an instance of this class with the specified flags.
java.util.IllegalFormatFlagsException.getFlags	(	): Returns the set of flags which contains an illegal combination.
java.util.IllegalFormatPrecisionException: Unchecked exception thrown when the precision is a negative value other than -1, the conversion does not support a precision, or the value is otherwise unsupported.
java.util.IllegalFormatPrecisionException.IllegalFormatPrecisionException	(	int	): Constructs an instance of this class with the specified precision.
java.util.IllegalFormatPrecisionException.getPrecision	(	): Returns the precision
java.util.IllegalFormatWidthException: Unchecked exception thrown when the format width is a negative value other than -1 or is otherwise unsupported.
java.util.IllegalFormatWidthException.IllegalFormatWidthException	(	int	): Constructs an instance of this class with the specified width.
java.util.IllegalFormatWidthException.getWidth	(	): Returns the width
java.util.IllformedLocaleException: Thrown by methods in Locale and Locale.Builder to indicate that an argument is not a well-formed BCP 47 tag.
java.util.IllformedLocaleException.IllformedLocaleException	(	): Constructs a new IllformedLocaleException with no detail message and -1 as the error index.
java.util.IllformedLocaleException.IllformedLocaleException	(	String	): Constructs a new IllformedLocaleException with the given message and -1 as the error index.
java.util.IllformedLocaleException.IllformedLocaleException	(	String	int	): Constructs a new IllformedLocaleException with the given message and the error index. The error index is the approximate offset from the start of the ill-formed value to the point where the parse first detected an error. A negative error index value indicates either the error index is not applicable or unknown.
java.util.IllformedLocaleException.getErrorIndex	(	): Returns the index where the error was found. A negative value indicates either the error index is not applicable or unknown.
java.util.InputMismatchException: Thrown by a Scanner to indicate that the token retrieved does not match the pattern for the expected type, or that the token is out of range for the expected type.
java.util.InputMismatchException.InputMismatchException	(	): Constructs an InputMismatchException with null as its error message string.
java.util.InputMismatchException.InputMismatchException	(	String	): Constructs an InputMismatchException, saving a reference to the error message string s for later retrieval by the getMessage method.
java.util.IntSummaryStatistics: A state object for collecting statistics such as count, min, max, sum, and average. This class is designed to work with (though does not require) java.util.stream streams. For example, you can compute summary statistics on a stream of ints with:  IntSummaryStatistics stats = intStream.collect(IntSummaryStatistics::new, IntSummaryStatistics::accept, IntSummaryStatistics::combine); IntSummaryStatistics can be used as a collect() reduction target for a java.util.stream.Stream stream. For example:  IntSummaryStatistics stats = people.stream() .collect(Collectors.summarizingInt(Person::getDependents)); This computes, in a single pass, the count of people, as well as the minimum, maximum, sum, and average of their number of dependents.
java.util.IntSummaryStatistics.IntSummaryStatistics	(	): Construct an empty instance with zero count, zero sum, Integer.MAX_VALUE min, Integer.MIN_VALUE max and zero average.
java.util.IntSummaryStatistics.accept	(	int	): Records a new value into the summary information
java.util.IntSummaryStatistics.combine	(	IntSummaryStatistics	): Combines the state of another IntSummaryStatistics into this one.
java.util.IntSummaryStatistics.getAverage	(	): Returns the arithmetic mean of values recorded, or zero if no values have been recorded.
java.util.IntSummaryStatistics.getCount	(	): Returns the count of values recorded.
java.util.IntSummaryStatistics.getMax	(	): Returns the maximum value recorded, or Integer.MIN_VALUE if no values have been recorded.
java.util.IntSummaryStatistics.getMin	(	): Returns the minimum value recorded, or Integer.MAX_VALUE if no values have been recorded.
java.util.IntSummaryStatistics.getSum	(	): Returns the sum of values recorded, or zero if no values have been recorded.
java.util.InvalidPropertiesFormatException: Thrown to indicate that an operation could not complete because the input did not conform to the appropriate XML document type for a collection of properties, as per the Properties specification. Note, that although InvalidPropertiesFormatException inherits Serializable interface from Exception, it is not intended to be Serializable. Appropriate serialization methods are implemented to throw NotSerializableException.
java.util.InvalidPropertiesFormatException.InvalidPropertiesFormatException	(	String	): Constructs an InvalidPropertiesFormatException with the specified detail message.
java.util.InvalidPropertiesFormatException.InvalidPropertiesFormatException	(	Throwable	): Constructs an InvalidPropertiesFormatException with the specified cause.
java.util.InvalidPropertiesFormatException.readObject	(	java.io.ObjectInputStream	): Throws NotSerializableException, since InvalidPropertiesFormatException objects are not intended to be serializable.
java.util.InvalidPropertiesFormatException.writeObject	(	java.io.ObjectOutputStream	): Throws NotSerializableException, since InvalidPropertiesFormatException objects are not intended to be serializable.
java.util.Iterator: An iterator over a collection. Iterator takes the place of Enumeration in the Java Collections Framework. Iterators differ from enumerations in two ways:   Iterators allow the caller to remove elements from the underlying collection during the iteration with well-defined semantics.  Method names have been improved.  This interface is a member of the  Java Collections Framework.
java.util.Iterator.forEachRemaining	(	Consumer	): Performs the given action for each remaining element until all elements have been processed or the action throws an exception. Actions are performed in the order of iteration, if that order is specified. Exceptions thrown by the action are relayed to the caller.
java.util.Iterator.hasNext	(	): Returns true if the iteration has more elements. (In other words, returns true if next would return an element rather than throwing an exception.)
java.util.Iterator.next	(	): Returns the next element in the iteration.
java.util.Iterator.remove	(	): Removes from the underlying collection the last element returned by this iterator (optional operation). This method can be called only once per call to next. The behavior of an iterator is unspecified if the underlying collection is modified while the iteration is in progress in any way other than by calling this method.
java.util.JapaneseImperialCalendar: JapaneseImperialCalendar implements a Japanese calendar system in which the imperial era-based year numbering is supported from the Meiji era. The following are the eras supported by this calendar system.  ERA value Era name Since (in Gregorian) ------------------------------------------------------ 0 N/A N/A 1 Meiji 1868-01-01 midnight local time 2 Taisho 1912-07-30 midnight local time 3 Showa 1926-12-25 midnight local time 4 Heisei 1989-01-08 midnight local time ------------------------------------------------------  ERA value 0 specifies the years before Meiji and the Gregorian year values are used. Unlike GregorianCalendar, the Julian to Gregorian transition is not supported because it doesn't make any sense to the Japanese calendar systems used before Meiji. To represent the years before Gregorian year 1, 0 and negative values are used. The Japanese Imperial rescripts and government decrees don't specify how to deal with time differences for applying the era transitions. This calendar implementation assumes local time for all transitions.
java.util.JapaneseImperialCalendar.JapaneseImperialCalendar	(	TimeZone	Locale	): Constructs a JapaneseImperialCalendar based on the current time in the given time zone with the given locale.
java.util.JapaneseImperialCalendar.JapaneseImperialCalendar	(	TimeZone	Locale	boolean	): Constructs an "empty" JapaneseImperialCalendar.
java.util.JapaneseImperialCalendar.add	(	int	int	): Adds the specified (signed) amount of time to the given calendar field, based on the calendar's rules. Add rule 1. The value of field after the call minus the value of field before the call is amount, modulo any overflow that has occurred in field. Overflow occurs when a field value exceeds its range and, as a result, the next larger field is incremented or decremented and the field value is adjusted back into its range. Add rule 2. If a smaller field is expected to be invariant, but it is impossible for it to be equal to its prior value because of changes in its minimum or maximum after field is changed, then its value is adjusted to be as close as possible to its expected value. A smaller field represents a smaller unit of time. HOUR is a smaller field than DAY_OF_MONTH. No adjustment is made to smaller fields that are not expected to be invariant. The calendar system determines what fields are expected to be invariant.
java.util.JapaneseImperialCalendar.computeFields	(	): Converts the time value (millisecond offset from the Epoch) to calendar field values. The time is not recomputed first; to recompute the time, then the fields, call the complete method.
java.util.JapaneseImperialCalendar.computeFields	(	int	int	): This computeFields implements the conversion from UTC (millisecond offset from the Epoch) to calendar field values. fieldMask specifies which fields to change the setting state to COMPUTED, although all fields are set to the correct values. This is required to fix 4685354.
java.util.JapaneseImperialCalendar.computeTime	(	): Converts calendar field values to the time value (millisecond offset from the Epoch).
java.util.JapaneseImperialCalendar.equals	(	Object	): Compares this JapaneseImperialCalendar to the specified Object. The result is true if and only if the argument is a JapaneseImperialCalendar object that represents the same time value (millisecond offset from the Epoch) under the same Calendar parameters.
java.util.JapaneseImperialCalendar.getActualMaximum	(	int	): Returns the maximum value that this calendar field could have, taking into consideration the given time value and the current values of the getFirstDayOfWeek(), getMinimalDaysInFirstWeek(), and getTimeZone() methods. For example, if the date of this instance is Heisei 16February 1, the actual maximum value of the DAY_OF_MONTH field is 29 because Heisei 16 is a leap year, and if the date of this instance is Heisei 17 February 1, it's 28.
java.util.JapaneseImperialCalendar.getActualMinimum	(	int	): Returns the minimum value that this calendar field could have, taking into consideration the given time value and the current values of the getFirstDayOfWeek(), getMinimalDaysInFirstWeek(), and getTimeZone() methods.
java.util.JapaneseImperialCalendar.getCalendarDate	(	long	): Returns a LocalGregorianCalendar.Date produced from the specified fixed date.
java.util.JapaneseImperialCalendar.getCalendarType	(	): Returns "japanese" as the calendar type of this JapaneseImperialCalendar.
java.util.JapaneseImperialCalendar.getFixedDate	(	int	int	int	): Computes the fixed date under either the Gregorian or the Julian calendar, using the given year and the specified calendar fields.
java.util.JapaneseImperialCalendar.getFixedDateJan1	(	LocalGregorianCalendar.Date	long	): Returns the fixed date of the first day of the year (usually January 1) before the specified date.
java.util.JapaneseImperialCalendar.getFixedDateMonth1	(	LocalGregorianCalendar.Date	long	): Returns the fixed date of the first date of the month (usually the 1st of the month) before the specified date.
java.util.JapaneseImperialCalendar.getGreatestMinimum	(	int	): Returns the highest minimum value for the given calendar field of this GregorianCalendar instance. The highest minimum value is defined as the largest value returned by getActualMinimum() for any possible time value, taking into consideration the current values of the getFirstDayOfWeek(), getMinimalDaysInFirstWeek(), and getTimeZone() methods.
java.util.JapaneseImperialCalendar.getLeastMaximum	(	int	): Returns the lowest maximum value for the given calendar field of this GregorianCalendar instance. The lowest maximum value is defined as the smallest value returned by getActualMaximum() for any possible time value, taking into consideration the current values of the getFirstDayOfWeek(), getMinimalDaysInFirstWeek(), and getTimeZone() methods.
java.util.JapaneseImperialCalendar.getMaximum	(	int	): Returns the maximum value for the given calendar field of this GregorianCalendar instance. The maximum value is defined as the largest value returned by the get() method for any possible time value, taking into consideration the current values of the getFirstDayOfWeek(), getMinimalDaysInFirstWeek(), and getTimeZone() methods.
java.util.JapaneseImperialCalendar.getMinimum	(	int	): Returns the minimum value for the given calendar field of this Calendar instance. The minimum value is defined as the smallest value returned by the get() method for any possible time value, taking into consideration the current values of the getFirstDayOfWeek(), getMinimalDaysInFirstWeek(), and getTimeZone() methods.
java.util.JapaneseImperialCalendar.getNormalizedCalendar	(	): Returns this object if it's normalized (all fields and time are in sync). Otherwise, a cloned object is returned after calling complete() in lenient mode.
java.util.JapaneseImperialCalendar.getRolledValue	(	int	int	int	int	): Returns the new value after 'roll'ing the specified value and amount.
java.util.JapaneseImperialCalendar.getTransitionEraIndex	(	LocalGregorianCalendar.Date	): Returns the index to the new era if the given date is in a transition month. For example, if the give date is Heisei 1 (1989) January 20, then the era index for Heisei is returned. Likewise, if the given date is Showa 64 (1989) January 3, then the era index for Heisei is returned. If the given date is not in any transition month, then -1 is returned.
java.util.JapaneseImperialCalendar.getWeekNumber	(	long	long	): Returns the number of weeks in a period between fixedDay1 and fixedDate. The getFirstDayOfWeek-getMinimalDaysInFirstWeek rule is applied to calculate the number of weeks.
java.util.JapaneseImperialCalendar.getYearOffsetInMillis	(	CalendarDate	): Returns the millisecond offset from the beginning of the year. In the year for Long.MIN_VALUE, it's a pseudo value beyond the limit. The given CalendarDate object must have been normalized before calling this method.
java.util.JapaneseImperialCalendar.hashCode	(	): Generates the hash code for this JapaneseImperialCalendar object.
java.util.JapaneseImperialCalendar.internalGetEra	(	): Returns the ERA. We need a special method for this because the default ERA is the current era, but a zero (unset) ERA means before Meiji.
java.util.JapaneseImperialCalendar.monthLength	(	int	): Returns the length of the specified month in the year provided by internalGet(YEAR).
java.util.JapaneseImperialCalendar.monthLength	(	int	int	): Returns the length of the specified month in the specified Gregorian year. The year number must be normalized.
java.util.JapaneseImperialCalendar.pinDayOfMonth	(	LocalGregorianCalendar.Date	): After adjustments such as add(MONTH), add(YEAR), we don't want the month to jump around. E.g., we don't want Jan 31 + 1 month to go to Mar 3, we want it to go to Feb 28. Adjustments which might run into this problem call this method to retain the proper month.
java.util.JapaneseImperialCalendar.readObject	(	ObjectInputStream	): Updates internal state.
java.util.JapaneseImperialCalendar.roll	(	int	int	): Adds a signed amount to the specified calendar field without changing larger fields. A negative roll amount means to subtract from field without changing larger fields. If the specified amount is 0, this method performs nothing. This method calls complete() before adding the amount so that all the calendar fields are normalized. If there is any calendar field having an out-of-range value in non-lenient mode, then an IllegalArgumentException is thrown.
java.util.JumboEnumSet: Private implementation class for EnumSet, for "jumbo" enum types (i.e., those with more than 64 elements).
java.util.JumboEnumSet.add	(	E	): Adds the specified element to this set if it is not already present.
java.util.JumboEnumSet.addAll	(	Collection	): Adds all of the elements in the specified collection to this set.
java.util.JumboEnumSet.clear	(	): Removes all of the elements from this set.
java.util.JumboEnumSet.contains	(	Object	): Returns true if this set contains the specified element.
java.util.JumboEnumSet.containsAll	(	Collection	): Returns true if this set contains all of the elements in the specified collection.
java.util.JumboEnumSet.equals	(	Object	): Compares the specified object with this set for equality. Returns true if the given object is also a set, the two sets have the same size, and every member of the given set is contained in this set.
java.util.JumboEnumSet.isEmpty	(	): Returns true if this set contains no elements.
java.util.JumboEnumSet.iterator	(	): Returns an iterator over the elements contained in this set. The iterator traverses the elements in their natural order (which is the order in which the enum constants are declared). The returned Iterator is a "weakly consistent" iterator that will never throw ConcurrentModificationException.
java.util.JumboEnumSet.recalculateSize	(	): Recalculates the size of the set. Returns true if it's changed.
java.util.JumboEnumSet.remove	(	Object	): Removes the specified element from this set if it is present.
java.util.JumboEnumSet.removeAll	(	Collection	): Removes from this set all of its elements that are contained in the specified collection.
java.util.JumboEnumSet.retainAll	(	Collection	): Retains only the elements in this set that are contained in the specified collection.
java.util.JumboEnumSet.size	(	): Returns the number of elements in this set.
java.util.LinkedHashMap: Hash table and linked list implementation of the Map interface, with predictable iteration order. This implementation differs from HashMap in that it maintains a doubly-linked list running through all of its entries. This linked list defines the iteration ordering, which is normally the order in which keys were inserted into the map (insertion-order). Note that insertion order is not affected if a key is re-inserted into the map. (A key k is reinserted into a map m if m.put(k, v) is invoked when m.containsKey(k) would return true immediately prior to the invocation.) This implementation spares its clients from the unspecified, generally chaotic ordering provided by HashMap (and Hashtable), without incurring the increased cost associated with TreeMap. It can be used to produce a copy of a map that has the same order as the original, regardless of the original map's implementation:  void foo(Map m) { Map copy = new LinkedHashMap(m); ... }  This technique is particularly useful if a module takes a map on input, copies it, and later returns results whose order is determined by that of the copy. (Clients generally appreciate having things returned in the same order they were presented.) A special LinkedHashMap() constructor is provided to create a linked hash map whose order of iteration is the order in which its entries were last accessed, from least-recently accessed to most-recently (access-order). This kind of map is well-suited to building LRU caches. Invoking the put, putIfAbsent, get, getOrDefault, compute, computeIfAbsent, computeIfPresent, or merge methods results in an access to the corresponding entry (assuming it exists after the invocation completes). The replace methods only result in an access of the entry if the value is replaced. The putAll method generates one entry access for each mapping in the specified map, in the order that key-value mappings are provided by the specified map's entry set iterator. No other methods generate entry accesses. In particular, operations on collection-views do not affect the order of iteration of the backing map. The removeEldestEntry() method may be overridden to impose a policy for removing stale mappings automatically when new mappings are added to the map. This class provides all of the optional Map operations, and permits null elements. Like HashMap, it provides constant-time performance for the basic operations (add, contains and remove), assuming the hash function disperses elements properly among the buckets. Performance is likely to be just slightly below that of HashMap, due to the added expense of maintaining the linked list, with one exception: Iteration over the collection-views of a LinkedHashMap requires time proportional to the size of the map, regardless of its capacity. Iteration over a HashMap is likely to be more expensive, requiring time proportional to its capacity. A linked hash map has two parameters that affect its performance: initial capacity and load factor. They are defined precisely as for HashMap. Note, however, that the penalty for choosing an excessively high value for initial capacity is less severe for this class than for HashMap, as iteration times for this class are unaffected by capacity. Note that this implementation is not synchronized. If multiple threads access a linked hash map concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally. This is typically accomplished by synchronizing on some object that naturally encapsulates the map. If no such object exists, the map should be "wrapped" using the synchronizedMap Collections.synchronizedMap method. This is best done at creation time, to prevent accidental unsynchronized access to the map: Map m = Collections.synchronizedMap(new LinkedHashMap(...)); A structural modification is any operation that adds or deletes one or more mappings or, in the case of access-ordered linked hash maps, affects iteration order. In insertion-ordered linked hash maps, merely changing the value associated with a key that is already contained in the map is not a structural modification. In access-ordered linked hash maps, merely querying the map with get is a structural modification. ) The iterators returned by the iterator method of the collections returned by all of this class's collection view methods are fail-fast: if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. The spliterators returned by the spliterator method of the collections returned by all of this class's collection view methods are late-binding, fail-fast, and additionally report ORDERED. This class is a member of the  Java Collections Framework.
java.util.LinkedHashMap.Entry: HashMap.Node subclass for normal LinkedHashMap entries.
java.util.LinkedHashMap.LinkedHashMap	(	): Constructs an empty insertion-ordered LinkedHashMap instance with the default initial capacity (16) and load factor (0.75).
java.util.LinkedHashMap.LinkedHashMap	(	Map	): Constructs an insertion-ordered LinkedHashMap instance with the same mappings as the specified map. The LinkedHashMap instance is created with a default load factor (0.75) and an initial capacity sufficient to hold the mappings in the specified map.
java.util.LinkedHashMap.LinkedHashMap	(	int	): Constructs an empty insertion-ordered LinkedHashMap instance with the specified initial capacity and a default load factor (0.75).
java.util.LinkedHashMap.LinkedHashMap	(	int	float	): Constructs an empty insertion-ordered LinkedHashMap instance with the specified initial capacity and load factor.
java.util.LinkedHashMap.LinkedHashMap	(	int	float	boolean	): Constructs an empty LinkedHashMap instance with the specified initial capacity, load factor and ordering mode.
java.util.LinkedHashMap.clear	(	): Removes all of the mappings from this map. The map will be empty after this call returns.
java.util.LinkedHashMap.containsValue	(	Object	): Returns true if this map maps one or more keys to the specified value.
java.util.LinkedHashMap.entrySet	(	): Returns a Set view of the mappings contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation, or through the setValue operation on a map entry returned by the iterator) the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations. Its Spliterator typically provides faster sequential performance but much poorer parallel performance than that of HashMap.
java.util.LinkedHashMap.get	(	Object	): Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that (key==null ? k==null : key.equals(k)), then this method returns v; otherwise it returns null. (There can be at most one such mapping.) A return value of null does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to null. The containsKey operation may be used to distinguish these two cases.
java.util.LinkedHashMap.getOrDefault	(	Object	V	): 
java.util.LinkedHashMap.keySet	(	): Returns a Set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations. Its Spliterator typically provides faster sequential performance but much poorer parallel performance than that of HashMap.
java.util.LinkedHashMap.removeEldestEntry	(	Map.Entry	): Returns true if this map should remove its eldest entry. This method is invoked by put and putAll after inserting a new entry into the map. It provides the implementor with the opportunity to remove the eldest entry each time a new one is added. This is useful if the map represents a cache: it allows the map to reduce memory consumption by deleting stale entries. Sample use: this override will allow the map to grow up to 100 entries and then delete the eldest entry each time a new entry is added, maintaining a steady state of 100 entries.  private static final int MAX_ENTRIES = 100; protected boolean removeEldestEntry(Map.Entry eldest) { return size() > MAX_ENTRIES; }  This method typically does not modify the map in any way, instead allowing the map to modify itself as directed by its return value. It is permitted for this method to modify the map directly, but if it does so, it must return false (indicating that the map should not attempt any further modification). The effects of returning true after modifying the map from within this method are unspecified. This implementation merely returns false (so that this map acts like a normal map - the eldest element is never removed).
java.util.LinkedHashMap.values	(	): Returns a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations. Its Spliterator typically provides faster sequential performance but much poorer parallel performance than that of HashMap.
java.util.LinkedHashSet: Hash table and linked list implementation of the Set interface, with predictable iteration order. This implementation differs from HashSet in that it maintains a doubly-linked list running through all of its entries. This linked list defines the iteration ordering, which is the order in which elements were inserted into the set (insertion-order). Note that insertion order is not affected if an element is re-inserted into the set. (An element e is reinserted into a set s if s.add(e) is invoked when s.contains(e) would return true immediately prior to the invocation.) This implementation spares its clients from the unspecified, generally chaotic ordering provided by HashSet, without incurring the increased cost associated with TreeSet. It can be used to produce a copy of a set that has the same order as the original, regardless of the original set's implementation:  void foo(Set s) { Set copy = new LinkedHashSet(s); ... }  This technique is particularly useful if a module takes a set on input, copies it, and later returns results whose order is determined by that of the copy. (Clients generally appreciate having things returned in the same order they were presented.) This class provides all of the optional Set operations, and permits null elements. Like HashSet, it provides constant-time performance for the basic operations (add, contains and remove), assuming the hash function disperses elements properly among the buckets. Performance is likely to be just slightly below that of HashSet, due to the added expense of maintaining the linked list, with one exception: Iteration over a LinkedHashSet requires time proportional to the size of the set, regardless of its capacity. Iteration over a HashSet is likely to be more expensive, requiring time proportional to its capacity. A linked hash set has two parameters that affect its performance: initial capacity and load factor. They are defined precisely as for HashSet. Note, however, that the penalty for choosing an excessively high value for initial capacity is less severe for this class than for HashSet, as iteration times for this class are unaffected by capacity. Note that this implementation is not synchronized. If multiple threads access a linked hash set concurrently, and at least one of the threads modifies the set, it must be synchronized externally. This is typically accomplished by synchronizing on some object that naturally encapsulates the set. If no such object exists, the set should be "wrapped" using the synchronizedSet Collections.synchronizedSet method. This is best done at creation time, to prevent accidental unsynchronized access to the set:  Set s = Collections.synchronizedSet(new LinkedHashSet(...)); The iterators returned by this class's iterator method are fail-fast: if the set is modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. This class is a member of the  Java Collections Framework.
java.util.LinkedHashSet.LinkedHashSet	(	): Constructs a new, empty linked hash set with the default initial capacity (16) and load factor (0.75).
java.util.LinkedHashSet.LinkedHashSet	(	Collection	): Constructs a new linked hash set with the same elements as the specified collection. The linked hash set is created with an initial capacity sufficient to hold the elements in the specified collection and the default load factor (0.75).
java.util.LinkedHashSet.LinkedHashSet	(	int	): Constructs a new, empty linked hash set with the specified initial capacity and the default load factor (0.75).
java.util.LinkedHashSet.LinkedHashSet	(	int	float	): Constructs a new, empty linked hash set with the specified initial capacity and load factor.
java.util.LinkedHashSet.spliterator	(	): Creates a late-binding and fail-fast Spliterator over the elements in this set. The Spliterator reports SIZED, DISTINCT, and ORDERED. Implementations should document the reporting of additional characteristic values.
java.util.LinkedList: Doubly-linked list implementation of the List and Deque interfaces. Implements all optional list operations, and permits all elements (including null). All of the operations perform as could be expected for a doubly-linked list. Operations that index into the list will traverse the list from the beginning or the end, whichever is closer to the specified index. Note that this implementation is not synchronized. If multiple threads access a linked list concurrently, and at least one of the threads modifies the list structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more elements; merely setting the value of an element is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the list. If no such object exists, the list should be "wrapped" using the synchronizedList Collections.synchronizedList method. This is best done at creation time, to prevent accidental unsynchronized access to the list: List list = Collections.synchronizedList(new LinkedList(...)); The iterators returned by this class's iterator and listIterator methods are fail-fast: if the list is structurally modified at any time after the iterator is created, in any way except through the Iterator's own remove or add methods, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. This class is a member of the  Java Collections Framework.
java.util.LinkedList.DescendingIterator: Adapter to provide descending iterators via ListItr.previous
java.util.LinkedList.LLSpliterator: A customized variant of Spliterators.IteratorSpliterator 
java.util.LinkedList.LinkedList	(	): Constructs an empty list.
java.util.LinkedList.LinkedList	(	Collection	): Constructs a list containing the elements of the specified collection, in the order they are returned by the collection's iterator.
java.util.LinkedList.add	(	E	): Appends the specified element to the end of this list. This method is equivalent to addLast.
java.util.LinkedList.add	(	int	E	): Inserts the specified element at the specified position in this list. Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices).
java.util.LinkedList.addAll	(	Collection	): Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's iterator. The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (Note that this will occur if the specified collection is this list, and it's nonempty.)
java.util.LinkedList.addAll	(	int	Collection	): Inserts all of the elements in the specified collection into this list, starting at the specified position. Shifts the element currently at that position (if any) and any subsequent elements to the right (increases their indices). The new elements will appear in the list in the order that they are returned by the specified collection's iterator.
java.util.LinkedList.addFirst	(	E	): Inserts the specified element at the beginning of this list.
java.util.LinkedList.addLast	(	E	): Appends the specified element to the end of this list. This method is equivalent to add.
java.util.LinkedList.clear	(	): Removes all of the elements from this list. The list will be empty after this call returns.
java.util.LinkedList.clone	(	): Returns a shallow copy of this LinkedList. (The elements themselves are not cloned.)
java.util.LinkedList.contains	(	Object	): Returns true if this list contains the specified element. More formally, returns true if and only if this list contains at least one element e such that (o==null ? e==null : o.equals(e)).
java.util.LinkedList.descendingIterator	(	): Returns an iterator over the elements in this deque in reverse sequential order. The elements will be returned in order from last (tail) to first (head).
java.util.LinkedList.element	(	): Retrieves, but does not remove, the head (first element) of this list.
java.util.LinkedList.get	(	int	): Returns the element at the specified position in this list.
java.util.LinkedList.getFirst	(	): Returns the first element in this list.
java.util.LinkedList.getLast	(	): Returns the last element in this list.
java.util.LinkedList.indexOf	(	Object	): Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.
java.util.LinkedList.isElementIndex	(	int	): Tells if the argument is the index of an existing element.
java.util.LinkedList.isPositionIndex	(	int	): Tells if the argument is the index of a valid position for an iterator or an add operation.
java.util.LinkedList.lastIndexOf	(	Object	): Returns the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the highest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.
java.util.LinkedList.linkBefore	(	E	Node	): Inserts element e before non-null Node succ.
java.util.LinkedList.linkFirst	(	E	): Links e as first element.
java.util.LinkedList.linkLast	(	E	): Links e as last element.
java.util.LinkedList.listIterator	(	int	): Returns a list-iterator of the elements in this list (in proper sequence), starting at the specified position in the list. Obeys the general contract of List.listIterator(int). The list-iterator is fail-fast: if the list is structurally modified at any time after the Iterator is created, in any way except through the list-iterator's own remove or add methods, the list-iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.
java.util.LinkedList.node	(	int	): Returns the (non-null) Node at the specified element index.
java.util.LinkedList.offer	(	E	): Adds the specified element as the tail (last element) of this list.
java.util.LinkedList.offerFirst	(	E	): Inserts the specified element at the front of this list.
java.util.LinkedList.offerLast	(	E	): Inserts the specified element at the end of this list.
java.util.LinkedList.outOfBoundsMsg	(	int	): Constructs an IndexOutOfBoundsException detail message. Of the many possible refactorings of the error handling code, this "outlining" performs best with both server and client VMs.
java.util.LinkedList.peek	(	): Retrieves, but does not remove, the head (first element) of this list.
java.util.LinkedList.peekFirst	(	): Retrieves, but does not remove, the first element of this list, or returns null if this list is empty.
java.util.LinkedList.peekLast	(	): Retrieves, but does not remove, the last element of this list, or returns null if this list is empty.
java.util.LinkedList.poll	(	): Retrieves and removes the head (first element) of this list.
java.util.LinkedList.pollFirst	(	): Retrieves and removes the first element of this list, or returns null if this list is empty.
java.util.LinkedList.pollLast	(	): Retrieves and removes the last element of this list, or returns null if this list is empty.
java.util.LinkedList.pop	(	): Pops an element from the stack represented by this list. In other words, removes and returns the first element of this list. This method is equivalent to removeFirst().
java.util.LinkedList.push	(	E	): Pushes an element onto the stack represented by this list. In other words, inserts the element at the front of this list. This method is equivalent to addFirst.
java.util.LinkedList.readObject	(	java.io.ObjectInputStream	): Reconstitutes this LinkedList instance from a stream (that is, deserializes it).
java.util.LinkedList.remove	(	): Retrieves and removes the head (first element) of this list.
java.util.LinkedList.remove	(	Object	): Removes the first occurrence of the specified element from this list, if it is present. If this list does not contain the element, it is unchanged. More formally, removes the element with the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))) (if such an element exists). Returns true if this list contained the specified element (or equivalently, if this list changed as a result of the call).
java.util.LinkedList.remove	(	int	): Removes the element at the specified position in this list. Shifts any subsequent elements to the left (subtracts one from their indices). Returns the element that was removed from the list.
java.util.LinkedList.removeFirst	(	): Removes and returns the first element from this list.
java.util.LinkedList.removeFirstOccurrence	(	Object	): Removes the first occurrence of the specified element in this list (when traversing the list from head to tail). If the list does not contain the element, it is unchanged.
java.util.LinkedList.removeLast	(	): Removes and returns the last element from this list.
java.util.LinkedList.removeLastOccurrence	(	Object	): Removes the last occurrence of the specified element in this list (when traversing the list from head to tail). If the list does not contain the element, it is unchanged.
java.util.LinkedList.set	(	int	E	): Replaces the element at the specified position in this list with the specified element.
java.util.LinkedList.size	(	): Returns the number of elements in this list.
java.util.LinkedList.spliterator	(	): Creates a late-binding and fail-fast Spliterator over the elements in this list. The Spliterator reports SIZED and ORDERED. Overriding implementations should document the reporting of additional characteristic values.
java.util.LinkedList.toArray	(	): Returns an array containing all of the elements in this list in proper sequence (from first to last element). The returned array will be "safe" in that no references to it are maintained by this list. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.LinkedList.toArray	(	T[]	): Returns an array containing all of the elements in this list in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array. If the list fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this list. If the list fits in the specified array with room to spare (i.e., the array has more elements than the list), the element in the array immediately following the end of the list is set to null. (This is useful in determining the length of the list only if the caller knows that the list does not contain any null elements.) Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a list known to contain only strings. The following code can be used to dump the list into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.LinkedList.unlink	(	Node	): Unlinks non-null node x.
java.util.LinkedList.unlinkFirst	(	Node	): Unlinks non-null first node f.
java.util.LinkedList.unlinkLast	(	Node	): Unlinks non-null last node l.
java.util.LinkedList.writeObject	(	java.io.ObjectOutputStream	): Saves the state of this LinkedList instance to a stream (that is, serializes it).
java.util.List: An ordered collection (also known as a sequence). The user of this interface has precise control over where in the list each element is inserted. The user can access elements by their integer index (position in the list), and search for elements in the list. Unlike sets, lists typically allow duplicate elements. More formally, lists typically allow pairs of elements e1 and e2 such that e1.equals(e2), and they typically allow multiple null elements if they allow null elements at all. It is not inconceivable that someone might wish to implement a list that prohibits duplicates, by throwing runtime exceptions when the user attempts to insert them, but we expect this usage to be rare. The List interface places additional stipulations, beyond those specified in the Collection interface, on the contracts of the iterator, add, remove, equals, and hashCode methods. Declarations for other inherited methods are also included here for convenience. The List interface provides four methods for positional (indexed) access to list elements. Lists (like Java arrays) are zero based. Note that these operations may execute in time proportional to the index value for some implementations (the LinkedList class, for example). Thus, iterating over the elements in a list is typically preferable to indexing through it if the caller does not know the implementation. The List interface provides a special iterator, called a ListIterator, that allows element insertion and replacement, and bidirectional access in addition to the normal operations that the Iterator interface provides. A method is provided to obtain a list iterator that starts at a specified position in the list. The List interface provides two methods to search for a specified object. From a performance standpoint, these methods should be used with caution. In many implementations they will perform costly linear searches. The List interface provides two methods to efficiently insert and remove multiple elements at an arbitrary point in the list. Note: While it is permissible for lists to contain themselves as elements, extreme caution is advised: the equals and hashCode methods are no longer well defined on such a list. Some list implementations have restrictions on the elements that they may contain. For example, some implementations prohibit null elements, and some have restrictions on the types of their elements. Attempting to add an ineligible element throws an unchecked exception, typically NullPointerException or ClassCastException. Attempting to query the presence of an ineligible element may throw an exception, or it may simply return false; some implementations will exhibit the former behavior and some will exhibit the latter. More generally, attempting an operation on an ineligible element whose completion would not result in the insertion of an ineligible element into the list may throw an exception or it may succeed, at the option of the implementation. Such exceptions are marked as "optional" in the specification for this interface. This interface is a member of the  Java Collections Framework.
java.util.List.add	(	E	): Appends the specified element to the end of this list (optional operation). Lists that support this operation may place limitations on what elements may be added to this list. In particular, some lists will refuse to add null elements, and others will impose restrictions on the type of elements that may be added. List classes should clearly specify in their documentation any restrictions on what elements may be added.
java.util.List.add	(	int	E	): Inserts the specified element at the specified position in this list (optional operation). Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices).
java.util.List.addAll	(	Collection	): Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's iterator (optional operation). The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (Note that this will occur if the specified collection is this list, and it's nonempty.)
java.util.List.addAll	(	int	Collection	): Inserts all of the elements in the specified collection into this list at the specified position (optional operation). Shifts the element currently at that position (if any) and any subsequent elements to the right (increases their indices). The new elements will appear in this list in the order that they are returned by the specified collection's iterator. The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (Note that this will occur if the specified collection is this list, and it's nonempty.)
java.util.List.clear	(	): Removes all of the elements from this list (optional operation). The list will be empty after this call returns.
java.util.List.contains	(	Object	): Returns true if this list contains the specified element. More formally, returns true if and only if this list contains at least one element e such that (o==null ? e==null : o.equals(e)).
java.util.List.containsAll	(	Collection	): Returns true if this list contains all of the elements of the specified collection.
java.util.List.equals	(	Object	): Compares the specified object with this list for equality. Returns true if and only if the specified object is also a list, both lists have the same size, and all corresponding pairs of elements in the two lists are equal. (Two elements e1 and e2 are equal if (e1==null ? e2==null : e1.equals(e2)).) In other words, two lists are defined to be equal if they contain the same elements in the same order. This definition ensures that the equals method works properly across different implementations of the List interface.
java.util.List.get	(	int	): Returns the element at the specified position in this list.
java.util.List.hashCode	(	): Returns the hash code value for this list. The hash code of a list is defined to be the result of the following calculation: int hashCode = 1; for (E e : list) hashCode = 31*hashCode + (e==null ? 0 : e.hashCode()); This ensures that list1.equals(list2) implies that list1.hashCode()==list2.hashCode() for any two lists, list1 and list2, as required by the general contract of hashCode.
java.util.List.indexOf	(	Object	): Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.
java.util.List.isEmpty	(	): Returns true if this list contains no elements.
java.util.List.iterator	(	): Returns an iterator over the elements in this list in proper sequence.
java.util.List.lastIndexOf	(	Object	): Returns the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the highest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.
java.util.List.listIterator	(	): Returns a list iterator over the elements in this list (in proper sequence).
java.util.List.listIterator	(	int	): Returns a list iterator over the elements in this list (in proper sequence), starting at the specified position in the list. The specified index indicates the first element that would be returned by an initial call to next. An initial call to previous would return the element with the specified index minus one.
java.util.List.remove	(	Object	): Removes the first occurrence of the specified element from this list, if it is present (optional operation). If this list does not contain the element, it is unchanged. More formally, removes the element with the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))) (if such an element exists). Returns true if this list contained the specified element (or equivalently, if this list changed as a result of the call).
java.util.List.remove	(	int	): Removes the element at the specified position in this list (optional operation). Shifts any subsequent elements to the left (subtracts one from their indices). Returns the element that was removed from the list.
java.util.List.removeAll	(	Collection	): Removes from this list all of its elements that are contained in the specified collection (optional operation).
java.util.List.replaceAll	(	UnaryOperator	): Replaces each element of this list with the result of applying the operator to that element. Errors or runtime exceptions thrown by the operator are relayed to the caller.
java.util.List.retainAll	(	Collection	): Retains only the elements in this list that are contained in the specified collection (optional operation). In other words, removes from this list all of its elements that are not contained in the specified collection.
java.util.List.set	(	int	E	): Replaces the element at the specified position in this list with the specified element (optional operation).
java.util.List.size	(	): Returns the number of elements in this list. If this list contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
java.util.List.sort	(	Comparator	): Sorts this list according to the order induced by the specified Comparator. All elements in this list must be mutually comparable using the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the list). If the specified comparator is null then all elements in this list must implement the Comparable interface and the elements' Comparable natural ordering should be used. This list must be modifiable, but need not be resizable.
java.util.List.spliterator	(	): Creates a Spliterator over the elements in this list. The Spliterator reports SIZED and ORDERED. Implementations should document the reporting of additional characteristic values.
java.util.List.subList	(	int	int	): Returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive. (If fromIndex and toIndex are equal, the returned list is empty.) The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa. The returned list supports all of the optional list operations supported by this list. This method eliminates the need for explicit range operations (of the sort that commonly exist for arrays). Any operation that expects a list can be used as a range operation by passing a subList view instead of a whole list. For example, the following idiom removes a range of elements from a list: list.subList(from, to).clear(); Similar idioms may be constructed for indexOf and lastIndexOf, and all of the algorithms in the Collections class can be applied to a subList. The semantics of the list returned by this method become undefined if the backing list (i.e., this list) is structurally modified in any way other than via the returned list. (Structural modifications are those that change the size of this list, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.)
java.util.List.toArray	(	): Returns an array containing all of the elements in this list in proper sequence (from first to last element). The returned array will be "safe" in that no references to it are maintained by this list. (In other words, this method must allocate a new array even if this list is backed by an array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.List.toArray	(	T[]	): Returns an array containing all of the elements in this list in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array. If the list fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this list. If the list fits in the specified array with room to spare (i.e., the array has more elements than the list), the element in the array immediately following the end of the list is set to null. (This is useful in determining the length of the list only if the caller knows that the list does not contain any null elements.) Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a list known to contain only strings. The following code can be used to dump the list into a newly allocated array of String: String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.ListIterator: An iterator for lists that allows the programmer to traverse the list in either direction, modify the list during iteration, and obtain the iterator's current position in the list. A ListIterator has no current element; its cursor position always lies between the element that would be returned by a call to previous() and the element that would be returned by a call to next(). An iterator for a list of length n has n+1 possible cursor positions, as illustrated by the carets (^) below:  Element(0) Element(1) Element(2) ... Element(n-1) cursor positions: ^ ^ ^ ^ ^  Note that the remove and set() methods are not defined in terms of the cursor position; they are defined to operate on the last element returned by a call to next or previous(). This interface is a member of the  Java Collections Framework.
java.util.ListIterator.add	(	E	): Inserts the specified element into the list (optional operation). The element is inserted immediately before the element that would be returned by next, if any, and after the element that would be returned by previous, if any. (If the list contains no elements, the new element becomes the sole element on the list.) The new element is inserted before the implicit cursor: a subsequent call to next would be unaffected, and a subsequent call to previous would return the new element. (This call increases by one the value that would be returned by a call to nextIndex or previousIndex.)
java.util.ListIterator.hasNext	(	): Returns true if this list iterator has more elements when traversing the list in the forward direction. (In other words, returns true if next would return an element rather than throwing an exception.)
java.util.ListIterator.hasPrevious	(	): Returns true if this list iterator has more elements when traversing the list in the reverse direction. (In other words, returns true if previous would return an element rather than throwing an exception.)
java.util.ListIterator.next	(	): Returns the next element in the list and advances the cursor position. This method may be called repeatedly to iterate through the list, or intermixed with calls to previous to go back and forth. (Note that alternating calls to next and previous will return the same element repeatedly.)
java.util.ListIterator.nextIndex	(	): Returns the index of the element that would be returned by a subsequent call to next. (Returns list size if the list iterator is at the end of the list.)
java.util.ListIterator.previous	(	): Returns the previous element in the list and moves the cursor position backwards. This method may be called repeatedly to iterate through the list backwards, or intermixed with calls to next to go back and forth. (Note that alternating calls to next and previous will return the same element repeatedly.)
java.util.ListIterator.previousIndex	(	): Returns the index of the element that would be returned by a subsequent call to previous. (Returns -1 if the list iterator is at the beginning of the list.)
java.util.ListIterator.remove	(	): Removes from the list the last element that was returned by next or previous (optional operation). This call can only be made once per call to next or previous. It can be made only if add has not been called after the last call to next or previous.
java.util.ListIterator.set	(	E	): Replaces the last element returned by next or previous with the specified element (optional operation). This call can be made only if neither remove nor add have been called after the last call to next or previous.
java.util.ListResourceBundle: ListResourceBundle is an abstract subclass of ResourceBundle that manages resources for a locale in a convenient and easy to use list. See ResourceBundle for more information about resource bundles in general.  Subclasses must override getContents and provide an array, where each item in the array is a pair of objects. The first element of each pair is the key, which must be a String, and the second element is the value associated with that key.  The following example shows two members of a resource bundle family with the base name "MyResources". "MyResources" is the default member of the bundle family, and "MyResources_fr" is the French member. These members are based on ListResourceBundle (a related example shows how you can add a bundle to this family that's based on a properties file). The keys in this example are of the form "s1" etc. The actual keys are entirely up to your choice, so long as they are the same as the keys you use in your program to retrieve the objects from the bundle. Keys are case-sensitive.   public class MyResources extends ListResourceBundle { protected Object[][] getContents() { return new Object[][] { // LOCALIZE THIS {"s1", "The disk \"{1}\" contains {0}."}, // MessageFormat pattern {"s2", "1"}, // location of {0} in pattern {"s3", "My Disk"}, // sample disk name {"s4", "no files"}, // first ChoiceFormat choice {"s5", "one file"}, // second ChoiceFormat choice {"s6", "{0,number} files"}, // third ChoiceFormat choice {"s7", "3 Mar 96"}, // sample date {"s8", new Dimension(1,5)} // real object, not just string // END OF MATERIAL TO LOCALIZE }; } } public class MyResources_fr extends ListResourceBundle { protected Object[][] getContents() { return new Object[][] { // LOCALIZE THIS {"s1", "Le disque \"{1}\" {0}."}, // MessageFormat pattern {"s2", "1"}, // location of {0} in pattern {"s3", "Mon disque"}, // sample disk name {"s4", "ne contient pas de fichiers"}, // first ChoiceFormat choice {"s5", "contient un fichier"}, // second ChoiceFormat choice {"s6", "contient {0,number} fichiers"}, // third ChoiceFormat choice {"s7", "3 mars 1996"}, // sample date {"s8", new Dimension(1,3)} // real object, not just string // END OF MATERIAL TO LOCALIZE }; } }    The implementation of a ListResourceBundle subclass must be thread-safe if it's simultaneously used by multiple threads. The default implementations of the methods in this class are thread-safe.
java.util.ListResourceBundle.ListResourceBundle	(	): Sole constructor. (For invocation by subclass constructors, typically implicit.)
java.util.ListResourceBundle.getContents	(	): Returns an array in which each item is a pair of objects in an Object array. The first element of each pair is the key, which must be a String, and the second element is the value associated with that key. See the class description for details.
java.util.ListResourceBundle.getKeys	(	): Returns an Enumeration of the keys contained in this ResourceBundle and its parent bundles.
java.util.ListResourceBundle.handleKeySet	(	): Returns a Set of the keys contained only in this ResourceBundle.
java.util.ListResourceBundle.loadLookup	(	): We lazily load the lookup hashtable. This function does the loading.
java.util.Locale: A Locale object represents a specific geographical, political, or cultural region. An operation that requires a Locale to perform its task is called locale-sensitive and uses the Locale to tailor information for the user. For example, displaying a number is a locale-sensitive operation the number should be formatted according to the customs and conventions of the user's native country, region, or culture.  The Locale class implements IETF BCP 47 which is composed of RFC 4647 "Matching of Language Tags" and RFC 5646 "Tags for Identifying Languages" with support for the LDML (UTS#35, "Unicode Locale Data Markup Language") BCP 47-compatible extensions for locale data exchange.  A Locale object logically consists of the fields described below.  language ISO 639 alpha-2 or alpha-3 language code, or registered language subtags up to 8 alpha letters (for future enhancements). When a language has both an alpha-2 code and an alpha-3 code, the alpha-2 code must be used. You can find a full list of valid language codes in the IANA Language Subtag Registry (search for "Type: language"). The language field is case insensitive, but Locale always canonicalizes to lower case. Well-formed language values have the form [a-zA-Z]{2,8}. Note that this is not the the full BCP47 language production, since it excludes extlang. They are not needed since modern three-letter language codes replace them. Example: "en" (English), "ja" (Japanese), "kok" (Konkani) script ISO 15924 alpha-4 script code. You can find a full list of valid script codes in the IANA Language Subtag Registry (search for "Type: script"). The script field is case insensitive, but Locale always canonicalizes to title case (the first letter is upper case and the rest of the letters are lower case). Well-formed script values have the form [a-zA-Z]{4} Example: "Latn" (Latin), "Cyrl" (Cyrillic) country (region) ISO 3166 alpha-2 country code or UN M.49 numeric-3 area code. You can find a full list of valid country and region codes in the IANA Language Subtag Registry (search for "Type: region"). The country (region) field is case insensitive, but Locale always canonicalizes to upper case. Well-formed country/region values have the form [a-zA-Z]{2} | [0-9]{3} Example: "US" (United States), "FR" (France), "029" (Caribbean) variant Any arbitrary value used to indicate a variation of a Locale. Where there are two or more variant values each indicating its own semantics, these values should be ordered by importance, with most important first, separated by underscore('_'). The variant field is case sensitive. Note: IETF BCP 47 places syntactic restrictions on variant subtags. Also BCP 47 subtags are strictly used to indicate additional variations that define a language or its dialects that are not covered by any combinations of language, script and region subtags. You can find a full list of valid variant codes in the IANA Language Subtag Registry (search for "Type: variant"). However, the variant field in Locale has historically been used for any kind of variation, not just language variations. For example, some supported variants available in Java SE Runtime Environments indicate alternative cultural behaviors such as calendar type or number script. In BCP 47 this kind of information, which does not identify the language, is supported by extension subtags or private use subtags. Well-formed variant values have the form SUBTAG (('_'|'-') SUBTAG)* where SUBTAG = [0-9][0-9a-zA-Z]{3} | [0-9a-zA-Z]{5,8}. (Note: BCP 47 only uses hyphen ('-') as a delimiter, this is more lenient). Example: "polyton" (Polytonic Greek), "POSIX" extensions A map from single character keys to string values, indicating extensions apart from language identification. The extensions in Locale implement the semantics and syntax of BCP 47 extension subtags and private use subtags. The extensions are case insensitive, but Locale canonicalizes all extension keys and values to lower case. Note that extensions cannot have empty values. Well-formed keys are single characters from the set [0-9a-zA-Z]. Well-formed values have the form SUBTAG ('-' SUBTAG)* where for the key 'x' SUBTAG = [0-9a-zA-Z]{1,8} and for other keys SUBTAG = [0-9a-zA-Z]{2,8} (that is, 'x' allows single-character subtags). Example: key="u"/value="ca-japanese" (Japanese Calendar), key="x"/value="java-1-7"  Note: Although BCP 47 requires field values to be registered in the IANA Language Subtag Registry, the Locale class does not provide any validation features. The Builder only checks if an individual field satisfies the syntactic requirement (is well-formed), but does not validate the value itself. See Builder for details. Unicode locale/language extension UTS#35, "Unicode Locale Data Markup Language" defines optional attributes and keywords to override or refine the default behavior associated with a locale. A keyword is represented by a pair of key and type. For example, "nu-thai" indicates that Thai local digits (value:"thai") should be used for formatting numbers (key:"nu"). The keywords are mapped to a BCP 47 extension value using the extension key 'u' (UNICODE_LOCALE_EXTENSION). The above example, "nu-thai", becomes the extension "u-nu-thai".code Thus, when a Locale object contains Unicode locale attributes and keywords, getExtension(UNICODE_LOCALE_EXTENSION) will return a String representing this information, for example, "nu-thai". The Locale class also provides getUnicodeLocaleAttributes, getUnicodeLocaleKeys, and getUnicodeLocaleType which allow you to access Unicode locale attributes and key/type pairs directly. When represented as a string, the Unicode Locale Extension lists attributes alphabetically, followed by key/type sequences with keys listed alphabetically (the order of subtags comprising a key's type is fixed when the type is defined) A well-formed locale key has the form [0-9a-zA-Z]{2}. A well-formed locale type has the form "" | [0-9a-zA-Z]{3,8} ('-' [0-9a-zA-Z]{3,8})* (it can be empty, or a series of subtags 3-8 alphanums in length). A well-formed locale attribute has the form [0-9a-zA-Z]{3,8} (it is a single subtag with the same form as a locale type subtag). The Unicode locale extension specifies optional behavior in locale-sensitive services. Although the LDML specification defines various keys and values, actual locale-sensitive service implementations in a Java Runtime Environment might not support any particular Unicode locale attributes or key/type pairs. Creating a Locale There are several different ways to create a Locale object. Builder Using Builder you can construct a Locale object that conforms to BCP 47 syntax. Constructors The Locale class provides three constructors:   Locale() Locale() Locale()   These constructors allow you to create a Locale object with language, country and variant, but you cannot specify script or extensions. Factory Methods The method forLanguageTag creates a Locale object for a well-formed BCP 47 language tag. Locale Constants The Locale class provides a number of convenient constants that you can use to create Locale objects for commonly used locales. For example, the following creates a Locale object for the United States:   Locale.US   Locale Matching If an application or a system is internationalized and provides localized resources for multiple locales, it sometimes needs to find one or more locales (or language tags) which meet each user's specific preferences. Note that a term "language tag" is used interchangeably with "locale" in this locale matching documentation. In order to do matching a user's preferred locales to a set of language tags, RFC 4647 Matching of Language Tags defines two mechanisms: filtering and lookup. Filtering is used to get all matching locales, whereas lookup is to choose the best matching locale. Matching is done case-insensitively. These matching mechanisms are described in the following sections. A user's preference is called a Language Priority List and is expressed as a list of language ranges. There are syntactically two types of language ranges: basic and extended. See Locale.LanguageRange Locale.LanguageRange for details. Filtering The filtering operation returns all matching language tags. It is defined in RFC 4647 as follows: "In filtering, each language range represents the least specific language tag (that is, the language tag with fewest number of subtags) that is an acceptable match. All of the language tags in the matching set of tags will have an equal or greater number of subtags than the language range. Every non-wildcard subtag in the language range will appear in every one of the matching language tags." There are two types of filtering: filtering for basic language ranges (called "basic filtering") and filtering for extended language ranges (called "extended filtering"). They may return different results by what kind of language ranges are included in the given Language Priority List. Locale.FilteringMode is a parameter to specify how filtering should be done. Lookup The lookup operation returns the best matching language tags. It is defined in RFC 4647 as follows: "By contrast with filtering, each language range represents the most specific tag that is an acceptable match. The first matching tag found, according to the user's priority, is considered the closest match and is the item returned." For example, if a Language Priority List consists of two language ranges, "zh-Hant-TW" and "en-US", in prioritized order, lookup method progressively searches the language tags below in order to find the best matching language tag.   1. zh-Hant-TW 2. zh-Hant 3. zh 4. en-US 5. en   If there is a language tag which matches completely to a language range above, the language tag is returned. "*" is the special language range, and it is ignored in lookup. If multiple language tags match as a result of the subtag '*' included in a language range, the first matching language tag returned by an Iterator over a Collection of language tags is treated as the best matching one. Use of Locale Once you've created a Locale you can query it for information about itself. Use getCountry to get the country (or region) code and getLanguage to get the language code. You can use getDisplayCountry to get the name of the country suitable for displaying to the user. Similarly, you can use getDisplayLanguage to get the name of the language suitable for displaying to the user. Interestingly, the getDisplayXXX methods are themselves locale-sensitive and have two versions: one that uses the default DISPLAY locale and one that uses the locale specified as an argument. The Java Platform provides a number of classes that perform locale-sensitive operations. For example, the NumberFormat class formats numbers, currency, and percentages in a locale-sensitive manner. Classes such as NumberFormat have several convenience methods for creating a default object of that type. For example, the NumberFormat class provides these three convenience methods for creating a default NumberFormat object:   NumberFormat.getInstance() NumberFormat.getCurrencyInstance() NumberFormat.getPercentInstance()   Each of these methods has two variants; one with an explicit locale and one without; the latter uses the default FORMAT locale:   NumberFormat.getInstance(myLocale) NumberFormat.getCurrencyInstance(myLocale) NumberFormat.getPercentInstance(myLocale)   A Locale is the mechanism for identifying the kind of object (NumberFormat) that you would like to get. The locale is just a mechanism for identifying objects, not a container for the objects themselves. Compatibility In order to maintain compatibility with existing usage, Locale's constructors retain their behavior prior to the Java Runtime Environment version 1.7. The same is largely true for the toString method. Thus Locale objects can continue to be used as they were. In particular, clients who parse the output of toString into language, country, and variant fields can continue to do so (although this is strongly discouraged), although the variant field will have additional information in it if script or extensions are present. In addition, BCP 47 imposes syntax restrictions that are not imposed by Locale's constructors. This means that conversions between some Locales and BCP 47 language tags cannot be made without losing information. Thus toLanguageTag cannot represent the state of locales whose language, country, or variant do not conform to BCP 47. Because of these issues, it is recommended that clients migrate away from constructing non-conforming locales and use the forLanguageTag and Locale.Builder APIs instead. Clients desiring a string representation of the complete locale can then always rely on toLanguageTag for this purpose. Special cases For compatibility reasons, two non-conforming locales are treated as special cases. These are ja_JP_JP and th_TH_TH. These are ill-formed in BCP 47 since the variants are too short. To ease migration to BCP 47, these are treated specially during construction. These two cases (and only these) cause a constructor to generate an extension, all other values behave exactly as they did prior to Java 7. Java has used ja_JP_JP to represent Japanese as used in Japan together with the Japanese Imperial calendar. This is now representable using a Unicode locale extension, by specifying the Unicode locale key ca (for "calendar") and type japanese. When the Locale constructor is called with the arguments "ja", "JP", "JP", the extension "u-ca-japanese" is automatically added. Java has used th_TH_TH to represent Thai as used in Thailand together with Thai digits. This is also now representable using a Unicode locale extension, by specifying the Unicode locale key nu (for "number") and value thai. When the Locale constructor is called with the arguments "th", "TH", "TH", the extension "u-nu-thai" is automatically added. Serialization During serialization, writeObject writes all fields to the output stream, including extensions. During deserialization, readResolve adds extensions as described in Special Cases, only for the two cases th_TH_TH and ja_JP_JP. Legacy language codes Locale's constructor has always converted three language codes to their earlier, obsoleted forms: he maps to iw, yi maps to ji, and id maps to in. This continues to be the case, in order to not break backwards compatibility. The APIs added in 1.7 map between the old and new language codes, maintaining the old codes internal to Locale (so that getLanguage and toString reflect the old code), but using the new codes in the BCP 47 language tag APIs (so that toLanguageTag reflects the new one). This preserves the equivalence between Locales no matter which code or API is used to construct them. Java's default resource bundle lookup mechanism also implements this mapping, so that resources can be named using either convention, see ResourceBundle.Control. Three-letter language/country(region) codes The Locale constructors have always specified that the language and the country param be two characters in length, although in practice they have accepted any length. The specification has now been relaxed to allow language codes of two to eight characters and country (region) codes of two to three characters, and in particular, three-letter language codes and three-digit region codes as specified in the IANA Language Subtag Registry. For compatibility, the implementation still does not impose a length constraint.
java.util.Locale.Builder: Builder is used to build instances of Locale from values configured by the setters. Unlike the Locale constructors, the Builder checks if a value configured by a setter satisfies the syntax requirements defined by the Locale class. A Locale object created by a Builder is well-formed and can be transformed to a well-formed IETF BCP 47 language tag without losing information. Note: The Locale class does not provide any syntactic restrictions on variant, while BCP 47 requires each variant subtag to be 5 to 8 alphanumerics or a single numeric followed by 3 alphanumerics. The method setVariant throws IllformedLocaleException for a variant that does not satisfy this restriction. If it is necessary to support such a variant, use a Locale constructor. However, keep in mind that a Locale object created this way might lose the variant information when transformed to a BCP 47 language tag. The following example shows how to create a Locale object with the Builder.   Locale aLocale = new Builder().setLanguage("sr").setScript("Latn").setRegion("RS").build();   Builders can be reused; clear() resets all fields to their default values.
java.util.Locale.Builder.Builder	(	): Constructs an empty Builder. The default value of all fields, extensions, and private use information is the empty string.
java.util.Locale.Builder.addUnicodeLocaleAttribute	(	String	): Adds a unicode locale attribute, if not already present, otherwise has no effect. The attribute must not be null and must be well-formed or an exception is thrown.
java.util.Locale.Builder.build	(	): Returns an instance of Locale created from the fields set on this builder. This applies the conversions listed in forLanguageTag when constructing a Locale. (Grandfathered tags are handled in setLanguageTag.)
java.util.Locale.Builder.clear	(	): Resets the builder to its initial, empty state.
java.util.Locale.Builder.clearExtensions	(	): Resets the extensions to their initial, empty state. Language, script, region and variant are unchanged.
java.util.Locale.Builder.removeUnicodeLocaleAttribute	(	String	): Removes a unicode locale attribute, if present, otherwise has no effect. The attribute must not be null and must be well-formed or an exception is thrown. Attribute comparision for removal is case-insensitive.
java.util.Locale.Builder.setExtension	(	char	String	): Sets the extension for the given key. If the value is null or the empty string, the extension is removed. Otherwise, the extension must be well-formed or an exception is thrown. Note: The key UNICODE_LOCALE_EXTENSION ('u') is used for the Unicode locale extension. Setting a value for this key replaces any existing Unicode locale key/type pairs with those defined in the extension. Note: The key PRIVATE_USE_EXTENSION ('x') is used for the private use code. To be well-formed, the value for this key needs only to have subtags of one to eight alphanumeric characters, not two to eight as in the general case.
java.util.Locale.Builder.setLanguage	(	String	): Sets the language. If language is the empty string or null, the language in this Builder is removed. Otherwise, the language must be well-formed or an exception is thrown. The typical language value is a two or three-letter language code as defined in ISO639.
java.util.Locale.Builder.setLanguageTag	(	String	): Resets the Builder to match the provided IETF BCP 47 language tag. Discards the existing state. Null and the empty string cause the builder to be reset, like clear. Grandfathered tags (see forLanguageTag) are converted to their canonical form before being processed. Otherwise, the language tag must be well-formed (see Locale) or an exception is thrown (unlike Locale.forLanguageTag, which just discards ill-formed and following portions of the tag).
java.util.Locale.Builder.setLocale	(	Locale	): Resets the Builder to match the provided locale. Existing state is discarded. All fields of the locale must be well-formed, see Locale. Locales with any ill-formed fields cause IllformedLocaleException to be thrown, except for the following three cases which are accepted for compatibility reasons: Locale("ja", "JP", "JP") is treated as "ja-JP-u-ca-japanese" Locale("th", "TH", "TH") is treated as "th-TH-u-nu-thai" Locale("no", "NO", "NY") is treated as "nn-NO"
java.util.Locale.Builder.setRegion	(	String	): Sets the region. If region is null or the empty string, the region in this Builder is removed. Otherwise, the region must be well-formed or an exception is thrown. The typical region value is a two-letter ISO 3166 code or a three-digit UN M.49 area code. The country value in the Locale created by the Builder is always normalized to upper case.
java.util.Locale.Builder.setScript	(	String	): Sets the script. If script is null or the empty string, the script in this Builder is removed. Otherwise, the script must be well-formed or an exception is thrown. The typical script value is a four-letter script code as defined by ISO 15924.
java.util.Locale.Builder.setUnicodeLocaleKeyword	(	String	String	): Sets the Unicode locale keyword type for the given key. If the type is null, the Unicode keyword is removed. Otherwise, the key must be non-null and both key and type must be well-formed or an exception is thrown. Keys and types are converted to lower case. Note:Setting the 'u' extension via setExtension replaces all Unicode locale keywords with those defined in the extension.
java.util.Locale.Builder.setVariant	(	String	): Sets the variant. If variant is null or the empty string, the variant in this Builder is removed. Otherwise, it must consist of one or more well-formed subtags, or an exception is thrown. Note: This method checks if variant satisfies the IETF BCP 47 variant subtag's syntax requirements, and normalizes the value to lowercase letters. However, the Locale class does not impose any syntactic restriction on variant, and the variant value in Locale is case sensitive. To set such a variant, use a Locale constructor.
java.util.Locale.LanguageRange: This class expresses a Language Range defined in RFC 4647 Matching of Language Tags. A language range is an identifier which is used to select language tag(s) meeting specific requirements by using the mechanisms described in Locale Matching. A list which represents a user's preferences and consists of language ranges is called a Language Priority List. There are two types of language ranges: basic and extended. In RFC 4647, the syntax of language ranges is expressed in ABNF as follows:   basic-language-range = (1*8ALPHA *("-" 1*8alphanum)) / "*" extended-language-range = (1*8ALPHA / "*") *("-" (1*8alphanum / "*")) alphanum = ALPHA / DIGIT   For example, "en" (English), "ja-JP" (Japanese, Japan), "*" (special language range which matches any language tag) are basic language ranges, whereas "*-CH" (any languages, Switzerland), "es-*" (Spanish, any regions), and "zh-Hant-*" (Traditional Chinese, any regions) are extended language ranges.
java.util.Locale.LanguageRange.LanguageRange	(	String	): Constructs a LanguageRange using the given range. Note that no validation is done against the IANA Language Subtag Registry at time of construction. This is equivalent to LanguageRange(range, MAX_WEIGHT).
java.util.Locale.LanguageRange.LanguageRange	(	String	double	): Constructs a LanguageRange using the given range and weight. Note that no validation is done against the IANA Language Subtag Registry at time of construction.
java.util.Locale.LanguageRange.equals	(	Object	): Compares this object to the specified object. The result is true if and only if the argument is not null and is a LanguageRange object that contains the same range and weight values as this object.
java.util.Locale.LanguageRange.getRange	(	): Returns the language range of this LanguageRange.
java.util.Locale.LanguageRange.getWeight	(	): Returns the weight of this LanguageRange.
java.util.Locale.LanguageRange.hashCode	(	): Returns a hash code value for the object.
java.util.Locale.LanguageRange.mapEquivalents	(	List	Map	): Generates a new customized Language Priority List using the given priorityList and map. If the given map is empty, this method returns a copy of the given priorityList. In the map, a key represents a language range whereas a value is a list of equivalents of it. '*' cannot be used in the map. Each equivalent language range has the same weight value as its original language range.  An example of map: Key Value "zh" (Chinese) "zh", "zh-Hans"(Simplified Chinese) "zh-HK" (Chinese, Hong Kong) "zh-HK" "zh-TW" (Chinese, Taiwan) "zh-TW"  The customization is performed after modification using the IANA Language Subtag Registry. For example, if a user's Language Priority List consists of five language ranges ("zh", "zh-CN", "en", "zh-TW", and "zh-HK"), the newly generated Language Priority List which is customized using the above map example will consists of "zh", "zh-Hans", "zh-CN", "zh-Hans-CN", "en", "zh-TW", and "zh-HK". "zh-HK" and "zh-TW" aren't converted to "zh-Hans-HK" nor "zh-Hans-TW" even if they are included in the Language Priority List. In this example, mapping is used to clearly distinguish Simplified Chinese and Traditional Chinese. If the "zh"-to-"zh" mapping isn't included in the map, a simple replacement will be performed and the customized list won't include "zh" and "zh-CN".
java.util.Locale.LanguageRange.parse	(	String	): Parses the given ranges to generate a Language Priority List. This method performs a syntactic check for each language range in the given ranges but doesn't do validation using the IANA Language Subtag Registry. The ranges to be given can take one of the following forms:  "Accept-Language: ja,en;q=0.4" (weighted list with Accept-Language prefix) "ja,en;q=0.4" (weighted list) "ja,en" (prioritized list)  In a weighted list, each language range is given a weight value. The weight value is identical to the "quality value" in RFC 2616, and it expresses how much the user prefers the language. A weight value is specified after a corresponding language range followed by ";q=", and the default weight value is MAX_WEIGHT when it is omitted. Unlike a weighted list, language ranges in a prioritized list are sorted in the descending order based on its priority. The first language range has the highest priority and meets the user's preference most. In either case, language ranges are sorted in descending order in the Language Priority List based on priority or weight. If a language range appears in the given ranges more than once, only the first one is included on the Language Priority List. The returned list consists of language ranges from the given ranges and their equivalents found in the IANA Language Subtag Registry. For example, if the given ranges is "Accept-Language: iw,en-us;q=0.7,en;q=0.3", the elements in the list to be returned are:  Range Weight "iw" (older tag for Hebrew) 1.0 "he" (new preferred code for Hebrew) 1.0 "en-us" (English, United States) 0.7 "en" (English) 0.3  Two language ranges, "iw" and "he", have the same highest priority in the list. By adding "he" to the user's Language Priority List, locale-matching method can find Hebrew as a matching locale (or language tag) even if the application or system offers only "he" as a supported locale (or language tag).
java.util.Locale.LanguageRange.parse	(	String	Map	): Parses the given ranges to generate a Language Priority List, and then customizes the list using the given map. This method is equivalent to mapEquivalents(parse(ranges), map).
java.util.Locale.Locale	(	BaseLocale	LocaleExtensions	): Private constructor used by getInstance method
java.util.Locale.Locale	(	String	): Construct a locale from a language code. This constructor normalizes the language value to lowercase.  Note:  ISO 639 is not a stable standard; some of the language codes it defines (specifically "iw", "ji", and "in") have changed. This constructor accepts both the old codes ("iw", "ji", and "in") and the new codes ("he", "yi", and "id"), but all other API on Locale will return only the OLD codes. For backward compatibility reasons, this constructor does not make any syntactic checks on the input. 
java.util.Locale.Locale	(	String	String	): Construct a locale from language and country. This constructor normalizes the language value to lowercase and the country value to uppercase.  Note:  ISO 639 is not a stable standard; some of the language codes it defines (specifically "iw", "ji", and "in") have changed. This constructor accepts both the old codes ("iw", "ji", and "in") and the new codes ("he", "yi", and "id"), but all other API on Locale will return only the OLD codes. For backward compatibility reasons, this constructor does not make any syntactic checks on the input. 
java.util.Locale.Locale	(	String	String	String	): Construct a locale from language, country and variant. This constructor normalizes the language value to lowercase and the country value to uppercase.  Note:  ISO 639 is not a stable standard; some of the language codes it defines (specifically "iw", "ji", and "in") have changed. This constructor accepts both the old codes ("iw", "ji", and "in") and the new codes ("he", "yi", and "id"), but all other API on Locale will return only the OLD codes. For backward compatibility reasons, this constructor does not make any syntactic checks on the input. The two cases ("ja", "JP", "JP") and ("th", "TH", "TH") are handled specially, see Special Cases for more information. 
java.util.Locale.LocaleNameGetter: Obtains a localized locale names from a LocaleNameProvider implementation.
java.util.Locale.clone	(	): Overrides Cloneable.
java.util.Locale.composeList	(	MessageFormat	String[]	): Given a list of strings, return a list shortened to three elements. Shorten it by applying the given format to the first two elements recursively.
java.util.Locale.createConstant	(	String	String	): This method must be called only for creating the Locale. constants due to making shortcuts.
java.util.Locale.equals	(	Object	): Returns true if this Locale is equal to another object. A Locale is deemed equal to another Locale with identical language, script, country, variant and extensions, and unequal to all other objects.
java.util.Locale.filter	(	List	Collection	): Returns a list of matching Locale instances using the filtering mechanism defined in RFC 4647. This is equivalent to filter() when mode is AUTOSELECT_FILTERING.
java.util.Locale.filter	(	List	Collection	FilteringMode	): Returns a list of matching Locale instances using the filtering mechanism defined in RFC 4647.
java.util.Locale.filterTags	(	List	Collection	): Returns a list of matching languages tags using the basic filtering mechanism defined in RFC 4647. This is equivalent to filterTags() when mode is AUTOSELECT_FILTERING.
java.util.Locale.filterTags	(	List	Collection	FilteringMode	): Returns a list of matching languages tags using the basic filtering mechanism defined in RFC 4647.
java.util.Locale.forLanguageTag	(	String	): Returns a locale for the specified IETF BCP 47 language tag string. If the specified language tag contains any ill-formed subtags, the first such subtag and all following subtags are ignored. Compare to setLanguageTag which throws an exception in this case. The following conversions are performed: The language code "und" is mapped to language "". The language codes "he", "yi", and "id" are mapped to "iw", "ji", and "in" respectively. (This is the same canonicalization that's done in Locale's constructors.) The portion of a private use subtag prefixed by "lvariant", if any, is removed and appended to the variant field in the result locale (without case normalization). If it is then empty, the private use subtag is discarded:  Locale loc; loc = Locale.forLanguageTag("en-US-x-lvariant-POSIX"); loc.getVariant(); // returns "POSIX" loc.getExtension('x'); // returns null loc = Locale.forLanguageTag("de-POSIX-x-URP-lvariant-Abc-Def"); loc.getVariant(); // returns "POSIX_Abc_Def" loc.getExtension('x'); // returns "urp"  When the languageTag argument contains an extlang subtag, the first such subtag is used as the language, and the primary language subtag and other extlang subtags are ignored:  Locale.forLanguageTag("ar-aao").getLanguage(); // returns "aao" Locale.forLanguageTag("en-abc-def-us").toString(); // returns "abc_US"  Case is normalized except for variant tags, which are left unchanged. Language is normalized to lower case, script to title case, country to upper case, and extensions to lower case. If, after processing, the locale would exactly match either ja_JP_JP or th_TH_TH with no extensions, the appropriate extensions are added as though the constructor had been called:  Locale.forLanguageTag("ja-JP-x-lvariant-JP").toLanguageTag(); // returns "ja-JP-u-ca-japanese-x-lvariant-JP" Locale.forLanguageTag("th-TH-x-lvariant-TH").toLanguageTag(); // returns "th-TH-u-nu-thai-x-lvariant-TH"  This implements the 'Language-Tag' production of BCP47, and so supports grandfathered (regular and irregular) as well as private use language tags. Stand alone private use tags are represented as empty language and extension 'x-whatever', and grandfathered tags are converted to their canonical replacements where they exist. Grandfathered tags with canonical replacements are as follows:   grandfathered tag modern replacement art-lojban jbo i-ami ami i-bnn bnn i-hak hak i-klingon tlh i-lux lb i-navajo nv i-pwn pwn i-tao tao i-tay tay i-tsu tsu no-bok nb no-nyn nn sgn-BE-FR sfb sgn-BE-NL vgt sgn-CH-DE sgg zh-guoyu cmn zh-hakka hak zh-min-nan nan zh-xiang hsn   Grandfathered tags with no modern replacement will be converted as follows:   grandfathered tag converts to cel-gaulish xtg-x-cel-gaulish en-GB-oed en-GB-x-oed i-default en-x-i-default i-enochian und-x-i-enochian i-mingo see-x-i-mingo zh-min nan-x-zh-min   For a list of all grandfathered tags, see the IANA Language Subtag Registry (search for "Type: grandfathered"). Note: there is no guarantee that toLanguageTag and forLanguageTag will round-trip.
java.util.Locale.formatList	(	String[]	String	String	): Format a list using given pattern strings. If either of the patterns is null, then a the list is formatted by concatenation with the delimiter ','.
java.util.Locale.getAvailableLocales	(	): Returns an array of all installed locales. The returned array represents the union of locales supported by the Java runtime environment and by installed java.util.spi.LocaleServiceProvider LocaleServiceProvider implementations. It must contain at least a Locale instance equal to US Locale.US.
java.util.Locale.getBaseLocale	(	): Package locale method returning the Locale's BaseLocale, used by ResourceBundle
java.util.Locale.getCountry	(	): Returns the country/region code for this locale, which should either be the empty string, an uppercase ISO 3166 2-letter code, or a UN M.49 3-digit code.
java.util.Locale.getDefault	(	): Gets the current value of the default locale for this instance of the Java Virtual Machine.  The Java Virtual Machine sets the default locale during startup based on the host environment. It is used by many locale-sensitive methods if no locale is explicitly specified. It can be changed using the setDefault() method.
java.util.Locale.getDefault	(	Locale.Category	): Gets the current value of the default locale for the specified Category for this instance of the Java Virtual Machine.  The Java Virtual Machine sets the default locale during startup based on the host environment. It is used by many locale-sensitive methods if no locale is explicitly specified. It can be changed using the setDefault(Locale.Category, Locale) method.
java.util.Locale.getDisplayCountry	(	): Returns a name for the locale's country that is appropriate for display to the user. If possible, the name returned will be localized for the default DISPLAY locale. For example, if the locale is fr_FR and the default DISPLAY locale is en_US, getDisplayCountry() will return "France"; if the locale is en_US and the default DISPLAY locale is fr_FR, getDisplayCountry() will return "Etats-Unis". If the name returned cannot be localized for the default DISPLAY locale, (say, we don't have a Japanese name for Croatia), this function falls back on the English name, and uses the ISO code as a last-resort value. If the locale doesn't specify a country, this function returns the empty string.
java.util.Locale.getDisplayCountry	(	Locale	): Returns a name for the locale's country that is appropriate for display to the user. If possible, the name returned will be localized according to inLocale. For example, if the locale is fr_FR and inLocale is en_US, getDisplayCountry() will return "France"; if the locale is en_US and inLocale is fr_FR, getDisplayCountry() will return "Etats-Unis". If the name returned cannot be localized according to inLocale. (say, we don't have a Japanese name for Croatia), this function falls back on the English name, and finally on the ISO code as a last-resort value. If the locale doesn't specify a country, this function returns the empty string.
java.util.Locale.getDisplayLanguage	(	): Returns a name for the locale's language that is appropriate for display to the user. If possible, the name returned will be localized for the default DISPLAY locale. For example, if the locale is fr_FR and the default DISPLAY locale is en_US, getDisplayLanguage() will return "French"; if the locale is en_US and the default DISPLAY locale is fr_FR, getDisplayLanguage() will return "anglais". If the name returned cannot be localized for the default DISPLAY locale, (say, we don't have a Japanese name for Croatian), this function falls back on the English name, and uses the ISO code as a last-resort value. If the locale doesn't specify a language, this function returns the empty string.
java.util.Locale.getDisplayLanguage	(	Locale	): Returns a name for the locale's language that is appropriate for display to the user. If possible, the name returned will be localized according to inLocale. For example, if the locale is fr_FR and inLocale is en_US, getDisplayLanguage() will return "French"; if the locale is en_US and inLocale is fr_FR, getDisplayLanguage() will return "anglais". If the name returned cannot be localized according to inLocale, (say, we don't have a Japanese name for Croatian), this function falls back on the English name, and finally on the ISO code as a last-resort value. If the locale doesn't specify a language, this function returns the empty string.
java.util.Locale.getDisplayName	(	): Returns a name for the locale that is appropriate for display to the user. This will be the values returned by getDisplayLanguage(), getDisplayScript(), getDisplayCountry(), and getDisplayVariant() assembled into a single string. The the non-empty values are used in order, with the second and subsequent names in parentheses. For example:  language (script, country, variant) language (country) language (variant) script (country) country  depending on which fields are specified in the locale. If the language, script, country, and variant fields are all empty, this function returns the empty string.
java.util.Locale.getDisplayName	(	Locale	): Returns a name for the locale that is appropriate for display to the user. This will be the values returned by getDisplayLanguage(), getDisplayScript(),getDisplayCountry(), and getDisplayVariant() assembled into a single string. The non-empty values are used in order, with the second and subsequent names in parentheses. For example:  language (script, country, variant) language (country) language (variant) script (country) country  depending on which fields are specified in the locale. If the language, script, country, and variant fields are all empty, this function returns the empty string.
java.util.Locale.getDisplayScript	(	): Returns a name for the the locale's script that is appropriate for display to the user. If possible, the name will be localized for the default DISPLAY locale. Returns the empty string if this locale doesn't specify a script code.
java.util.Locale.getDisplayScript	(	Locale	): Returns a name for the locale's script that is appropriate for display to the user. If possible, the name will be localized for the given locale. Returns the empty string if this locale doesn't specify a script code.
java.util.Locale.getDisplayVariant	(	): Returns a name for the locale's variant code that is appropriate for display to the user. If possible, the name will be localized for the default DISPLAY locale. If the locale doesn't specify a variant code, this function returns the empty string.
java.util.Locale.getDisplayVariant	(	Locale	): Returns a name for the locale's variant code that is appropriate for display to the user. If possible, the name will be localized for inLocale. If the locale doesn't specify a variant code, this function returns the empty string.
java.util.Locale.getDisplayVariantArray	(	Locale	): Return an array of the display names of the variant.
java.util.Locale.getExtension	(	char	): Returns the extension (or private use) value associated with the specified key, or null if there is no extension associated with the key. To be well-formed, the key must be one of [0-9A-Za-z]. Keys are case-insensitive, so for example 'z' and 'Z' represent the same extension.
java.util.Locale.getExtensionKeys	(	): Returns the set of extension keys associated with this locale, or the empty set if it has no extensions. The returned set is unmodifiable. The keys will all be lower-case.
java.util.Locale.getISO3Country	(	): Returns a three-letter abbreviation for this locale's country. If the country matches an ISO 3166-1 alpha-2 code, the corresponding ISO 3166-1 alpha-3 uppercase code is returned. If the locale doesn't specify a country, this will be the empty string. The ISO 3166-1 codes can be found on-line.
java.util.Locale.getISO3Language	(	): Returns a three-letter abbreviation of this locale's language. If the language matches an ISO 639-1 two-letter code, the corresponding ISO 639-2/T three-letter lowercase code is returned. The ISO 639-2 language codes can be found on-line, see "Codes for the Representation of Names of Languages Part 2: Alpha-3 Code". If the locale specifies a three-letter language, the language is returned as is. If the locale does not specify a language the empty string is returned.
java.util.Locale.getISOCountries	(	): Returns a list of all 2-letter country codes defined in ISO 3166. Can be used to create Locales.  Note: The Locale class also supports other codes for country (region), such as 3-letter numeric UN M.49 area codes. Therefore, the list returned by this method does not contain ALL valid codes that can be used to create Locales.
java.util.Locale.getISOLanguages	(	): Returns a list of all 2-letter language codes defined in ISO 639. Can be used to create Locales.  Note:  ISO 639 is not a stable standard some languages' codes have changed. The list this function returns includes both the new and the old codes for the languages whose codes have changed. The Locale class also supports language codes up to 8 characters in length. Therefore, the list returned by this method does not contain ALL valid codes that can be used to create Locales. 
java.util.Locale.getInstance	(	String	String	String	): Returns a Locale constructed from the given language, country and variant. If the same Locale instance is available in the cache, then that instance is returned. Otherwise, a new Locale instance is created and cached.
java.util.Locale.getLanguage	(	): Returns the language code of this Locale. Note: ISO 639 is not a stable standard some languages' codes have changed. Locale's constructor recognizes both the new and the old codes for the languages whose codes have changed, but this function always returns the old code. If you want to check for a specific language whose code has changed, don't do  if (locale.getLanguage().equals("he")) // BAD! ...  Instead, do  if (locale.getLanguage().equals(new Locale("he").getLanguage())) ... 
java.util.Locale.getLocaleExtensions	(	): Package private method returning the Locale's LocaleExtensions, used by ResourceBundle.
java.util.Locale.getScript	(	): Returns the script for this locale, which should either be the empty string or an ISO 15924 4-letter script code. The first letter is uppercase and the rest are lowercase, for example, 'Latn', 'Cyrl'.
java.util.Locale.getUnicodeLocaleAttributes	(	): Returns the set of unicode locale attributes associated with this locale, or the empty set if it has no attributes. The returned set is unmodifiable.
java.util.Locale.getUnicodeLocaleKeys	(	): Returns the set of Unicode locale keys defined by this locale, or the empty set if this locale has none. The returned set is immutable. Keys are all lower case.
java.util.Locale.getUnicodeLocaleType	(	String	): Returns the Unicode locale type associated with the specified Unicode locale key for this locale. Returns the empty string for keys that are defined with no type. Returns null if the key is not defined. Keys are case-insensitive. The key must be two alphanumeric characters ([0-9a-zA-Z]), or an IllegalArgumentException is thrown.
java.util.Locale.getVariant	(	): Returns the variant code for this locale.
java.util.Locale.hasExtensions	(	): Returns true if this Locale has any  extensions.
java.util.Locale.hashCode	(	): Override hashCode. Since Locales are often used in hashtables, caches the value for speed.
java.util.Locale.lookup	(	List	Collection	): Returns a Locale instance for the best-matching language tag using the lookup mechanism defined in RFC 4647.
java.util.Locale.lookupTag	(	List	Collection	): Returns the best-matching language tag using the lookup mechanism defined in RFC 4647.
java.util.Locale.readObject	(	ObjectInputStream	): Deserializes this Locale.
java.util.Locale.readResolve	(	): Returns a cached Locale instance equivalent to the deserialized Locale. When serialized language, country and variant fields read from the object data stream are exactly "ja", "JP", "JP" or "th", "TH", "TH" and script/extensions fields are empty, this method supplies UNICODE_LOCALE_EXTENSION "ca"/"japanese" (calendar type is "japanese") or "nu"/"thai" (number script type is "thai"). See Special Cases for more information.
java.util.Locale.setDefault	(	Locale	): Sets the default locale for this instance of the Java Virtual Machine. This does not affect the host locale.  If there is a security manager, its checkPermission method is called with a PropertyPermission("user.language", "write") permission before the default locale is changed.  The Java Virtual Machine sets the default locale during startup based on the host environment. It is used by many locale-sensitive methods if no locale is explicitly specified.  Since changing the default locale may affect many different areas of functionality, this method should only be used if the caller is prepared to reinitialize locale-sensitive code running within the same Java Virtual Machine.  By setting the default locale with this method, all of the default locales for each Category are also set to the specified default locale.
java.util.Locale.setDefault	(	Locale.Category	Locale	): Sets the default locale for the specified Category for this instance of the Java Virtual Machine. This does not affect the host locale.  If there is a security manager, its checkPermission method is called with a PropertyPermission("user.language", "write") permission before the default locale is changed.  The Java Virtual Machine sets the default locale during startup based on the host environment. It is used by many locale-sensitive methods if no locale is explicitly specified.  Since changing the default locale may affect many different areas of functionality, this method should only be used if the caller is prepared to reinitialize locale-sensitive code running within the same Java Virtual Machine. 
java.util.Locale.stripExtensions	(	): Returns a copy of this Locale with no  extensions. If this Locale has no extensions, this Locale is returned.
java.util.Locale.toLanguageTag	(	): Returns a well-formed IETF BCP 47 language tag representing this locale. If this Locale has a language, country, or variant that does not satisfy the IETF BCP 47 language tag syntax requirements, this method handles these fields as described below: Language: If language is empty, or not well-formed (for example "a" or "e2"), it will be emitted as "und" (Undetermined). Country: If country is not well-formed (for example "12" or "USA"), it will be omitted. Variant: If variant is well-formed, each sub-segment (delimited by '-' or '_') is emitted as a subtag. Otherwise:  if all sub-segments match [0-9a-zA-Z]{1,8} (for example "WIN" or "Oracle_JDK_Standard_Edition"), the first ill-formed sub-segment and all following will be appended to the private use subtag. The first appended subtag will be "lvariant", followed by the sub-segments in order, separated by hyphen. For example, "x-lvariant-WIN", "Oracle-x-lvariant-JDK-Standard-Edition". if any sub-segment does not match [0-9a-zA-Z]{1,8}, the variant will be truncated and the problematic sub-segment and all following sub-segments will be omitted. If the remainder is non-empty, it will be emitted as a private use subtag as above (even if the remainder turns out to be well-formed). For example, "Solaris_isjustthecoolestthing" is emitted as "x-lvariant-Solaris", not as "solaris". Special Conversions: Java supports some old locale representations, including deprecated ISO language codes, for compatibility. This method performs the following conversions:  Deprecated ISO language codes "iw", "ji", and "in" are converted to "he", "yi", and "id", respectively. A locale with language "no", country "NO", and variant "NY", representing Norwegian Nynorsk (Norway), is converted to a language tag "nn-NO". Note: Although the language tag created by this method is well-formed (satisfies the syntax requirements defined by the IETF BCP 47 specification), it is not necessarily a valid BCP 47 language tag. For example,  new Locale("xx", "YY").toLanguageTag(); will return "xx-YY", but the language subtag "xx" and the region subtag "YY" are invalid because they are not registered in the IANA Language Subtag Registry.
java.util.Locale.toString	(	): Returns a string representation of this Locale object, consisting of language, country, variant, script, and extensions as below:  language + "_" + country + "_" + (variant + "_#" | "#") + script + "-" + extensions  Language is always lower case, country is always upper case, script is always title case, and extensions are always lower case. Extensions and private use subtags will be in canonical order as explained in toLanguageTag. When the locale has neither script nor extensions, the result is the same as in Java 6 and prior. If both the language and country fields are missing, this function will return the empty string, even if the variant, script, or extensions field is present (you can't have a locale with just a variant, the variant must accompany a well-formed language or country code). If script or extensions are present and variant is missing, no underscore is added before the "#". This behavior is designed to support debugging and to be compatible with previous uses of toString that expected language, country, and variant fields only. To represent a Locale as a String for interchange purposes, use toLanguageTag. Examples:  en de_DE _GB en_US_WIN de__POSIX zh_CN_#Hans zh_TW_#Hant-x-java th_TH_TH_#u-nu-thai
java.util.Locale.writeObject	(	ObjectOutputStream	): Serializes this Locale to the specified ObjectOutputStream.
java.util.LongSummaryStatistics: A state object for collecting statistics such as count, min, max, sum, and average. This class is designed to work with (though does not require) java.util.stream streams. For example, you can compute summary statistics on a stream of longs with:  LongSummaryStatistics stats = longStream.collect(LongSummaryStatistics::new, LongSummaryStatistics::accept, LongSummaryStatistics::combine); LongSummaryStatistics can be used as a collect() reduction} target for a java.util.stream.Stream stream. For example:  LongSummaryStatistics stats = people.stream() .collect(Collectors.summarizingLong(Person::getAge)); This computes, in a single pass, the count of people, as well as the minimum, maximum, sum, and average of their ages.
java.util.LongSummaryStatistics.LongSummaryStatistics	(	): Construct an empty instance with zero count, zero sum, Long.MAX_VALUE min, Long.MIN_VALUE max and zero average.
java.util.LongSummaryStatistics.accept	(	int	): Records a new int value into the summary information.
java.util.LongSummaryStatistics.accept	(	long	): Records a new long value into the summary information.
java.util.LongSummaryStatistics.combine	(	LongSummaryStatistics	): Combines the state of another LongSummaryStatistics into this one.
java.util.LongSummaryStatistics.getAverage	(	): Returns the arithmetic mean of values recorded, or zero if no values have been recorded.
java.util.LongSummaryStatistics.getCount	(	): Returns the count of values recorded.
java.util.LongSummaryStatistics.getMax	(	): Returns the maximum value recorded, or Long.MIN_VALUE if no values have been recorded
java.util.LongSummaryStatistics.getMin	(	): Returns the minimum value recorded, or Long.MAX_VALUE if no values have been recorded.
java.util.LongSummaryStatistics.getSum	(	): Returns the sum of values recorded, or zero if no values have been recorded.
java.util.Map: An object that maps keys to values. A map cannot contain duplicate keys; each key can map to at most one value. This interface takes the place of the Dictionary class, which was a totally abstract class rather than an interface. The Map interface provides three collection views, which allow a map's contents to be viewed as a set of keys, collection of values, or set of key-value mappings. The order of a map is defined as the order in which the iterators on the map's collection views return their elements. Some map implementations, like the TreeMap class, make specific guarantees as to their order; others, like the HashMap class, do not. Note: great care must be exercised if mutable objects are used as map keys. The behavior of a map is not specified if the value of an object is changed in a manner that affects equals comparisons while the object is a key in the map. A special case of this prohibition is that it is not permissible for a map to contain itself as a key. While it is permissible for a map to contain itself as a value, extreme caution is advised: the equals and hashCode methods are no longer well defined on such a map. All general-purpose map implementation classes should provide two "standard" constructors: a void (no arguments) constructor which creates an empty map, and a constructor with a single argument of type Map, which creates a new map with the same key-value mappings as its argument. In effect, the latter constructor allows the user to copy any map, producing an equivalent map of the desired class. There is no way to enforce this recommendation (as interfaces cannot contain constructors) but all of the general-purpose map implementations in the JDK comply. The "destructive" methods contained in this interface, that is, the methods that modify the map on which they operate, are specified to throw UnsupportedOperationException if this map does not support the operation. If this is the case, these methods may, but are not required to, throw an UnsupportedOperationException if the invocation would have no effect on the map. For example, invoking the putAll() method on an unmodifiable map may, but is not required to, throw the exception if the map whose mappings are to be "superimposed" is empty. Some map implementations have restrictions on the keys and values they may contain. For example, some implementations prohibit null keys and values, and some have restrictions on the types of their keys. Attempting to insert an ineligible key or value throws an unchecked exception, typically NullPointerException or ClassCastException. Attempting to query the presence of an ineligible key or value may throw an exception, or it may simply return false; some implementations will exhibit the former behavior and some will exhibit the latter. More generally, attempting an operation on an ineligible key or value whose completion would not result in the insertion of an ineligible element into the map may throw an exception or it may succeed, at the option of the implementation. Such exceptions are marked as "optional" in the specification for this interface. Many methods in Collections Framework interfaces are defined in terms of the equals() method. For example, the specification for the containsKey() containsKey(Object key) method says: "returns true if and only if this map contains a mapping for a key k such that (key==null ? k==null : key.equals(k))." This specification should not be construed to imply that invoking Map.containsKey with a non-null argument key will cause key.equals(k) to be invoked for any key k. Implementations are free to implement optimizations whereby the equals invocation is avoided, for example, by first comparing the hash codes of the two keys. (The hashCode() specification guarantees that two objects with unequal hash codes cannot be equal.) More generally, implementations of the various Collections Framework interfaces are free to take advantage of the specified behavior of underlying Object methods wherever the implementor deems it appropriate. Some map operations which perform recursive traversal of the map may fail with an exception for self-referential instances where the map directly or indirectly contains itself. This includes the clone(), equals(), hashCode() and toString() methods. Implementations may optionally handle the self-referential scenario, however most current implementations do not do so. This interface is a member of the  Java Collections Framework.
java.util.Map.Entry: A map entry (key-value pair). The Map.entrySet method returns a collection-view of the map, whose elements are of this class. The only way to obtain a reference to a map entry is from the iterator of this collection-view. These Map.Entry objects are valid only for the duration of the iteration; more formally, the behavior of a map entry is undefined if the backing map has been modified after the entry was returned by the iterator, except through the setValue operation on the map entry.
java.util.Map.Entry.comparingByKey	(	): Returns a comparator that compares Map.Entry in natural order on key. The returned comparator is serializable and throws NullPointerException when comparing an entry with a null key.
java.util.Map.Entry.comparingByKey	(	Comparator	): Returns a comparator that compares Map.Entry by key using the given Comparator. The returned comparator is serializable if the specified comparator is also serializable.
java.util.Map.Entry.comparingByValue	(	): Returns a comparator that compares Map.Entry in natural order on value. The returned comparator is serializable and throws NullPointerException when comparing an entry with null values.
java.util.Map.Entry.comparingByValue	(	Comparator	): Returns a comparator that compares Map.Entry by value using the given Comparator. The returned comparator is serializable if the specified comparator is also serializable.
java.util.Map.Entry.equals	(	Object	): Compares the specified object with this entry for equality. Returns true if the given object is also a map entry and the two entries represent the same mapping. More formally, two entries e1 and e2 represent the same mapping if (e1.getKey()==null ? e2.getKey()==null : e1.getKey().equals(e2.getKey())) && (e1.getValue()==null ? e2.getValue()==null : e1.getValue().equals(e2.getValue()))  This ensures that the equals method works properly across different implementations of the Map.Entry interface.
java.util.Map.Entry.getKey	(	): Returns the key corresponding to this entry.
java.util.Map.Entry.getValue	(	): Returns the value corresponding to this entry. If the mapping has been removed from the backing map (by the iterator's remove operation), the results of this call are undefined.
java.util.Map.Entry.hashCode	(	): Returns the hash code value for this map entry. The hash code of a map entry e is defined to be:  (e.getKey()==null ? 0 : e.getKey().hashCode()) ^ (e.getValue()==null ? 0 : e.getValue().hashCode())  This ensures that e1.equals(e2) implies that e1.hashCode()==e2.hashCode() for any two Entries e1 and e2, as required by the general contract of Object.hashCode.
java.util.Map.Entry.setValue	(	V	): Replaces the value corresponding to this entry with the specified value (optional operation). (Writes through to the map.) The behavior of this call is undefined if the mapping has already been removed from the map (by the iterator's remove operation).
java.util.Map.clear	(	): Removes all of the mappings from this map (optional operation). The map will be empty after this call returns.
java.util.Map.compute	(	K	BiFunction	): Attempts to compute a mapping for the specified key and its current mapped value (or null if there is no current mapping). For example, to either create or append a String msg to a value mapping:  map.compute(key, (k, v) -> (v == null) ? msg : v.concat(msg)) (Method merge merge() is often simpler to use for such purposes.) If the function returns null, the mapping is removed (or remains absent if initially absent). If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.
java.util.Map.computeIfAbsent	(	K	Function	): If the specified key is not already associated with a value (or is mapped to null), attempts to compute its value using the given mapping function and enters it into this map unless null. If the function returns null no mapping is recorded. If the function itself throws an (unchecked) exception, the exception is rethrown, and no mapping is recorded. The most common usage is to construct a new object serving as an initial mapped value or memoized result, as in:  map.computeIfAbsent(key, k -> new Value(f(k))); Or to implement a multi-value map, Map>, supporting multiple values per key:  map.computeIfAbsent(key, k -> new HashSet()).add(v);
java.util.Map.computeIfPresent	(	K	BiFunction	): If the value for the specified key is present and non-null, attempts to compute a new mapping given the key and its current mapped value. If the function returns null, the mapping is removed. If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.
java.util.Map.containsKey	(	Object	): Returns true if this map contains a mapping for the specified key. More formally, returns true if and only if this map contains a mapping for a key k such that (key==null ? k==null : key.equals(k)). (There can be at most one such mapping.)
java.util.Map.containsValue	(	Object	): Returns true if this map maps one or more keys to the specified value. More formally, returns true if and only if this map contains at least one mapping to a value v such that (value==null ? v==null : value.equals(v)). This operation will probably require time linear in the map size for most implementations of the Map interface.
java.util.Map.entrySet	(	): Returns a Set view of the mappings contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation, or through the setValue operation on a map entry returned by the iterator) the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.Map.equals	(	Object	): Compares the specified object with this map for equality. Returns true if the given object is also a map and the two maps represent the same mappings. More formally, two maps m1 and m2 represent the same mappings if m1.entrySet().equals(m2.entrySet()). This ensures that the equals method works properly across different implementations of the Map interface.
java.util.Map.forEach	(	BiConsumer	): Performs the given action for each entry in this map until all entries have been processed or the action throws an exception. Unless otherwise specified by the implementing class, actions are performed in the order of entry set iteration (if an iteration order is specified.) Exceptions thrown by the action are relayed to the caller.
java.util.Map.get	(	Object	): Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that (key==null ? k==null : key.equals(k)), then this method returns v; otherwise it returns null. (There can be at most one such mapping.) If this map permits null values, then a return value of null does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to null. The containsKey operation may be used to distinguish these two cases.
java.util.Map.getOrDefault	(	Object	V	): Returns the value to which the specified key is mapped, or defaultValue if this map contains no mapping for the key.
java.util.Map.hashCode	(	): Returns the hash code value for this map. The hash code of a map is defined to be the sum of the hash codes of each entry in the map's entrySet() view. This ensures that m1.equals(m2) implies that m1.hashCode()==m2.hashCode() for any two maps m1 and m2, as required by the general contract of hashCode.
java.util.Map.isEmpty	(	): Returns true if this map contains no key-value mappings.
java.util.Map.keySet	(	): Returns a Set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.Map.merge	(	K	V	BiFunction	): If the specified key is not already associated with a value or is associated with null, associates it with the given non-null value. Otherwise, replaces the associated value with the results of the given remapping function, or removes if the result is null. This method may be of use when combining multiple mapped values for a key. For example, to either create or append a String msg to a value mapping:  map.merge(key, msg, String::concat) If the function returns null the mapping is removed. If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.
java.util.Map.put	(	K	V	): Associates the specified value with the specified key in this map (optional operation). If the map previously contained a mapping for the key, the old value is replaced by the specified value. (A map m is said to contain a mapping for a key k if and only if containsKey() m.containsKey(k) would return true.)
java.util.Map.putAll	(	Map	): Copies all of the mappings from the specified map to this map (optional operation). The effect of this call is equivalent to that of calling put() put(k, v) on this map once for each mapping from key k to value v in the specified map. The behavior of this operation is undefined if the specified map is modified while the operation is in progress.
java.util.Map.putIfAbsent	(	K	V	): If the specified key is not already associated with a value (or is mapped to null) associates it with the given value and returns null, else returns the current value.
java.util.Map.remove	(	Object	): Removes the mapping for a key from this map if it is present (optional operation). More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. If this map permits null values, then a return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.
java.util.Map.remove	(	Object	Object	): Removes the entry for the specified key only if it is currently mapped to the specified value.
java.util.Map.replace	(	K	V	): Replaces the entry for the specified key only if it is currently mapped to some value.
java.util.Map.replace	(	K	V	V	): Replaces the entry for the specified key only if currently mapped to the specified value.
java.util.Map.replaceAll	(	BiFunction	): Replaces each entry's value with the result of invoking the given function on that entry until all entries have been processed or the function throws an exception. Exceptions thrown by the function are relayed to the caller.
java.util.Map.size	(	): Returns the number of key-value mappings in this map. If the map contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
java.util.Map.values	(	): Returns a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.MissingFormatArgumentException: Unchecked exception thrown when there is a format specifier which does not have a corresponding argument or if an argument index refers to an argument that does not exist.  Unless otherwise specified, passing a null argument to any method or constructor in this class will cause a NullPointerException to be thrown.
java.util.MissingFormatArgumentException.MissingFormatArgumentException	(	String	): Constructs an instance of this class with the unmatched format specifier.
java.util.MissingFormatArgumentException.getFormatSpecifier	(	): Returns the unmatched format specifier.
java.util.MissingFormatWidthException: Unchecked exception thrown when the format width is required.  Unless otherwise specified, passing a null argument to any method or constructor in this class will cause a NullPointerException to be thrown.
java.util.MissingFormatWidthException.MissingFormatWidthException	(	String	): Constructs an instance of this class with the specified format specifier.
java.util.MissingFormatWidthException.getFormatSpecifier	(	): Returns the format specifier which does not have a width.
java.util.MissingResourceException: Signals that a resource is missing.
java.util.MissingResourceException.MissingResourceException	(	String	String	String	): Constructs a MissingResourceException with the specified information. A detail message is a String that describes this particular exception.
java.util.MissingResourceException.MissingResourceException	(	String	String	String	Throwable	): Constructs a MissingResourceException with message, className, key, and cause. This constructor is package private for use by ResourceBundle.getBundle.
java.util.MissingResourceException.getClassName	(	): Gets parameter passed by constructor.
java.util.MissingResourceException.getKey	(	): Gets parameter passed by constructor.
java.util.NavigableMap: A SortedMap extended with navigation methods returning the closest matches for given search targets. Methods lowerEntry, floorEntry, ceilingEntry, and higherEntry return Map.Entry objects associated with keys respectively less than, less than or equal, greater than or equal, and greater than a given key, returning null if there is no such key. Similarly, methods lowerKey, floorKey, ceilingKey, and higherKey return only the associated keys. All of these methods are designed for locating, not traversing entries. A NavigableMap may be accessed and traversed in either ascending or descending key order. The descendingMap method returns a view of the map with the senses of all relational and directional methods inverted. The performance of ascending operations and views is likely to be faster than that of descending ones. Methods subMap, headMap, and tailMap differ from the like-named SortedMap methods in accepting additional arguments describing whether lower and upper bounds are inclusive versus exclusive. Submaps of any NavigableMap must implement the NavigableMap interface. This interface additionally defines methods firstEntry, pollFirstEntry, lastEntry, and pollLastEntry that return and/or remove the least and greatest mappings, if any exist, else returning null. Implementations of entry-returning methods are expected to return Map.Entry pairs representing snapshots of mappings at the time they were produced, and thus generally do not support the optional Entry.setValue method. Note however that it is possible to change mappings in the associated map using method put. Methods subMap() subMap(K, K), headMap() headMap(K), and tailMap() tailMap(K) are specified to return SortedMap to allow existing implementations of SortedMap to be compatibly retrofitted to implement NavigableMap, but extensions and implementations of this interface are encouraged to override these methods to return NavigableMap. Similarly, keySet() can be overriden to return NavigableSet. This interface is a member of the  Java Collections Framework.
java.util.NavigableMap.ceilingEntry	(	K	): Returns a key-value mapping associated with the least key greater than or equal to the given key, or null if there is no such key.
java.util.NavigableMap.ceilingKey	(	K	): Returns the least key greater than or equal to the given key, or null if there is no such key.
java.util.NavigableMap.descendingKeySet	(	): Returns a reverse order NavigableSet view of the keys contained in this map. The set's iterator returns the keys in descending order. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.NavigableMap.descendingMap	(	): Returns a reverse order view of the mappings contained in this map. The descending map is backed by this map, so changes to the map are reflected in the descending map, and vice-versa. If either map is modified while an iteration over a collection view of either map is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The returned map has an ordering equivalent to reverseOrder() Collections.reverseOrder(comparator()). The expression m.descendingMap().descendingMap() returns a view of m essentially equivalent to m.
java.util.NavigableMap.firstEntry	(	): Returns a key-value mapping associated with the least key in this map, or null if the map is empty.
java.util.NavigableMap.floorEntry	(	K	): Returns a key-value mapping associated with the greatest key less than or equal to the given key, or null if there is no such key.
java.util.NavigableMap.floorKey	(	K	): Returns the greatest key less than or equal to the given key, or null if there is no such key.
java.util.NavigableMap.headMap	(	K	): Returns a view of the portion of this map whose keys are strictly less than toKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range. Equivalent to headMap(toKey, false).
java.util.NavigableMap.headMap	(	K	boolean	): Returns a view of the portion of this map whose keys are less than (or equal to, if inclusive is true) toKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range.
java.util.NavigableMap.higherEntry	(	K	): Returns a key-value mapping associated with the least key strictly greater than the given key, or null if there is no such key.
java.util.NavigableMap.higherKey	(	K	): Returns the least key strictly greater than the given key, or null if there is no such key.
java.util.NavigableMap.lastEntry	(	): Returns a key-value mapping associated with the greatest key in this map, or null if the map is empty.
java.util.NavigableMap.lowerEntry	(	K	): Returns a key-value mapping associated with the greatest key strictly less than the given key, or null if there is no such key.
java.util.NavigableMap.lowerKey	(	K	): Returns the greatest key strictly less than the given key, or null if there is no such key.
java.util.NavigableMap.navigableKeySet	(	): Returns a NavigableSet view of the keys contained in this map. The set's iterator returns the keys in ascending order. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.NavigableMap.pollFirstEntry	(	): Removes and returns a key-value mapping associated with the least key in this map, or null if the map is empty.
java.util.NavigableMap.pollLastEntry	(	): Removes and returns a key-value mapping associated with the greatest key in this map, or null if the map is empty.
java.util.NavigableMap.subMap	(	K	K	): Returns a view of the portion of this map whose keys range from fromKey, inclusive, to toKey, exclusive. (If fromKey and toKey are equal, the returned map is empty.) The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range. Equivalent to subMap(fromKey, true, toKey, false).
java.util.NavigableMap.subMap	(	K	boolean	K	boolean	): Returns a view of the portion of this map whose keys range from fromKey to toKey. If fromKey and toKey are equal, the returned map is empty unless fromInclusive and toInclusive are both true. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside of its range, or to construct a submap either of whose endpoints lie outside its range.
java.util.NavigableMap.tailMap	(	K	): Returns a view of the portion of this map whose keys are greater than or equal to fromKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range. Equivalent to tailMap(fromKey, true).
java.util.NavigableMap.tailMap	(	K	boolean	): Returns a view of the portion of this map whose keys are greater than (or equal to, if inclusive is true) fromKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range.
java.util.NavigableSet: A SortedSet extended with navigation methods reporting closest matches for given search targets. Methods lower, floor, ceiling, and higher return elements respectively less than, less than or equal, greater than or equal, and greater than a given element, returning null if there is no such element. A NavigableSet may be accessed and traversed in either ascending or descending order. The descendingSet method returns a view of the set with the senses of all relational and directional methods inverted. The performance of ascending operations and views is likely to be faster than that of descending ones. This interface additionally defines methods pollFirst and pollLast that return and remove the lowest and highest element, if one exists, else returning null. Methods subSet, headSet, and tailSet differ from the like-named SortedSet methods in accepting additional arguments describing whether lower and upper bounds are inclusive versus exclusive. Subsets of any NavigableSet must implement the NavigableSet interface.  The return values of navigation methods may be ambiguous in implementations that permit null elements. However, even in this case the result can be disambiguated by checking contains(null). To avoid such issues, implementations of this interface are encouraged to not permit insertion of null elements. (Note that sorted sets of Comparable elements intrinsically do not permit null.) Methods subSet() subSet(E, E), headSet() headSet(E), and tailSet() tailSet(E) are specified to return SortedSet to allow existing implementations of SortedSet to be compatibly retrofitted to implement NavigableSet, but extensions and implementations of this interface are encouraged to override these methods to return NavigableSet. This interface is a member of the  Java Collections Framework.
java.util.NavigableSet.ceiling	(	E	): Returns the least element in this set greater than or equal to the given element, or null if there is no such element.
java.util.NavigableSet.descendingIterator	(	): Returns an iterator over the elements in this set, in descending order. Equivalent in effect to descendingSet().iterator().
java.util.NavigableSet.descendingSet	(	): Returns a reverse order view of the elements contained in this set. The descending set is backed by this set, so changes to the set are reflected in the descending set, and vice-versa. If either set is modified while an iteration over either set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The returned set has an ordering equivalent to reverseOrder() Collections.reverseOrder(comparator()). The expression s.descendingSet().descendingSet() returns a view of s essentially equivalent to s.
java.util.NavigableSet.floor	(	E	): Returns the greatest element in this set less than or equal to the given element, or null if there is no such element.
java.util.NavigableSet.headSet	(	E	): Returns a view of the portion of this set whose elements are strictly less than toElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range. Equivalent to headSet(toElement, false).
java.util.NavigableSet.headSet	(	E	boolean	): Returns a view of the portion of this set whose elements are less than (or equal to, if inclusive is true) toElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range.
java.util.NavigableSet.higher	(	E	): Returns the least element in this set strictly greater than the given element, or null if there is no such element.
java.util.NavigableSet.iterator	(	): Returns an iterator over the elements in this set, in ascending order.
java.util.NavigableSet.lower	(	E	): Returns the greatest element in this set strictly less than the given element, or null if there is no such element.
java.util.NavigableSet.pollFirst	(	): Retrieves and removes the first (lowest) element, or returns null if this set is empty.
java.util.NavigableSet.pollLast	(	): Retrieves and removes the last (highest) element, or returns null if this set is empty.
java.util.NavigableSet.subSet	(	E	E	): Returns a view of the portion of this set whose elements range from fromElement, inclusive, to toElement, exclusive. (If fromElement and toElement are equal, the returned set is empty.) The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range. Equivalent to subSet(fromElement, true, toElement, false).
java.util.NavigableSet.subSet	(	E	boolean	E	boolean	): Returns a view of the portion of this set whose elements range from fromElement to toElement. If fromElement and toElement are equal, the returned set is empty unless fromInclusive and toInclusive are both true. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range.
java.util.NavigableSet.tailSet	(	E	): Returns a view of the portion of this set whose elements are greater than or equal to fromElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range. Equivalent to tailSet(fromElement, true).
java.util.NavigableSet.tailSet	(	E	boolean	): Returns a view of the portion of this set whose elements are greater than (or equal to, if inclusive is true) fromElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range.
java.util.NoSuchElementException: Thrown by various accessor methods to indicate that the element being requested does not exist.
java.util.NoSuchElementException.NoSuchElementException	(	): Constructs a NoSuchElementException with null as its error message string.
java.util.NoSuchElementException.NoSuchElementException	(	String	): Constructs a NoSuchElementException, saving a reference to the error message string s for later retrieval by the getMessage method.
java.util.Objects: This class consists of static utility methods for operating on objects. These utilities include null-safe or null-tolerant methods for computing the hash code of an object, returning a string for an object, and comparing two objects.
java.util.Objects.compare	(	T	T	Comparator	): Returns 0 if the arguments are identical and c.compare(a, b) otherwise. Consequently, if both arguments are null 0 is returned. Note that if one of the arguments is null, a NullPointerException may or may not be thrown depending on what ordering policy, if any, the Comparator Comparator chooses to have for null values.
java.util.Objects.deepEquals	(	Object	Object	): Returns true if the arguments are deeply equal to each other and false otherwise. Two null values are deeply equal. If both arguments are arrays, the algorithm in deepEquals() Arrays.deepEquals is used to determine equality. Otherwise, equality is determined by using the equals method of the first argument.
java.util.Objects.equals	(	Object	Object	): Returns true if the arguments are equal to each other and false otherwise. Consequently, if both arguments are null, true is returned and if exactly one argument is null, false is returned. Otherwise, equality is determined by using the equals method of the first argument.
java.util.Objects.hash	(	Object	): Generates a hash code for a sequence of input values. The hash code is generated as if all the input values were placed into an array, and that array were hashed by calling hashCode(). This method is useful for implementing hashCode() on objects containing multiple fields. For example, if an object that has three fields, x, y, and z, one could write:  @Override public int hashCode() { return Objects.hash(x, y, z); }  Warning: When a single object reference is supplied, the returned value does not equal the hash code of that object reference. This value can be computed by calling hashCode().
java.util.Objects.hashCode	(	Object	): Returns the hash code of a non-null argument and 0 for a null argument.
java.util.Objects.isNull	(	Object	): Returns true if the provided reference is null otherwise returns false.
java.util.Objects.nonNull	(	Object	): Returns true if the provided reference is non-null otherwise returns false.
java.util.Objects.requireNonNull	(	T	): Checks that the specified object reference is not null. This method is designed primarily for doing parameter validation in methods and constructors, as demonstrated below:  public Foo(Bar bar) { this.bar = Objects.requireNonNull(bar); } 
java.util.Objects.requireNonNull	(	T	String	): Checks that the specified object reference is not null and throws a customized NullPointerException if it is. This method is designed primarily for doing parameter validation in methods and constructors with multiple parameters, as demonstrated below:  public Foo(Bar bar, Baz baz) { this.bar = Objects.requireNonNull(bar, "bar must not be null"); this.baz = Objects.requireNonNull(baz, "baz must not be null"); } 
java.util.Objects.requireNonNull	(	T	Supplier	): Checks that the specified object reference is not null and throws a customized NullPointerException if it is. Unlike the method requireNonNull(), this method allows creation of the message to be deferred until after the null check is made. While this may confer a performance advantage in the non-null case, when deciding to call this method care should be taken that the costs of creating the message supplier are less than the cost of just creating the string message directly.
java.util.Objects.toString	(	Object	): Returns the result of calling toString for a non-null argument and "null" for a null argument.
java.util.Objects.toString	(	Object	String	): Returns the result of calling toString on the first argument if the first argument is not null and returns the second argument otherwise.
java.util.Observable: This class represents an observable object, or "data" in the model-view paradigm. It can be subclassed to represent an object that the application wants to have observed.  An observable object can have one or more observers. An observer may be any object that implements interface Observer. After an observable instance changes, an application calling the Observable's notifyObservers method causes all of its observers to be notified of the change by a call to their update method.  The order in which notifications will be delivered is unspecified. The default implementation provided in the Observable class will notify Observers in the order in which they registered interest, but subclasses may change this order, use no guaranteed order, deliver notifications on separate threads, or may guarantee that their subclass follows this order, as they choose.  Note that this notification mechanism has nothing to do with threads and is completely separate from the wait and notify mechanism of class Object.  When an observable object is newly created, its set of observers is empty. Two observers are considered the same if and only if the equals method returns true for them.
java.util.Observable.Observable	(	): Construct an Observable with zero Observers. 
java.util.Observable.addObserver	(	Observer	): Adds an observer to the set of observers for this object, provided that it is not the same as some observer already in the set. The order in which notifications will be delivered to multiple observers is not specified. See the class comment.
java.util.Observable.clearChanged	(	): Indicates that this object has no longer changed, or that it has already notified all of its observers of its most recent change, so that the hasChanged method will now return false. This method is called automatically by the notifyObservers methods.
java.util.Observable.countObservers	(	): Returns the number of observers of this Observable object.
java.util.Observable.deleteObserver	(	Observer	): Deletes an observer from the set of observers of this object. Passing null to this method will have no effect.
java.util.Observable.deleteObservers	(	): Clears the observer list so that this object no longer has any observers.
java.util.Observable.hasChanged	(	): Tests if this object has changed.
java.util.Observable.notifyObservers	(	): If this object has changed, as indicated by the hasChanged method, then notify all of its observers and then call the clearChanged method to indicate that this object has no longer changed.  Each observer has its update method called with two arguments: this observable object and null. In other words, this method is equivalent to:  notifyObservers(null)
java.util.Observable.notifyObservers	(	Object	): If this object has changed, as indicated by the hasChanged method, then notify all of its observers and then call the clearChanged method to indicate that this object has no longer changed.  Each observer has its update method called with two arguments: this observable object and the arg argument.
java.util.Observable.setChanged	(	): Marks this Observable object as having been changed; the hasChanged method will now return true.
java.util.Observer: A class can implement the Observer interface when it wants to be informed of changes in observable objects.
java.util.Observer.update	(	Observable	Object	): This method is called whenever the observed object is changed. An application calls an Observable object's notifyObservers method to have all the object's observers notified of the change.
java.util.Optional: A container object which may or may not contain a non-null value. If a value is present, isPresent() will return true and get() will return the value. Additional methods that depend on the presence or absence of a contained value are provided, such as orElse() orElse() (return a default value if value not present) and ifPresent() ifPresent() (execute a block of code if the value is present). This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of Optional may have unpredictable results and should be avoided.
java.util.Optional.Optional	(	): Constructs an empty instance.
java.util.Optional.Optional	(	T	): Constructs an instance with the value present.
java.util.Optional.empty	(	): Returns an empty Optional instance. No value is present for this Optional.
java.util.Optional.equals	(	Object	): Indicates whether some other object is "equal to" this Optional. The other object is considered equal if:  it is also an Optional and; both instances have no value present or; the present values are "equal to" each other via equals(). 
java.util.Optional.filter	(	Predicate	): If a value is present, and the value matches the given predicate, return an Optional describing the value, otherwise return an empty Optional.
java.util.Optional.flatMap	(	Function	): If a value is present, apply the provided Optional-bearing mapping function to it, return that result, otherwise return an empty Optional. This method is similar to map(), but the provided mapper is one whose result is already an Optional, and if invoked, flatMap does not wrap it with an additional Optional.
java.util.Optional.get	(	): If a value is present in this Optional, returns the value, otherwise throws NoSuchElementException.
java.util.Optional.hashCode	(	): Returns the hash code value of the present value, if any, or 0 (zero) if no value is present.
java.util.Optional.ifPresent	(	Consumer	): If a value is present, invoke the specified consumer with the value, otherwise do nothing.
java.util.Optional.isPresent	(	): Return true if there is a value present, otherwise false.
java.util.Optional.map	(	Function	): If a value is present, apply the provided mapping function to it, and if the result is non-null, return an Optional describing the result. Otherwise return an empty Optional.
java.util.Optional.of	(	T	): Returns an Optional with the specified present non-null value.
java.util.Optional.ofNullable	(	T	): Returns an Optional describing the specified value, if non-null, otherwise returns an empty Optional.
java.util.Optional.orElse	(	T	): Return the value if present, otherwise return other.
java.util.Optional.orElseGet	(	Supplier	): Return the value if present, otherwise invoke other and return the result of that invocation.
java.util.Optional.orElseThrow	(	Supplier	): Return the contained value, if present, otherwise throw an exception to be created by the provided supplier.
java.util.Optional.toString	(	): Returns a non-empty string representation of this Optional suitable for debugging. The exact presentation format is unspecified and may vary between implementations and versions.
java.util.OptionalDouble: A container object which may or may not contain a double value. If a value is present, isPresent() will return true and getAsDouble() will return the value. Additional methods that depend on the presence or absence of a contained value are provided, such as orElse() orElse() (return a default value if value not present) and ifPresent() ifPresent() (execute a block of code if the value is present). This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of OptionalDouble may have unpredictable results and should be avoided.
java.util.OptionalDouble.OptionalDouble	(	): Construct an empty instance.
java.util.OptionalDouble.OptionalDouble	(	double	): Construct an instance with the value present.
java.util.OptionalDouble.empty	(	): Returns an empty OptionalDouble instance. No value is present for this OptionalDouble.
java.util.OptionalDouble.equals	(	Object	): Indicates whether some other object is "equal to" this OptionalDouble. The other object is considered equal if:  it is also an OptionalDouble and; both instances have no value present or; the present values are "equal to" each other via Double.compare() == 0. 
java.util.OptionalDouble.getAsDouble	(	): If a value is present in this OptionalDouble, returns the value, otherwise throws NoSuchElementException.
java.util.OptionalDouble.hashCode	(	): Returns the hash code value of the present value, if any, or 0 (zero) if no value is present.
java.util.OptionalDouble.ifPresent	(	DoubleConsumer	): Have the specified consumer accept the value if a value is present, otherwise do nothing.
java.util.OptionalDouble.isPresent	(	): Return true if there is a value present, otherwise false.
java.util.OptionalDouble.of	(	double	): Return an OptionalDouble with the specified value present.
java.util.OptionalDouble.orElse	(	double	): Return the value if present, otherwise return other.
java.util.OptionalDouble.orElseGet	(	DoubleSupplier	): Return the value if present, otherwise invoke other and return the result of that invocation.
java.util.OptionalDouble.orElseThrow	(	Supplier	): Return the contained value, if present, otherwise throw an exception to be created by the provided supplier.
java.util.OptionalDouble.toString	(	):  Returns a non-empty string representation of this object suitable for debugging. The exact presentation format is unspecified and may vary between implementations and versions.
java.util.OptionalInt: A container object which may or may not contain a int value. If a value is present, isPresent() will return true and getAsInt() will return the value. Additional methods that depend on the presence or absence of a contained value are provided, such as orElse() orElse() (return a default value if value not present) and ifPresent() ifPresent() (execute a block of code if the value is present). This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of OptionalInt may have unpredictable results and should be avoided.
java.util.OptionalInt.OptionalInt	(	): Construct an empty instance.
java.util.OptionalInt.OptionalInt	(	int	): Construct an instance with the value present.
java.util.OptionalInt.empty	(	): Returns an empty OptionalInt instance. No value is present for this OptionalInt.
java.util.OptionalInt.equals	(	Object	): Indicates whether some other object is "equal to" this OptionalInt. The other object is considered equal if:  it is also an OptionalInt and; both instances have no value present or; the present values are "equal to" each other via ==. 
java.util.OptionalInt.getAsInt	(	): If a value is present in this OptionalInt, returns the value, otherwise throws NoSuchElementException.
java.util.OptionalInt.hashCode	(	): Returns the hash code value of the present value, if any, or 0 (zero) if no value is present.
java.util.OptionalInt.ifPresent	(	IntConsumer	): Have the specified consumer accept the value if a value is present, otherwise do nothing.
java.util.OptionalInt.isPresent	(	): Return true if there is a value present, otherwise false.
java.util.OptionalInt.of	(	int	): Return an OptionalInt with the specified value present.
java.util.OptionalInt.orElse	(	int	): Return the value if present, otherwise return other.
java.util.OptionalInt.orElseGet	(	IntSupplier	): Return the value if present, otherwise invoke other and return the result of that invocation.
java.util.OptionalInt.orElseThrow	(	Supplier	): Return the contained value, if present, otherwise throw an exception to be created by the provided supplier.
java.util.OptionalInt.toString	(	):  Returns a non-empty string representation of this object suitable for debugging. The exact presentation format is unspecified and may vary between implementations and versions.
java.util.OptionalLong: A container object which may or may not contain a long value. If a value is present, isPresent() will return true and getAsLong() will return the value. Additional methods that depend on the presence or absence of a contained value are provided, such as orElse() orElse() (return a default value if value not present) and ifPresent() ifPresent() (execute a block of code if the value is present). This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of OptionalLong may have unpredictable results and should be avoided.
java.util.OptionalLong.OptionalLong	(	): Construct an empty instance.
java.util.OptionalLong.OptionalLong	(	long	): Construct an instance with the value present.
java.util.OptionalLong.empty	(	): Returns an empty OptionalLong instance. No value is present for this OptionalLong.
java.util.OptionalLong.equals	(	Object	): Indicates whether some other object is "equal to" this OptionalLong. The other object is considered equal if:  it is also an OptionalLong and; both instances have no value present or; the present values are "equal to" each other via ==. 
java.util.OptionalLong.getAsLong	(	): If a value is present in this OptionalLong, returns the value, otherwise throws NoSuchElementException.
java.util.OptionalLong.hashCode	(	): Returns the hash code value of the present value, if any, or 0 (zero) if no value is present.
java.util.OptionalLong.ifPresent	(	LongConsumer	): Have the specified consumer accept the value if a value is present, otherwise do nothing.
java.util.OptionalLong.isPresent	(	): Return true if there is a value present, otherwise false.
java.util.OptionalLong.of	(	long	): Return an OptionalLong with the specified value present.
java.util.OptionalLong.orElse	(	long	): Return the value if present, otherwise return other.
java.util.OptionalLong.orElseGet	(	LongSupplier	): Return the value if present, otherwise invoke other and return the result of that invocation.
java.util.OptionalLong.orElseThrow	(	Supplier	): Return the contained value, if present, otherwise throw an exception to be created by the provided supplier.
java.util.OptionalLong.toString	(	):  Returns a non-empty string representation of this object suitable for debugging. The exact presentation format is unspecified and may vary between implementations and versions.
java.util.PrimitiveIterator: A base type for primitive specializations of Iterator. Specialized subtypes are provided for OfInt int, OfLong long, and OfDouble double values. The specialized subtype default implementations of next and forEachRemaining() box primitive values to instances of their corresponding wrapper class. Such boxing may offset any advantages gained when using the primitive specializations. To avoid boxing, the corresponding primitive-based methods should be used. For example, nextInt() and forEachRemaining() should be used in preference to next() and forEachRemaining(). Iteration of primitive values using boxing-based methods next next() and forEachRemaining() forEachRemaining(), does not affect the order in which the values, transformed to boxed values, are encountered.
java.util.PrimitiveIterator.OfDouble: An Iterator specialized for double values.
java.util.PrimitiveIterator.OfDouble.forEachRemaining	(	Consumer	): Performs the given action for each remaining element until all elements have been processed or the action throws an exception. Actions are performed in the order of iteration, if that order is specified. Exceptions thrown by the action are relayed to the caller.
java.util.PrimitiveIterator.OfDouble.forEachRemaining	(	DoubleConsumer	): Performs the given action for each remaining element until all elements have been processed or the action throws an exception. Actions are performed in the order of iteration, if that order is specified. Exceptions thrown by the action are relayed to the caller.
java.util.PrimitiveIterator.OfDouble.next	(	): Returns the next element in the iteration.
java.util.PrimitiveIterator.OfDouble.nextDouble	(	): Returns the next double element in the iteration.
java.util.PrimitiveIterator.OfInt: An Iterator specialized for int values.
java.util.PrimitiveIterator.OfInt.forEachRemaining	(	Consumer	): Performs the given action for each remaining element until all elements have been processed or the action throws an exception. Actions are performed in the order of iteration, if that order is specified. Exceptions thrown by the action are relayed to the caller.
java.util.PrimitiveIterator.OfInt.forEachRemaining	(	IntConsumer	): Performs the given action for each remaining element until all elements have been processed or the action throws an exception. Actions are performed in the order of iteration, if that order is specified. Exceptions thrown by the action are relayed to the caller.
java.util.PrimitiveIterator.OfInt.next	(	): Returns the next element in the iteration.
java.util.PrimitiveIterator.OfInt.nextInt	(	): Returns the next int element in the iteration.
java.util.PrimitiveIterator.OfLong: An Iterator specialized for long values.
java.util.PrimitiveIterator.OfLong.forEachRemaining	(	Consumer	): Performs the given action for each remaining element until all elements have been processed or the action throws an exception. Actions are performed in the order of iteration, if that order is specified. Exceptions thrown by the action are relayed to the caller.
java.util.PrimitiveIterator.OfLong.forEachRemaining	(	LongConsumer	): Performs the given action for each remaining element until all elements have been processed or the action throws an exception. Actions are performed in the order of iteration, if that order is specified. Exceptions thrown by the action are relayed to the caller.
java.util.PrimitiveIterator.OfLong.next	(	): Returns the next element in the iteration.
java.util.PrimitiveIterator.OfLong.nextLong	(	): Returns the next long element in the iteration.
java.util.PrimitiveIterator.forEachRemaining	(	T_CONS	): Performs the given action for each remaining element, in the order elements occur when iterating, until all elements have been processed or the action throws an exception. Errors or runtime exceptions thrown by the action are relayed to the caller.
java.util.PriorityQueue: An unbounded priority Queue queue based on a priority heap. The elements of the priority queue are ordered according to their Comparable natural ordering, or by a Comparator provided at queue construction time, depending on which constructor is used. A priority queue does not permit null elements. A priority queue relying on natural ordering also does not permit insertion of non-comparable objects (doing so may result in ClassCastException). The head of this queue is the least element with respect to the specified ordering. If multiple elements are tied for least value, the head is one of those elements -- ties are broken arbitrarily. The queue retrieval operations poll, remove, peek, and element access the element at the head of the queue. A priority queue is unbounded, but has an internal capacity governing the size of an array used to store the elements on the queue. It is always at least as large as the queue size. As elements are added to a priority queue, its capacity grows automatically. The details of the growth policy are not specified. This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces. The Iterator provided in method iterator() is not guaranteed to traverse the elements of the priority queue in any particular order. If you need ordered traversal, consider using Arrays.sort(pq.toArray()). Note that this implementation is not synchronized. Multiple threads should not access a PriorityQueue instance concurrently if any of the threads modifies the queue. Instead, use the thread-safe java.util.concurrent.PriorityBlockingQueue class. Implementation note: this implementation provides O(log(n)) time for the enqueuing and dequeuing methods (offer, poll, remove() and add); linear time for the remove(Object) and contains(Object) methods; and constant time for the retrieval methods (peek, element, and size). This class is a member of the  Java Collections Framework.
java.util.PriorityQueue.PriorityQueue	(	): Creates a PriorityQueue with the default initial capacity (11) that orders its elements according to their Comparable natural ordering.
java.util.PriorityQueue.PriorityQueue	(	Collection	): Creates a PriorityQueue containing the elements in the specified collection. If the specified collection is an instance of a SortedSet or is another PriorityQueue, this priority queue will be ordered according to the same ordering. Otherwise, this priority queue will be ordered according to the Comparable natural ordering of its elements.
java.util.PriorityQueue.PriorityQueue	(	Comparator	): Creates a PriorityQueue with the default initial capacity and whose elements are ordered according to the specified comparator.
java.util.PriorityQueue.PriorityQueue	(	PriorityQueue	): Creates a PriorityQueue containing the elements in the specified priority queue. This priority queue will be ordered according to the same ordering as the given priority queue.
java.util.PriorityQueue.PriorityQueue	(	SortedSet	): Creates a PriorityQueue containing the elements in the specified sorted set. This priority queue will be ordered according to the same ordering as the given sorted set.
java.util.PriorityQueue.PriorityQueue	(	int	): Creates a PriorityQueue with the specified initial capacity that orders its elements according to their Comparable natural ordering.
java.util.PriorityQueue.PriorityQueue	(	int	Comparator	): Creates a PriorityQueue with the specified initial capacity that orders its elements according to the specified comparator.
java.util.PriorityQueue.PriorityQueueSpliterator.PriorityQueueSpliterator	(	PriorityQueue	int	int	int	): Creates new spliterator covering the given range 
java.util.PriorityQueue.add	(	E	): Inserts the specified element into this priority queue.
java.util.PriorityQueue.clear	(	): Removes all of the elements from this priority queue. The queue will be empty after this call returns.
java.util.PriorityQueue.comparator	(	): Returns the comparator used to order the elements in this queue, or null if this queue is sorted according to the Comparable natural ordering of its elements.
java.util.PriorityQueue.contains	(	Object	): Returns true if this queue contains the specified element. More formally, returns true if and only if this queue contains at least one element e such that o.equals(e).
java.util.PriorityQueue.grow	(	int	): Increases the capacity of the array.
java.util.PriorityQueue.heapify	(	): Establishes the heap invariant (described above) in the entire tree, assuming nothing about the order of the elements prior to the call.
java.util.PriorityQueue.initFromCollection	(	Collection	): Initializes queue array with elements from the given Collection.
java.util.PriorityQueue.iterator	(	): Returns an iterator over the elements in this queue. The iterator does not return the elements in any particular order.
java.util.PriorityQueue.offer	(	E	): Inserts the specified element into this priority queue.
java.util.PriorityQueue.readObject	(	java.io.ObjectInputStream	): Reconstitutes the PriorityQueue instance from a stream (that is, deserializes it).
java.util.PriorityQueue.remove	(	Object	): Removes a single instance of the specified element from this queue, if it is present. More formally, removes an element e such that o.equals(e), if this queue contains one or more such elements. Returns true if and only if this queue contained the specified element (or equivalently, if this queue changed as a result of the call).
java.util.PriorityQueue.removeAt	(	int	): Removes the ith element from queue. Normally this method leaves the elements at up to i-1, inclusive, untouched. Under these circumstances, it returns null. Occasionally, in order to maintain the heap invariant, it must swap a later element of the list with one earlier than i. Under these circumstances, this method returns the element that was previously at the end of the list and is now at some position before i. This fact is used by iterator.remove so as to avoid missing traversing elements.
java.util.PriorityQueue.removeEq	(	Object	): Version of remove using reference equality, not equals. Needed by iterator.remove.
java.util.PriorityQueue.siftDown	(	int	E	): Inserts item x at position k, maintaining heap invariant by demoting x down the tree repeatedly until it is less than or equal to its children or is a leaf.
java.util.PriorityQueue.siftUp	(	int	E	): Inserts item x at position k, maintaining heap invariant by promoting x up the tree until it is greater than or equal to its parent, or is the root. To simplify and speed up coercions and comparisons. the Comparable and Comparator versions are separated into different methods that are otherwise identical. (Similarly for siftDown.)
java.util.PriorityQueue.spliterator	(	): Creates a late-binding and fail-fast Spliterator over the elements in this queue. The Spliterator reports SIZED, SUBSIZED, and NONNULL. Overriding implementations should document the reporting of additional characteristic values.
java.util.PriorityQueue.toArray	(	): Returns an array containing all of the elements in this queue. The elements are in no particular order. The returned array will be "safe" in that no references to it are maintained by this queue. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.PriorityQueue.toArray	(	T[]	): Returns an array containing all of the elements in this queue; the runtime type of the returned array is that of the specified array. The returned array elements are in no particular order. If the queue fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this queue. If the queue fits in the specified array with room to spare (i.e., the array has more elements than the queue), the element in the array immediately following the end of the collection is set to null. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a queue known to contain only strings. The following code can be used to dump the queue into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.PriorityQueue.writeObject	(	java.io.ObjectOutputStream	): Saves this queue to a stream (that is, serializes it).
java.util.Properties: The Properties class represents a persistent set of properties. The Properties can be saved to a stream or loaded from a stream. Each key and its corresponding value in the property list is a string.  A property list can contain another property list as its "defaults"; this second property list is searched if the property key is not found in the original property list.  Because Properties inherits from Hashtable, the put and putAll methods can be applied to a Properties object. Their use is strongly discouraged as they allow the caller to insert entries whose keys or values are not Strings. The setProperty method should be used instead. If the store or save method is called on a "compromised" Properties object that contains a non-String key or value, the call will fail. Similarly, the call to the propertyNames or list method will fail if it is called on a "compromised" Properties object that contains a non-String key.  The load() load(Reader) / store() store(Writer, String) methods load and store properties from and to a character based stream in a simple line-oriented format specified below. The load() load(InputStream) / store() store(OutputStream, String) methods work the same way as the load(Reader)/store(Writer, String) pair, except the input/output stream is encoded in ISO 8859-1 character encoding. Characters that cannot be directly represented in this encoding can be written using Unicode escapes as defined in section 3.3 of The Java Language Specification; only a single 'u' character is allowed in an escape sequence. The native2ascii tool can be used to convert property files to and from other character encodings.  The loadFromXML() and storeToXML() methods load and store properties in a simple XML format. By default the UTF-8 character encoding is used, however a specific encoding may be specified if required. Implementations are required to support UTF-8 and UTF-16 and may support other encodings. An XML properties document has the following DOCTYPE declaration:  <!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">  Note that the system URI (http://java.sun.com/dtd/properties.dtd) is not accessed when exporting or importing properties; it merely serves as a string to uniquely identify the DTD, which is:  <?xml version="1.0" encoding="UTF-8"?> <!-- DTD for properties --> <!ELEMENT properties ( comment?, entry* ) > <!ATTLIST properties version CDATA #FIXED "1.0"> <!ELEMENT comment (#PCDATA) > <!ELEMENT entry (#PCDATA) > <!ATTLIST entry key CDATA #REQUIRED>  This class is thread-safe: multiple threads can share a single Properties object without the need for external synchronization.
java.util.Properties.Properties	(	): Creates an empty property list with no default values.
java.util.Properties.Properties	(	Properties	): Creates an empty property list with the specified defaults.
java.util.Properties.XmlSupport: Supporting class for loading/storing properties in XML format.  The load and store methods defined here delegate to a system-wide XmlPropertiesProvider. On first invocation of either method then the system-wide provider is located as follows:    If the system property sun.util.spi.XmlPropertiesProvider is defined then it is taken to be the full-qualified name of a concrete provider class. The class is loaded with the system class loader as the initiating loader. If it cannot be loaded or instantiated using a zero argument constructor then an unspecified error is thrown.   If the system property is not defined then the service-provider loading facility defined by the ServiceLoader class is used to locate a provider with the system class loader as the initiating loader and sun.util.spi.XmlPropertiesProvider as the service type. If this process fails then an unspecified error is thrown. If there is more than one service provider installed then it is not specified as to which provider will be used.   If the provider is not found by the above means then a system default provider will be instantiated and used.  
java.util.Properties.enumerate	(	Hashtable	): Enumerates all key/value pairs in the specified hashtable.
java.util.Properties.enumerateStringProperties	(	Hashtable	): Enumerates all key/value pairs in the specified hashtable and omits the property if the key or value is not a string.
java.util.Properties.getProperty	(	String	): Searches for the property with the specified key in this property list. If the key is not found in this property list, the default property list, and its defaults, recursively, are then checked. The method returns null if the property is not found.
java.util.Properties.getProperty	(	String	String	): Searches for the property with the specified key in this property list. If the key is not found in this property list, the default property list, and its defaults, recursively, are then checked. The method returns the default value argument if the property is not found.
java.util.Properties.list	(	PrintStream	): Prints this property list out to the specified output stream. This method is useful for debugging.
java.util.Properties.list	(	PrintWriter	): Prints this property list out to the specified output stream. This method is useful for debugging.
java.util.Properties.load	(	InputStream	): Reads a property list (key and element pairs) from the input byte stream. The input stream is in a simple line-oriented format as specified in load() load(Reader) and is assumed to use the ISO 8859-1 character encoding; that is each byte is one Latin1 character. Characters not in Latin1, and certain special characters, are represented in keys and elements using Unicode escapes as defined in section 3.3 of The Java Language Specification.  The specified stream remains open after this method returns.
java.util.Properties.load	(	Reader	): Reads a property list (key and element pairs) from the input character stream in a simple line-oriented format.  Properties are processed in terms of lines. There are two kinds of line, natural lines and logical lines. A natural line is defined as a line of characters that is terminated either by a set of line terminator characters (\n or \r or \r\n) or by the end of the stream. A natural line may be either a blank line, a comment line, or hold all or some of a key-element pair. A logical line holds all the data of a key-element pair, which may be spread out across several adjacent natural lines by escaping the line terminator sequence with a backslash character \. Note that a comment line cannot be extended in this manner; every natural line that is a comment must have its own comment indicator, as described below. Lines are read from input until the end of the stream is reached.  A natural line that contains only white space characters is considered blank and is ignored. A comment line has an ASCII '#' or '!' as its first non-white space character; comment lines are also ignored and do not encode key-element information. In addition to line terminators, this format considers the characters space (' ', '\u005Cu0020'), tab ('\t', '\u005Cu0009'), and form feed ('\f', '\u005Cu000C') to be white space.  If a logical line is spread across several natural lines, the backslash escaping the line terminator sequence, the line terminator sequence, and any white space at the start of the following line have no affect on the key or element values. The remainder of the discussion of key and element parsing (when loading) will assume all the characters constituting the key and element appear on a single natural line after line continuation characters have been removed. Note that it is not sufficient to only examine the character preceding a line terminator sequence to decide if the line terminator is escaped; there must be an odd number of contiguous backslashes for the line terminator to be escaped. Since the input is processed from left to right, a non-zero even number of 2n contiguous backslashes before a line terminator (or elsewhere) encodes n backslashes after escape processing.  The key contains all of the characters in the line starting with the first non-white space character and up to, but not including, the first unescaped '=', ':', or white space character other than a line terminator. All of these key termination characters may be included in the key by escaping them with a preceding backslash character; for example, \:\= would be the two-character key ":=". Line terminator characters can be included using \r and \n escape sequences. Any white space after the key is skipped; if the first non-white space character after the key is '=' or ':', then it is ignored and any white space characters after it are also skipped. All remaining characters on the line become part of the associated element string; if there are no remaining characters, the element is the empty string "". Once the raw character sequences constituting the key and element are identified, escape processing is performed as described above.  As an example, each of the following three lines specifies the key "Truth" and the associated element value "Beauty":  Truth = Beauty Truth:Beauty Truth :Beauty  As another example, the following three lines specify a single property:  fruits apple, banana, pear, \ cantaloupe, watermelon, \ kiwi, mango  The key is "fruits" and the associated element is: "apple, banana, pear, cantaloupe, watermelon, kiwi, mango" Note that a space appears before each \ so that a space will appear after each comma in the final result; the \, line terminator, and leading white space on the continuation line are merely discarded and are not replaced by one or more other characters.  As a third example, the line: cheeses  specifies that the key is "cheeses" and the associated element is the empty string "".   Characters in keys and elements can be represented in escape sequences similar to those used for character and string literals (see sections 3.3 and 3.10.6 of The Java Language Specification). The differences from the character escape sequences and Unicode escapes used for characters and strings are:   Octal escapes are not recognized.  The character sequence \b does not represent a backspace character.  The method does not treat a backslash character, \, before a non-valid escape character as an error; the backslash is silently dropped. For example, in a Java string the sequence "\z" would cause a compile time error. In contrast, this method silently drops the backslash. Therefore, this method treats the two character sequence "\b" as equivalent to the single character 'b'.  Escapes are not necessary for single and double quotes; however, by the rule above, single and double quote characters preceded by a backslash still yield single and double quote characters, respectively.  Only a single 'u' character is allowed in a Unicode escape sequence.   The specified stream remains open after this method returns.
java.util.Properties.loadFromXML	(	InputStream	): Loads all of the properties represented by the XML document on the specified input stream into this properties table. The XML document must have the following DOCTYPE declaration:  <!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">  Furthermore, the document must satisfy the properties DTD described above.  An implementation is required to read XML documents that use the "UTF-8" or "UTF-16" encoding. An implementation may support additional encodings. The specified stream is closed after this method returns.
java.util.Properties.propertyNames	(	): Returns an enumeration of all the keys in this property list, including distinct keys in the default property list if a key of the same name has not already been found from the main properties list.
java.util.Properties.save	(	OutputStream	String	): Calls the store(OutputStream out, String comments) method and suppresses IOExceptions that were thrown.
java.util.Properties.setProperty	(	String	String	): Calls the Hashtable method put. Provided for parallelism with the getProperty method. Enforces use of strings for property keys and values. The value returned is the result of the Hashtable call to put.
java.util.Properties.store	(	OutputStream	String	): Writes this property list (key and element pairs) in this Properties table to the output stream in a format suitable for loading into a Properties table using the load() load(InputStream) method.  Properties from the defaults table of this Properties table (if any) are not written out by this method.  This method outputs the comments, properties keys and values in the same format as specified in store() store(Writer), with the following differences:  The stream is written using the ISO 8859-1 character encoding. Characters not in Latin-1 in the comments are written as \u005Cuxxxx for their appropriate unicode hexadecimal value xxxx. Characters less than \u005Cu0020 and characters greater than \u005Cu007E in property keys or values are written as \u005Cuxxxx for the appropriate hexadecimal value xxxx.   After the entries have been written, the output stream is flushed. The output stream remains open after this method returns. 
java.util.Properties.store	(	Writer	String	): Writes this property list (key and element pairs) in this Properties table to the output character stream in a format suitable for using the load() load(Reader) method.  Properties from the defaults table of this Properties table (if any) are not written out by this method.  If the comments argument is not null, then an ASCII # character, the comments string, and a line separator are first written to the output stream. Thus, the comments can serve as an identifying comment. Any one of a line feed ('\n'), a carriage return ('\r'), or a carriage return followed immediately by a line feed in comments is replaced by a line separator generated by the Writer and if the next character in comments is not character # or character ! then an ASCII # is written out after that line separator.  Next, a comment line is always written, consisting of an ASCII # character, the current date and time (as if produced by the toString method of Date for the current time), and a line separator as generated by the Writer.  Then every entry in this Properties table is written out, one per line. For each entry the key string is written, then an ASCII =, then the associated element string. For the key, all space characters are written with a preceding \ character. For the element, leading space characters, but not embedded or trailing space characters, are written with a preceding \ character. The key and element characters #, !, =, and : are written with a preceding backslash to ensure that they are properly loaded.  After the entries have been written, the output stream is flushed. The output stream remains open after this method returns. 
java.util.Properties.storeToXML	(	OutputStream	String	): Emits an XML document representing all of the properties contained in this table.  An invocation of this method of the form props.storeToXML(os, comment) behaves in exactly the same way as the invocation props.storeToXML(os, comment, "UTF-8");.
java.util.Properties.storeToXML	(	OutputStream	String	String	): Emits an XML document representing all of the properties contained in this table, using the specified encoding. The XML document will have the following DOCTYPE declaration:  <!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">  If the specified comment is null then no comment will be stored in the document.  An implementation is required to support writing of XML documents that use the "UTF-8" or "UTF-16" encoding. An implementation may support additional encodings. The specified stream remains open after this method returns.
java.util.Properties.stringPropertyNames	(	): Returns a set of keys in this property list where the key and its corresponding value are strings, including distinct keys in the default property list if a key of the same name has not already been found from the main properties list. Properties whose key or value is not of type String are omitted.  The returned set is not backed by the Properties object. Changes to this Properties are not reflected in the set, or vice versa.
java.util.Properties.toHex	(	int	): Convert a nibble to a hex character
java.util.PropertyPermission: This class is for property permissions.  The name is the name of the property ("java.home", "os.name", etc). The naming convention follows the hierarchical property naming convention. Also, an asterisk may appear at the end of the name, following a ".", or by itself, to signify a wildcard match. For example: "java.*" and "*" signify a wildcard match, while "*java" and "a*b" do not.  The actions to be granted are passed to the constructor in a string containing a list of one or more comma-separated keywords. The possible keywords are "read" and "write". Their meaning is defined as follows:   read  read permission. Allows System.getProperty to be called.  write  write permission. Allows System.setProperty to be called.   The actions string is converted to lowercase before processing.  Care should be taken before granting code permission to access certain system properties. For example, granting permission to access the "java.home" system property gives potentially malevolent code sensitive information about the system environment (the Java installation directory). Also, granting permission to access the "user.name" and "user.home" system properties gives potentially malevolent code sensitive information about the user environment (the user's account name and home directory).
java.util.PropertyPermission.PropertyPermission	(	String	String	): Creates a new PropertyPermission object with the specified name. The name is the name of the system property, and actions contains a comma-separated list of the desired actions granted on the property. Possible actions are "read" and "write".
java.util.PropertyPermission.equals	(	Object	): Checks two PropertyPermission objects for equality. Checks that obj is a PropertyPermission, and has the same name and actions as this object. 
java.util.PropertyPermission.getActions	(	): Returns the "canonical string representation" of the actions. That is, this method always returns present actions in the following order: read, write. For example, if this PropertyPermission object allows both write and read actions, a call to getActions will return the string "read,write".
java.util.PropertyPermission.getActions	(	int	): Return the canonical string representation of the actions. Always returns present actions in the following order: read, write.
java.util.PropertyPermission.getMask	(	): Return the current action mask. Used by the PropertyPermissionCollection
java.util.PropertyPermission.getMask	(	String	): Converts an actions String to an actions mask.
java.util.PropertyPermission.hashCode	(	): Returns the hash code value for this object. The hash code used is the hash code of this permissions name, that is, getName().hashCode(), where getName is from the Permission superclass.
java.util.PropertyPermission.implies	(	Permission	): Checks if this PropertyPermission object "implies" the specified permission.  More specifically, this method returns true if:   p is an instanceof PropertyPermission,  p's actions are a subset of this object's actions, and  p's name is implied by this object's name. For example, "java.*" implies "java.home". 
java.util.PropertyPermission.init	(	int	): initialize a PropertyPermission object. Common to all constructors. Also called during de-serialization.
java.util.PropertyPermission.newPermissionCollection	(	): Returns a new PermissionCollection object for storing PropertyPermission objects. 
java.util.PropertyPermission.readObject	(	java.io.ObjectInputStream	): readObject is called to restore the state of the PropertyPermission from a stream.
java.util.PropertyPermission.writeObject	(	java.io.ObjectOutputStream	): WriteObject is called to save the state of the PropertyPermission to a stream. The actions are serialized, and the superclass takes care of the name.
java.util.PropertyPermissionCollection: A PropertyPermissionCollection stores a set of PropertyPermission permissions.
java.util.PropertyPermissionCollection.PropertyPermissionCollection	(	): Create an empty PropertyPermissionCollection object.
java.util.PropertyPermissionCollection.add	(	Permission	): Adds a permission to the PropertyPermissions. The key for the hash is the name.
java.util.PropertyPermissionCollection.elements	(	): Returns an enumeration of all the PropertyPermission objects in the container.
java.util.PropertyPermissionCollection.implies	(	Permission	): Check and see if this set of permissions implies the permissions expressed in "permission".
java.util.PropertyPermissionCollection.writeObject	(	ObjectOutputStream	): 
java.util.PropertyResourceBundle: PropertyResourceBundle is a concrete subclass of ResourceBundle that manages resources for a locale using a set of static strings from a property file. See ResourceBundle ResourceBundle for more information about resource bundles.  Unlike other types of resource bundle, you don't subclass PropertyResourceBundle. Instead, you supply properties files containing the resource data. ResourceBundle.getBundle will automatically look for the appropriate properties file and create a PropertyResourceBundle that refers to it. See getBundle() ResourceBundle.getBundle for a complete description of the search and instantiation strategy.  The following example shows a member of a resource bundle family with the base name "MyResources". The text defines the bundle "MyResources_de", the German member of the bundle family. This member is based on PropertyResourceBundle, and the text therefore is the content of the file "MyResources_de.properties" (a related example shows how you can add bundles to this family that are implemented as subclasses of ListResourceBundle). The keys in this example are of the form "s1" etc. The actual keys are entirely up to your choice, so long as they are the same as the keys you use in your program to retrieve the objects from the bundle. Keys are case-sensitive.   # MessageFormat pattern s1=Die Platte \"{1}\" enthält {0}. # location of {0} in pattern s2=1 # sample disk name s3=Meine Platte # first ChoiceFormat choice s4=keine Dateien # second ChoiceFormat choice s5=eine Datei # third ChoiceFormat choice s6={0,number} Dateien # sample date s7=3. März 1996    The implementation of a PropertyResourceBundle subclass must be thread-safe if it's simultaneously used by multiple threads. The default implementations of the non-abstract methods in this class are thread-safe.  Note: PropertyResourceBundle can be constructed either from an InputStream or a Reader, which represents a property file. Constructing a PropertyResourceBundle instance from an InputStream requires that the input stream be encoded in ISO-8859-1. In that case, characters that cannot be represented in ISO-8859-1 encoding must be represented by Unicode Escapes as defined in section 3.3 of The Java Language Specification whereas the other constructor which takes a Reader does not have that limitation.
java.util.PropertyResourceBundle.PropertyResourceBundle	(	InputStream	): Creates a property resource bundle from an java.io.InputStream InputStream. The property file read with this constructor must be encoded in ISO-8859-1.
java.util.PropertyResourceBundle.PropertyResourceBundle	(	Reader	): Creates a property resource bundle from a java.io.Reader Reader. Unlike the constructor PropertyResourceBundle() PropertyResourceBundle(InputStream), there is no limitation as to the encoding of the input property file.
java.util.PropertyResourceBundle.getKeys	(	): Returns an Enumeration of the keys contained in this ResourceBundle and its parent bundles.
java.util.PropertyResourceBundle.handleKeySet	(	): Returns a Set of the keys contained only in this ResourceBundle.
java.util.Queue: A collection designed for holding elements prior to processing. Besides basic java.util.Collection Collection operations, queues provide additional insertion, extraction, and inspection operations. Each of these methods exists in two forms: one throws an exception if the operation fails, the other returns a special value (either null or false, depending on the operation). The latter form of the insert operation is designed specifically for use with capacity-restricted Queue implementations; in most implementations, insert operations cannot fail.  Summary of Queue methods   Throws exception Returns special value   Insert add add(e) offer offer(e)   Remove remove remove() poll poll()   Examine element element() peek peek()   Queues typically, but do not necessarily, order elements in a FIFO (first-in-first-out) manner. Among the exceptions are priority queues, which order elements according to a supplied comparator, or the elements' natural ordering, and LIFO queues (or stacks) which order the elements LIFO (last-in-first-out). Whatever the ordering used, the head of the queue is that element which would be removed by a call to remove() or poll(). In a FIFO queue, all new elements are inserted at the tail of the queue. Other kinds of queues may use different placement rules. Every Queue implementation must specify its ordering properties. The offer method inserts an element if possible, otherwise returning false. This differs from the add Collection.add method, which can fail to add an element only by throwing an unchecked exception. The offer method is designed for use when failure is a normal, rather than exceptional occurrence, for example, in fixed-capacity (or "bounded") queues. The remove() and poll() methods remove and return the head of the queue. Exactly which element is removed from the queue is a function of the queue's ordering policy, which differs from implementation to implementation. The remove() and poll() methods differ only in their behavior when the queue is empty: the remove() method throws an exception, while the poll() method returns null. The element() and peek() methods return, but do not remove, the head of the queue. The Queue interface does not define the blocking queue methods, which are common in concurrent programming. These methods, which wait for elements to appear or for space to become available, are defined in the java.util.concurrent.BlockingQueue interface, which extends this interface. Queue implementations generally do not allow insertion of null elements, although some implementations, such as LinkedList, do not prohibit insertion of null. Even in the implementations that permit it, null should not be inserted into a Queue, as null is also used as a special return value by the poll method to indicate that the queue contains no elements. Queue implementations generally do not define element-based versions of methods equals and hashCode but instead inherit the identity based versions from class Object, because element-based equality is not always well-defined for queues with the same elements but different ordering properties. This interface is a member of the  Java Collections Framework.
java.util.Queue.add	(	E	): Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an IllegalStateException if no space is currently available.
java.util.Queue.element	(	): Retrieves, but does not remove, the head of this queue. This method differs from peek only in that it throws an exception if this queue is empty.
java.util.Queue.offer	(	E	): Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions. When using a capacity-restricted queue, this method is generally preferable to add, which can fail to insert an element only by throwing an exception.
java.util.Queue.peek	(	): Retrieves, but does not remove, the head of this queue, or returns null if this queue is empty.
java.util.Queue.poll	(	): Retrieves and removes the head of this queue, or returns null if this queue is empty.
java.util.Queue.remove	(	): Retrieves and removes the head of this queue. This method differs from poll only in that it throws an exception if this queue is empty.
java.util.Random: An instance of this class is used to generate a stream of pseudorandom numbers. The class uses a 48-bit seed, which is modified using a linear congruential formula. (See Donald Knuth, The Art of Computer Programming, Volume 2, Section 3.2.1.)  If two instances of Random are created with the same seed, and the same sequence of method calls is made for each, they will generate and return identical sequences of numbers. In order to guarantee this property, particular algorithms are specified for the class Random. Java implementations must use all the algorithms shown here for the class Random, for the sake of absolute portability of Java code. However, subclasses of class Random are permitted to use other algorithms, so long as they adhere to the general contracts for all the methods.  The algorithms implemented by class Random use a protected utility method that on each invocation can supply up to 32 pseudorandomly generated bits.  Many applications will find the method random simpler to use. Instances of java.util.Random are threadsafe. However, the concurrent use of the same java.util.Random instance across threads may encounter contention and consequent poor performance. Consider instead using java.util.concurrent.ThreadLocalRandom in multithreaded designs. Instances of java.util.Random are not cryptographically secure. Consider instead using java.security.SecureRandom to get a cryptographically secure pseudo-random number generator for use by security-sensitive applications.
java.util.Random.Random	(	): Creates a new random number generator. This constructor sets the seed of the random number generator to a value very likely to be distinct from any other invocation of this constructor.
java.util.Random.Random	(	long	): Creates a new random number generator using a single long seed. The seed is the initial value of the internal state of the pseudorandom number generator which is maintained by method next. The invocation new Random(seed) is equivalent to:  Random rnd = new Random(); rnd.setSeed(seed);
java.util.Random.RandomDoublesSpliterator: Spliterator for double streams.
java.util.Random.RandomIntsSpliterator: Spliterator for int streams. We multiplex the four int versions into one class by treating a bound less than origin as unbounded, and also by treating "infinite" as equivalent to Long.MAX_VALUE. For splits, it uses the standard divide-by-two approach. The long and double versions of this class are identical except for types.
java.util.Random.RandomLongsSpliterator: Spliterator for long streams.
java.util.Random.doubles	(	): Returns an effectively unlimited stream of pseudorandom double values, each between zero (inclusive) and one (exclusive). A pseudorandom double value is generated as if it's the result of calling the method nextDouble().
java.util.Random.doubles	(	double	double	): Returns an effectively unlimited stream of pseudorandom double values, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom double value is generated as if it's the result of calling the following method with the origin and bound:  double nextDouble(double origin, double bound) double r = nextDouble(); r = r * (bound - origin) + origin; if (r >= bound) // correct for rounding r = Math.nextDown(bound); return r; }}
java.util.Random.doubles	(	long	): Returns a stream producing the given streamSize number of pseudorandom double values, each between zero (inclusive) and one (exclusive). A pseudorandom double value is generated as if it's the result of calling the method nextDouble().
java.util.Random.doubles	(	long	double	double	): Returns a stream producing the given streamSize number of pseudorandom double values, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom double value is generated as if it's the result of calling the following method with the origin and bound:  double nextDouble(double origin, double bound) double r = nextDouble(); r = r * (bound - origin) + origin; if (r >= bound) // correct for rounding r = Math.nextDown(bound); return r; }}
java.util.Random.internalNextDouble	(	double	double	): The form of nextDouble used by DoubleStream Spliterators.
java.util.Random.internalNextInt	(	int	int	): The form of nextInt used by IntStream Spliterators. For the unbounded case: uses nextInt(). For the bounded case with representable range: uses nextInt(int bound) For the bounded case with unrepresentable range: uses nextInt()
java.util.Random.internalNextLong	(	long	long	): The form of nextLong used by LongStream Spliterators. If origin is greater than bound, acts as unbounded form of nextLong, else as bounded form.
java.util.Random.ints	(	): Returns an effectively unlimited stream of pseudorandom int values. A pseudorandom int value is generated as if it's the result of calling the method nextInt().
java.util.Random.ints	(	int	int	): Returns an effectively unlimited stream of pseudorandom int values, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom int value is generated as if it's the result of calling the following method with the origin and bound:  int nextInt(int origin, int bound) int n = bound - origin; if (n > 0) { return nextInt(n) + origin; } else { // range not representable as int int r; do { r = nextInt(); } while (r < origin || r >= bound); return r; } }}
java.util.Random.ints	(	long	): Returns a stream producing the given streamSize number of pseudorandom int values. A pseudorandom int value is generated as if it's the result of calling the method nextInt().
java.util.Random.ints	(	long	int	int	): Returns a stream producing the given streamSize number of pseudorandom int values, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom int value is generated as if it's the result of calling the following method with the origin and bound:  int nextInt(int origin, int bound) int n = bound - origin; if (n > 0) { return nextInt(n) + origin; } else { // range not representable as int int r; do { r = nextInt(); } while (r < origin || r >= bound); return r; } }}
java.util.Random.longs	(	): Returns an effectively unlimited stream of pseudorandom long values. A pseudorandom long value is generated as if it's the result of calling the method nextLong().
java.util.Random.longs	(	long	): Returns a stream producing the given streamSize number of pseudorandom long values. A pseudorandom long value is generated as if it's the result of calling the method nextLong().
java.util.Random.longs	(	long	long	): Returns an effectively unlimited stream of pseudorandom long values, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom long value is generated as if it's the result of calling the following method with the origin and bound:  long nextLong(long origin, long bound) long r = nextLong(); long n = bound - origin, m = n - 1; if ((n & m) == 0L) // power of two r = (r & m) + origin; else if (n > 0L) { // reject over-represented candidates for (long u = r >>> 1; // ensure nonnegative u + m - (r = u % n) < 0L; // rejection check u = nextLong() >>> 1) // retry ; r += origin; } else { // range not representable as long while (r < origin || r >= bound) r = nextLong(); } return r; }}
java.util.Random.longs	(	long	long	long	): Returns a stream producing the given streamSize number of pseudorandom long, each conforming to the given origin (inclusive) and bound (exclusive). A pseudorandom long value is generated as if it's the result of calling the following method with the origin and bound:  long nextLong(long origin, long bound) long r = nextLong(); long n = bound - origin, m = n - 1; if ((n & m) == 0L) // power of two r = (r & m) + origin; else if (n > 0L) { // reject over-represented candidates for (long u = r >>> 1; // ensure nonnegative u + m - (r = u % n) < 0L; // rejection check u = nextLong() >>> 1) // retry ; r += origin; } else { // range not representable as long while (r < origin || r >= bound) r = nextLong(); } return r; }}
java.util.Random.next	(	int	): Generates the next pseudorandom number. Subclasses should override this, as this is used by all other methods. The general contract of next is that it returns an int value and if the argument bits is between 1 and 32 (inclusive), then that many low-order bits of the returned value will be (approximately) independently chosen bit values, each of which is (approximately) equally likely to be 0 or 1. The method next is implemented by class Random by atomically updating the seed to (seed * 0x5DEECE66DL + 0xBL) & ((1L << 48) - 1) and returning (int)(seed >>> (48 - bits)). This is a linear congruential pseudorandom number generator, as defined by D. H. Lehmer and described by Donald E. Knuth in The Art of Computer Programming, Volume 3: Seminumerical Algorithms, section 3.2.1.
java.util.Random.nextBoolean	(	): Returns the next pseudorandom, uniformly distributed boolean value from this random number generator's sequence. The general contract of nextBoolean is that one boolean value is pseudorandomly generated and returned. The values true and false are produced with (approximately) equal probability. The method nextBoolean is implemented by class Random as if by:  public boolean nextBoolean() return next(1) != 0; }}
java.util.Random.nextBytes	(	byte[]	): Generates random bytes and places them into a user-supplied byte array. The number of random bytes produced is equal to the length of the byte array. The method nextBytes is implemented by class Random as if by:  public void nextBytes(byte[] bytes) for (int i = 0; i < bytes.length; ) for (int rnd = nextInt(), n = Math.min(bytes.length - i, 4); n-- > 0; rnd >>= 8) bytes[i++] = (byte)rnd; }}
java.util.Random.nextDouble	(	): Returns the next pseudorandom, uniformly distributed double value between 0.0 and 1.0 from this random number generator's sequence. The general contract of nextDouble is that one double value, chosen (approximately) uniformly from the range 0.0d (inclusive) to 1.0d (exclusive), is pseudorandomly generated and returned. The method nextDouble is implemented by class Random as if by:  public double nextDouble() return (((long)next(26) << 27) + next(27)) / (double)(1L << 53); }} The hedge "approximately" is used in the foregoing description only because the next method is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm shown would choose double values from the stated range with perfect uniformity. [In early versions of Java, the result was incorrectly calculated as:  return (((long)next(27) << 27) + next(27)) / (double)(1L << 54); This might seem to be equivalent, if not better, but in fact it introduced a large nonuniformity because of the bias in the rounding of floating-point numbers: it was three times as likely that the low-order bit of the significand would be 0 than that it would be 1! This nonuniformity probably doesn't matter much in practice, but we strive for perfection.]
java.util.Random.nextFloat	(	): Returns the next pseudorandom, uniformly distributed float value between 0.0 and 1.0 from this random number generator's sequence. The general contract of nextFloat is that one float value, chosen (approximately) uniformly from the range 0.0f (inclusive) to 1.0f (exclusive), is pseudorandomly generated and returned. All 224 possible float values of the form m x 2-24, where m is a positive integer less than 224, are produced with (approximately) equal probability. The method nextFloat is implemented by class Random as if by:  public float nextFloat() return next(24) / ((float)(1 << 24)); }} The hedge "approximately" is used in the foregoing description only because the next method is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm shown would choose float values from the stated range with perfect uniformity. [In early versions of Java, the result was incorrectly calculated as:  return next(30) / ((float)(1 << 30)); This might seem to be equivalent, if not better, but in fact it introduced a slight nonuniformity because of the bias in the rounding of floating-point numbers: it was slightly more likely that the low-order bit of the significand would be 0 than that it would be 1.]
java.util.Random.nextGaussian	(	): Returns the next pseudorandom, Gaussian ("normally") distributed double value with mean 0.0 and standard deviation 1.0 from this random number generator's sequence.  The general contract of nextGaussian is that one double value, chosen from (approximately) the usual normal distribution with mean 0.0 and standard deviation 1.0, is pseudorandomly generated and returned. The method nextGaussian is implemented by class Random as if by a threadsafe version of the following:  private double nextNextGaussian; private boolean haveNextNextGaussian = false; public double nextGaussian() if (haveNextNextGaussian) { haveNextNextGaussian = false; return nextNextGaussian; } else { double v1, v2, s; do { v1 = 2 * nextDouble() - 1; // between -1.0 and 1.0 v2 = 2 * nextDouble() - 1; // between -1.0 and 1.0 s = v1 * v1 + v2 * v2; } while (s >= 1 || s == 0); double multiplier = StrictMath.sqrt(-2 * StrictMath.log(s)/s); nextNextGaussian = v2 * multiplier; haveNextNextGaussian = true; return v1 * multiplier; } }} This uses the polar method of G. E. P. Box, M. E. Muller, and G. Marsaglia, as described by Donald E. Knuth in The Art of Computer Programming, Volume 3: Seminumerical Algorithms, section 3.4.1, subsection C, algorithm P. Note that it generates two independent values at the cost of only one call to StrictMath.log and one call to StrictMath.sqrt.
java.util.Random.nextInt	(	): Returns the next pseudorandom, uniformly distributed int value from this random number generator's sequence. The general contract of nextInt is that one int value is pseudorandomly generated and returned. All 232 possible int values are produced with (approximately) equal probability. The method nextInt is implemented by class Random as if by:  public int nextInt() return next(32); }}
java.util.Random.nextInt	(	int	): Returns a pseudorandom, uniformly distributed int value between 0 (inclusive) and the specified value (exclusive), drawn from this random number generator's sequence. The general contract of nextInt is that one int value in the specified range is pseudorandomly generated and returned. All bound possible int values are produced with (approximately) equal probability. The method nextInt(int bound) is implemented by class Random as if by:  public int nextInt(int bound) if (bound <= 0) throw new IllegalArgumentException("bound must be positive"); if ((bound & -bound) == bound) // i.e., bound is a power of 2 return (int)((bound * (long)next(31)) >> 31); int bits, val; do { bits = next(31); val = bits % bound; } while (bits - val + (bound-1) < 0); return val; }} The hedge "approximately" is used in the foregoing description only because the next method is only approximately an unbiased source of independently chosen bits. If it were a perfect source of randomly chosen bits, then the algorithm shown would choose int values from the stated range with perfect uniformity.  The algorithm is slightly tricky. It rejects values that would result in an uneven distribution (due to the fact that 2^31 is not divisible by n). The probability of a value being rejected depends on n. The worst case is n=2^30+1, for which the probability of a reject is 1/2, and the expected number of iterations before the loop terminates is 2.  The algorithm treats the case where n is a power of two specially: it returns the correct number of high-order bits from the underlying pseudo-random number generator. In the absence of special treatment, the correct number of low-order bits would be returned. Linear congruential pseudo-random number generators such as the one implemented by this class are known to have short periods in the sequence of values of their low-order bits. Thus, this special case greatly increases the length of the sequence of values returned by successive calls to this method if n is a small power of two.
java.util.Random.nextLong	(	): Returns the next pseudorandom, uniformly distributed long value from this random number generator's sequence. The general contract of nextLong is that one long value is pseudorandomly generated and returned. The method nextLong is implemented by class Random as if by:  public long nextLong() return ((long)next(32) << 32) + next(32); }} Because class Random uses a seed with only 48 bits, this algorithm will not return all possible long values.
java.util.Random.readObject	(	java.io.ObjectInputStream	): Reconstitute the Random instance from a stream (that is, deserialize it).
java.util.Random.setSeed	(	long	): Sets the seed of this random number generator using a single long seed. The general contract of setSeed is that it alters the state of this random number generator object so as to be in exactly the same state as if it had just been created with the argument seed as a seed. The method setSeed is implemented by class Random by atomically updating the seed to (seed ^ 0x5DEECE66DL) & ((1L << 48) - 1) and clearing the haveNextNextGaussian flag used by nextGaussian. The implementation of setSeed by class Random happens to use only 48 bits of the given seed. In general, however, an overriding method may use all 64 bits of the long argument as a seed value.
java.util.Random.writeObject	(	ObjectOutputStream	): Save the Random instance to a stream.
java.util.RandomAccess: Marker interface used by List implementations to indicate that they support fast (generally constant time) random access. The primary purpose of this interface is to allow generic algorithms to alter their behavior to provide good performance when applied to either random or sequential access lists. The best algorithms for manipulating random access lists (such as ArrayList) can produce quadratic behavior when applied to sequential access lists (such as LinkedList). Generic list algorithms are encouraged to check whether the given list is an instanceof this interface before applying an algorithm that would provide poor performance if it were applied to a sequential access list, and to alter their behavior if necessary to guarantee acceptable performance. It is recognized that the distinction between random and sequential access is often fuzzy. For example, some List implementations provide asymptotically linear access times if they get huge, but constant access times in practice. Such a List implementation should generally implement this interface. As a rule of thumb, a List implementation should implement this interface if, for typical instances of the class, this loop:  for (int i=0, n=list.size(); i < n; i++) list.get(i);  runs faster than this loop:  for (Iterator i=list.iterator(); i.hasNext(); ) i.next();  This interface is a member of the  Java Collections Framework.
java.util.RegularEnumSet: Private implementation class for EnumSet, for "regular sized" enum types (i.e., those with 64 or fewer enum constants).
java.util.RegularEnumSet.add	(	E	): Adds the specified element to this set if it is not already present.
java.util.RegularEnumSet.addAll	(	Collection	): Adds all of the elements in the specified collection to this set.
java.util.RegularEnumSet.clear	(	): Removes all of the elements from this set.
java.util.RegularEnumSet.contains	(	Object	): Returns true if this set contains the specified element.
java.util.RegularEnumSet.containsAll	(	Collection	): Returns true if this set contains all of the elements in the specified collection.
java.util.RegularEnumSet.equals	(	Object	): Compares the specified object with this set for equality. Returns true if the given object is also a set, the two sets have the same size, and every member of the given set is contained in this set.
java.util.RegularEnumSet.isEmpty	(	): Returns true if this set contains no elements.
java.util.RegularEnumSet.iterator	(	): Returns an iterator over the elements contained in this set. The iterator traverses the elements in their natural order (which is the order in which the enum constants are declared). The returned Iterator is a "snapshot" iterator that will never throw ConcurrentModificationException; the elements are traversed as they existed when this call was invoked.
java.util.RegularEnumSet.remove	(	Object	): Removes the specified element from this set if it is present.
java.util.RegularEnumSet.removeAll	(	Collection	): Removes from this set all of its elements that are contained in the specified collection.
java.util.RegularEnumSet.retainAll	(	Collection	): Retains only the elements in this set that are contained in the specified collection.
java.util.RegularEnumSet.size	(	): Returns the number of elements in this set.
java.util.ResourceBundle: Resource bundles contain locale-specific objects. When your program needs a locale-specific resource, a String for example, your program can load it from the resource bundle that is appropriate for the current user's locale. In this way, you can write program code that is largely independent of the user's locale isolating most, if not all, of the locale-specific information in resource bundles.  This allows you to write programs that can:   be easily localized, or translated, into different languages  handle multiple locales at once  be easily modified later to support even more locales   Resource bundles belong to families whose members share a common base name, but whose names also have additional components that identify their locales. For example, the base name of a family of resource bundles might be "MyResources". The family should have a default resource bundle which simply has the same name as its family - "MyResources" - and will be used as the bundle of last resort if a specific locale is not supported. The family can then provide as many locale-specific members as needed, for example a German one named "MyResources_de".  Each resource bundle in a family contains the same items, but the items have been translated for the locale represented by that resource bundle. For example, both "MyResources" and "MyResources_de" may have a String that's used on a button for canceling operations. In "MyResources" the String may contain "Cancel" and in "MyResources_de" it may contain "Abbrechen".  If there are different resources for different countries, you can make specializations: for example, "MyResources_de_CH" contains objects for the German language (de) in Switzerland (CH). If you want to only modify some of the resources in the specialization, you can do so.  When your program needs a locale-specific object, it loads the ResourceBundle class using the getBundle() method:   ResourceBundle myResources = ResourceBundle.getBundle("MyResources", currentLocale);    Resource bundles contain key/value pairs. The keys uniquely identify a locale-specific object in the bundle. Here's an example of a ListResourceBundle that contains two key/value pairs:   public class MyResources extends ListResourceBundle { protected Object[][] getContents() { return new Object[][] { // LOCALIZE THE SECOND STRING OF EACH ARRAY (e.g., "OK") {"OkKey", "OK"}, {"CancelKey", "Cancel"}, // END OF MATERIAL TO LOCALIZE }; } }   Keys are always Strings. In this example, the keys are "OkKey" and "CancelKey". In the above example, the values are also Strings--"OK" and "Cancel"--but they don't have to be. The values can be any type of object.  You retrieve an object from resource bundle using the appropriate getter method. Because "OkKey" and "CancelKey" are both strings, you would use getString to retrieve them:   button1 = new Button(myResources.getString("OkKey")); button2 = new Button(myResources.getString("CancelKey"));   The getter methods all require the key as an argument and return the object if found. If the object is not found, the getter method throws a MissingResourceException.  Besides getString, ResourceBundle also provides a method for getting string arrays, getStringArray, as well as a generic getObject method for any other type of object. When using getObject, you'll have to cast the result to the appropriate type. For example:   int[] myIntegers = (int[]) myResources.getObject("intList");    The Java Platform provides two subclasses of ResourceBundle, ListResourceBundle and PropertyResourceBundle, that provide a fairly simple way to create resources. As you saw briefly in a previous example, ListResourceBundle manages its resource as a list of key/value pairs. PropertyResourceBundle uses a properties file to manage its resources.  If ListResourceBundle or PropertyResourceBundle do not suit your needs, you can write your own ResourceBundle subclass. Your subclasses must override two methods: handleGetObject and getKeys().  The implementation of a ResourceBundle subclass must be thread-safe if it's simultaneously used by multiple threads. The default implementations of the non-abstract methods in this class, and the methods in the direct known concrete subclasses ListResourceBundle and PropertyResourceBundle are thread-safe. ResourceBundle.Control The ResourceBundle.Control class provides information necessary to perform the bundle loading process by the getBundle factory methods that take a ResourceBundle.Control instance. You can implement your own subclass in order to enable non-standard resource bundle formats, change the search strategy, or define caching parameters. Refer to the descriptions of the class and the getBundle() factory method for details. For the getBundle factory methods that take no Control instance, their  default behavior of resource bundle loading can be modified with installed ResourceBundleControlProvider implementations. Any installed providers are detected at the ResourceBundle class loading time. If any of the providers provides a Control for the given base name, that Control will be used instead of the default Control. If there is more than one service provider installed for supporting the same base name, the first one returned from ServiceLoader will be used. Cache Management Resource bundle instances created by the getBundle factory methods are cached by default, and the factory methods return the same resource bundle instance multiple times if it has been cached. getBundle clients may clear the cache, manage the lifetime of cached resource bundle instances using time-to-live values, or specify not to cache resource bundle instances. Refer to the descriptions of the getBundle() getBundle factory method, clearCache(), getTimeToLive() ResourceBundle.Control.getTimeToLive, and needsReload() ResourceBundle.Control.needsReload for details. Example The following is a very simple example of a ResourceBundle subclass, MyResources, that manages two resources (for a larger number of resources you would probably use a Map). Notice that you don't need to supply a value if a "parent-level" ResourceBundle handles the same key with the same value (as for the okKey below).   // default (English language, United States) public class MyResources extends ResourceBundle { public Object handleGetObject(String key) { if (key.equals("okKey")) return "Ok"; if (key.equals("cancelKey")) return "Cancel"; return null; } public Enumeration<String> getKeys() { return Collections.enumeration(keySet()); } // Overrides handleKeySet() so that the getKeys() implementation // can rely on the keySet() value. protected Set<String> handleKeySet() { return new HashSet<String>(Arrays.asList("okKey", "cancelKey")); } } // German language public class MyResources_de extends MyResources { public Object handleGetObject(String key) { // don't need okKey, since parent level handles it. if (key.equals("cancelKey")) return "Abbrechen"; return null; } protected Set<String> handleKeySet() { return new HashSet<String>(Arrays.asList("cancelKey")); } }   You do not have to restrict yourself to using a single family of ResourceBundles. For example, you could have a set of bundles for exception messages, ExceptionResources (ExceptionResources_fr, ExceptionResources_de, ...), and one for widgets, WidgetResource (WidgetResources_fr, WidgetResources_de, ...); breaking up the resources however you like.
java.util.ResourceBundle.BundleReference: References to bundles are soft references so that they can be garbage collected when they have no hard references.
java.util.ResourceBundle.CacheKey: Key used for cached resource bundles. The key checks the base name, the locale, and the class loader to determine if the resource is a match to the requested one. The loader may be null, but the base name and the locale must have a non-null value.
java.util.ResourceBundle.CacheKeyReference: The common interface to get a CacheKey in LoaderReference and BundleReference.
java.util.ResourceBundle.Control: ResourceBundle.Control defines a set of callback methods that are invoked by the getBundle() ResourceBundle.getBundle factory methods during the bundle loading process. In other words, a ResourceBundle.Control collaborates with the factory methods for loading resource bundles. The default implementation of the callback methods provides the information necessary for the factory methods to perform the default behavior. In addition to the callback methods, the toBundleName() and toResourceName() methods are defined primarily for convenience in implementing the callback methods. However, the toBundleName method could be overridden to provide different conventions in the organization and packaging of localized resources. The toResourceName method is final to avoid use of wrong resource and class name separators. Two factory methods, getControl() and getNoFallbackControl(), provide ResourceBundle.Control instances that implement common variations of the default bundle loading process. The formats returned by the getFormats() method and candidate locales returned by the getCandidateLocales() method must be consistent in all ResourceBundle.getBundle invocations for the same base bundle. Otherwise, the ResourceBundle.getBundle methods may return unintended bundles. For example, if only "java.class" is returned by the getFormats method for the first call to ResourceBundle.getBundle and only "java.properties" for the second call, then the second call will return the class-based one that has been cached during the first call. A ResourceBundle.Control instance must be thread-safe if it's simultaneously used by multiple threads. ResourceBundle.getBundle does not synchronize to call the ResourceBundle.Control methods. The default implementations of the methods are thread-safe. Applications can specify ResourceBundle.Control instances returned by the getControl factory methods or created from a subclass of ResourceBundle.Control to customize the bundle loading process. The following are examples of changing the default bundle loading process. Example 1 The following code lets ResourceBundle.getBundle look up only properties-based resources.  import java.util.*; import static java.util.ResourceBundle.Control.*; ... ResourceBundle bundle = ResourceBundle.getBundle("MyResources", new Locale("fr", "CH"), ResourceBundle.Control.getControl(FORMAT_PROPERTIES));  Given the resource bundles in the example in the ResourceBundle.getBundle description, this ResourceBundle.getBundle call loads MyResources_fr_CH.properties whose parent is MyResources_fr.properties whose parent is MyResources.properties. (MyResources_fr_CH.properties is not hidden, but MyResources_fr_CH.class is.) Example 2 The following is an example of loading XML-based bundles using loadFromXML() Properties.loadFromXML.  ResourceBundle rb = ResourceBundle.getBundle("Messages", new ResourceBundle.Control() { public List<String> getFormats(String baseName) { if (baseName == null) throw new NullPointerException(); return Arrays.asList("xml"); } public ResourceBundle newBundle(String baseName, Locale locale, String format, ClassLoader loader, boolean reload) throws IllegalAccessException, InstantiationException, IOException { if (baseName == null || locale == null || format == null || loader == null) throw new NullPointerException(); ResourceBundle bundle = null; if (format.equals("xml")) { String bundleName = toBundleName(baseName, locale); String resourceName = toResourceName(bundleName, format); InputStream stream = null; if (reload) { URL url = loader.getResource(resourceName); if (url != null) { URLConnection connection = url.openConnection(); if (connection != null) { // Disable caches to get fresh data for // reloading. connection.setUseCaches(false); stream = connection.getInputStream(); } } } else { stream = loader.getResourceAsStream(resourceName); } if (stream != null) { BufferedInputStream bis = new BufferedInputStream(stream); bundle = new XMLResourceBundle(bis); bis.close(); } } return bundle; } }); ... private static class XMLResourceBundle extends ResourceBundle { private Properties props; XMLResourceBundle(InputStream stream) throws IOException { props = new Properties(); props.loadFromXML(stream); } protected Object handleGetObject(String key) { return props.getProperty(key); } public Enumeration<String> getKeys() { ... } } 
java.util.ResourceBundle.Control.Control	(	): Sole constructor. (For invocation by subclass constructors, typically implicit.)
java.util.ResourceBundle.Control.getCandidateLocales	(	String	Locale	): Returns a List of Locales as candidate locales for baseName and locale. This method is called by the ResourceBundle.getBundle factory method each time the factory method tries finding a resource bundle for a target Locale. The sequence of the candidate locales also corresponds to the runtime resource lookup path (also known as the parent chain), if the corresponding resource bundles for the candidate locales exist and their parents are not defined by loaded resource bundles themselves. The last element of the list must be a ROOT root locale if it is desired to have the base bundle as the terminal of the parent chain. If the given locale is equal to Locale.ROOT (the root locale), a List containing only the root Locale must be returned. In this case, the ResourceBundle.getBundle factory method loads only the base bundle as the resulting resource bundle. It is not a requirement to return an immutable (unmodifiable) List. However, the returned List must not be mutated after it has been returned by getCandidateLocales. The default implementation returns a List containing Locales using the rules described below. In the description below, L, S, C and V respectively represent non-empty language, script, country, and variant. For example, [L, C] represents a Locale that has non-empty values only for language and country. The form L("xx") represents the (non-empty) language value is "xx". For all cases, Locales whose final component values are empty strings are omitted. For an input Locale with an empty script value, append candidate Locales by omitting the final component one by one as below:   [L, C, V]   [L, C]   [L]   Locale.ROOT   For an input Locale with a non-empty script value, append candidate Locales by omitting the final component up to language, then append candidates generated from the Locale with country and variant restored:   [L, S, C, V]  [L, S, C]  [L, S]  [L, C, V]  [L, C]  [L]  Locale.ROOT  For an input Locale with a variant value consisting of multiple subtags separated by underscore, generate candidate Locales by omitting the variant subtags one by one, then insert them after every occurrence of  Locales with the full variant value in the original list. For example, if the the variant consists of two subtags V1 and V2:   [L, S, C, V1, V2]  [L, S, C, V1]  [L, S, C]  [L, S]  [L, C, V1, V2]  [L, C, V1]  [L, C]  [L]  Locale.ROOT  Special cases for Chinese. When an input Locale has the language "zh" (Chinese) and an empty script value, either "Hans" (Simplified) or "Hant" (Traditional) might be supplied, depending on the country. When the country is "CN" (China) or "SG" (Singapore), "Hans" is supplied. When the country is "HK" (Hong Kong SAR China), "MO" (Macau SAR China), or "TW" (Taiwan), "Hant" is supplied. For all other countries or when the country is empty, no script is supplied. For example, for Locale("zh", "CN") , the candidate list will be:   [L("zh"), S("Hans"), C("CN")]  [L("zh"), S("Hans")]  [L("zh"), C("CN")]  [L("zh")]  Locale.ROOT  For Locale("zh", "TW"), the candidate list will be:   [L("zh"), S("Hant"), C("TW")]  [L("zh"), S("Hant")]  [L("zh"), C("TW")]  [L("zh")]  Locale.ROOT  Special cases for Norwegian. Both Locale("no", "NO", "NY") and Locale("nn", "NO") represent Norwegian Nynorsk. When a locale's language is "nn", the standard candidate list is generated up to [L("nn")], and then the following candidates are added:  [L("no"), C("NO"), V("NY")]  [L("no"), C("NO")]  [L("no")]  Locale.ROOT  If the locale is exactly Locale("no", "NO", "NY"), it is first converted to Locale("nn", "NO") and then the above procedure is followed. Also, Java treats the language "no" as a synonym of Norwegian Bokmål "nb". Except for the single case Locale("no", "NO", "NY") (handled above), when an input Locale has language "no" or "nb", candidate Locales with language code "no" and "nb" are interleaved, first using the requested language, then using its synonym. For example, Locale("nb", "NO", "POSIX") generates the following candidate list:   [L("nb"), C("NO"), V("POSIX")]  [L("no"), C("NO"), V("POSIX")]  [L("nb"), C("NO")]  [L("no"), C("NO")]  [L("nb")]  [L("no")]  Locale.ROOT  Locale("no", "NO", "POSIX") would generate the same list except that locales with "no" would appear before the corresponding locales with "nb".  The default implementation uses an ArrayList that overriding implementations may modify before returning it to the caller. However, a subclass must not modify it after it has been returned by getCandidateLocales. For example, if the given baseName is "Messages" and the given locale is Locale("ja", "", "XX"), then a List of Locales:  Locale("ja", "", "XX") Locale("ja") Locale.ROOT  is returned. And if the resource bundles for the "ja" and "" Locales are found, then the runtime resource lookup path (parent chain) is: Messages_ja -> Messages
java.util.ResourceBundle.Control.getControl	(	List	): Returns a ResourceBundle.Control in which the getFormats() method returns the specified formats. The formats must be equal to one of FORMAT_PROPERTIES, FORMAT_CLASS or FORMAT_DEFAULT. ResourceBundle.Control instances returned by this method are singletons and thread-safe. Specifying FORMAT_DEFAULT is equivalent to instantiating the ResourceBundle.Control class, except that this method returns a singleton.
java.util.ResourceBundle.Control.getFallbackLocale	(	String	Locale	): Returns a Locale to be used as a fallback locale for further resource bundle searches by the ResourceBundle.getBundle factory method. This method is called from the factory method every time when no resulting resource bundle has been found for baseName and locale, where locale is either the parameter for ResourceBundle.getBundle or the previous fallback locale returned by this method. The method returns null if no further fallback search is desired. The default implementation returns the getDefault() default Locale if the given locale isn't the default one. Otherwise, null is returned.
java.util.ResourceBundle.Control.getFormats	(	String	): Returns a List of Strings containing formats to be used to load resource bundles for the given baseName. The ResourceBundle.getBundle factory method tries to load resource bundles with formats in the order specified by the list. The list returned by this method must have at least one String. The predefined formats are "java.class" for class-based resource bundles and "java.properties" for PropertyResourceBundle properties-based ones. Strings starting with "java." are reserved for future extensions and must not be used by application-defined formats. It is not a requirement to return an immutable (unmodifiable) List. However, the returned List must not be mutated after it has been returned by getFormats. The default implementation returns FORMAT_DEFAULT so that the ResourceBundle.getBundle factory method looks up first class-based resource bundles, then properties-based ones.
java.util.ResourceBundle.Control.getNoFallbackControl	(	List	): Returns a ResourceBundle.Control in which the getFormats() method returns the specified formats and the getFallbackLocale() method returns null. The formats must be equal to one of FORMAT_PROPERTIES, FORMAT_CLASS or FORMAT_DEFAULT. ResourceBundle.Control instances returned by this method are singletons and thread-safe.
java.util.ResourceBundle.Control.getTimeToLive	(	String	Locale	): Returns the time-to-live (TTL) value for resource bundles that are loaded under this ResourceBundle.Control. Positive time-to-live values specify the number of milliseconds a bundle can remain in the cache without being validated against the source data from which it was constructed. The value 0 indicates that a bundle must be validated each time it is retrieved from the cache. TTL_DONT_CACHE specifies that loaded resource bundles are not put in the cache. TTL_NO_EXPIRATION_CONTROL specifies that loaded resource bundles are put in the cache with no expiration control. The expiration affects only the bundle loading process by the ResourceBundle.getBundle factory method. That is, if the factory method finds a resource bundle in the cache that has expired, the factory method calls the needsReload() method to determine whether the resource bundle needs to be reloaded. If needsReload returns true, the cached resource bundle instance is removed from the cache. Otherwise, the instance stays in the cache, updated with the new TTL value returned by this method. All cached resource bundles are subject to removal from the cache due to memory constraints of the runtime environment. Returning a large positive value doesn't mean to lock loaded resource bundles in the cache. The default implementation returns TTL_NO_EXPIRATION_CONTROL.
java.util.ResourceBundle.Control.needsReload	(	String	Locale	String	ClassLoader	ResourceBundle	long	): Determines if the expired bundle in the cache needs to be reloaded based on the loading time given by loadTime or some other criteria. The method returns true if reloading is required; false otherwise. loadTime is a millisecond offset since the  Calendar Epoch. The calling ResourceBundle.getBundle factory method calls this method on the ResourceBundle.Control instance used for its current invocation, not on the instance used in the invocation that originally loaded the resource bundle. The default implementation compares loadTime and the last modified time of the source data of the resource bundle. If it's determined that the source data has been modified since loadTime, true is returned. Otherwise, false is returned. This implementation assumes that the given format is the same string as its file suffix if it's not one of the default formats, "java.class" or "java.properties".
java.util.ResourceBundle.Control.newBundle	(	String	Locale	String	ClassLoader	boolean	): Instantiates a resource bundle for the given bundle name of the given format and locale, using the given class loader if necessary. This method returns null if there is no resource bundle available for the given parameters. If a resource bundle can't be instantiated due to an unexpected error, the error must be reported by throwing an Error or Exception rather than simply returning null. If the reload flag is true, it indicates that this method is being called because the previously loaded resource bundle has expired. The default implementation instantiates a ResourceBundle as follows.  The bundle name is obtained by calling toBundleName() toBundleName(baseName, locale). If format is "java.class", the Class specified by the bundle name is loaded by calling loadClass(). Then, a ResourceBundle is instantiated by calling newInstance(). Note that the reload flag is ignored for loading class-based resource bundles in this default implementation. If format is "java.properties", toResourceName() toResourceName(bundlename, "properties") is called to get the resource name. If reload is true, getResource() load.getResource is called to get a URL for creating a URLConnection. This URLConnection is used to setUseCaches() disable the caches of the underlying resource loading layers, and to getInputStream() get an InputStream. Otherwise, getResourceAsStream() loader.getResourceAsStream is called to get an InputStream. Then, a PropertyResourceBundle is constructed with the InputStream. If format is neither "java.class" nor "java.properties", an IllegalArgumentException is thrown. 
java.util.ResourceBundle.Control.toBundleName	(	String	Locale	): Converts the given baseName and locale to the bundle name. This method is called from the default implementation of the newBundle() and needsReload() methods. This implementation returns the following value:  baseName + "_" + language + "_" + script + "_" + country + "_" + variant  where language, script, country, and variant are the language, script, country, and variant values of locale, respectively. Final component values that are empty Strings are omitted along with the preceding '_'. When the script is empty, the script value is omitted along with the preceding '_'. If all of the values are empty strings, then baseName is returned. For example, if baseName is "baseName" and locale is Locale("ja", "", "XX"), then "baseName_ja_?_XX" is returned. If the given locale is Locale("en"), then "baseName_en" is returned. Overriding this method allows applications to use different conventions in the organization and packaging of localized resources.
java.util.ResourceBundle.Control.toResourceName	(	String	String	): Converts the given bundleName to the form required by the getResource ClassLoader.getResource method by replacing all occurrences of '.' in bundleName with '/' and appending a '.' and the given file suffix. For example, if bundleName is "foo.bar.MyResources_ja_JP" and suffix is "properties", then "foo/bar/MyResources_ja_JP.properties" is returned.
java.util.ResourceBundle.LoaderReference: References to class loaders are weak references, so that they can be garbage collected when nobody else is using them. The ResourceBundle class has no reason to keep class loaders alive.
java.util.ResourceBundle.RBClassLoader: A wrapper of ClassLoader.getSystemClassLoader().
java.util.ResourceBundle.ResourceBundle	(	): Sole constructor. (For invocation by subclass constructors, typically implicit.)
java.util.ResourceBundle.checkList	(	List	): Checks if the given List is not null, not empty, not having null in its elements.
java.util.ResourceBundle.clearCache	(	): Removes all resource bundles from the cache that have been loaded using the caller's class loader.
java.util.ResourceBundle.clearCache	(	ClassLoader	): Removes all resource bundles from the cache that have been loaded using the given class loader.
java.util.ResourceBundle.containsKey	(	String	): Determines whether the given key is contained in this ResourceBundle or its parent bundles.
java.util.ResourceBundle.findBundleInCache	(	CacheKey	Control	): Finds a bundle in the cache. Any expired bundles are marked as `expired' and removed from the cache upon return.
java.util.ResourceBundle.getBaseBundleName	(	): Returns the base name of this bundle, if known, or null if unknown. If not null, then this is the value of the baseName parameter that was passed to the ResourceBundle.getBundle(...) method when the resource bundle was loaded.
java.util.ResourceBundle.getBundle	(	String	): Gets a resource bundle using the specified base name, the default locale, and the caller's class loader. Calling this method is equivalent to calling  getBundle(baseName, Locale.getDefault(), this.getClass().getClassLoader()),  except that getClassLoader() is run with the security privileges of ResourceBundle. See getBundle() for a complete description of the search and instantiation strategy.
java.util.ResourceBundle.getBundle	(	String	Control	): Returns a resource bundle using the specified base name, the default locale and the specified control. Calling this method is equivalent to calling  getBundle(baseName, Locale.getDefault(), this.getClass().getClassLoader(), control),  except that getClassLoader() is run with the security privileges of ResourceBundle. See getBundle() for the complete description of the resource bundle loading process with a ResourceBundle.Control.
java.util.ResourceBundle.getBundle	(	String	Locale	): Gets a resource bundle using the specified base name and locale, and the caller's class loader. Calling this method is equivalent to calling  getBundle(baseName, locale, this.getClass().getClassLoader()),  except that getClassLoader() is run with the security privileges of ResourceBundle. See getBundle() for a complete description of the search and instantiation strategy.
java.util.ResourceBundle.getBundle	(	String	Locale	ClassLoader	): Gets a resource bundle using the specified base name, locale, and class loader. This method behaves the same as calling getBundle() passing a default instance of Control unless another Control is provided with the ResourceBundleControlProvider SPI. Refer to the description of modifying the default behavior. The following describes the default behavior. getBundle uses the base name, the specified locale, and the default locale (obtained from getDefault() Locale.getDefault) to generate a sequence of candidate bundle names. If the specified locale's language, script, country, and variant are all empty strings, then the base name is the only candidate bundle name. Otherwise, a list of candidate locales is generated from the attribute values of the specified locale (language, script, country and variant) and appended to the base name. Typically, this will look like the following:  baseName + "_" + language + "_" + script + "_" + country + "_" + variant baseName + "_" + language + "_" + script + "_" + country baseName + "_" + language + "_" + script baseName + "_" + language + "_" + country + "_" + variant baseName + "_" + language + "_" + country baseName + "_" + language  Candidate bundle names where the final component is an empty string are omitted, along with the underscore. For example, if country is an empty string, the second and the fifth candidate bundle names above would be omitted. Also, if script is an empty string, the candidate names including script are omitted. For example, a locale with language "de" and variant "JAVA" will produce candidate names with base name "MyResource" below.  MyResource_de__JAVA MyResource_de  In the case that the variant contains one or more underscores ('_'), a sequence of bundle names generated by truncating the last underscore and the part following it is inserted after a candidate bundle name with the original variant. For example, for a locale with language "en", script "Latn, country "US" and variant "WINDOWS_VISTA", and bundle base name "MyResource", the list of candidate bundle names below is generated:  MyResource_en_Latn_US_WINDOWS_VISTA MyResource_en_Latn_US_WINDOWS MyResource_en_Latn_US MyResource_en_Latn MyResource_en_US_WINDOWS_VISTA MyResource_en_US_WINDOWS MyResource_en_US MyResource_en  Note: For some Locales, the list of candidate bundle names contains extra names, or the order of bundle names is slightly modified. See the description of the default implementation of getCandidateLocales() for details. getBundle then iterates over the candidate bundle names to find the first one for which it can instantiate an actual resource bundle. It uses the default controls' getFormats method, which generates two bundle names for each generated name, the first a class name and the second a properties file name. For each candidate bundle name, it attempts to create a resource bundle: First, it attempts to load a class using the generated class name. If such a class can be found and loaded using the specified class loader, is assignment compatible with ResourceBundle, is accessible from ResourceBundle, and can be instantiated, getBundle creates a new instance of this class and uses it as the result resource bundle. Otherwise, getBundle attempts to locate a property resource file using the generated properties file name. It generates a path name from the candidate bundle name by replacing all "." characters with "/" and appending the string ".properties". It attempts to find a "resource" with this name using getResource() ClassLoader.getResource. (Note that a "resource" in the sense of getResource has nothing to do with the contents of a resource bundle, it is just a container of data, such as a file.) If it finds a "resource", it attempts to create a new PropertyResourceBundle instance from its contents. If successful, this instance becomes the result resource bundle.  This continues until a result resource bundle is instantiated or the list of candidate bundle names is exhausted. If no matching resource bundle is found, the default control's getFallbackLocale method is called, which returns the current default locale. A new sequence of candidate locale names is generated using this locale and and searched again, as above. If still no result bundle is found, the base name alone is looked up. If this still fails, a MissingResourceException is thrown.  Once a result resource bundle has been found, its parent chain is instantiated. If the result bundle already has a parent (perhaps because it was returned from a cache) the chain is complete. Otherwise, getBundle examines the remainder of the candidate locale list that was used during the pass that generated the result resource bundle. (As before, candidate bundle names where the final component is an empty string are omitted.) When it comes to the end of the candidate list, it tries the plain bundle name. With each of the candidate bundle names it attempts to instantiate a resource bundle (first looking for a class and then a properties file, as described above). Whenever it succeeds, it calls the previously instantiated resource bundle's setParent() method with the new resource bundle. This continues until the list of names is exhausted or the current bundle already has a non-null parent. Once the parent chain is complete, the bundle is returned. Note: getBundle caches instantiated resource bundles and might return the same resource bundle instance multiple times. Note:The baseName argument should be a fully qualified class name. However, for compatibility with earlier versions, Sun's Java SE Runtime Environments do not verify this, and so it is possible to access PropertyResourceBundles by specifying a path name (using "/") instead of a fully qualified class name (using ".").  Example:  The following class and property files are provided:  MyResources.class MyResources.properties MyResources_fr.properties MyResources_fr_CH.class MyResources_fr_CH.properties MyResources_en.properties MyResources_es_ES.class  The contents of all files are valid (that is, public non-abstract subclasses of ResourceBundle for the ".class" files, syntactically correct ".properties" files). The default locale is Locale("en", "GB"). Calling getBundle with the locale arguments below will instantiate resource bundles as follows:  Locale("fr", "CH")MyResources_fr_CH.class, parent MyResources_fr.properties, parent MyResources.class Locale("fr", "FR")MyResources_fr.properties, parent MyResources.class Locale("de", "DE")MyResources_en.properties, parent MyResources.class Locale("en", "US")MyResources_en.properties, parent MyResources.class Locale("es", "ES")MyResources_es_ES.class, parent MyResources.class  The file MyResources_fr_CH.properties is never used because it is hidden by the MyResources_fr_CH.class. Likewise, MyResources.properties is also hidden by MyResources.class.
java.util.ResourceBundle.getBundle	(	String	Locale	ClassLoader	Control	): Returns a resource bundle using the specified base name, target locale, class loader and control. Unlike the getBundle() getBundle factory methods with no control argument, the given control specifies how to locate and instantiate resource bundles. Conceptually, the bundle loading process with the given control is performed in the following steps.  This factory method looks up the resource bundle in the cache for the specified baseName, targetLocale and loader. If the requested resource bundle instance is found in the cache and the time-to-live periods of the instance and all of its parent instances have not expired, the instance is returned to the caller. Otherwise, this factory method proceeds with the loading process below. The getFormats() control.getFormats method is called to get resource bundle formats to produce bundle or resource names. The strings "java.class" and "java.properties" designate class-based and PropertyResourceBundle property-based resource bundles, respectively. Other strings starting with "java." are reserved for future extensions and must not be used for application-defined formats. Other strings designate application-defined formats. The getCandidateLocales() control.getCandidateLocales method is called with the target locale to get a list of candidate Locales for which resource bundles are searched. The newBundle() control.newBundle method is called to instantiate a ResourceBundle for the base bundle name, a candidate locale, and a format. (Refer to the note on the cache lookup below.) This step is iterated over all combinations of the candidate locales and formats until the newBundle method returns a ResourceBundle instance or the iteration has used up all the combinations. For example, if the candidate locales are Locale("de", "DE"), Locale("de") and Locale("") and the formats are "java.class" and "java.properties", then the following is the sequence of locale-format combinations to be used to call control.newBundle.    Locale  format    Locale("de", "DE")  java.class    Locale("de", "DE") java.properties    Locale("de") java.class   Locale("de") java.properties   Locale("")  java.class   Locale("") java.properties     If the previous step has found no resource bundle, proceed to Step 6. If a bundle has been found that is a base bundle (a bundle for Locale("")), and the candidate locale list only contained Locale(""), return the bundle to the caller. If a bundle has been found that is a base bundle, but the candidate locale list contained locales other than Locale(""), put the bundle on hold and proceed to Step 6. If a bundle has been found that is not a base bundle, proceed to Step 7. The getFallbackLocale() control.getFallbackLocale method is called to get a fallback locale (alternative to the current target locale) to try further finding a resource bundle. If the method returns a non-null locale, it becomes the next target locale and the loading process starts over from Step 3. Otherwise, if a base bundle was found and put on hold in a previous Step 5, it is returned to the caller now. Otherwise, a MissingResourceException is thrown. At this point, we have found a resource bundle that's not the base bundle. If this bundle set its parent during its instantiation, it is returned to the caller. Otherwise, its parent chain is instantiated based on the list of candidate locales from which it was found. Finally, the bundle is returned to the caller.  During the resource bundle loading process above, this factory method looks up the cache before calling the newBundle() control.newBundle method. If the time-to-live period of the resource bundle found in the cache has expired, the factory method calls the needsReload() control.needsReload method to determine whether the resource bundle needs to be reloaded. If reloading is required, the factory method calls control.newBundle to reload the resource bundle. If control.newBundle returns null, the factory method puts a dummy resource bundle in the cache as a mark of nonexistent resource bundles in order to avoid lookup overhead for subsequent requests. Such dummy resource bundles are under the same expiration control as specified by control. All resource bundles loaded are cached by default. Refer to getTimeToLive() control.getTimeToLive for details. The following is an example of the bundle loading process with the default ResourceBundle.Control implementation. Conditions:  Base bundle name: foo.bar.Messages Requested Locale: ITALY Default Locale: FRENCH Available resource bundles: foo/bar/Messages_fr.properties and foo/bar/Messages.properties  First, getBundle tries loading a resource bundle in the following sequence.  class foo.bar.Messages_it_IT file foo/bar/Messages_it_IT.properties class foo.bar.Messages_it file foo/bar/Messages_it.properties class foo.bar.Messages file foo/bar/Messages.properties  At this point, getBundle finds foo/bar/Messages.properties, which is put on hold because it's the base bundle. getBundle calls getFallbackLocale() control.getFallbackLocale("foo.bar.Messages", Locale.ITALY) which returns Locale.FRENCH. Next, getBundle tries loading a bundle in the following sequence.  class foo.bar.Messages_fr file foo/bar/Messages_fr.properties class foo.bar.Messages file foo/bar/Messages.properties  getBundle finds foo/bar/Messages_fr.properties and creates a ResourceBundle instance. Then, getBundle sets up its parent chain from the list of the candidate locales. Only foo/bar/Messages.properties is found in the list and getBundle creates a ResourceBundle instance that becomes the parent of the instance for foo/bar/Messages_fr.properties.
java.util.ResourceBundle.getBundle	(	String	Locale	Control	): Returns a resource bundle using the specified base name, target locale and control, and the caller's class loader. Calling this method is equivalent to calling  getBundle(baseName, targetLocale, this.getClass().getClassLoader(), control),  except that getClassLoader() is run with the security privileges of ResourceBundle. See getBundle() for the complete description of the resource bundle loading process with a ResourceBundle.Control.
java.util.ResourceBundle.getKeys	(	): Returns an enumeration of the keys.
java.util.ResourceBundle.getLocale	(	): Returns the locale of this resource bundle. This method can be used after a call to getBundle() to determine whether the resource bundle returned really corresponds to the requested locale or is a fallback.
java.util.ResourceBundle.getObject	(	String	): Gets an object for the given key from this resource bundle or one of its parents. This method first tries to obtain the object from this resource bundle using handleGetObject(). If not successful, and the parent resource bundle is not null, it calls the parent's getObject method. If still not successful, it throws a MissingResourceException.
java.util.ResourceBundle.getString	(	String	): Gets a string for the given key from this resource bundle or one of its parents. Calling this method is equivalent to calling  (String) getObject()(key). 
java.util.ResourceBundle.getStringArray	(	String	): Gets a string array for the given key from this resource bundle or one of its parents. Calling this method is equivalent to calling  (String[]) getObject()(key). 
java.util.ResourceBundle.handleGetObject	(	String	): Gets an object for the given key from this resource bundle. Returns null if this resource bundle does not contain an object for the given key.
java.util.ResourceBundle.handleKeySet	(	): Returns a Set of the keys contained only in this ResourceBundle. The default implementation returns a Set of the keys returned by the getKeys() method except for the ones for which the handleGetObject() method returns null. Once the Set has been created, the value is kept in this ResourceBundle in order to avoid producing the same Set in subsequent calls. Subclasses can override this method for faster handling.
java.util.ResourceBundle.hasValidParentChain	(	ResourceBundle	): Determines whether any of resource bundles in the parent chain, including the leaf, have expired.
java.util.ResourceBundle.keySet	(	): Returns a Set of all keys contained in this ResourceBundle and its parent bundles.
java.util.ResourceBundle.putBundleInCache	(	CacheKey	ResourceBundle	Control	): Put a new bundle in the cache.
java.util.ResourceBundle.setParent	(	ResourceBundle	): Sets the parent bundle of this bundle. The parent bundle is searched by getObject when this bundle does not contain a particular resource.
java.util.ResourceBundle.throwMissingResourceException	(	String	Locale	Throwable	): Throw a MissingResourceException with proper message
java.util.Scanner: A simple text scanner which can parse primitive types and strings using regular expressions. A Scanner breaks its input into tokens using a delimiter pattern, which by default matches whitespace. The resulting tokens may then be converted into values of different types using the various next methods. For example, this code allows a user to read a number from System.in: Scanner sc = new Scanner(System.in); int i = sc.nextInt(); As another example, this code allows long types to be assigned from entries in a file myNumbers: Scanner sc = new Scanner(new File("myNumbers")); while (sc.hasNextLong()) long aLong = sc.nextLong(); } } The scanner can also use delimiters other than whitespace. This example reads several items in from a string: String input = "1 fish 2 fish red fish blue fish"; Scanner s = new Scanner(input).useDelimiter("\\s*fish\\s*"); System.out.println(s.nextInt()); System.out.println(s.nextInt()); System.out.println(s.next()); System.out.println(s.next()); s.close();  prints the following output: 1 2 red blue The same output can be generated with this code, which uses a regular expression to parse all four tokens at once: String input = "1 fish 2 fish red fish blue fish"; Scanner s = new Scanner(input); s.findInLine("(\\d+) fish (\\d+) fish (\\w+) fish (\\w+)"); MatchResult result = s.match(); for (int i=1; i<=result.groupCount(); i++) System.out.println(result.group(i)); s.close(); The default whitespace delimiter used by a scanner is as recognized by java.lang.Character.isWhitespace(). The reset method will reset the value of the scanner's delimiter to the default whitespace delimiter regardless of whether it was previously changed. A scanning operation may block waiting for input. The next and hasNext methods and their primitive-type companion methods (such as nextInt and hasNextInt) first skip any input that matches the delimiter pattern, and then attempt to return the next token. Both hasNext and next methods may block waiting for further input. Whether a hasNext method blocks has no connection to whether or not its associated next method will block.  The findInLine, findWithinHorizon, and skip methods operate independently of the delimiter pattern. These methods will attempt to match the specified pattern with no regard to delimiters in the input and thus can be used in special circumstances where delimiters are not relevant. These methods may block waiting for more input. When a scanner throws an InputMismatchException, the scanner will not pass the token that caused the exception, so that it may be retrieved or skipped via some other method. Depending upon the type of delimiting pattern, empty tokens may be returned. For example, the pattern "\\s+" will return no empty tokens since it matches multiple instances of the delimiter. The delimiting pattern "\\s" could return empty tokens since it only passes one space at a time.  A scanner can read text from any object which implements the java.lang.Readable interface. If an invocation of the underlying readable's read method throws an java.io.IOException then the scanner assumes that the end of the input has been reached. The most recent IOException thrown by the underlying readable can be retrieved via the ioException method. When a Scanner is closed, it will close its input source if the source implements the java.io.Closeable interface. A Scanner is not safe for multithreaded use without external synchronization. Unless otherwise mentioned, passing a null parameter into any method of a Scanner will cause a NullPointerException to be thrown. A scanner will default to interpreting numbers as decimal unless a different radix has been set by using the useRadix method. The reset method will reset the value of the scanner's radix to 10 regardless of whether it was previously changed.  Localized numbers   An instance of this class is capable of scanning numbers in the standard formats as well as in the formats of the scanner's locale. A scanner's initial locale is the value returned by the getDefault() Locale.getDefault(Locale.Category.FORMAT) method; it may be changed via the useLocale method. The reset method will reset the value of the scanner's locale to the initial locale regardless of whether it was previously changed. The localized formats are defined in terms of the following parameters, which for a particular locale are taken from that locale's java.text.DecimalFormat DecimalFormat object, df, and its and java.text.DecimalFormatSymbols DecimalFormatSymbols object, dfs.  LocalGroupSeparator   The character used to separate thousands groups, i.e., dfs.getGroupingSeparator getGroupingSeparator() LocalDecimalSeparator   The character used for the decimal point, i.e., dfs.getDecimalSeparator getDecimalSeparator() LocalPositivePrefix   The string that appears before a positive number (may be empty), i.e., df.getPositivePrefix getPositivePrefix() LocalPositiveSuffix   The string that appears after a positive number (may be empty), i.e., df.getPositiveSuffix getPositiveSuffix() LocalNegativePrefix   The string that appears before a negative number (may be empty), i.e., df.getNegativePrefix getNegativePrefix() LocalNegativeSuffix   The string that appears after a negative number (may be empty), i.e., df.getNegativeSuffix getNegativeSuffix() LocalNaN   The string that represents not-a-number for floating-point values, i.e., dfs.getNaN getNaN() LocalInfinity   The string that represents infinity for floating-point values, i.e., dfs.getInfinity getInfinity()   Number syntax   The strings that can be parsed as numbers by an instance of this class are specified in terms of the following regular-expression grammar, where Rmax is the highest digit in the radix being used (for example, Rmax is 9 in base 10).  NonAsciiDigit: A non-ASCII character c for which isDigit Character.isDigit(c) returns true Non0Digit: [1-Rmax] | NonASCIIDigit Digit: [0-Rmax] | NonASCIIDigit GroupedNumeral: ( Non0Digit Digit? Digit?     ( LocalGroupSeparator Digit Digit Digit )+ ) Numeral: ( ( Digit+ ) | GroupedNumeral ) Integer: ( [-+]? ( Numeral ) ) | LocalPositivePrefix Numeral LocalPositiveSuffix | LocalNegativePrefix Numeral LocalNegativeSuffix DecimalNumeral: Numeral | Numeral LocalDecimalSeparator Digit* | LocalDecimalSeparator Digit+ Exponent: ( [eE] [+-]? Digit+ ) Decimal: ( [-+]? DecimalNumeral Exponent? ) | LocalPositivePrefix DecimalNumeral LocalPositiveSuffix Exponent? | LocalNegativePrefix DecimalNumeral LocalNegativeSuffix Exponent? HexFloat: [-+]? 0[xX][0-9a-fA-F]*\.[0-9a-fA-F]+ ([pP][-+]?[0-9]+)? NonNumber: NaN | LocalNan | Infinity | LocalInfinity SignedNonNumber: ( [-+]? NonNumber ) | LocalPositivePrefix NonNumber LocalPositiveSuffix | LocalNegativePrefix NonNumber LocalNegativeSuffix Float: Decimal | HexFloat | SignedNonNumber  Whitespace is not significant in the above regular expressions.
java.util.Scanner.Scanner	(	File	): Constructs a new Scanner that produces values scanned from the specified file. Bytes from the file are converted into characters using the underlying platform's defaultCharset() default charset.
java.util.Scanner.Scanner	(	File	String	): Constructs a new Scanner that produces values scanned from the specified file. Bytes from the file are converted into characters using the specified charset.
java.util.Scanner.Scanner	(	InputStream	): Constructs a new Scanner that produces values scanned from the specified input stream. Bytes from the stream are converted into characters using the underlying platform's defaultCharset() default charset.
java.util.Scanner.Scanner	(	InputStream	String	): Constructs a new Scanner that produces values scanned from the specified input stream. Bytes from the stream are converted into characters using the specified charset.
java.util.Scanner.Scanner	(	Path	): Constructs a new Scanner that produces values scanned from the specified file. Bytes from the file are converted into characters using the underlying platform's defaultCharset() default charset.
java.util.Scanner.Scanner	(	Path	String	): Constructs a new Scanner that produces values scanned from the specified file. Bytes from the file are converted into characters using the specified charset.
java.util.Scanner.Scanner	(	Readable	): Constructs a new Scanner that produces values scanned from the specified source.
java.util.Scanner.Scanner	(	Readable	Pattern	): Constructs a Scanner that returns values scanned from the specified source delimited by the specified pattern.
java.util.Scanner.Scanner	(	ReadableByteChannel	): Constructs a new Scanner that produces values scanned from the specified channel. Bytes from the source are converted into characters using the underlying platform's defaultCharset() default charset.
java.util.Scanner.Scanner	(	ReadableByteChannel	String	): Constructs a new Scanner that produces values scanned from the specified channel. Bytes from the source are converted into characters using the specified charset.
java.util.Scanner.Scanner	(	String	): Constructs a new Scanner that produces values scanned from the specified string.
java.util.Scanner.close	(	): Closes this scanner.  If this scanner has not yet been closed then if its underlying java.lang.Readable readable also implements the java.io.Closeable interface then the readable's close method will be invoked. If this scanner is already closed then invoking this method will have no effect. Attempting to perform search operations after a scanner has been closed will result in an IllegalStateException.
java.util.Scanner.delimiter	(	): Returns the Pattern this Scanner is currently using to match delimiters.
java.util.Scanner.findInLine	(	Pattern	): Attempts to find the next occurrence of the specified pattern ignoring delimiters. If the pattern is found before the next line separator, the scanner advances past the input that matched and returns the string that matched the pattern. If no such pattern is detected in the input up to the next line separator, then null is returned and the scanner's position is unchanged. This method may block waiting for input that matches the pattern. Since this method continues to search through the input looking for the specified pattern, it may buffer all of the input searching for the desired token if no line separators are present.
java.util.Scanner.findInLine	(	String	): Attempts to find the next occurrence of a pattern constructed from the specified string, ignoring delimiters. An invocation of this method of the form findInLine(pattern) behaves in exactly the same way as the invocation findInLine(Pattern.compile(pattern)).
java.util.Scanner.findWithinHorizon	(	Pattern	int	): Attempts to find the next occurrence of the specified pattern. This method searches through the input up to the specified search horizon, ignoring delimiters. If the pattern is found the scanner advances past the input that matched and returns the string that matched the pattern. If no such pattern is detected then the null is returned and the scanner's position remains unchanged. This method may block waiting for input that matches the pattern. A scanner will never search more than horizon code points beyond its current position. Note that a match may be clipped by the horizon; that is, an arbitrary match result may have been different if the horizon had been larger. The scanner treats the horizon as a transparent, non-anchoring bound (see useTransparentBounds and useAnchoringBounds). If horizon is 0, then the horizon is ignored and this method continues to search through the input looking for the specified pattern without bound. In this case it may buffer all of the input searching for the pattern. If horizon is negative, then an IllegalArgumentException is thrown.
java.util.Scanner.findWithinHorizon	(	String	int	): Attempts to find the next occurrence of a pattern constructed from the specified string, ignoring delimiters. An invocation of this method of the form findWithinHorizon(pattern) behaves in exactly the same way as the invocation findWithinHorizon(Pattern.compile(pattern, horizon)).
java.util.Scanner.hasNext	(	): Returns true if this scanner has another token in its input. This method may block while waiting for input to scan. The scanner does not advance past any input.
java.util.Scanner.hasNext	(	Pattern	): Returns true if the next complete token matches the specified pattern. A complete token is prefixed and postfixed by input that matches the delimiter pattern. This method may block while waiting for input. The scanner does not advance past any input.
java.util.Scanner.hasNext	(	String	): Returns true if the next token matches the pattern constructed from the specified string. The scanner does not advance past any input.  An invocation of this method of the form hasNext(pattern) behaves in exactly the same way as the invocation hasNext(Pattern.compile(pattern)).
java.util.Scanner.hasNextBigDecimal	(	): Returns true if the next token in this scanner's input can be interpreted as a BigDecimal using the nextBigDecimal method. The scanner does not advance past any input.
java.util.Scanner.hasNextBigInteger	(	): Returns true if the next token in this scanner's input can be interpreted as a BigInteger in the default radix using the nextBigInteger method. The scanner does not advance past any input.
java.util.Scanner.hasNextBigInteger	(	int	): Returns true if the next token in this scanner's input can be interpreted as a BigInteger in the specified radix using the nextBigInteger method. The scanner does not advance past any input.
java.util.Scanner.hasNextBoolean	(	): Returns true if the next token in this scanner's input can be interpreted as a boolean value using a case insensitive pattern created from the string "true|false". The scanner does not advance past the input that matched.
java.util.Scanner.hasNextByte	(	): Returns true if the next token in this scanner's input can be interpreted as a byte value in the default radix using the nextByte method. The scanner does not advance past any input.
java.util.Scanner.hasNextByte	(	int	): Returns true if the next token in this scanner's input can be interpreted as a byte value in the specified radix using the nextByte method. The scanner does not advance past any input.
java.util.Scanner.hasNextDouble	(	): Returns true if the next token in this scanner's input can be interpreted as a double value using the nextDouble method. The scanner does not advance past any input.
java.util.Scanner.hasNextFloat	(	): Returns true if the next token in this scanner's input can be interpreted as a float value using the nextFloat method. The scanner does not advance past any input.
java.util.Scanner.hasNextInt	(	): Returns true if the next token in this scanner's input can be interpreted as an int value in the default radix using the nextInt method. The scanner does not advance past any input.
java.util.Scanner.hasNextInt	(	int	): Returns true if the next token in this scanner's input can be interpreted as an int value in the specified radix using the nextInt method. The scanner does not advance past any input.
java.util.Scanner.hasNextLine	(	): Returns true if there is another line in the input of this scanner. This method may block while waiting for input. The scanner does not advance past any input.
java.util.Scanner.hasNextLong	(	): Returns true if the next token in this scanner's input can be interpreted as a long value in the default radix using the nextLong method. The scanner does not advance past any input.
java.util.Scanner.hasNextLong	(	int	): Returns true if the next token in this scanner's input can be interpreted as a long value in the specified radix using the nextLong method. The scanner does not advance past any input.
java.util.Scanner.hasNextShort	(	): Returns true if the next token in this scanner's input can be interpreted as a short value in the default radix using the nextShort method. The scanner does not advance past any input.
java.util.Scanner.hasNextShort	(	int	): Returns true if the next token in this scanner's input can be interpreted as a short value in the specified radix using the nextShort method. The scanner does not advance past any input.
java.util.Scanner.ioException	(	): Returns the IOException last thrown by this Scanner's underlying Readable. This method returns null if no such exception exists.
java.util.Scanner.locale	(	): Returns this scanner's locale. A scanner's locale affects many elements of its default primitive matching regular expressions; see localized numbers above.
java.util.Scanner.match	(	): Returns the match result of the last scanning operation performed by this scanner. This method throws IllegalStateException if no match has been performed, or if the last match was not successful. The various nextmethods of Scanner make a match result available if they complete without throwing an exception. For instance, after an invocation of the nextInt method that returned an int, this method returns a MatchResult for the search of the Integer regular expression defined above. Similarly the findInLine, findWithinHorizon, and skip methods will make a match available if they succeed.
java.util.Scanner.next	(	): Finds and returns the next complete token from this scanner. A complete token is preceded and followed by input that matches the delimiter pattern. This method may block while waiting for input to scan, even if a previous invocation of hasNext returned true.
java.util.Scanner.next	(	Pattern	): Returns the next token if it matches the specified pattern. This method may block while waiting for input to scan, even if a previous invocation of hasNext() returned true. If the match is successful, the scanner advances past the input that matched the pattern.
java.util.Scanner.next	(	String	): Returns the next token if it matches the pattern constructed from the specified string. If the match is successful, the scanner advances past the input that matched the pattern.  An invocation of this method of the form next(pattern) behaves in exactly the same way as the invocation next(Pattern.compile(pattern)).
java.util.Scanner.nextBigDecimal	(	): Scans the next token of the input as a java.math.BigDecimal BigDecimal.  If the next token matches the Decimal regular expression defined above then the token is converted into a BigDecimal value as if by removing all group separators, mapping non-ASCII digits into ASCII digits via the digit Character.digit, and passing the resulting string to the BigDecimal() BigDecimal(String) constructor.
java.util.Scanner.nextBigInteger	(	): Scans the next token of the input as a java.math.BigInteger BigInteger.  An invocation of this method of the form nextBigInteger() behaves in exactly the same way as the invocation nextBigInteger(radix), where radix is the default radix of this scanner.
java.util.Scanner.nextBigInteger	(	int	): Scans the next token of the input as a java.math.BigInteger BigInteger.  If the next token matches the Integer regular expression defined above then the token is converted into a BigInteger value as if by removing all group separators, mapping non-ASCII digits into ASCII digits via the digit Character.digit, and passing the resulting string to the BigInteger() BigInteger(String, int) constructor with the specified radix.
java.util.Scanner.nextBoolean	(	): Scans the next token of the input into a boolean value and returns that value. This method will throw InputMismatchException if the next token cannot be translated into a valid boolean value. If the match is successful, the scanner advances past the input that matched.
java.util.Scanner.nextByte	(	): Scans the next token of the input as a byte.  An invocation of this method of the form nextByte() behaves in exactly the same way as the invocation nextByte(radix), where radix is the default radix of this scanner.
java.util.Scanner.nextByte	(	int	): Scans the next token of the input as a byte. This method will throw InputMismatchException if the next token cannot be translated into a valid byte value as described below. If the translation is successful, the scanner advances past the input that matched.  If the next token matches the Integer regular expression defined above then the token is converted into a byte value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via digit Character.digit, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to parseByte() Byte.parseByte with the specified radix.
java.util.Scanner.nextDouble	(	): Scans the next token of the input as a double. This method will throw InputMismatchException if the next token cannot be translated into a valid double value. If the translation is successful, the scanner advances past the input that matched.  If the next token matches the Float regular expression defined above then the token is converted into a double value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via digit Character.digit, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to parseDouble Double.parseDouble. If the token matches the localized NaN or infinity strings, then either "Nan" or "Infinity" is passed to parseDouble() Double.parseDouble as appropriate.
java.util.Scanner.nextFloat	(	): Scans the next token of the input as a float. This method will throw InputMismatchException if the next token cannot be translated into a valid float value as described below. If the translation is successful, the scanner advances past the input that matched.  If the next token matches the Float regular expression defined above then the token is converted into a float value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via digit Character.digit, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to parseFloat Float.parseFloat. If the token matches the localized NaN or infinity strings, then either "Nan" or "Infinity" is passed to parseFloat() Float.parseFloat as appropriate.
java.util.Scanner.nextInt	(	): Scans the next token of the input as an int.  An invocation of this method of the form nextInt() behaves in exactly the same way as the invocation nextInt(radix), where radix is the default radix of this scanner.
java.util.Scanner.nextInt	(	int	): Scans the next token of the input as an int. This method will throw InputMismatchException if the next token cannot be translated into a valid int value as described below. If the translation is successful, the scanner advances past the input that matched.  If the next token matches the Integer regular expression defined above then the token is converted into an int value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via digit Character.digit, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to parseInt() Integer.parseInt with the specified radix.
java.util.Scanner.nextLine	(	): Advances this scanner past the current line and returns the input that was skipped. This method returns the rest of the current line, excluding any line separator at the end. The position is set to the beginning of the next line. Since this method continues to search through the input looking for a line separator, it may buffer all of the input searching for the line to skip if no line separators are present.
java.util.Scanner.nextLong	(	): Scans the next token of the input as a long.  An invocation of this method of the form nextLong() behaves in exactly the same way as the invocation nextLong(radix), where radix is the default radix of this scanner.
java.util.Scanner.nextLong	(	int	): Scans the next token of the input as a long. This method will throw InputMismatchException if the next token cannot be translated into a valid long value as described below. If the translation is successful, the scanner advances past the input that matched.  If the next token matches the Integer regular expression defined above then the token is converted into a long value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via digit Character.digit, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to parseLong() Long.parseLong with the specified radix.
java.util.Scanner.nextShort	(	): Scans the next token of the input as a short.  An invocation of this method of the form nextShort() behaves in exactly the same way as the invocation nextShort(radix), where radix is the default radix of this scanner.
java.util.Scanner.nextShort	(	int	): Scans the next token of the input as a short. This method will throw InputMismatchException if the next token cannot be translated into a valid short value as described below. If the translation is successful, the scanner advances past the input that matched.  If the next token matches the Integer regular expression defined above then the token is converted into a short value as if by removing all locale specific prefixes, group separators, and locale specific suffixes, then mapping non-ASCII digits into ASCII digits via digit Character.digit, prepending a negative sign (-) if the locale specific negative prefixes and suffixes were present, and passing the resulting string to parseShort() Short.parseShort with the specified radix.
java.util.Scanner.processFloatToken	(	String	): The float token must be stripped of prefixes, group separators, and suffixes, non ascii digits must be converted into ascii digits before parseFloat will accept it. If there are non-ascii digits in the token these digits must be processed before the token is passed to parseFloat.
java.util.Scanner.processIntegerToken	(	String	): The integer token must be stripped of prefixes, group separators, and suffixes, non ascii digits must be converted into ascii digits before parse will accept it.
java.util.Scanner.radix	(	): Returns this scanner's default radix. A scanner's radix affects elements of its default number matching regular expressions; see localized numbers above.
java.util.Scanner.remove	(	): The remove operation is not supported by this implementation of Iterator.
java.util.Scanner.reset	(	): Resets this scanner.  Resetting a scanner discards all of its explicit state information which may have been changed by invocations of useDelimiter, useLocale, or useRadix.  An invocation of this method of the form scanner.reset() behaves in exactly the same way as the invocation scanner.useDelimiter("\\p{javaWhitespace}+") .useLocale(Locale.getDefault(Locale.Category.FORMAT)) .useRadix(10); }
java.util.Scanner.skip	(	Pattern	): Skips input that matches the specified pattern, ignoring delimiters. This method will skip input if an anchored match of the specified pattern succeeds. If a match to the specified pattern is not found at the current position, then no input is skipped and a NoSuchElementException is thrown. Since this method seeks to match the specified pattern starting at the scanner's current position, patterns that can match a lot of input (".*", for example) may cause the scanner to buffer a large amount of input. Note that it is possible to skip something without risking a NoSuchElementException by using a pattern that can match nothing, e.g., sc.skip("[ \t]*").
java.util.Scanner.skip	(	String	): Skips input that matches a pattern constructed from the specified string.  An invocation of this method of the form skip(pattern) behaves in exactly the same way as the invocation skip(Pattern.compile(pattern)).
java.util.Scanner.toCharset	(	String	): Returns a charset object for the given charset name.
java.util.Scanner.toString	(	): Returns the string representation of this Scanner. The string representation of a Scanner contains information that may be useful for debugging. The exact format is unspecified.
java.util.Scanner.useDelimiter	(	Pattern	): Sets this scanner's delimiting pattern to the specified pattern.
java.util.Scanner.useDelimiter	(	String	): Sets this scanner's delimiting pattern to a pattern constructed from the specified String.  An invocation of this method of the form useDelimiter(pattern) behaves in exactly the same way as the invocation useDelimiter(Pattern.compile(pattern)).  Invoking the reset method will set the scanner's delimiter to the default.
java.util.Scanner.useLocale	(	Locale	): Sets this scanner's locale to the specified locale. A scanner's locale affects many elements of its default primitive matching regular expressions; see localized numbers above. Invoking the reset method will set the scanner's locale to the initial locale.
java.util.Scanner.useRadix	(	int	): Sets this scanner's default radix to the specified radix. A scanner's radix affects elements of its default number matching regular expressions; see localized numbers above. If the radix is less than Character.MIN_RADIX or greater than Character.MAX_RADIX, then an IllegalArgumentException is thrown. Invoking the reset method will set the scanner's radix to 10.
java.util.ServiceConfigurationError: Error thrown when something goes wrong while loading a service provider.  This error will be thrown in the following situations:   The format of a provider-configuration file violates the specification;   An java.io.IOException IOException occurs while reading a provider-configuration file;   A concrete provider class named in a provider-configuration file cannot be found;   A concrete provider class is not a subclass of the service class;   A concrete provider class cannot be instantiated; or  Some other kind of error occurs.  
java.util.ServiceConfigurationError.ServiceConfigurationError	(	String	): Constructs a new instance with the specified message.
java.util.ServiceConfigurationError.ServiceConfigurationError	(	String	Throwable	): Constructs a new instance with the specified message and cause.
java.util.ServiceLoader: A simple service-provider loading facility.  A service is a well-known set of interfaces and (usually abstract) classes. A service provider is a specific implementation of a service. The classes in a provider typically implement the interfaces and subclass the classes defined in the service itself. Service providers can be installed in an implementation of the Java platform in the form of extensions, that is, jar files placed into any of the usual extension directories. Providers can also be made available by adding them to the application's class path or by some other platform-specific means.  For the purpose of loading, a service is represented by a single type, that is, a single interface or abstract class. (A concrete class can be used, but this is not recommended.) A provider of a given service contains one or more concrete classes that extend this service type with data and code specific to the provider. The provider class is typically not the entire provider itself but rather a proxy which contains enough information to decide whether the provider is able to satisfy a particular request together with code that can create the actual provider on demand. The details of provider classes tend to be highly service-specific; no single class or interface could possibly unify them, so no such type is defined here. The only requirement enforced by this facility is that provider classes must have a zero-argument constructor so that they can be instantiated during loading.  A service provider is identified by placing a provider-configuration file in the resource directory META-INF/services. The file's name is the fully-qualified binary name of the service's type. The file contains a list of fully-qualified binary names of concrete provider classes, one per line. Space and tab characters surrounding each name, as well as blank lines, are ignored. The comment character is '#' ('\u0023', NUMBER SIGN); on each line all characters following the first comment character are ignored. The file must be encoded in UTF-8.  If a particular concrete provider class is named in more than one configuration file, or is named in the same configuration file more than once, then the duplicates are ignored. The configuration file naming a particular provider need not be in the same jar file or other distribution unit as the provider itself. The provider must be accessible from the same class loader that was initially queried to locate the configuration file; note that this is not necessarily the class loader from which the file was actually loaded.  Providers are located and instantiated lazily, that is, on demand. A service loader maintains a cache of the providers that have been loaded so far. Each invocation of the iterator method returns an iterator that first yields all of the elements of the cache, in instantiation order, and then lazily locates and instantiates any remaining providers, adding each one to the cache in turn. The cache can be cleared via the reload method.  Service loaders always execute in the security context of the caller. Trusted system code should typically invoke the methods in this class, and the methods of the iterators which they return, from within a privileged security context.  Instances of this class are not safe for use by multiple concurrent threads.  Unless otherwise specified, passing a null argument to any method in this class will cause a NullPointerException to be thrown. Example Suppose we have a service type com.example.CodecSet which is intended to represent sets of encoder/decoder pairs for some protocol. In this case it is an abstract class with two abstract methods:  public abstract Encoder getEncoder(String encodingName); public abstract Decoder getDecoder(String encodingName); Each method returns an appropriate object or null if the provider does not support the given encoding. Typical providers support more than one encoding.  If com.example.impl.StandardCodecs is an implementation of the CodecSet service then its jar file also contains a file named  META-INF/services/com.example.CodecSet  This file contains the single line:  com.example.impl.StandardCodecs # Standard codecs  The CodecSet class creates and saves a single service instance at initialization:  private static ServiceLoader<CodecSet> codecSetLoader = ServiceLoader.load(CodecSet.class);  To locate an encoder for a given encoding name it defines a static factory method which iterates through the known and available providers, returning only when it has located a suitable encoder or has run out of providers.  public static Encoder getEncoder(String encodingName) { for (CodecSet cp : codecSetLoader) { Encoder enc = cp.getEncoder(encodingName); if (enc != null) return enc; } return null; }  A getDecoder method is defined similarly. Usage Note If the class path of a class loader that is used for provider loading includes remote network URLs then those URLs will be dereferenced in the process of searching for provider-configuration files.  This activity is normal, although it may cause puzzling entries to be created in web-server logs. If a web server is not configured correctly, however, then this activity may cause the provider-loading algorithm to fail spuriously.  A web server should return an HTTP 404 (Not Found) response when a requested resource does not exist. Sometimes, however, web servers are erroneously configured to return an HTTP 200 (OK) response along with a helpful HTML error page in such cases. This will cause a ServiceConfigurationError to be thrown when this class attempts to parse the HTML page as a provider-configuration file. The best solution to this problem is to fix the misconfigured web server to return the correct response code (HTTP 404) along with the HTML error page.
java.util.ServiceLoader.iterator	(	): Lazily loads the available providers of this loader's service.  The iterator returned by this method first yields all of the elements of the provider cache, in instantiation order. It then lazily loads and instantiates any remaining providers, adding each one to the cache in turn.  To achieve laziness the actual work of parsing the available provider-configuration files and instantiating providers must be done by the iterator itself. Its hasNext and next methods can therefore throw a ServiceConfigurationError if a provider-configuration file violates the specified format, or if it names a provider class that cannot be found and instantiated, or if the result of instantiating the class is not assignable to the service type, or if any other kind of exception or error is thrown as the next provider is located and instantiated. To write robust code it is only necessary to catch ServiceConfigurationError when using a service iterator.  If such an error is thrown then subsequent invocations of the iterator will make a best effort to locate and instantiate the next available provider, but in general such recovery cannot be guaranteed. Design Note Throwing an error in these cases may seem extreme. The rationale for this behavior is that a malformed provider-configuration file, like a malformed class file, indicates a serious problem with the way the Java virtual machine is configured or is being used. As such it is preferable to throw an error rather than try to recover or, even worse, fail silently.  The iterator returned by this method does not support removal. Invoking its remove() method will cause an UnsupportedOperationException to be thrown.
java.util.ServiceLoader.load	(	Class	): Creates a new service loader for the given service type, using the current thread's getContextClassLoader context class loader.  An invocation of this convenience method of the form  ServiceLoader.load(service) is equivalent to  ServiceLoader.load(service, Thread.currentThread().getContextClassLoader())
java.util.ServiceLoader.load	(	Class	ClassLoader	): Creates a new service loader for the given service type and class loader.
java.util.ServiceLoader.loadInstalled	(	Class	): Creates a new service loader for the given service type, using the extension class loader.  This convenience method simply locates the extension class loader, call it extClassLoader, and then returns  ServiceLoader.load(service, extClassLoader)  If the extension class loader cannot be found then the system class loader is used; if there is no system class loader then the bootstrap class loader is used.  This method is intended for use when only installed providers are desired. The resulting service will only find and load providers that have been installed into the current Java virtual machine; providers on the application's class path will be ignored.
java.util.ServiceLoader.reload	(	): Clear this loader's provider cache so that all providers will be reloaded.  After invoking this method, subsequent invocations of the iterator() method will lazily look up and instantiate providers from scratch, just as is done by a newly-created loader.  This method is intended for use in situations in which new providers can be installed into a running Java virtual machine.
java.util.ServiceLoader.toString	(	): Returns a string describing this service.
java.util.Set: A collection that contains no duplicate elements. More formally, sets contain no pair of elements e1 and e2 such that e1.equals(e2), and at most one null element. As implied by its name, this interface models the mathematical set abstraction. The Set interface places additional stipulations, beyond those inherited from the Collection interface, on the contracts of all constructors and on the contracts of the add, equals and hashCode methods. Declarations for other inherited methods are also included here for convenience. (The specifications accompanying these declarations have been tailored to the Set interface, but they do not contain any additional stipulations.) The additional stipulation on constructors is, not surprisingly, that all constructors must create a set that contains no duplicate elements (as defined above). Note: Great care must be exercised if mutable objects are used as set elements. The behavior of a set is not specified if the value of an object is changed in a manner that affects equals comparisons while the object is an element in the set. A special case of this prohibition is that it is not permissible for a set to contain itself as an element. Some set implementations have restrictions on the elements that they may contain. For example, some implementations prohibit null elements, and some have restrictions on the types of their elements. Attempting to add an ineligible element throws an unchecked exception, typically NullPointerException or ClassCastException. Attempting to query the presence of an ineligible element may throw an exception, or it may simply return false; some implementations will exhibit the former behavior and some will exhibit the latter. More generally, attempting an operation on an ineligible element whose completion would not result in the insertion of an ineligible element into the set may throw an exception or it may succeed, at the option of the implementation. Such exceptions are marked as "optional" in the specification for this interface. This interface is a member of the  Java Collections Framework.
java.util.Set.add	(	E	): Adds the specified element to this set if it is not already present (optional operation). More formally, adds the specified element e to this set if the set contains no element e2 such that (e==null ? e2==null : e.equals(e2)). If this set already contains the element, the call leaves the set unchanged and returns false. In combination with the restriction on constructors, this ensures that sets never contain duplicate elements. The stipulation above does not imply that sets must accept all elements; sets may refuse to add any particular element, including null, and throw an exception, as described in the specification for add Collection.add. Individual set implementations should clearly document any restrictions on the elements that they may contain.
java.util.Set.addAll	(	Collection	): Adds all of the elements in the specified collection to this set if they're not already present (optional operation). If the specified collection is also a set, the addAll operation effectively modifies this set so that its value is the union of the two sets. The behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.Set.clear	(	): Removes all of the elements from this set (optional operation). The set will be empty after this call returns.
java.util.Set.contains	(	Object	): Returns true if this set contains the specified element. More formally, returns true if and only if this set contains an element e such that (o==null ? e==null : o.equals(e)).
java.util.Set.containsAll	(	Collection	): Returns true if this set contains all of the elements of the specified collection. If the specified collection is also a set, this method returns true if it is a subset of this set.
java.util.Set.equals	(	Object	): Compares the specified object with this set for equality. Returns true if the specified object is also a set, the two sets have the same size, and every member of the specified set is contained in this set (or equivalently, every member of this set is contained in the specified set). This definition ensures that the equals method works properly across different implementations of the set interface.
java.util.Set.hashCode	(	): Returns the hash code value for this set. The hash code of a set is defined to be the sum of the hash codes of the elements in the set, where the hash code of a null element is defined to be zero. This ensures that s1.equals(s2) implies that s1.hashCode()==s2.hashCode() for any two sets s1 and s2, as required by the general contract of hashCode.
java.util.Set.isEmpty	(	): Returns true if this set contains no elements.
java.util.Set.iterator	(	): Returns an iterator over the elements in this set. The elements are returned in no particular order (unless this set is an instance of some class that provides a guarantee).
java.util.Set.remove	(	Object	): Removes the specified element from this set if it is present (optional operation). More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)
java.util.Set.removeAll	(	Collection	): Removes from this set all of its elements that are contained in the specified collection (optional operation). If the specified collection is also a set, this operation effectively modifies this set so that its value is the asymmetric set difference of the two sets.
java.util.Set.retainAll	(	Collection	): Retains only the elements in this set that are contained in the specified collection (optional operation). In other words, removes from this set all of its elements that are not contained in the specified collection. If the specified collection is also a set, this operation effectively modifies this set so that its value is the intersection of the two sets.
java.util.Set.size	(	): Returns the number of elements in this set (its cardinality). If this set contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
java.util.Set.spliterator	(	): Creates a Spliterator over the elements in this set. The Spliterator reports DISTINCT. Implementations should document the reporting of additional characteristic values.
java.util.Set.toArray	(	): Returns an array containing all of the elements in this set. If this set makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. The returned array will be "safe" in that no references to it are maintained by this set. (In other words, this method must allocate a new array even if this set is backed by an array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.Set.toArray	(	T[]	): Returns an array containing all of the elements in this set; the runtime type of the returned array is that of the specified array. If the set fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this set. If this set fits in the specified array with room to spare (i.e., the array has more elements than this set), the element in the array immediately following the end of the set is set to null. (This is useful in determining the length of this set only if the caller knows that this set does not contain any null elements.) If this set makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a set known to contain only strings. The following code can be used to dump the set into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.SimpleTimeZone: SimpleTimeZone is a concrete subclass of TimeZone that represents a time zone for use with a Gregorian calendar. The class holds an offset from GMT, called raw offset, and start and end rules for a daylight saving time schedule. Since it only holds single values for each, it cannot handle historical changes in the offset from GMT and the daylight saving schedule, except that the setStartYear method can specify the year when the daylight saving time schedule starts in effect.  To construct a SimpleTimeZone with a daylight saving time schedule, the schedule can be described with a set of rules, start-rule and end-rule. A day when daylight saving time starts or ends is specified by a combination of month, day-of-month, and day-of-week values. The month value is represented by a Calendar MONTH field value, such as MARCH. The day-of-week value is represented by a Calendar DAY_OF_WEEK value, such as SUNDAY. The meanings of value combinations are as follows.  Exact day of month To specify an exact day of month, set the month and day-of-month to an exact value, and day-of-week to zero. For example, to specify March 1, set the month to MARCH , day-of-month to 1, and day-of-week to 0. Day of week on or after day of month To specify a day of week on or after an exact day of month, set the month to an exact month value, day-of-month to the day on or after which the rule is applied, and day-of-week to a negative DAY_OF_WEEK field value. For example, to specify the second Sunday of April, set month to APRIL, day-of-month to 8, and day-of-week to -SUNDAY. Day of week on or before day of month To specify a day of the week on or before an exact day of the month, set day-of-month and day-of-week to a negative value. For example, to specify the last Wednesday on or before the 21st of March, set month to MARCH, day-of-month is -21 and day-of-week is -WEDNESDAY.  Last day-of-week of month To specify, the last day-of-week of the month, set day-of-week to a DAY_OF_WEEK value and day-of-month to -1. For example, to specify the last Sunday of October, set month to OCTOBER, day-of-week to SUNDAY and day-of-month to -1.   The time of the day at which daylight saving time starts or ends is specified by a millisecond value within the day. There are three kinds of modes to specify the time: WALL_TIME, STANDARD_TIME and UTC_TIME. For example, if daylight saving time ends at 2:00 am in the wall clock time, it can be specified by 7200000 milliseconds in the WALL_TIME mode. In this case, the wall clock time for an end-rule means the same thing as the daylight time.  The following are examples of parameters for constructing time zone objects.  // Base GMT offset: -8:00 // DST starts: at 2:00am in standard time // on the first Sunday in April // DST ends: at 2:00am in daylight time // on the last Sunday in October // Save: 1 hour SimpleTimeZone(-28800000, "America/Los_Angeles", Calendar.APRIL, 1, -Calendar.SUNDAY, 7200000, Calendar.OCTOBER, -1, Calendar.SUNDAY, 7200000, 3600000) // Base GMT offset: +1:00 // DST starts: at 1:00am in UTC time // on the last Sunday in March // DST ends: at 1:00am in UTC time // on the last Sunday in October // Save: 1 hour SimpleTimeZone(3600000, "Europe/Paris", Calendar.MARCH, -1, Calendar.SUNDAY, 3600000, SimpleTimeZone.UTC_TIME, Calendar.OCTOBER, -1, Calendar.SUNDAY, 3600000, SimpleTimeZone.UTC_TIME, 3600000)  These parameter rules are also applicable to the set rule methods, such as setStartRule.
java.util.SimpleTimeZone.SimpleTimeZone	(	int	String	): Constructs a SimpleTimeZone with the given base time zone offset from GMT and time zone ID with no daylight saving time schedule.
java.util.SimpleTimeZone.SimpleTimeZone	(	int	String	int	int	int	int	int	int	int	int	): Constructs a SimpleTimeZone with the given base time zone offset from GMT, time zone ID, and rules for starting and ending the daylight time. Both startTime and endTime are specified to be represented in the wall clock time. The amount of daylight saving is assumed to be 3600000 milliseconds (i.e., one hour). This constructor is equivalent to:  SimpleTimeZone(rawOffset, ID, startMonth, startDay, startDayOfWeek, startTime, SimpleTimeZone.WALL_TIME, endMonth, endDay, endDayOfWeek, endTime, SimpleTimeZone.WALL_TIME, 3600000) 
java.util.SimpleTimeZone.SimpleTimeZone	(	int	String	int	int	int	int	int	int	int	int	int	): Constructs a SimpleTimeZone with the given base time zone offset from GMT, time zone ID, and rules for starting and ending the daylight time. Both startTime and endTime are assumed to be represented in the wall clock time. This constructor is equivalent to:  SimpleTimeZone(rawOffset, ID, startMonth, startDay, startDayOfWeek, startTime, SimpleTimeZone.WALL_TIME, endMonth, endDay, endDayOfWeek, endTime, SimpleTimeZone.WALL_TIME, dstSavings) 
java.util.SimpleTimeZone.SimpleTimeZone	(	int	String	int	int	int	int	int	int	int	int	int	int	int	): Constructs a SimpleTimeZone with the given base time zone offset from GMT, time zone ID, and rules for starting and ending the daylight time. This constructor takes the full set of the start and end rules parameters, including modes of startTime and endTime. The mode specifies either WALL_TIME wall time or STANDARD_TIME standard time or UTC_TIME UTC time.
java.util.SimpleTimeZone.clone	(	): Returns a clone of this SimpleTimeZone instance.
java.util.SimpleTimeZone.decodeEndRule	(	): Decode the end rule and validate the parameters. This method is exactly analogous to decodeStartRule().
java.util.SimpleTimeZone.decodeRules	(	): Given a set of encoded rules in startDay and startDayOfMonth, decode them and set the startMode appropriately. Do the same for endDay and endDayOfMonth. Upon entry, the day of week variables may be zero or negative, in order to indicate special modes. The day of month variables may also be negative. Upon exit, the mode variables will be set, and the day of week and day of month variables will be positive. This method also recognizes a startDay or endDay of zero as indicating no DST.
java.util.SimpleTimeZone.decodeStartRule	(	): Decode the start rule and validate the parameters. The parameters are expected to be in encoded form, which represents the various rule modes by negating or zeroing certain values. Representation formats are:   DOW_IN_MONTH DOM DOW>=DOM DOW<=DOM no DST ------------ ----- -------- -------- ---------- month 0..11 same same same don't care day -5..5 1..31 1..31 -1..-31 0 dayOfWeek 1..7 0 -1..-7 -1..-7 don't care time 0..ONEDAY same same same don't care  The range for month does not include UNDECIMBER since this class is really specific to GregorianCalendar, which does not use that month. The range for time includes ONEDAY (vs. ending at ONEDAY-1) because the end rule is an exclusive limit point. That is, the range of times that are in DST include those >= the start and < the end. For this reason, it should be possible to specify an end of ONEDAY in order to include the entire day. Although this is equivalent to time 0 of the following day, it's not always possible to specify that, for example, on December 31. While arguably the start range should still be 0..ONEDAY-1, we keep the start and end ranges the same for consistency.
java.util.SimpleTimeZone.equals	(	Object	): Compares the equality of two SimpleTimeZone objects.
java.util.SimpleTimeZone.getDSTSavings	(	): Returns the amount of time in milliseconds that the clock is advanced during daylight saving time.
java.util.SimpleTimeZone.getOffset	(	int	int	int	int	int	int	): Returns the difference in milliseconds between local time and UTC, taking into account both the raw offset and the effect of daylight saving, for the specified date and time. This method assumes that the start and end month are distinct. It also uses a default GregorianCalendar object as its underlying calendar, such as for determining leap years. Do not use the result of this method with a calendar other than a default GregorianCalendar. Note: In general, clients should use Calendar.get(ZONE_OFFSET) + Calendar.get(DST_OFFSET) instead of calling this method.
java.util.SimpleTimeZone.getOffset	(	long	): Returns the offset of this time zone from UTC at the given time. If daylight saving time is in effect at the given time, the offset value is adjusted with the amount of daylight saving.
java.util.SimpleTimeZone.getOffsets	(	long	int[]	): Gets the raw GMT offset and the amount of daylight saving of this time zone at the given time.
java.util.SimpleTimeZone.getRawOffset	(	): Gets the GMT offset for this time zone.
java.util.SimpleTimeZone.hasSameRules	(	TimeZone	): Returns true if this zone has the same rules and offset as another zone.
java.util.SimpleTimeZone.hashCode	(	): Generates the hash code for the SimpleDateFormat object.
java.util.SimpleTimeZone.inDaylightTime	(	Date	): Queries if the given date is in daylight saving time.
java.util.SimpleTimeZone.makeRulesCompatible	(	): Make rules compatible to 1.1 FCS code. Since 1.1 FCS code only understands day-of-week-in-month rules, we must modify other modes of rules to their approximate equivalent in 1.1 FCS terms. This method is used when streaming out objects of this class. After it is called, the rules will be modified, with a possible loss of information. startMode and endMode will NOT be altered, even though semantically they should be set to DOW_IN_MONTH_MODE, since the rule modification is only intended to be temporary.
java.util.SimpleTimeZone.observesDaylightTime	(	): Returns true if this SimpleTimeZone observes Daylight Saving Time. This method is equivalent to useDaylightTime().
java.util.SimpleTimeZone.packRules	(	): Pack the start and end rules into an array of bytes. Only pack data which is not preserved by makeRulesCompatible.
java.util.SimpleTimeZone.packTimes	(	): Pack the start and end times into an array of bytes. This is required as of serial version 2.
java.util.SimpleTimeZone.readObject	(	ObjectInputStream	): Reconstitute this object from a stream (i.e., deserialize it). We handle both JDK 1.1 binary formats and full formats with a packed byte array.
java.util.SimpleTimeZone.setDSTSavings	(	int	): Sets the amount of time in milliseconds that the clock is advanced during daylight saving time.
java.util.SimpleTimeZone.setEndRule	(	int	int	int	): Sets the daylight saving time end rule to a fixed date within a month. This method is equivalent to: setEndRule(endMonth, endDay, 0, endTime)
java.util.SimpleTimeZone.setEndRule	(	int	int	int	int	): Sets the daylight saving time end rule. For example, if daylight saving time ends on the last Sunday in October at 2 am in wall clock time, you can set the end rule by calling: setEndRule(Calendar.OCTOBER, -1, Calendar.SUNDAY, 2*60*60*1000);
java.util.SimpleTimeZone.setEndRule	(	int	int	int	int	boolean	): Sets the daylight saving time end rule to a weekday before or after the given date within a month, e.g., the first Monday on or after the 8th.
java.util.SimpleTimeZone.setRawOffset	(	int	): Sets the base time zone offset to GMT. This is the offset to add to UTC to get local time.
java.util.SimpleTimeZone.setStartRule	(	int	int	int	): Sets the daylight saving time start rule to a fixed date within a month. This method is equivalent to: setStartRule(startMonth, startDay, 0, startTime)
java.util.SimpleTimeZone.setStartRule	(	int	int	int	int	): Sets the daylight saving time start rule. For example, if daylight saving time starts on the first Sunday in April at 2 am in local wall clock time, you can set the start rule by calling: setStartRule(Calendar.APRIL, 1, Calendar.SUNDAY, 2*60*60*1000);
java.util.SimpleTimeZone.setStartRule	(	int	int	int	int	boolean	): Sets the daylight saving time start rule to a weekday before or after the given date within a month, e.g., the first Monday on or after the 8th.
java.util.SimpleTimeZone.setStartYear	(	int	): Sets the daylight saving time starting year.
java.util.SimpleTimeZone.toString	(	): Returns a string representation of this time zone.
java.util.SimpleTimeZone.unpackRules	(	byte[]	): Given an array of bytes produced by packRules, interpret them as the start and end rules.
java.util.SimpleTimeZone.unpackTimes	(	int[]	): Unpack the start and end times from an array of bytes. This is required as of serial version 2.
java.util.SimpleTimeZone.useDaylightTime	(	): Queries if this time zone uses daylight saving time.
java.util.SimpleTimeZone.writeObject	(	ObjectOutputStream	): Save the state of this object to a stream (i.e., serialize it).
java.util.SortedMap: A Map that further provides a total ordering on its keys. The map is ordered according to the Comparable natural ordering of its keys, or by a Comparator typically provided at sorted map creation time. This order is reflected when iterating over the sorted map's collection views (returned by the entrySet, keySet and values methods). Several additional operations are provided to take advantage of the ordering. (This interface is the map analogue of SortedSet.) All keys inserted into a sorted map must implement the Comparable interface (or be accepted by the specified comparator). Furthermore, all such keys must be mutually comparable: k1.compareTo(k2) (or comparator.compare(k1, k2)) must not throw a ClassCastException for any keys k1 and k2 in the sorted map. Attempts to violate this restriction will cause the offending method or constructor invocation to throw a ClassCastException. Note that the ordering maintained by a sorted map (whether or not an explicit comparator is provided) must be consistent with equals if the sorted map is to correctly implement the Map interface. (See the Comparable interface or Comparator interface for a precise definition of consistent with equals.) This is so because the Map interface is defined in terms of the equals operation, but a sorted map performs all key comparisons using its compareTo (or compare) method, so two keys that are deemed equal by this method are, from the standpoint of the sorted map, equal. The behavior of a tree map is well-defined even if its ordering is inconsistent with equals; it just fails to obey the general contract of the Map interface. All general-purpose sorted map implementation classes should provide four "standard" constructors. It is not possible to enforce this recommendation though as required constructors cannot be specified by interfaces. The expected "standard" constructors for all sorted map implementations are:  A void (no arguments) constructor, which creates an empty sorted map sorted according to the natural ordering of its keys. A constructor with a single argument of type Comparator, which creates an empty sorted map sorted according to the specified comparator. A constructor with a single argument of type Map, which creates a new map with the same key-value mappings as its argument, sorted according to the keys' natural ordering. A constructor with a single argument of type SortedMap, which creates a new sorted map with the same key-value mappings and the same ordering as the input sorted map.  Note: several methods return submaps with restricted key ranges. Such ranges are half-open, that is, they include their low endpoint but not their high endpoint (where applicable). If you need a closed range (which includes both endpoints), and the key type allows for calculation of the successor of a given key, merely request the subrange from lowEndpoint to successor(highEndpoint). For example, suppose that m is a map whose keys are strings. The following idiom obtains a view containing all of the key-value mappings in m whose keys are between low and high, inclusive: SortedMap<String, V> sub = m.subMap(low, high+"\0"); A similar technique can be used to generate an open range (which contains neither endpoint). The following idiom obtains a view containing all of the key-value mappings in m whose keys are between low and high, exclusive: SortedMap<String, V> sub = m.subMap(low+"\0", high); This interface is a member of the  Java Collections Framework.
java.util.SortedMap.comparator	(	): Returns the comparator used to order the keys in this map, or null if this map uses the Comparable natural ordering of its keys.
java.util.SortedMap.entrySet	(	): Returns a Set view of the mappings contained in this map. The set's iterator returns the entries in ascending key order. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation, or through the setValue operation on a map entry returned by the iterator) the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.SortedMap.firstKey	(	): Returns the first (lowest) key currently in this map.
java.util.SortedMap.headMap	(	K	): Returns a view of the portion of this map whose keys are strictly less than toKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range.
java.util.SortedMap.keySet	(	): Returns a Set view of the keys contained in this map. The set's iterator returns the keys in ascending order. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.SortedMap.lastKey	(	): Returns the last (highest) key currently in this map.
java.util.SortedMap.subMap	(	K	K	): Returns a view of the portion of this map whose keys range from fromKey, inclusive, to toKey, exclusive. (If fromKey and toKey are equal, the returned map is empty.) The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range.
java.util.SortedMap.tailMap	(	K	): Returns a view of the portion of this map whose keys are greater than or equal to fromKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range.
java.util.SortedMap.values	(	): Returns a Collection view of the values contained in this map. The collection's iterator returns the values in ascending order of the corresponding keys. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.SortedSet: A Set that further provides a total ordering on its elements. The elements are ordered using their Comparable natural ordering, or by a Comparator typically provided at sorted set creation time. The set's iterator will traverse the set in ascending element order. Several additional operations are provided to take advantage of the ordering. (This interface is the set analogue of SortedMap.) All elements inserted into a sorted set must implement the Comparable interface (or be accepted by the specified comparator). Furthermore, all such elements must be mutually comparable: e1.compareTo(e2) (or comparator.compare(e1, e2)) must not throw a ClassCastException for any elements e1 and e2 in the sorted set. Attempts to violate this restriction will cause the offending method or constructor invocation to throw a ClassCastException. Note that the ordering maintained by a sorted set (whether or not an explicit comparator is provided) must be consistent with equals if the sorted set is to correctly implement the Set interface. (See the Comparable interface or Comparator interface for a precise definition of consistent with equals.) This is so because the Set interface is defined in terms of the equals operation, but a sorted set performs all element comparisons using its compareTo (or compare) method, so two elements that are deemed equal by this method are, from the standpoint of the sorted set, equal. The behavior of a sorted set is well-defined even if its ordering is inconsistent with equals; it just fails to obey the general contract of the Set interface. All general-purpose sorted set implementation classes should provide four "standard" constructors: 1) A void (no arguments) constructor, which creates an empty sorted set sorted according to the natural ordering of its elements. 2) A constructor with a single argument of type Comparator, which creates an empty sorted set sorted according to the specified comparator. 3) A constructor with a single argument of type Collection, which creates a new sorted set with the same elements as its argument, sorted according to the natural ordering of the elements. 4) A constructor with a single argument of type SortedSet, which creates a new sorted set with the same elements and the same ordering as the input sorted set. There is no way to enforce this recommendation, as interfaces cannot contain constructors. Note: several methods return subsets with restricted ranges. Such ranges are half-open, that is, they include their low endpoint but not their high endpoint (where applicable). If you need a closed range (which includes both endpoints), and the element type allows for calculation of the successor of a given value, merely request the subrange from lowEndpoint to successor(highEndpoint). For example, suppose that s is a sorted set of strings. The following idiom obtains a view containing all of the strings in s from low to high, inclusive: SortedSet<String> sub = s.subSet(low, high+"\0"); A similar technique can be used to generate an open range (which contains neither endpoint). The following idiom obtains a view containing all of the Strings in s from low to high, exclusive: SortedSet<String> sub = s.subSet(low+"\0", high); This interface is a member of the  Java Collections Framework.
java.util.SortedSet.comparator	(	): Returns the comparator used to order the elements in this set, or null if this set uses the Comparable natural ordering of its elements.
java.util.SortedSet.first	(	): Returns the first (lowest) element currently in this set.
java.util.SortedSet.headSet	(	E	): Returns a view of the portion of this set whose elements are strictly less than toElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range.
java.util.SortedSet.last	(	): Returns the last (highest) element currently in this set.
java.util.SortedSet.spliterator	(	): Creates a Spliterator over the elements in this sorted set. The Spliterator reports DISTINCT, SORTED and ORDERED. Implementations should document the reporting of additional characteristic values. The spliterator's comparator (see getComparator()) must be null if the sorted set's comparator (see comparator()) is null. Otherwise, the spliterator's comparator must be the same as or impose the same total ordering as the sorted set's comparator.
java.util.SortedSet.subSet	(	E	E	): Returns a view of the portion of this set whose elements range from fromElement, inclusive, to toElement, exclusive. (If fromElement and toElement are equal, the returned set is empty.) The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range.
java.util.SortedSet.tailSet	(	E	): Returns a view of the portion of this set whose elements are greater than or equal to fromElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range.
java.util.Spliterator: An object for traversing and partitioning elements of a source. The source of elements covered by a Spliterator could be, for example, an array, a Collection, an IO channel, or a generator function. A Spliterator may traverse elements individually (tryAdvance tryAdvance()) or sequentially in bulk (forEachRemaining forEachRemaining()). A Spliterator may also partition off some of its elements (using trySplit) as another Spliterator, to be used in possibly-parallel operations. Operations using a Spliterator that cannot split, or does so in a highly imbalanced or inefficient manner, are unlikely to benefit from parallelism. Traversal and splitting exhaust elements; each Spliterator is useful for only a single bulk computation. A Spliterator also reports a set of characteristics() of its structure, source, and elements from among ORDERED, DISTINCT, SORTED, SIZED, NONNULL, IMMUTABLE, CONCURRENT, and SUBSIZED. These may be employed by Spliterator clients to control, specialize or simplify computation. For example, a Spliterator for a Collection would report SIZED, a Spliterator for a Set would report DISTINCT, and a Spliterator for a SortedSet would also report SORTED. Characteristics are reported as a simple unioned bit set. Some characteristics additionally constrain method behavior; for example if ORDERED, traversal methods must conform to their documented ordering. New characteristics may be defined in the future, so implementors should not assign meanings to unlisted values. A Spliterator that does not report IMMUTABLE or CONCURRENT is expected to have a documented policy concerning: when the spliterator binds to the element source; and detection of structural interference of the element source detected after binding. A late-binding Spliterator binds to the source of elements at the point of first traversal, first split, or first query for estimated size, rather than at the time the Spliterator is created. A Spliterator that is not late-binding binds to the source of elements at the point of construction or first invocation of any method. Modifications made to the source prior to binding are reflected when the Spliterator is traversed. After binding a Spliterator should, on a best-effort basis, throw ConcurrentModificationException if structural interference is detected. Spliterators that do this are called fail-fast. The bulk traversal method (forEachRemaining forEachRemaining()) of a Spliterator may optimize traversal and check for structural interference after all elements have been traversed, rather than checking per-element and failing immediately. Spliterators can provide an estimate of the number of remaining elements via the estimateSize method. Ideally, as reflected in characteristic SIZED, this value corresponds exactly to the number of elements that would be encountered in a successful traversal. However, even when not exactly known, an estimated value value may still be useful to operations being performed on the source, such as helping to determine whether it is preferable to split further or traverse the remaining elements sequentially. Despite their obvious utility in parallel algorithms, spliterators are not expected to be thread-safe; instead, implementations of parallel algorithms using spliterators should ensure that the spliterator is only used by one thread at a time. This is generally easy to attain via serial thread-confinement, which often is a natural consequence of typical parallel algorithms that work by recursive decomposition. A thread calling trySplit() may hand over the returned Spliterator to another thread, which in turn may traverse or further split that Spliterator. The behaviour of splitting and traversal is undefined if two or more threads operate concurrently on the same spliterator. If the original thread hands a spliterator off to another thread for processing, it is best if that handoff occurs before any elements are consumed with tryAdvance() tryAdvance(), as certain guarantees (such as the accuracy of estimateSize() for SIZED spliterators) are only valid before traversal has begun. Primitive subtype specializations of Spliterator are provided for OfInt int, OfLong long, and OfDouble double values. The subtype default implementations of tryAdvance() and forEachRemaining() box primitive values to instances of their corresponding wrapper class. Such boxing may undermine any performance advantages gained by using the primitive specializations. To avoid boxing, the corresponding primitive-based methods should be used. For example, tryAdvance() and forEachRemaining() should be used in preference to tryAdvance() and forEachRemaining(). Traversal of primitive values using boxing-based methods tryAdvance tryAdvance() and forEachRemaining() forEachRemaining() does not affect the order in which the values, transformed to boxed values, are encountered.
java.util.Spliterator.OfDouble: A Spliterator specialized for double values.
java.util.Spliterator.OfDouble.forEachRemaining	(	Consumer	): Performs the given action for each remaining element, sequentially in the current thread, until all elements have been processed or the action throws an exception. If this Spliterator is ORDERED, actions are performed in encounter order. Exceptions thrown by the action are relayed to the caller.
java.util.Spliterator.OfDouble.tryAdvance	(	Consumer	): If a remaining element exists, performs the given action on it, returning true; else returns false. If this Spliterator is ORDERED the action is performed on the next element in encounter order. Exceptions thrown by the action are relayed to the caller.
java.util.Spliterator.OfInt: A Spliterator specialized for int values.
java.util.Spliterator.OfInt.forEachRemaining	(	Consumer	): Performs the given action for each remaining element, sequentially in the current thread, until all elements have been processed or the action throws an exception. If this Spliterator is ORDERED, actions are performed in encounter order. Exceptions thrown by the action are relayed to the caller.
java.util.Spliterator.OfInt.tryAdvance	(	Consumer	): If a remaining element exists, performs the given action on it, returning true; else returns false. If this Spliterator is ORDERED the action is performed on the next element in encounter order. Exceptions thrown by the action are relayed to the caller.
java.util.Spliterator.OfLong: A Spliterator specialized for long values.
java.util.Spliterator.OfLong.forEachRemaining	(	Consumer	): Performs the given action for each remaining element, sequentially in the current thread, until all elements have been processed or the action throws an exception. If this Spliterator is ORDERED, actions are performed in encounter order. Exceptions thrown by the action are relayed to the caller.
java.util.Spliterator.OfLong.tryAdvance	(	Consumer	): If a remaining element exists, performs the given action on it, returning true; else returns false. If this Spliterator is ORDERED the action is performed on the next element in encounter order. Exceptions thrown by the action are relayed to the caller.
java.util.Spliterator.OfPrimitive: A Spliterator specialized for primitive values.
java.util.Spliterator.OfPrimitive.forEachRemaining	(	T_CONS	): Performs the given action for each remaining element, sequentially in the current thread, until all elements have been processed or the action throws an exception. If this Spliterator is ORDERED, actions are performed in encounter order. Exceptions thrown by the action are relayed to the caller.
java.util.Spliterator.OfPrimitive.tryAdvance	(	T_CONS	): If a remaining element exists, performs the given action on it, returning true; else returns false. If this Spliterator is ORDERED the action is performed on the next element in encounter order. Exceptions thrown by the action are relayed to the caller.
java.util.Spliterator.characteristics	(	): Returns a set of characteristics of this Spliterator and its elements. The result is represented as ORed values from ORDERED, DISTINCT, SORTED, SIZED, NONNULL, IMMUTABLE, CONCURRENT, SUBSIZED. Repeated calls to characteristics() on a given spliterator, prior to or in-between calls to trySplit, should always return the same result. If a Spliterator reports an inconsistent set of characteristics (either those returned from a single invocation or across multiple invocations), no guarantees can be made about any computation using this Spliterator.
java.util.Spliterator.estimateSize	(	): Returns an estimate of the number of elements that would be encountered by a forEachRemaining traversal, or returns MAX_VALUE if infinite, unknown, or too expensive to compute. If this Spliterator is SIZED and has not yet been partially traversed or split, or this Spliterator is SUBSIZED and has not yet been partially traversed, this estimate must be an accurate count of elements that would be encountered by a complete traversal. Otherwise, this estimate may be arbitrarily inaccurate, but must decrease as specified across invocations of trySplit.
java.util.Spliterator.forEachRemaining	(	Consumer	): Performs the given action for each remaining element, sequentially in the current thread, until all elements have been processed or the action throws an exception. If this Spliterator is ORDERED, actions are performed in encounter order. Exceptions thrown by the action are relayed to the caller.
java.util.Spliterator.getComparator	(	): If this Spliterator's source is SORTED by a Comparator, returns that Comparator. If the source is SORTED in Comparable natural order, returns null. Otherwise, if the source is not SORTED, throws IllegalStateException.
java.util.Spliterator.getExactSizeIfKnown	(	): Convenience method that returns estimateSize() if this Spliterator is SIZED, else -1.
java.util.Spliterator.hasCharacteristics	(	int	): Returns true if this Spliterator's characteristics contain all of the given characteristics.
java.util.Spliterator.tryAdvance	(	Consumer	): If a remaining element exists, performs the given action on it, returning true; else returns false. If this Spliterator is ORDERED the action is performed on the next element in encounter order. Exceptions thrown by the action are relayed to the caller.
java.util.Spliterator.trySplit	(	): If this spliterator can be partitioned, returns a Spliterator covering elements, that will, upon return from this method, not be covered by this Spliterator. If this Spliterator is ORDERED, the returned Spliterator must cover a strict prefix of the elements. Unless this Spliterator covers an infinite number of elements, repeated calls to trySplit() must eventually return null. Upon non-null return:  the value reported for estimateSize() before splitting, must, after splitting, be greater than or equal to estimateSize() for this and the returned Spliterator; and if this Spliterator is SUBSIZED, then estimateSize() for this spliterator before splitting must be equal to the sum of estimateSize() for this and the returned Spliterator after splitting.  This method may return null for any reason, including emptiness, inability to split after traversal has commenced, data structure constraints, and efficiency considerations.
java.util.Spliterators: Static classes and methods for operating on or creating instances of Spliterator and its primitive specializations Spliterator.OfInt, Spliterator.OfLong, and Spliterator.OfDouble.
java.util.Spliterators.AbstractDoubleSpliterator: An abstract Spliterator.OfDouble that implements trySplit to permit limited parallelism. To implement a spliterator an extending class need only implement tryAdvance() tryAdvance}. The extending class should override forEachRemaining() forEach} if it can provide a more performant implementation.
java.util.Spliterators.AbstractDoubleSpliterator.AbstractDoubleSpliterator	(	long	int	): Creates a spliterator reporting the given estimated size and characteristics.
java.util.Spliterators.AbstractDoubleSpliterator.characteristics	(	): Returns a set of characteristics of this Spliterator and its elements. The result is represented as ORed values from ORDERED, DISTINCT, SORTED, SIZED, NONNULL, IMMUTABLE, CONCURRENT, SUBSIZED. Repeated calls to characteristics() on a given spliterator, prior to or in-between calls to trySplit, should always return the same result. If a Spliterator reports an inconsistent set of characteristics (either those returned from a single invocation or across multiple invocations), no guarantees can be made about any computation using this Spliterator.
java.util.Spliterators.AbstractDoubleSpliterator.estimateSize	(	): Returns an estimate of the number of elements that would be encountered by a forEachRemaining traversal, or returns MAX_VALUE if infinite, unknown, or too expensive to compute. If this Spliterator is SIZED and has not yet been partially traversed or split, or this Spliterator is SUBSIZED and has not yet been partially traversed, this estimate must be an accurate count of elements that would be encountered by a complete traversal. Otherwise, this estimate may be arbitrarily inaccurate, but must decrease as specified across invocations of trySplit.
java.util.Spliterators.AbstractDoubleSpliterator.trySplit	(	):  This implementation permits limited parallelism.
java.util.Spliterators.AbstractIntSpliterator: An abstract Spliterator.OfInt that implements trySplit to permit limited parallelism. To implement a spliterator an extending class need only implement tryAdvance() tryAdvance}. The extending class should override forEachRemaining() forEach} if it can provide a more performant implementation.
java.util.Spliterators.AbstractIntSpliterator.AbstractIntSpliterator	(	long	int	): Creates a spliterator reporting the given estimated size and characteristics.
java.util.Spliterators.AbstractIntSpliterator.characteristics	(	): Returns a set of characteristics of this Spliterator and its elements. The result is represented as ORed values from ORDERED, DISTINCT, SORTED, SIZED, NONNULL, IMMUTABLE, CONCURRENT, SUBSIZED. Repeated calls to characteristics() on a given spliterator, prior to or in-between calls to trySplit, should always return the same result. If a Spliterator reports an inconsistent set of characteristics (either those returned from a single invocation or across multiple invocations), no guarantees can be made about any computation using this Spliterator.
java.util.Spliterators.AbstractIntSpliterator.estimateSize	(	): Returns an estimate of the number of elements that would be encountered by a forEachRemaining traversal, or returns MAX_VALUE if infinite, unknown, or too expensive to compute. If this Spliterator is SIZED and has not yet been partially traversed or split, or this Spliterator is SUBSIZED and has not yet been partially traversed, this estimate must be an accurate count of elements that would be encountered by a complete traversal. Otherwise, this estimate may be arbitrarily inaccurate, but must decrease as specified across invocations of trySplit.
java.util.Spliterators.AbstractIntSpliterator.trySplit	(	):  This implementation permits limited parallelism.
java.util.Spliterators.AbstractLongSpliterator: An abstract Spliterator.OfLong that implements trySplit to permit limited parallelism. To implement a spliterator an extending class need only implement tryAdvance() tryAdvance}. The extending class should override forEachRemaining() forEach} if it can provide a more performant implementation.
java.util.Spliterators.AbstractLongSpliterator.AbstractLongSpliterator	(	long	int	): Creates a spliterator reporting the given estimated size and characteristics.
java.util.Spliterators.AbstractLongSpliterator.characteristics	(	): Returns a set of characteristics of this Spliterator and its elements. The result is represented as ORed values from ORDERED, DISTINCT, SORTED, SIZED, NONNULL, IMMUTABLE, CONCURRENT, SUBSIZED. Repeated calls to characteristics() on a given spliterator, prior to or in-between calls to trySplit, should always return the same result. If a Spliterator reports an inconsistent set of characteristics (either those returned from a single invocation or across multiple invocations), no guarantees can be made about any computation using this Spliterator.
java.util.Spliterators.AbstractLongSpliterator.estimateSize	(	): Returns an estimate of the number of elements that would be encountered by a forEachRemaining traversal, or returns MAX_VALUE if infinite, unknown, or too expensive to compute. If this Spliterator is SIZED and has not yet been partially traversed or split, or this Spliterator is SUBSIZED and has not yet been partially traversed, this estimate must be an accurate count of elements that would be encountered by a complete traversal. Otherwise, this estimate may be arbitrarily inaccurate, but must decrease as specified across invocations of trySplit.
java.util.Spliterators.AbstractLongSpliterator.trySplit	(	):  This implementation permits limited parallelism.
java.util.Spliterators.AbstractSpliterator: An abstract Spliterator that implements trySplit to permit limited parallelism. An extending class need only implement tryAdvance(). The extending class should override forEachRemaining() forEach if it can provide a more performant implementation.
java.util.Spliterators.AbstractSpliterator.AbstractSpliterator	(	long	int	): Creates a spliterator reporting the given estimated size and additionalCharacteristics.
java.util.Spliterators.AbstractSpliterator.characteristics	(	): Returns a set of characteristics of this Spliterator and its elements. The result is represented as ORed values from ORDERED, DISTINCT, SORTED, SIZED, NONNULL, IMMUTABLE, CONCURRENT, SUBSIZED. Repeated calls to characteristics() on a given spliterator, prior to or in-between calls to trySplit, should always return the same result. If a Spliterator reports an inconsistent set of characteristics (either those returned from a single invocation or across multiple invocations), no guarantees can be made about any computation using this Spliterator.
java.util.Spliterators.AbstractSpliterator.estimateSize	(	): Returns an estimate of the number of elements that would be encountered by a forEachRemaining traversal, or returns MAX_VALUE if infinite, unknown, or too expensive to compute. If this Spliterator is SIZED and has not yet been partially traversed or split, or this Spliterator is SUBSIZED and has not yet been partially traversed, this estimate must be an accurate count of elements that would be encountered by a complete traversal. Otherwise, this estimate may be arbitrarily inaccurate, but must decrease as specified across invocations of trySplit.
java.util.Spliterators.AbstractSpliterator.trySplit	(	): If this spliterator can be partitioned, returns a Spliterator covering elements, that will, upon return from this method, not be covered by this Spliterator. If this Spliterator is ORDERED, the returned Spliterator must cover a strict prefix of the elements. Unless this Spliterator covers an infinite number of elements, repeated calls to trySplit() must eventually return null. Upon non-null return:  the value reported for estimateSize() before splitting, must, after splitting, be greater than or equal to estimateSize() for this and the returned Spliterator; and if this Spliterator is SUBSIZED, then estimateSize() for this spliterator before splitting must be equal to the sum of estimateSize() for this and the returned Spliterator after splitting.  This method may return null for any reason, including emptiness, inability to split after traversal has commenced, data structure constraints, and efficiency considerations. This implementation permits limited parallelism.
java.util.Spliterators.ArraySpliterator: A Spliterator designed for use by sources that traverse and split elements maintained in an unmodifiable Object[] array.
java.util.Spliterators.ArraySpliterator.ArraySpliterator	(	Object[]	int	): Creates a spliterator covering all of the given array.
java.util.Spliterators.ArraySpliterator.ArraySpliterator	(	Object[]	int	int	int	): Creates a spliterator covering the given array and range
java.util.Spliterators.DoubleArraySpliterator: A Spliterator.OfDouble designed for use by sources that traverse and split elements maintained in an unmodifiable int[] array.
java.util.Spliterators.DoubleArraySpliterator.DoubleArraySpliterator	(	double[]	int	): Creates a spliterator covering all of the given array.
java.util.Spliterators.DoubleArraySpliterator.DoubleArraySpliterator	(	double[]	int	int	int	): Creates a spliterator covering the given array and range
java.util.Spliterators.DoubleIteratorSpliterator.DoubleIteratorSpliterator	(	PrimitiveIterator.OfDouble	int	): Creates a spliterator using the given iterator for a source of unknown size, reporting the given characteristics.
java.util.Spliterators.DoubleIteratorSpliterator.DoubleIteratorSpliterator	(	PrimitiveIterator.OfDouble	long	int	): Creates a spliterator using the given iterator for traversal, and reporting the given initial size and characteristics.
java.util.Spliterators.IntArraySpliterator: A Spliterator.OfInt designed for use by sources that traverse and split elements maintained in an unmodifiable int[] array.
java.util.Spliterators.IntArraySpliterator.IntArraySpliterator	(	int[]	int	): Creates a spliterator covering all of the given array.
java.util.Spliterators.IntArraySpliterator.IntArraySpliterator	(	int[]	int	int	int	): Creates a spliterator covering the given array and range
java.util.Spliterators.IntIteratorSpliterator: A Spliterator.OfInt using a given IntStream.IntIterator for element operations. The spliterator implements trySplit to permit limited parallelism.
java.util.Spliterators.IntIteratorSpliterator.IntIteratorSpliterator	(	PrimitiveIterator.OfInt	int	): Creates a spliterator using the given iterator for a source of unknown size, reporting the given characteristics.
java.util.Spliterators.IntIteratorSpliterator.IntIteratorSpliterator	(	PrimitiveIterator.OfInt	long	int	): Creates a spliterator using the given iterator for traversal, and reporting the given initial size and characteristics.
java.util.Spliterators.IteratorSpliterator: A Spliterator using a given Iterator for element operations. The spliterator implements trySplit to permit limited parallelism.
java.util.Spliterators.IteratorSpliterator.IteratorSpliterator	(	Collection	int	): Creates a spliterator using the given given collection's java.util.Collection#iterator()) for traversal, and reporting its java.util.Collection#size()) as its initial size.
java.util.Spliterators.IteratorSpliterator.IteratorSpliterator	(	Iterator	int	): Creates a spliterator using the given iterator for traversal, and reporting the given initial size and characteristics.
java.util.Spliterators.IteratorSpliterator.IteratorSpliterator	(	Iterator	long	int	): Creates a spliterator using the given iterator for traversal, and reporting the given initial size and characteristics.
java.util.Spliterators.LongArraySpliterator: A Spliterator.OfLong designed for use by sources that traverse and split elements maintained in an unmodifiable int[] array.
java.util.Spliterators.LongArraySpliterator.LongArraySpliterator	(	long[]	int	): Creates a spliterator covering all of the given array.
java.util.Spliterators.LongArraySpliterator.LongArraySpliterator	(	long[]	int	int	int	): Creates a spliterator covering the given array and range
java.util.Spliterators.LongIteratorSpliterator.LongIteratorSpliterator	(	PrimitiveIterator.OfLong	int	): Creates a spliterator using the given iterator for a source of unknown size, reporting the given characteristics.
java.util.Spliterators.LongIteratorSpliterator.LongIteratorSpliterator	(	PrimitiveIterator.OfLong	long	int	): Creates a spliterator using the given iterator for traversal, and reporting the given initial size and characteristics.
java.util.Spliterators.checkFromToBounds	(	int	int	int	): Validate inclusive start index and exclusive end index against the length of an array.
java.util.Spliterators.emptyDoubleSpliterator	(	): Creates an empty Spliterator.OfDouble The empty spliterator reports SIZED and SUBSIZED. Calls to trySplit() always return null.
java.util.Spliterators.emptyIntSpliterator	(	): Creates an empty Spliterator.OfInt The empty spliterator reports SIZED and SUBSIZED. Calls to trySplit() always return null.
java.util.Spliterators.emptyLongSpliterator	(	): Creates an empty Spliterator.OfLong The empty spliterator reports SIZED and SUBSIZED. Calls to trySplit() always return null.
java.util.Spliterators.emptySpliterator	(	): Creates an empty Spliterator The empty spliterator reports SIZED and SUBSIZED. Calls to trySplit() always return null.
java.util.Spliterators.iterator	(	Spliterator	): Creates an Iterator from a Spliterator. Traversal of elements should be accomplished through the iterator. The behaviour of traversal is undefined if the spliterator is operated after the iterator is returned.
java.util.Spliterators.iterator	(	Spliterator.OfDouble	): Creates an PrimitiveIterator.OfDouble from a Spliterator.OfDouble. Traversal of elements should be accomplished through the iterator. The behaviour of traversal is undefined if the spliterator is operated after the iterator is returned.
java.util.Spliterators.iterator	(	Spliterator.OfInt	): Creates an PrimitiveIterator.OfInt from a Spliterator.OfInt. Traversal of elements should be accomplished through the iterator. The behaviour of traversal is undefined if the spliterator is operated after the iterator is returned.
java.util.Spliterators.iterator	(	Spliterator.OfLong	): Creates an PrimitiveIterator.OfLong from a Spliterator.OfLong. Traversal of elements should be accomplished through the iterator. The behaviour of traversal is undefined if the spliterator is operated after the iterator is returned.
java.util.Spliterators.spliterator	(	Collection	int	): Creates a Spliterator using the given collection's iterator() as the source of elements, and reporting its size() as its initial size. The spliterator is late-binding, inherits the fail-fast properties of the collection's iterator, and implements trySplit to permit limited parallelism.
java.util.Spliterators.spliterator	(	Iterator	long	int	): Creates a Spliterator using a given Iterator as the source of elements, and with a given initially reported size. The spliterator is not late-binding, inherits the fail-fast properties of the iterator, and implements trySplit to permit limited parallelism. Traversal of elements should be accomplished through the spliterator. The behaviour of splitting and traversal is undefined if the iterator is operated on after the spliterator is returned, or the initially reported size is not equal to the actual number of elements in the source.
java.util.Spliterators.spliterator	(	Object[]	int	): Creates a Spliterator covering the elements of a given array, using a customized set of spliterator characteristics. This method is provided as an implementation convenience for Spliterators which store portions of their elements in arrays, and need fine control over Spliterator characteristics. Most other situations in which a Spliterator for an array is needed should use spliterator(). The returned spliterator always reports the characteristics SIZED and SUBSIZED. The caller may provide additional characteristics for the spliterator to report; it is common to additionally specify IMMUTABLE and ORDERED.
java.util.Spliterators.spliterator	(	Object[]	int	int	int	): Creates a Spliterator covering a range of elements of a given array, using a customized set of spliterator characteristics. This method is provided as an implementation convenience for Spliterators which store portions of their elements in arrays, and need fine control over Spliterator characteristics. Most other situations in which a Spliterator for an array is needed should use spliterator(). The returned spliterator always reports the characteristics SIZED and SUBSIZED. The caller may provide additional characteristics for the spliterator to report; it is common to additionally specify IMMUTABLE and ORDERED.
java.util.Spliterators.spliterator	(	PrimitiveIterator.OfDouble	long	int	): Creates a Spliterator.OfDouble using a given DoubleStream.DoubleIterator as the source of elements, and with a given initially reported size. The spliterator is not late-binding, inherits the fail-fast properties of the iterator, and implements trySplit to permit limited parallelism. Traversal of elements should be accomplished through the spliterator. The behaviour of splitting and traversal is undefined if the iterator is operated on after the spliterator is returned, or the initially reported size is not equal to the actual number of elements in the source.
java.util.Spliterators.spliterator	(	PrimitiveIterator.OfInt	long	int	): Creates a Spliterator.OfInt using a given IntStream.IntIterator as the source of elements, and with a given initially reported size. The spliterator is not late-binding, inherits the fail-fast properties of the iterator, and implements trySplit to permit limited parallelism. Traversal of elements should be accomplished through the spliterator. The behaviour of splitting and traversal is undefined if the iterator is operated on after the spliterator is returned, or the initially reported size is not equal to the actual number of elements in the source.
java.util.Spliterators.spliterator	(	PrimitiveIterator.OfLong	long	int	): Creates a Spliterator.OfLong using a given LongStream.LongIterator as the source of elements, and with a given initially reported size. The spliterator is not late-binding, inherits the fail-fast properties of the iterator, and implements trySplit to permit limited parallelism. Traversal of elements should be accomplished through the spliterator. The behaviour of splitting and traversal is undefined if the iterator is operated on after the spliterator is returned, or the initially reported size is not equal to the actual number of elements in the source.
java.util.Spliterators.spliterator	(	double[]	int	): Creates a Spliterator.OfDouble covering the elements of a given array, using a customized set of spliterator characteristics. This method is provided as an implementation convenience for Spliterators which store portions of their elements in arrays, and need fine control over Spliterator characteristics. Most other situations in which a Spliterator for an array is needed should use spliterator(). The returned spliterator always reports the characteristics SIZED and SUBSIZED. The caller may provide additional characteristics for the spliterator to report; it is common to additionally specify IMMUTABLE and ORDERED.
java.util.Spliterators.spliterator	(	double[]	int	int	int	): Creates a Spliterator.OfDouble covering a range of elements of a given array, using a customized set of spliterator characteristics. This method is provided as an implementation convenience for Spliterators which store portions of their elements in arrays, and need fine control over Spliterator characteristics. Most other situations in which a Spliterator for an array is needed should use spliterator(). The returned spliterator always reports the characteristics SIZED and SUBSIZED. The caller may provide additional characteristics for the spliterator to report. (For example, if it is known the array will not be further modified, specify IMMUTABLE; if the array data is considered to have an an encounter order, specify ORDERED). The method spliterator() can often be used instead, which returns a spliterator that reports SIZED, SUBSIZED, IMMUTABLE, and ORDERED.
java.util.Spliterators.spliterator	(	int[]	int	): Creates a Spliterator.OfInt covering the elements of a given array, using a customized set of spliterator characteristics. This method is provided as an implementation convenience for Spliterators which store portions of their elements in arrays, and need fine control over Spliterator characteristics. Most other situations in which a Spliterator for an array is needed should use spliterator(). The returned spliterator always reports the characteristics SIZED and SUBSIZED. The caller may provide additional characteristics for the spliterator to report; it is common to additionally specify IMMUTABLE and ORDERED.
java.util.Spliterators.spliterator	(	int[]	int	int	int	): Creates a Spliterator.OfInt covering a range of elements of a given array, using a customized set of spliterator characteristics. This method is provided as an implementation convenience for Spliterators which store portions of their elements in arrays, and need fine control over Spliterator characteristics. Most other situations in which a Spliterator for an array is needed should use spliterator(). The returned spliterator always reports the characteristics SIZED and SUBSIZED. The caller may provide additional characteristics for the spliterator to report; it is common to additionally specify IMMUTABLE and ORDERED.
java.util.Spliterators.spliterator	(	long[]	int	): Creates a Spliterator.OfLong covering the elements of a given array, using a customized set of spliterator characteristics. This method is provided as an implementation convenience for Spliterators which store portions of their elements in arrays, and need fine control over Spliterator characteristics. Most other situations in which a Spliterator for an array is needed should use spliterator(). The returned spliterator always reports the characteristics SIZED and SUBSIZED. The caller may provide additional characteristics for the spliterator to report; it is common to additionally specify IMMUTABLE and ORDERED.
java.util.Spliterators.spliterator	(	long[]	int	int	int	): Creates a Spliterator.OfLong covering a range of elements of a given array, using a customized set of spliterator characteristics. This method is provided as an implementation convenience for Spliterators which store portions of their elements in arrays, and need fine control over Spliterator characteristics. Most other situations in which a Spliterator for an array is needed should use spliterator(). The returned spliterator always reports the characteristics SIZED and SUBSIZED. The caller may provide additional characteristics for the spliterator to report. (For example, if it is known the array will not be further modified, specify IMMUTABLE; if the array data is considered to have an an encounter order, specify ORDERED). The method spliterator() can often be used instead, which returns a spliterator that reports SIZED, SUBSIZED, IMMUTABLE, and ORDERED.
java.util.Spliterators.spliteratorUnknownSize	(	Iterator	int	): Creates a Spliterator using a given Iterator as the source of elements, with no initial size estimate. The spliterator is not late-binding, inherits the fail-fast properties of the iterator, and implements trySplit to permit limited parallelism. Traversal of elements should be accomplished through the spliterator. The behaviour of splitting and traversal is undefined if the iterator is operated on after the spliterator is returned.
java.util.Spliterators.spliteratorUnknownSize	(	PrimitiveIterator.OfDouble	int	): Creates a Spliterator.OfDouble using a given DoubleStream.DoubleIterator as the source of elements, with no initial size estimate. The spliterator is not late-binding, inherits the fail-fast properties of the iterator, and implements trySplit to permit limited parallelism. Traversal of elements should be accomplished through the spliterator. The behaviour of splitting and traversal is undefined if the iterator is operated on after the spliterator is returned.
java.util.Spliterators.spliteratorUnknownSize	(	PrimitiveIterator.OfInt	int	): Creates a Spliterator.OfInt using a given IntStream.IntIterator as the source of elements, with no initial size estimate. The spliterator is not late-binding, inherits the fail-fast properties of the iterator, and implements trySplit to permit limited parallelism. Traversal of elements should be accomplished through the spliterator. The behaviour of splitting and traversal is undefined if the iterator is operated on after the spliterator is returned.
java.util.Spliterators.spliteratorUnknownSize	(	PrimitiveIterator.OfLong	int	): Creates a Spliterator.OfLong using a given LongStream.LongIterator as the source of elements, with no initial size estimate. The spliterator is not late-binding, inherits the fail-fast properties of the iterator, and implements trySplit to permit limited parallelism. Traversal of elements should be accomplished through the spliterator. The behaviour of splitting and traversal is undefined if the iterator is operated on after the spliterator is returned.
java.util.SplittableRandom: A generator of uniform pseudorandom values applicable for use in (among other contexts) isolated parallel computations that may generate subtasks. Class SplittableRandom supports methods for producing pseudorandom numbers of type int, long, and double with similar usages as for class java.util.Random but differs in the following ways:  Series of generated values pass the DieHarder suite testing independence and uniformity properties of random number generators. (Most recently validated with  version 3.31.1.) These tests validate only the methods for certain types and ranges, but similar properties are expected to hold, at least approximately, for others as well. The period (length of any series of generated values before it repeats) is at least 264.   Method split constructs and returns a new SplittableRandom instance that shares no mutable state with the current instance. However, with very high probability, the values collectively generated by the two objects have the same statistical properties as if the same quantity of values were generated by a single thread using a single SplittableRandom object.  Instances of SplittableRandom are not thread-safe. They are designed to be split, not shared, across threads. For example, a java.util.concurrent.ForkJoinTask fork/join-style computation using random numbers might include a construction of the form new Subtask(aSplittableRandom.split()).fork(). This class provides additional methods for generating random streams, that employ the above techniques when used in stream.parallel() mode.  Instances of SplittableRandom are not cryptographically secure. Consider instead using java.security.SecureRandom in security-sensitive applications. Additionally, default-constructed instances do not use a cryptographically random seed unless the getProperty system property java.util.secureRandomSeed is set to true.
java.util.SplittableRandom.RandomDoublesSpliterator: Spliterator for double streams.
java.util.SplittableRandom.RandomIntsSpliterator: Spliterator for int streams. We multiplex the four int versions into one class by treating a bound less than origin as unbounded, and also by treating "infinite" as equivalent to Long.MAX_VALUE. For splits, it uses the standard divide-by-two approach. The long and double versions of this class are identical except for types.
java.util.SplittableRandom.RandomLongsSpliterator: Spliterator for long streams.
java.util.SplittableRandom.SplittableRandom	(	): Creates a new SplittableRandom instance that is likely to generate sequences of values that are statistically independent of those of any other instances in the current program; and may, and typically does, vary across program invocations.
java.util.SplittableRandom.SplittableRandom	(	long	): Creates a new SplittableRandom instance using the specified initial seed. SplittableRandom instances created with the same seed in the same program generate identical sequences of values.
java.util.SplittableRandom.SplittableRandom	(	long	long	): Internal constructor used by all others except default constructor.
java.util.SplittableRandom.doubles	(	): Returns an effectively unlimited stream of pseudorandom double values from this generator and/or one split from it; each value is between zero (inclusive) and one (exclusive).
java.util.SplittableRandom.doubles	(	double	double	): Returns an effectively unlimited stream of pseudorandom double values from this generator and/or one split from it; each value conforms to the given origin (inclusive) and bound (exclusive).
java.util.SplittableRandom.doubles	(	long	): Returns a stream producing the given streamSize number of pseudorandom double values from this generator and/or one split from it; each value is between zero (inclusive) and one (exclusive).
java.util.SplittableRandom.doubles	(	long	double	double	): Returns a stream producing the given streamSize number of pseudorandom double values from this generator and/or one split from it; each value conforms to the given origin (inclusive) and bound (exclusive).
java.util.SplittableRandom.internalNextDouble	(	double	double	): The form of nextDouble used by DoubleStream Spliterators.
java.util.SplittableRandom.internalNextInt	(	int	int	): The form of nextInt used by IntStream Spliterators. Exactly the same as long version, except for types.
java.util.SplittableRandom.internalNextLong	(	long	long	): The form of nextLong used by LongStream Spliterators. If origin is greater than bound, acts as unbounded form of nextLong, else as bounded form.
java.util.SplittableRandom.ints	(	): Returns an effectively unlimited stream of pseudorandom int values from this generator and/or one split from it.
java.util.SplittableRandom.ints	(	int	int	): Returns an effectively unlimited stream of pseudorandom int values from this generator and/or one split from it; each value conforms to the given origin (inclusive) and bound (exclusive).
java.util.SplittableRandom.ints	(	long	): Returns a stream producing the given streamSize number of pseudorandom int values from this generator and/or one split from it.
java.util.SplittableRandom.ints	(	long	int	int	): Returns a stream producing the given streamSize number of pseudorandom int values from this generator and/or one split from it; each value conforms to the given origin (inclusive) and bound (exclusive).
java.util.SplittableRandom.longs	(	): Returns an effectively unlimited stream of pseudorandom long values from this generator and/or one split from it.
java.util.SplittableRandom.longs	(	long	): Returns a stream producing the given streamSize number of pseudorandom long values from this generator and/or one split from it.
java.util.SplittableRandom.longs	(	long	long	): Returns an effectively unlimited stream of pseudorandom long values from this generator and/or one split from it; each value conforms to the given origin (inclusive) and bound (exclusive).
java.util.SplittableRandom.longs	(	long	long	long	): Returns a stream producing the given streamSize number of pseudorandom long values from this generator and/or one split from it; each value conforms to the given origin (inclusive) and bound (exclusive).
java.util.SplittableRandom.mix32	(	long	): Returns the 32 high bits of Stafford variant 4 mix64 function as int.
java.util.SplittableRandom.mix64	(	long	): Computes Stafford variant 13 of 64bit mix function.
java.util.SplittableRandom.mixGamma	(	long	): Returns the gamma value to use for a new split instance.
java.util.SplittableRandom.nextBoolean	(	): Returns a pseudorandom boolean value.
java.util.SplittableRandom.nextDouble	(	): Returns a pseudorandom double value between zero (inclusive) and one (exclusive).
java.util.SplittableRandom.nextDouble	(	double	): Returns a pseudorandom double value between 0.0 (inclusive) and the specified bound (exclusive).
java.util.SplittableRandom.nextDouble	(	double	double	): Returns a pseudorandom double value between the specified origin (inclusive) and bound (exclusive).
java.util.SplittableRandom.nextInt	(	): Returns a pseudorandom int value.
java.util.SplittableRandom.nextInt	(	int	): Returns a pseudorandom int value between zero (inclusive) and the specified bound (exclusive).
java.util.SplittableRandom.nextInt	(	int	int	): Returns a pseudorandom int value between the specified origin (inclusive) and the specified bound (exclusive).
java.util.SplittableRandom.nextLong	(	): Returns a pseudorandom long value.
java.util.SplittableRandom.nextLong	(	long	): Returns a pseudorandom long value between zero (inclusive) and the specified bound (exclusive).
java.util.SplittableRandom.nextLong	(	long	long	): Returns a pseudorandom long value between the specified origin (inclusive) and the specified bound (exclusive).
java.util.SplittableRandom.nextSeed	(	): Adds gamma to seed.
java.util.SplittableRandom.split	(	): Constructs and returns a new SplittableRandom instance that shares no mutable state with this instance. However, with very high probability, the set of values collectively generated by the two objects has the same statistical properties as if the same quantity of values were generated by a single thread using a single SplittableRandom object. Either or both of the two objects may be further split using the split() method, and the same expected statistical properties apply to the entire set of generators constructed by such recursive splitting.
java.util.Stack: The Stack class represents a last-in-first-out (LIFO) stack of objects. It extends class Vector with five operations that allow a vector to be treated as a stack. The usual push and pop operations are provided, as well as a method to peek at the top item on the stack, a method to test for whether the stack is empty, and a method to search the stack for an item and discover how far it is from the top.  When a stack is first created, it contains no items. A more complete and consistent set of LIFO stack operations is provided by the Deque interface and its implementations, which should be used in preference to this class. For example:  Deque stack = new ArrayDeque();
java.util.Stack.Stack	(	): Creates an empty Stack.
java.util.Stack.empty	(	): Tests if this stack is empty.
java.util.Stack.peek	(	): Looks at the object at the top of this stack without removing it from the stack.
java.util.Stack.pop	(	): Removes the object at the top of this stack and returns that object as the value of this function.
java.util.Stack.push	(	E	): Pushes an item onto the top of this stack. This has exactly the same effect as:  addElement(item)
java.util.Stack.search	(	Object	): Returns the 1-based position where an object is on this stack. If the object o occurs as an item in this stack, this method returns the distance from the top of the stack of the occurrence nearest the top of the stack; the topmost item on the stack is considered to be at distance 1. The equals method is used to compare o to the items in this stack.
java.util.StringJoiner: StringJoiner is used to construct a sequence of characters separated by a delimiter and optionally starting with a supplied prefix and ending with a supplied suffix.  Prior to adding something to the StringJoiner, its sj.toString() method will, by default, return prefix + suffix. However, if the setEmptyValue method is called, the emptyValue supplied will be returned instead. This can be used, for example, when creating a string using set notation to indicate an empty set, i.e. "{}", where the prefix is "{", the suffix is "}" and nothing has been added to the StringJoiner.
java.util.StringJoiner.StringJoiner	(	CharSequence	): Constructs a StringJoiner with no characters in it, with no prefix or suffix, and a copy of the supplied delimiter. If no characters are added to the StringJoiner and methods accessing the value of it are invoked, it will not return a prefix or suffix (or properties thereof) in the result, unless setEmptyValue has first been called.
java.util.StringJoiner.StringJoiner	(	CharSequence	CharSequence	CharSequence	): Constructs a StringJoiner with no characters in it using copies of the supplied prefix, delimiter and suffix. If no characters are added to the StringJoiner and methods accessing the string value of it are invoked, it will return the prefix + suffix (or properties thereof) in the result, unless setEmptyValue has first been called.
java.util.StringJoiner.add	(	CharSequence	): Adds a copy of the given CharSequence value as the next element of the StringJoiner value. If newElement is null, then "null" is added.
java.util.StringJoiner.length	(	): Returns the length of the String representation of this StringJoiner. Note that if no add methods have been called, then the length of the String representation (either prefix + suffix or emptyValue) will be returned. The value should be equivalent to toString().length().
java.util.StringJoiner.merge	(	StringJoiner	): Adds the contents of the given StringJoiner without prefix and suffix as the next element if it is non-empty. If the given StringJoiner is empty, the call has no effect. A StringJoiner is empty if add() add() has never been called, and if merge() has never been called with a non-empty StringJoiner argument. If the other StringJoiner is using a different delimiter, then elements from the other StringJoiner are concatenated with that delimiter and the result is appended to this StringJoiner as a single element.
java.util.StringJoiner.setEmptyValue	(	CharSequence	): Sets the sequence of characters to be used when determining the string representation of this StringJoiner and no elements have been added yet, that is, when it is empty. A copy of the emptyValue parameter is made for this purpose. Note that once an add method has been called, the StringJoiner is no longer considered empty, even if the element(s) added correspond to the empty String.
java.util.StringJoiner.toString	(	): Returns the current value, consisting of the prefix, the values added so far separated by the delimiter, and the suffix, unless no elements have been added in which case, the prefix + suffix or the emptyValue characters are returned
java.util.StringTokenizer: The string tokenizer class allows an application to break a string into tokens. The tokenization method is much simpler than the one used by the StreamTokenizer class. The StringTokenizer methods do not distinguish among identifiers, numbers, and quoted strings, nor do they recognize and skip comments.  The set of delimiters (the characters that separate tokens) may be specified either at creation time or on a per-token basis.  An instance of StringTokenizer behaves in one of two ways, depending on whether it was created with the returnDelims flag having the value true or false:  If the flag is false, delimiter characters serve to separate tokens. A token is a maximal sequence of consecutive characters that are not delimiters. If the flag is true, delimiter characters are themselves considered to be tokens. A token is thus either one delimiter character, or a maximal sequence of consecutive characters that are not delimiters.  A StringTokenizer object internally maintains a current position within the string to be tokenized. Some operations advance this current position past the characters processed. A token is returned by taking a substring of the string that was used to create the StringTokenizer object.  The following is one example of the use of the tokenizer. The code:  StringTokenizer st = new StringTokenizer("this is a test"); while (st.hasMoreTokens()) { System.out.println(st.nextToken()); }   prints the following output:  this is a test   StringTokenizer is a legacy class that is retained for compatibility reasons although its use is discouraged in new code. It is recommended that anyone seeking this functionality use the split method of String or the java.util.regex package instead.  The following example illustrates how the String.split method can be used to break up a string into its basic tokens:  String[] result = "this is a test".split("\\s"); for (int x=0; x<result.length; x++) System.out.println(result[x]);   prints the following output:  this is a test 
java.util.StringTokenizer.StringTokenizer	(	String	): Constructs a string tokenizer for the specified string. The tokenizer uses the default delimiter set, which is " \t\n\r\f": the space character, the tab character, the newline character, the carriage-return character, and the form-feed character. Delimiter characters themselves will not be treated as tokens.
java.util.StringTokenizer.StringTokenizer	(	String	String	): Constructs a string tokenizer for the specified string. The characters in the delim argument are the delimiters for separating tokens. Delimiter characters themselves will not be treated as tokens.  Note that if delim is null, this constructor does not throw an exception. However, trying to invoke other methods on the resulting StringTokenizer may result in a NullPointerException.
java.util.StringTokenizer.StringTokenizer	(	String	String	boolean	): Constructs a string tokenizer for the specified string. All characters in the delim argument are the delimiters for separating tokens.  If the returnDelims flag is true, then the delimiter characters are also returned as tokens. Each delimiter is returned as a string of length one. If the flag is false, the delimiter characters are skipped and only serve as separators between tokens.  Note that if delim is null, this constructor does not throw an exception. However, trying to invoke other methods on the resulting StringTokenizer may result in a NullPointerException.
java.util.StringTokenizer.countTokens	(	): Calculates the number of times that this tokenizer's nextToken method can be called before it generates an exception. The current position is not advanced.
java.util.StringTokenizer.hasMoreElements	(	): Returns the same value as the hasMoreTokens method. It exists so that this class can implement the Enumeration interface.
java.util.StringTokenizer.hasMoreTokens	(	): Tests if there are more tokens available from this tokenizer's string. If this method returns true, then a subsequent call to nextToken with no argument will successfully return a token.
java.util.StringTokenizer.nextElement	(	): Returns the same value as the nextToken method, except that its declared return value is Object rather than String. It exists so that this class can implement the Enumeration interface.
java.util.StringTokenizer.nextToken	(	): Returns the next token from this string tokenizer.
java.util.StringTokenizer.nextToken	(	String	): Returns the next token in this string tokenizer's string. First, the set of characters considered to be delimiters by this StringTokenizer object is changed to be the characters in the string delim. Then the next token in the string after the current position is returned. The current position is advanced beyond the recognized token. The new delimiter set remains the default after this call.
java.util.StringTokenizer.scanToken	(	int	): Skips ahead from startPos and returns the index of the next delimiter character encountered, or maxPosition if no such delimiter is found.
java.util.StringTokenizer.setMaxDelimCodePoint	(	): Set maxDelimCodePoint to the highest char in the delimiter set.
java.util.StringTokenizer.skipDelimiters	(	int	): Skips delimiters starting from the specified position. If retDelims is false, returns the index of the first non-delimiter character at or after startPos. If retDelims is true, startPos is returned.
java.util.TaskQueue: This class represents a timer task queue: a priority queue of TimerTasks, ordered on nextExecutionTime. Each Timer object has one of these, which it shares with its TimerThread. Internally this class uses a heap, which offers log(n) performance for the add, removeMin and rescheduleMin operations, and constant time performance for the getMin operation.
java.util.TaskQueue.add	(	TimerTask	): Adds a new task to the priority queue.
java.util.TaskQueue.clear	(	): Removes all elements from the priority queue.
java.util.TaskQueue.fixDown	(	int	): Establishes the heap invariant (described above) in the subtree rooted at k, which is assumed to satisfy the heap invariant except possibly for node k itself (which may have a nextExecutionTime greater than its children's). This method functions by "demoting" queue[k] down the hierarchy (by swapping it with its smaller child) repeatedly until queue[k]'s nextExecutionTime is less than or equal to those of its children.
java.util.TaskQueue.fixUp	(	int	): Establishes the heap invariant (described above) assuming the heap satisfies the invariant except possibly for the leaf-node indexed by k (which may have a nextExecutionTime less than its parent's). This method functions by "promoting" queue[k] up the hierarchy (by swapping it with its parent) repeatedly until queue[k]'s nextExecutionTime is greater than or equal to that of its parent.
java.util.TaskQueue.get	(	int	): Return the ith task in the priority queue, where i ranges from 1 (the head task, which is returned by getMin) to the number of tasks on the queue, inclusive.
java.util.TaskQueue.getMin	(	): Return the "head task" of the priority queue. (The head task is an task with the lowest nextExecutionTime.)
java.util.TaskQueue.heapify	(	): Establishes the heap invariant (described above) in the entire tree, assuming nothing about the order of the elements prior to the call.
java.util.TaskQueue.isEmpty	(	): Returns true if the priority queue contains no elements.
java.util.TaskQueue.quickRemove	(	int	): Removes the ith element from queue without regard for maintaining the heap invariant. Recall that queue is one-based, so 1 <= i <= size.
java.util.TaskQueue.removeMin	(	): Remove the head task from the priority queue.
java.util.TaskQueue.rescheduleMin	(	long	): Sets the nextExecutionTime associated with the head task to the specified value, and adjusts priority queue accordingly.
java.util.TaskQueue.size	(	): Returns the number of tasks currently on the queue.
java.util.TimSort: A stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when running on partially sorted arrays, while offering performance comparable to a traditional mergesort when run on random arrays. Like all proper mergesorts, this sort is stable and runs O(n log n) time (worst case). In the worst case, this sort requires temporary storage space for n/2 object references; in the best case, it requires only a small constant amount of space. This implementation was adapted from Tim Peters's list sort for Python, which is described in detail here: http://svn.python.org/projects/python/trunk/Objects/listsort.txt Tim's C code may be found here: http://svn.python.org/projects/python/trunk/Objects/listobject.c The underlying techniques are described in this paper (and may have even earlier origins): "Optimistic Sorting and Information Theoretic Complexity" Peter McIlroy SODA (Fourth Annual ACM-SIAM Symposium on Discrete Algorithms), pp 467-474, Austin, Texas, 25-27 January 1993. While the API to this class consists solely of static methods, it is (privately) instantiable; a TimSort instance holds the state of an ongoing sort, assuming the input array is large enough to warrant the full-blown TimSort. Small arrays are sorted in place, using a binary insertion sort.
java.util.TimSort.TimSort	(	T[]	Comparator	T[]	int	int	): Creates a TimSort instance to maintain the state of an ongoing sort.
java.util.TimSort.binarySort	(	T[]	int	int	int	Comparator	): Sorts the specified portion of the specified array using a binary insertion sort. This is the best method for sorting small numbers of elements. It requires O(n log n) compares, but O(n^2) data movement (worst case). If the initial part of the specified range is already sorted, this method can take advantage of it: the method assumes that the elements from index lo, inclusive, to start, exclusive are already sorted.
java.util.TimSort.countRunAndMakeAscending	(	T[]	int	int	Comparator	): Returns the length of the run beginning at the specified position in the specified array and reverses the run if it is descending (ensuring that the run will always be ascending when the method returns). A run is the longest ascending sequence with: a[lo] <= a[lo + 1] <= a[lo + 2] <= ... or the longest descending sequence with: a[lo] > a[lo + 1] > a[lo + 2] > ... For its intended use in a stable mergesort, the strictness of the definition of "descending" is needed so that the call can safely reverse a descending sequence without violating stability.
java.util.TimSort.ensureCapacity	(	int	): Ensures that the external array tmp has at least the specified number of elements, increasing its size if necessary. The size increases exponentially to ensure amortized linear time complexity.
java.util.TimSort.gallopLeft	(	T	T[]	int	int	int	Comparator	): Locates the position at which to insert the specified key into the specified sorted range; if the range contains an element equal to key, returns the index of the leftmost equal element.
java.util.TimSort.gallopRight	(	T	T[]	int	int	int	Comparator	): Like gallopLeft, except that if the range contains an element equal to key, gallopRight returns the index after the rightmost equal element.
java.util.TimSort.mergeAt	(	int	): Merges the two runs at stack indices i and i+1. Run i must be the penultimate or antepenultimate run on the stack. In other words, i must be equal to stackSize-2 or stackSize-3.
java.util.TimSort.mergeCollapse	(	): Examines the stack of runs waiting to be merged and merges adjacent runs until the stack invariants are reestablished: 1. runLen[i - 3] > runLen[i - 2] + runLen[i - 1] 2. runLen[i - 2] > runLen[i - 1] This method is called each time a new run is pushed onto the stack, so the invariants are guaranteed to hold for i < stackSize upon entry to the method.
java.util.TimSort.mergeForceCollapse	(	): Merges all runs on the stack until only one remains. This method is called once, to complete the sort.
java.util.TimSort.mergeHi	(	int	int	int	int	): Like mergeLo, except that this method should be called only if len1 >= len2; mergeLo should be called if len1 <= len2. (Either method may be called if len1 == len2.)
java.util.TimSort.mergeLo	(	int	int	int	int	): Merges two adjacent runs in place, in a stable fashion. The first element of the first run must be greater than the first element of the second run (a[base1] > a[base2]), and the last element of the first run (a[base1 + len1-1]) must be greater than all elements of the second run. For performance, this method should be called only when len1 <= len2; its twin, mergeHi should be called if len1 >= len2. (Either method may be called if len1 == len2.)
java.util.TimSort.minRunLength	(	int	): Returns the minimum acceptable run length for an array of the specified length. Natural runs shorter than this will be extended with binarySort. Roughly speaking, the computation is: If n < MIN_MERGE, return n (it's too small to bother with fancy stuff). Else if n is an exact power of 2, return MIN_MERGE/2. Else return an int k, MIN_MERGE/2 <= k <= MIN_MERGE, such that n/k is close to, but strictly less than, an exact power of 2. For the rationale, see listsort.txt.
java.util.TimSort.pushRun	(	int	int	): Pushes the specified run onto the pending-run stack.
java.util.TimSort.reverseRange	(	Object[]	int	int	): Reverse the specified range of the specified array.
java.util.TimSort.sort	(	T[]	int	int	Comparator	T[]	int	int	): Sorts the given range, using the given workspace array slice for temp storage when possible. This method is designed to be invoked from public methods (in class Arrays) after performing any necessary array bounds checks and expanding parameters into the required forms.
java.util.TimeZone: TimeZone represents a time zone offset, and also figures out daylight savings.  Typically, you get a TimeZone using getDefault which creates a TimeZone based on the time zone where the program is running. For example, for a program running in Japan, getDefault creates a TimeZone object based on Japanese Standard Time.  You can also get a TimeZone using getTimeZone along with a time zone ID. For instance, the time zone ID for the U.S. Pacific Time zone is "America/Los_Angeles". So, you can get a U.S. Pacific Time TimeZone object with:  TimeZone tz = TimeZone.getTimeZone("America/Los_Angeles");  You can use the getAvailableIDs method to iterate through all the supported time zone IDs. You can then choose a supported ID to get a TimeZone. If the time zone you want is not represented by one of the supported IDs, then a custom time zone ID can be specified to produce a TimeZone. The syntax of a custom time zone ID is:  CustomID: GMT Sign Hours : Minutes GMT Sign Hours Minutes GMT Sign Hours Sign: one of + - Hours: Digit Digit Digit Minutes: Digit Digit Digit: one of 0 1 2 3 4 5 6 7 8 9  Hours must be between 0 to 23 and Minutes must be between 00 to 59. For example, "GMT+10" and "GMT+0010" mean ten hours and ten minutes ahead of GMT, respectively.  The format is locale independent and digits must be taken from the Basic Latin block of the Unicode standard. No daylight saving time transition schedule can be specified with a custom time zone ID. If the specified string doesn't match the syntax, "GMT" is used.  When creating a TimeZone, the specified custom time zone ID is normalized in the following syntax:  NormalizedCustomID: GMT Sign TwoDigitHours : Minutes Sign: one of + - TwoDigitHours: Digit Digit Minutes: Digit Digit Digit: one of 0 1 2 3 4 5 6 7 8 9  For example, TimeZone.getTimeZone("GMT-8").getID() returns "GMT-08:00". Three-letter time zone IDs For compatibility with JDK 1.1.x, some other three-letter time zone IDs (such as "PST", "CTT", "AST") are also supported. However, their use is deprecated because the same abbreviation is often used for multiple time zones (for example, "CST" could be U.S. "Central Standard Time" and "China Standard Time"), and the Java platform can then only recognize one of them.
java.util.TimeZone.TimeZone	(	): Sole constructor. (For invocation by subclass constructors, typically implicit.)
java.util.TimeZone.clone	(	): Creates a copy of this TimeZone.
java.util.TimeZone.getAvailableIDs	(	): Gets all the available IDs supported.
java.util.TimeZone.getAvailableIDs	(	int	): Gets the available IDs according to the given time zone offset in milliseconds.
java.util.TimeZone.getDSTSavings	(	): Returns the amount of time to be added to local standard time to get local wall clock time. The default implementation returns 3600000 milliseconds (i.e., one hour) if a call to useDaylightTime() returns true. Otherwise, 0 (zero) is returned. If an underlying TimeZone implementation subclass supports historical and future Daylight Saving Time schedule changes, this method returns the amount of saving time of the last known Daylight Saving Time rule that can be a future prediction. If the amount of saving time at any given time stamp is required, construct a Calendar with this TimeZone and the time stamp, and call get() Calendar.get (DST_OFFSET ).
java.util.TimeZone.getDefault	(	): Gets the default TimeZone of the Java virtual machine. If the cached default TimeZone is available, its clone is returned. Otherwise, the method takes the following steps to determine the default time zone.  Use the user.timezone property value as the default time zone ID if it's available. Detect the platform time zone ID. The source of the platform time zone and ID mapping may vary with implementation. Use GMT as the last resort if the given or detected time zone ID is unknown.  The default TimeZone created from the ID is cached, and its clone is returned. The user.timezone property value is set to the ID upon return.
java.util.TimeZone.getDefaultRef	(	): Returns the reference to the default TimeZone object. This method doesn't create a clone.
java.util.TimeZone.getDisplayName	(	): Returns a long standard time name of this TimeZone suitable for presentation to the user in the default locale. This method is equivalent to:  getDisplayName(false, LONG, Locale.getDefault(DISPLAY)) 
java.util.TimeZone.getDisplayName	(	Locale	): Returns a long standard time name of this TimeZone suitable for presentation to the user in the specified locale. This method is equivalent to:  getDisplayName(false, LONG, locale) 
java.util.TimeZone.getDisplayName	(	boolean	int	): Returns a name in the specified style of this TimeZone suitable for presentation to the user in the default locale. If the specified daylight is true, a Daylight Saving Time name is returned (even if this TimeZone doesn't observe Daylight Saving Time). Otherwise, a Standard Time name is returned. This method is equivalent to:  getDisplayName(daylight, style, Locale.getDefault(DISPLAY)) 
java.util.TimeZone.getDisplayName	(	boolean	int	Locale	): Returns a name in the specified style of this TimeZone suitable for presentation to the user in the specified locale. If the specified daylight is true, a Daylight Saving Time name is returned (even if this TimeZone doesn't observe Daylight Saving Time). Otherwise, a Standard Time name is returned. When looking up a time zone name, the getCandidateLocales() default Locale search path of ResourceBundle derived from the specified locale is used. (No getFallbackLocale() fallback Locale search is performed.) If a time zone name in any Locale of the search path, including ROOT, is found, the name is returned. Otherwise, a string in the normalized custom ID format is returned.
java.util.TimeZone.getID	(	): Gets the ID of this time zone.
java.util.TimeZone.getOffset	(	int	int	int	int	int	int	): Gets the time zone offset, for current date, modified in case of daylight savings. This is the offset to add to UTC to get local time.  This method returns a historically correct offset if an underlying TimeZone implementation subclass supports historical Daylight Saving Time schedule and GMT offset changes.
java.util.TimeZone.getOffset	(	long	): Returns the offset of this time zone from UTC at the specified date. If Daylight Saving Time is in effect at the specified date, the offset value is adjusted with the amount of daylight saving.  This method returns a historically correct offset value if an underlying TimeZone implementation subclass supports historical Daylight Saving Time schedule and GMT offset changes.
java.util.TimeZone.getOffsets	(	long	int[]	): Gets the raw GMT offset and the amount of daylight saving of this time zone at the given time.
java.util.TimeZone.getRawOffset	(	): Returns the amount of time in milliseconds to add to UTC to get standard time in this time zone. Because this value is not affected by daylight saving time, it is called raw offset.  If an underlying TimeZone implementation subclass supports historical GMT offset changes, the method returns the raw offset value of the current date. In Honolulu, for example, its raw offset changed from GMT-10:30 to GMT-10:00 in 1947, and this method always returns -36000000 milliseconds (i.e., -10 hours).
java.util.TimeZone.getSystemGMTOffsetID	(	): Gets the custom time zone ID based on the GMT offset of the platform. (e.g., "GMT+08:00")
java.util.TimeZone.getSystemTimeZoneID	(	String	): Gets the platform defined TimeZone ID.
java.util.TimeZone.getTimeZone	(	String	): Gets the TimeZone for the given ID.
java.util.TimeZone.getTimeZone	(	ZoneId	): Gets the TimeZone for the given zoneId.
java.util.TimeZone.hasSameRules	(	TimeZone	): Returns true if this zone has the same rule and offset as another zone. That is, if this zone differs only in ID, if at all. Returns false if the other zone is null.
java.util.TimeZone.inDaylightTime	(	Date	): Queries if the given date is in Daylight Saving Time in this time zone.
java.util.TimeZone.observesDaylightTime	(	): Returns true if this TimeZone is currently in Daylight Saving Time, or if a transition from Standard Time to Daylight Saving Time occurs at any future time. The default implementation returns true if useDaylightTime() or inDaylightTime(new Date()) returns true.
java.util.TimeZone.parseCustomTimeZone	(	String	): Parses a custom time zone identifier and returns a corresponding zone. This method doesn't support the RFC 822 time zone format. (e.g., +hhmm)
java.util.TimeZone.setDefault	(	TimeZone	): Sets the TimeZone that is returned by the getDefault method. zone is cached. If zone is null, the cached default TimeZone is cleared. This method doesn't change the value of the user.timezone property.
java.util.TimeZone.setID	(	String	): Sets the time zone ID. This does not change any other data in the time zone object.
java.util.TimeZone.setRawOffset	(	int	): Sets the base time zone offset to GMT. This is the offset to add to UTC to get local time.  If an underlying TimeZone implementation subclass supports historical GMT offset changes, the specified GMT offset is set as the latest GMT offset and the difference from the known latest GMT offset value is used to adjust all historical GMT offset values.
java.util.TimeZone.toZoneId	(	): Converts this TimeZone object to a ZoneId.
java.util.TimeZone.useDaylightTime	(	): Queries if this TimeZone uses Daylight Saving Time. If an underlying TimeZone implementation subclass supports historical and future Daylight Saving Time schedule changes, this method refers to the last known Daylight Saving Time rule that can be a future prediction and may not be the same as the current rule. Consider calling observesDaylightTime() if the current rule should also be taken into account.
java.util.Timer: A facility for threads to schedule tasks for future execution in a background thread. Tasks may be scheduled for one-time execution, or for repeated execution at regular intervals. Corresponding to each Timer object is a single background thread that is used to execute all of the timer's tasks, sequentially. Timer tasks should complete quickly. If a timer task takes excessive time to complete, it "hogs" the timer's task execution thread. This can, in turn, delay the execution of subsequent tasks, which may "bunch up" and execute in rapid succession when (and if) the offending task finally completes. After the last live reference to a Timer object goes away and all outstanding tasks have completed execution, the timer's task execution thread terminates gracefully (and becomes subject to garbage collection). However, this can take arbitrarily long to occur. By default, the task execution thread does not run as a daemon thread, so it is capable of keeping an application from terminating. If a caller wants to terminate a timer's task execution thread rapidly, the caller should invoke the timer's cancel method. If the timer's task execution thread terminates unexpectedly, for example, because its stop method is invoked, any further attempt to schedule a task on the timer will result in an IllegalStateException, as if the timer's cancel method had been invoked. This class is thread-safe: multiple threads can share a single Timer object without the need for external synchronization. This class does not offer real-time guarantees: it schedules tasks using the Object.wait(long) method. Java 5.0 introduced the java.util.concurrent package and one of the concurrency utilities therein is the java.util.concurrent.ScheduledThreadPoolExecutor ScheduledThreadPoolExecutor which is a thread pool for repeatedly executing tasks at a given rate or delay. It is effectively a more versatile replacement for the Timer/TimerTask combination, as it allows multiple service threads, accepts various time units, and doesn't require subclassing TimerTask (just implement Runnable). Configuring ScheduledThreadPoolExecutor with one thread makes it equivalent to Timer. Implementation note: This class scales to large numbers of concurrently scheduled tasks (thousands should present no problem). Internally, it uses a binary heap to represent its task queue, so the cost to schedule a task is O(log n), where n is the number of concurrently scheduled tasks. Implementation note: All constructors start a timer thread.
java.util.Timer.Timer	(	): Creates a new timer. The associated thread does not setDaemon run as a daemon.
java.util.Timer.Timer	(	String	): Creates a new timer whose associated thread has the specified name. The associated thread does not setDaemon run as a daemon.
java.util.Timer.Timer	(	String	boolean	): Creates a new timer whose associated thread has the specified name, and may be specified to setDaemon run as a daemon.
java.util.Timer.Timer	(	boolean	): Creates a new timer whose associated thread may be specified to setDaemon run as a daemon. A daemon thread is called for if the timer will be used to schedule repeating "maintenance activities", which must be performed as long as the application is running, but should not prolong the lifetime of the application.
java.util.Timer.cancel	(	): Terminates this timer, discarding any currently scheduled tasks. Does not interfere with a currently executing task (if it exists). Once a timer has been terminated, its execution thread terminates gracefully, and no more tasks may be scheduled on it. Note that calling this method from within the run method of a timer task that was invoked by this timer absolutely guarantees that the ongoing task execution is the last task execution that will ever be performed by this timer. This method may be called repeatedly; the second and subsequent calls have no effect.
java.util.Timer.purge	(	): Removes all cancelled tasks from this timer's task queue. Calling this method has no effect on the behavior of the timer, but eliminates the references to the cancelled tasks from the queue. If there are no external references to these tasks, they become eligible for garbage collection. Most programs will have no need to call this method. It is designed for use by the rare application that cancels a large number of tasks. Calling this method trades time for space: the runtime of the method may be proportional to n + c log n, where n is the number of tasks in the queue and c is the number of cancelled tasks. Note that it is permissible to call this method from within a a task scheduled on this timer.
java.util.Timer.sched	(	TimerTask	long	long	): Schedule the specified timer task for execution at the specified time with the specified period, in milliseconds. If period is positive, the task is scheduled for repeated execution; if period is zero, the task is scheduled for one-time execution. Time is specified in Date.getTime() format. This method checks timer state, task state, and initial execution time, but not period.
java.util.Timer.schedule	(	TimerTask	Date	): Schedules the specified task for execution at the specified time. If the time is in the past, the task is scheduled for immediate execution.
java.util.Timer.schedule	(	TimerTask	Date	long	): Schedules the specified task for repeated fixed-delay execution, beginning at the specified time. Subsequent executions take place at approximately regular intervals, separated by the specified period. In fixed-delay execution, each execution is scheduled relative to the actual execution time of the previous execution. If an execution is delayed for any reason (such as garbage collection or other background activity), subsequent executions will be delayed as well. In the long run, the frequency of execution will generally be slightly lower than the reciprocal of the specified period (assuming the system clock underlying Object.wait(long) is accurate). As a consequence of the above, if the scheduled first time is in the past, it is scheduled for immediate execution. Fixed-delay execution is appropriate for recurring activities that require "smoothness." In other words, it is appropriate for activities where it is more important to keep the frequency accurate in the short run than in the long run. This includes most animation tasks, such as blinking a cursor at regular intervals. It also includes tasks wherein regular activity is performed in response to human input, such as automatically repeating a character as long as a key is held down.
java.util.Timer.schedule	(	TimerTask	long	): Schedules the specified task for execution after the specified delay.
java.util.Timer.schedule	(	TimerTask	long	long	): Schedules the specified task for repeated fixed-delay execution, beginning after the specified delay. Subsequent executions take place at approximately regular intervals separated by the specified period. In fixed-delay execution, each execution is scheduled relative to the actual execution time of the previous execution. If an execution is delayed for any reason (such as garbage collection or other background activity), subsequent executions will be delayed as well. In the long run, the frequency of execution will generally be slightly lower than the reciprocal of the specified period (assuming the system clock underlying Object.wait(long) is accurate). Fixed-delay execution is appropriate for recurring activities that require "smoothness." In other words, it is appropriate for activities where it is more important to keep the frequency accurate in the short run than in the long run. This includes most animation tasks, such as blinking a cursor at regular intervals. It also includes tasks wherein regular activity is performed in response to human input, such as automatically repeating a character as long as a key is held down.
java.util.Timer.scheduleAtFixedRate	(	TimerTask	Date	long	): Schedules the specified task for repeated fixed-rate execution, beginning at the specified time. Subsequent executions take place at approximately regular intervals, separated by the specified period. In fixed-rate execution, each execution is scheduled relative to the scheduled execution time of the initial execution. If an execution is delayed for any reason (such as garbage collection or other background activity), two or more executions will occur in rapid succession to "catch up." In the long run, the frequency of execution will be exactly the reciprocal of the specified period (assuming the system clock underlying Object.wait(long) is accurate). As a consequence of the above, if the scheduled first time is in the past, then any "missed" executions will be scheduled for immediate "catch up" execution. Fixed-rate execution is appropriate for recurring activities that are sensitive to absolute time, such as ringing a chime every hour on the hour, or running scheduled maintenance every day at a particular time. It is also appropriate for recurring activities where the total time to perform a fixed number of executions is important, such as a countdown timer that ticks once every second for ten seconds. Finally, fixed-rate execution is appropriate for scheduling multiple repeating timer tasks that must remain synchronized with respect to one another.
java.util.Timer.scheduleAtFixedRate	(	TimerTask	long	long	): Schedules the specified task for repeated fixed-rate execution, beginning after the specified delay. Subsequent executions take place at approximately regular intervals, separated by the specified period. In fixed-rate execution, each execution is scheduled relative to the scheduled execution time of the initial execution. If an execution is delayed for any reason (such as garbage collection or other background activity), two or more executions will occur in rapid succession to "catch up." In the long run, the frequency of execution will be exactly the reciprocal of the specified period (assuming the system clock underlying Object.wait(long) is accurate). Fixed-rate execution is appropriate for recurring activities that are sensitive to absolute time, such as ringing a chime every hour on the hour, or running scheduled maintenance every day at a particular time. It is also appropriate for recurring activities where the total time to perform a fixed number of executions is important, such as a countdown timer that ticks once every second for ten seconds. Finally, fixed-rate execution is appropriate for scheduling multiple repeating timer tasks that must remain synchronized with respect to one another.
java.util.TimerTask: A task that can be scheduled for one-time or repeated execution by a Timer.
java.util.TimerTask.TimerTask	(	): Creates a new timer task.
java.util.TimerTask.cancel	(	): Cancels this timer task. If the task has been scheduled for one-time execution and has not yet run, or has not yet been scheduled, it will never run. If the task has been scheduled for repeated execution, it will never run again. (If the task is running when this call occurs, the task will run to completion, but will never run again.) Note that calling this method from within the run method of a repeating timer task absolutely guarantees that the timer task will not run again. This method may be called repeatedly; the second and subsequent calls have no effect.
java.util.TimerTask.run	(	): The action to be performed by this timer task.
java.util.TimerTask.scheduledExecutionTime	(	): Returns the scheduled execution time of the most recent actual execution of this task. (If this method is invoked while task execution is in progress, the return value is the scheduled execution time of the ongoing task execution.) This method is typically invoked from within a task's run method, to determine whether the current execution of the task is sufficiently timely to warrant performing the scheduled activity: public void run() if (System.currentTimeMillis() - scheduledExecutionTime() >= MAX_TARDINESS) return; // Too late; skip this execution. // Perform the task } } This method is typically not used in conjunction with fixed-delay execution repeating tasks, as their scheduled execution times are allowed to drift over time, and so are not terribly significant.
java.util.TimerThread: This "helper class" implements the timer's task execution thread, which waits for tasks on the timer queue, executions them when they fire, reschedules repeating tasks, and removes cancelled tasks and spent non-repeating tasks from the queue.
java.util.TimerThread.mainLoop	(	): The main timer loop. (See class comment.)
java.util.TooManyListenersException:  The  TooManyListenersException  Exception is used as part of the Java Event model to annotate and implement a unicast special case of a multicast Event Source.   The presence of a "throws TooManyListenersException" clause on any given concrete implementation of the normally multicast "void addXyzEventListener" event listener registration pattern is used to annotate that interface as implementing a unicast Listener special case, that is, that one and only one Listener may be registered on the particular event listener source concurrently. 
java.util.TooManyListenersException.TooManyListenersException	(	): Constructs a TooManyListenersException with no detail message. A detail message is a String that describes this particular exception.
java.util.TooManyListenersException.TooManyListenersException	(	String	): Constructs a TooManyListenersException with the specified detail message. A detail message is a String that describes this particular exception.
java.util.TreeMap: A Red-Black tree based NavigableMap implementation. The map is sorted according to the Comparable natural ordering of its keys, or by a Comparator provided at map creation time, depending on which constructor is used. This implementation provides guaranteed log(n) time cost for the containsKey, get, put and remove operations. Algorithms are adaptations of those in Cormen, Leiserson, and Rivest's Introduction to Algorithms. Note that the ordering maintained by a tree map, like any sorted map, and whether or not an explicit comparator is provided, must be consistent with equals if this sorted map is to correctly implement the Map interface. (See Comparable or Comparator for a precise definition of consistent with equals.) This is so because the Map interface is defined in terms of the equals operation, but a sorted map performs all key comparisons using its compareTo (or compare) method, so two keys that are deemed equal by this method are, from the standpoint of the sorted map, equal. The behavior of a sorted map is well-defined even if its ordering is inconsistent with equals; it just fails to obey the general contract of the Map interface. Note that this implementation is not synchronized. If multiple threads access a map concurrently, and at least one of the threads modifies the map structurally, it must be synchronized externally. (A structural modification is any operation that adds or deletes one or more mappings; merely changing the value associated with an existing key is not a structural modification.) This is typically accomplished by synchronizing on some object that naturally encapsulates the map. If no such object exists, the map should be "wrapped" using the synchronizedSortedMap Collections.synchronizedSortedMap method. This is best done at creation time, to prevent accidental unsynchronized access to the map:  SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...)); The iterators returned by the iterator method of the collections returned by all of this class's "collection view methods" are fail-fast: if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. All Map.Entry pairs returned by methods in this class and its views represent snapshots of mappings at the time they were produced. They do not support the Entry.setValue method. (Note however that it is possible to change mappings in the associated map using put.) This class is a member of the  Java Collections Framework.
java.util.TreeMap.Entry: Node in the Tree. Doubles as a means to pass key-value pairs back to user (see Map.Entry).
java.util.TreeMap.Entry.Entry	(	K	V	Entry	): Make a new cell with given key, value, and parent, and with null child links, and BLACK color.
java.util.TreeMap.Entry.getKey	(	): Returns the key.
java.util.TreeMap.Entry.getValue	(	): Returns the value associated with the key.
java.util.TreeMap.Entry.setValue	(	V	): Replaces the value currently associated with the key with the given value.
java.util.TreeMap.NavigableSubMap.SubMapIterator: Iterators for SubMaps
java.util.TreeMap.NavigableSubMap.absHighFence	(	): Returns the absolute high fence for ascending traversal 
java.util.TreeMap.NavigableSubMap.absLowFence	(	): Return the absolute low fence for descending traversal 
java.util.TreeMap.NavigableSubMap.descendingKeyIterator	(	): Returns descending iterator from the perspective of this submap 
java.util.TreeMap.NavigableSubMap.keyIterator	(	): Returns ascending iterator from the perspective of this submap 
java.util.TreeMap.PrivateEntryIterator: Base class for TreeMap Iterators
java.util.TreeMap.SubMap: This class exists solely for the sake of serialization compatibility with previous releases of TreeMap that did not support NavigableMap. It translates an old-version SubMap into a new-version AscendingSubMap. This class is never otherwise used.
java.util.TreeMap.TreeMap	(	): Constructs a new, empty tree map, using the natural ordering of its keys. All keys inserted into the map must implement the Comparable interface. Furthermore, all such keys must be mutually comparable: k1.compareTo(k2) must not throw a ClassCastException for any keys k1 and k2 in the map. If the user attempts to put a key into the map that violates this constraint (for example, the user attempts to put a string key into a map whose keys are integers), the put(Object key, Object value) call will throw a ClassCastException.
java.util.TreeMap.TreeMap	(	Comparator	): Constructs a new, empty tree map, ordered according to the given comparator. All keys inserted into the map must be mutually comparable by the given comparator: comparator.compare(k1, k2) must not throw a ClassCastException for any keys k1 and k2 in the map. If the user attempts to put a key into the map that violates this constraint, the put(Object key, Object value) call will throw a ClassCastException.
java.util.TreeMap.TreeMap	(	Map	): Constructs a new tree map containing the same mappings as the given map, ordered according to the natural ordering of its keys. All keys inserted into the new map must implement the Comparable interface. Furthermore, all such keys must be mutually comparable: k1.compareTo(k2) must not throw a ClassCastException for any keys k1 and k2 in the map. This method runs in n*log(n) time.
java.util.TreeMap.TreeMap	(	SortedMap	): Constructs a new tree map containing the same mappings and using the same ordering as the specified sorted map. This method runs in linear time.
java.util.TreeMap.TreeMapSpliterator: Base class for spliterators. Iteration starts at a given origin and continues up to but not including a given fence (or null for end). At top-level, for ascending cases, the first split uses the root as left-fence/right-origin. From there, right-hand splits replace the current fence with its left child, also serving as origin for the split-off spliterator. Left-hands are symmetric. Descending versions place the origin at the end and invert ascending split rules. This base class is non-commital about directionality, or whether the top-level spliterator covers the whole tree. This means that the actual split mechanics are located in subclasses. Some of the subclass trySplit methods are identical (except for return types), but not nicely factorable. Currently, subclass versions exist only for the full map (including descending keys via its descendingMap). Others are possible but currently not worthwhile because submaps require O(n) computations to determine size, which substantially limits potential speed-ups of using custom Spliterators versus default mechanics. To boostrap initialization, external constructors use negative size estimates: -1 for ascend, -2 for descend.
java.util.TreeMap.addAllForTreeSet	(	SortedSet	V	): Intended to be called only from TreeSet.addAll 
java.util.TreeMap.buildFromSorted	(	int	Iterator	java.io.ObjectInputStream	V	): Linear time tree building algorithm from sorted data. Can accept keys and/or values from iterator or stream. This leads to too many parameters, but seems better than alternatives. The four formats that this method accepts are: 1) An iterator of Map.Entries. (it != null, defaultVal == null). 2) An iterator of keys. (it != null, defaultVal != null). 3) A stream of alternating serialized keys and values. (it == null, defaultVal == null). 4) A stream of serialized keys. (it == null, defaultVal != null). It is assumed that the comparator of the TreeMap is already set prior to calling this method.
java.util.TreeMap.buildFromSorted	(	int	int	int	int	Iterator	java.io.ObjectInputStream	V	): Recursive "helper method" that does the real work of the previous method. Identically named parameters have identical definitions. Additional parameters are documented below. It is assumed that the comparator and size fields of the TreeMap are already set prior to calling this method. (It ignores both fields.)
java.util.TreeMap.ceilingEntry	(	K	): Returns a key-value mapping associated with the least key greater than or equal to the given key, or null if there is no such key.
java.util.TreeMap.ceilingKey	(	K	): Returns the least key greater than or equal to the given key, or null if there is no such key.
java.util.TreeMap.clear	(	): Removes all of the mappings from this map. The map will be empty after this call returns.
java.util.TreeMap.clone	(	): Returns a shallow copy of this TreeMap instance. (The keys and values themselves are not cloned.)
java.util.TreeMap.colorOf	(	Entry	): Balancing operations. Implementations of rebalancings during insertion and deletion are slightly different than the CLR version. Rather than using dummy nilnodes, we use a set of accessors that deal properly with null. They are used to avoid messiness surrounding nullness checks in the main algorithms.
java.util.TreeMap.compare	(	Object	Object	): Compares two keys using the correct comparison method for this TreeMap.
java.util.TreeMap.computeRedLevel	(	int	): Find the level down to which to assign all nodes BLACK. This is the last `full' level of the complete binary tree produced by buildTree. The remaining nodes are colored RED. (This makes a `nice' set of color assignments wrt future insertions.) This level number is computed by finding the number of splits needed to reach the zeroeth node. (The answer is ~lg(N), but in any case must be computed by same quick O(lg(N)) loop.)
java.util.TreeMap.containsKey	(	Object	): Returns true if this map contains a mapping for the specified key.
java.util.TreeMap.containsValue	(	Object	): Returns true if this map maps one or more keys to the specified value. More formally, returns true if and only if this map contains at least one mapping to a value v such that (value==null ? v==null : value.equals(v)). This operation will probably require time linear in the map size for most implementations.
java.util.TreeMap.deleteEntry	(	Entry	): Delete node p, and then rebalance the tree.
java.util.TreeMap.descendingKeySet	(	): Returns a reverse order NavigableSet view of the keys contained in this map. The set's iterator returns the keys in descending order. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.TreeMap.descendingMap	(	): Returns a reverse order view of the mappings contained in this map. The descending map is backed by this map, so changes to the map are reflected in the descending map, and vice-versa. If either map is modified while an iteration over a collection view of either map is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The returned map has an ordering equivalent to reverseOrder() Collections.reverseOrder(comparator()). The expression m.descendingMap().descendingMap() returns a view of m essentially equivalent to m.
java.util.TreeMap.entrySet	(	): Returns a Set view of the mappings contained in this map. The set's iterator returns the entries in ascending key order. The sets's spliterator is late-binding, fail-fast, and additionally reports SORTED and ORDERED with an encounter order that is ascending key order. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation, or through the setValue operation on a map entry returned by the iterator) the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.TreeMap.exportEntry	(	TreeMap.Entry	): Return SimpleImmutableEntry for entry, or null if null
java.util.TreeMap.firstEntry	(	): Returns a key-value mapping associated with the least key in this map, or null if the map is empty.
java.util.TreeMap.firstKey	(	): Returns the first (lowest) key currently in this map.
java.util.TreeMap.fixAfterDeletion	(	Entry	): From CLR 
java.util.TreeMap.fixAfterInsertion	(	Entry	): From CLR 
java.util.TreeMap.floorEntry	(	K	): Returns a key-value mapping associated with the greatest key less than or equal to the given key, or null if there is no such key.
java.util.TreeMap.floorKey	(	K	): Returns the greatest key less than or equal to the given key, or null if there is no such key.
java.util.TreeMap.get	(	Object	): Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that key compares equal to k according to the map's ordering, then this method returns v; otherwise it returns null. (There can be at most one such mapping.) A return value of null does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to null. The containsKey operation may be used to distinguish these two cases.
java.util.TreeMap.getCeilingEntry	(	K	): Gets the entry corresponding to the specified key; if no such entry exists, returns the entry for the least key greater than the specified key; if no such entry exists (i.e., the greatest key in the Tree is less than the specified key), returns null.
java.util.TreeMap.getEntry	(	Object	): Returns this map's entry for the given key, or null if the map does not contain an entry for the key.
java.util.TreeMap.getEntryUsingComparator	(	Object	): Version of getEntry using comparator. Split off from getEntry for performance. (This is not worth doing for most methods, that are less dependent on comparator performance, but is worthwhile here.)
java.util.TreeMap.getFirstEntry	(	): Returns the first Entry in the TreeMap (according to the TreeMap's key-sort function). Returns null if the TreeMap is empty.
java.util.TreeMap.getFloorEntry	(	K	): Gets the entry corresponding to the specified key; if no such entry exists, returns the entry for the greatest key less than the specified key; if no such entry exists, returns null.
java.util.TreeMap.getHigherEntry	(	K	): Gets the entry for the least key greater than the specified key; if no such entry exists, returns the entry for the least key greater than the specified key; if no such entry exists returns null.
java.util.TreeMap.getLastEntry	(	): Returns the last Entry in the TreeMap (according to the TreeMap's key-sort function). Returns null if the TreeMap is empty.
java.util.TreeMap.getLowerEntry	(	K	): Returns the entry for the greatest key less than the specified key; if no such entry exists (i.e., the least key in the Tree is greater than the specified key), returns null.
java.util.TreeMap.headMap	(	K	): Returns a view of the portion of this map whose keys are strictly less than toKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range. Equivalent to headMap(toKey, false).
java.util.TreeMap.headMap	(	K	boolean	): Returns a view of the portion of this map whose keys are less than (or equal to, if inclusive is true) toKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range.
java.util.TreeMap.higherEntry	(	K	): Returns a key-value mapping associated with the least key strictly greater than the given key, or null if there is no such key.
java.util.TreeMap.higherKey	(	K	): Returns the least key strictly greater than the given key, or null if there is no such key.
java.util.TreeMap.key	(	Entry	): Returns the key corresponding to the specified Entry.
java.util.TreeMap.keyOrNull	(	TreeMap.Entry	): Return key for entry, or null if null
java.util.TreeMap.keySet	(	): Returns a Set view of the keys contained in this map. The set's iterator returns the keys in ascending order. The set's spliterator is late-binding, fail-fast, and additionally reports SORTED and ORDERED with an encounter order that is ascending key order. The spliterator's comparator (see getComparator()) is null if the tree map's comparator (see comparator()) is null. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the tree map's comparator. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.TreeMap.keySpliteratorFor	(	NavigableMap	): Currently, we support Spliterator-based versions only for the full map, in either plain of descending form, otherwise relying on defaults because size estimation for submaps would dominate costs. The type tests needed to check these for key views are not very nice but avoid disrupting existing class structures. Callers must use plain default spliterators if this returns null.
java.util.TreeMap.lastEntry	(	): Returns a key-value mapping associated with the greatest key in this map, or null if the map is empty.
java.util.TreeMap.lastKey	(	): Returns the last (highest) key currently in this map.
java.util.TreeMap.lowerEntry	(	K	): Returns a key-value mapping associated with the greatest key strictly less than the given key, or null if there is no such key.
java.util.TreeMap.lowerKey	(	K	): Returns the greatest key strictly less than the given key, or null if there is no such key.
java.util.TreeMap.navigableKeySet	(	): Returns a NavigableSet view of the keys contained in this map. The set's iterator returns the keys in ascending order. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.TreeMap.pollFirstEntry	(	): Removes and returns a key-value mapping associated with the least key in this map, or null if the map is empty.
java.util.TreeMap.pollLastEntry	(	): Removes and returns a key-value mapping associated with the greatest key in this map, or null if the map is empty.
java.util.TreeMap.predecessor	(	Entry	): Returns the predecessor of the specified Entry, or null if no such.
java.util.TreeMap.put	(	K	V	): Associates the specified value with the specified key in this map. If the map previously contained a mapping for the key, the old value is replaced.
java.util.TreeMap.putAll	(	Map	): Copies all of the mappings from the specified map to this map. These mappings replace any mappings that this map had for any of the keys currently in the specified map.
java.util.TreeMap.readObject	(	java.io.ObjectInputStream	): Reconstitute the TreeMap instance from a stream (i.e., deserialize it).
java.util.TreeMap.readTreeSet	(	int	java.io.ObjectInputStream	V	): Intended to be called only from TreeSet.readObject 
java.util.TreeMap.remove	(	Object	): Removes the mapping for this key from this TreeMap if present.
java.util.TreeMap.rotateLeft	(	Entry	): From CLR 
java.util.TreeMap.rotateRight	(	Entry	): From CLR 
java.util.TreeMap.size	(	): Returns the number of key-value mappings in this map.
java.util.TreeMap.subMap	(	K	K	): Returns a view of the portion of this map whose keys range from fromKey, inclusive, to toKey, exclusive. (If fromKey and toKey are equal, the returned map is empty.) The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range. Equivalent to subMap(fromKey, true, toKey, false).
java.util.TreeMap.subMap	(	K	boolean	K	boolean	): Returns a view of the portion of this map whose keys range from fromKey to toKey. If fromKey and toKey are equal, the returned map is empty unless fromInclusive and toInclusive are both true. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside of its range, or to construct a submap either of whose endpoints lie outside its range.
java.util.TreeMap.successor	(	Entry	): Returns the successor of the specified Entry, or null if no such.
java.util.TreeMap.tailMap	(	K	): Returns a view of the portion of this map whose keys are greater than or equal to fromKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range. Equivalent to tailMap(fromKey, true).
java.util.TreeMap.tailMap	(	K	boolean	): Returns a view of the portion of this map whose keys are greater than (or equal to, if inclusive is true) fromKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range.
java.util.TreeMap.valEquals	(	Object	Object	): Test two values for equality. Differs from o1.equals(o2) only in that it copes with null o1 properly.
java.util.TreeMap.values	(	): Returns a Collection view of the values contained in this map. The collection's iterator returns the values in ascending order of the corresponding keys. The collection's spliterator is late-binding, fail-fast, and additionally reports ORDERED with an encounter order that is ascending order of the corresponding keys. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.TreeMap.writeObject	(	java.io.ObjectOutputStream	): Save the state of the TreeMap instance to a stream (i.e., serialize it).
java.util.TreeSet: A NavigableSet implementation based on a TreeMap. The elements are ordered using their Comparable natural ordering, or by a Comparator provided at set creation time, depending on which constructor is used. This implementation provides guaranteed log(n) time cost for the basic operations (add, remove and contains). Note that the ordering maintained by a set (whether or not an explicit comparator is provided) must be consistent with equals if it is to correctly implement the Set interface. (See Comparable or Comparator for a precise definition of consistent with equals.) This is so because the Set interface is defined in terms of the equals operation, but a TreeSet instance performs all element comparisons using its compareTo (or compare) method, so two elements that are deemed equal by this method are, from the standpoint of the set, equal. The behavior of a set is well-defined even if its ordering is inconsistent with equals; it just fails to obey the general contract of the Set interface. Note that this implementation is not synchronized. If multiple threads access a tree set concurrently, and at least one of the threads modifies the set, it must be synchronized externally. This is typically accomplished by synchronizing on some object that naturally encapsulates the set. If no such object exists, the set should be "wrapped" using the synchronizedSortedSet Collections.synchronizedSortedSet method. This is best done at creation time, to prevent accidental unsynchronized access to the set:  SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...)); The iterators returned by this class's iterator method are fail-fast: if the set is modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. This class is a member of the  Java Collections Framework.
java.util.TreeSet.TreeSet	(	): Constructs a new, empty tree set, sorted according to the natural ordering of its elements. All elements inserted into the set must implement the Comparable interface. Furthermore, all such elements must be mutually comparable: e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the set. If the user attempts to add an element to the set that violates this constraint (for example, the user attempts to add a string element to a set whose elements are integers), the add call will throw a ClassCastException.
java.util.TreeSet.TreeSet	(	Collection	): Constructs a new tree set containing the elements in the specified collection, sorted according to the natural ordering of its elements. All elements inserted into the set must implement the Comparable interface. Furthermore, all such elements must be mutually comparable: e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the set.
java.util.TreeSet.TreeSet	(	Comparator	): Constructs a new, empty tree set, sorted according to the specified comparator. All elements inserted into the set must be mutually comparable by the specified comparator: comparator.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the set. If the user attempts to add an element to the set that violates this constraint, the add call will throw a ClassCastException.
java.util.TreeSet.TreeSet	(	NavigableMap	): Constructs a set backed by the specified navigable map.
java.util.TreeSet.TreeSet	(	SortedSet	): Constructs a new tree set containing the same elements and using the same ordering as the specified sorted set.
java.util.TreeSet.add	(	E	): Adds the specified element to this set if it is not already present. More formally, adds the specified element e to this set if the set contains no element e2 such that (e==null ? e2==null : e.equals(e2)). If this set already contains the element, the call leaves the set unchanged and returns false.
java.util.TreeSet.addAll	(	Collection	): Adds all of the elements in the specified collection to this set.
java.util.TreeSet.ceiling	(	E	): Returns the least element in this set greater than or equal to the given element, or null if there is no such element.
java.util.TreeSet.clear	(	): Removes all of the elements from this set. The set will be empty after this call returns.
java.util.TreeSet.clone	(	): Returns a shallow copy of this TreeSet instance. (The elements themselves are not cloned.)
java.util.TreeSet.contains	(	Object	): Returns true if this set contains the specified element. More formally, returns true if and only if this set contains an element e such that (o==null ? e==null : o.equals(e)).
java.util.TreeSet.descendingIterator	(	): Returns an iterator over the elements in this set in descending order.
java.util.TreeSet.descendingSet	(	): Returns a reverse order view of the elements contained in this set. The descending set is backed by this set, so changes to the set are reflected in the descending set, and vice-versa. If either set is modified while an iteration over either set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The returned set has an ordering equivalent to reverseOrder() Collections.reverseOrder(comparator()). The expression s.descendingSet().descendingSet() returns a view of s essentially equivalent to s.
java.util.TreeSet.first	(	): Returns the first (lowest) element currently in this set.
java.util.TreeSet.floor	(	E	): Returns the greatest element in this set less than or equal to the given element, or null if there is no such element.
java.util.TreeSet.headSet	(	E	): Returns a view of the portion of this set whose elements are strictly less than toElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range. Equivalent to headSet(toElement, false).
java.util.TreeSet.headSet	(	E	boolean	): Returns a view of the portion of this set whose elements are less than (or equal to, if inclusive is true) toElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range.
java.util.TreeSet.higher	(	E	): Returns the least element in this set strictly greater than the given element, or null if there is no such element.
java.util.TreeSet.isEmpty	(	): Returns true if this set contains no elements.
java.util.TreeSet.iterator	(	): Returns an iterator over the elements in this set in ascending order.
java.util.TreeSet.last	(	): Returns the last (highest) element currently in this set.
java.util.TreeSet.lower	(	E	): Returns the greatest element in this set strictly less than the given element, or null if there is no such element.
java.util.TreeSet.pollFirst	(	): Retrieves and removes the first (lowest) element, or returns null if this set is empty.
java.util.TreeSet.pollLast	(	): Retrieves and removes the last (highest) element, or returns null if this set is empty.
java.util.TreeSet.readObject	(	java.io.ObjectInputStream	): Reconstitute the TreeSet instance from a stream (that is, deserialize it).
java.util.TreeSet.remove	(	Object	): Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)
java.util.TreeSet.size	(	): Returns the number of elements in this set (its cardinality).
java.util.TreeSet.spliterator	(	): Creates a late-binding and fail-fast Spliterator over the elements in this set. The Spliterator reports SIZED, DISTINCT, SORTED, and ORDERED. Overriding implementations should document the reporting of additional characteristic values. The spliterator's comparator (see getComparator()) is null if the tree set's comparator (see comparator()) is null. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the tree set's comparator.
java.util.TreeSet.subSet	(	E	E	): Returns a view of the portion of this set whose elements range from fromElement, inclusive, to toElement, exclusive. (If fromElement and toElement are equal, the returned set is empty.) The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range. Equivalent to subSet(fromElement, true, toElement, false).
java.util.TreeSet.subSet	(	E	boolean	E	boolean	): Returns a view of the portion of this set whose elements range from fromElement to toElement. If fromElement and toElement are equal, the returned set is empty unless fromInclusive and toInclusive are both true. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range.
java.util.TreeSet.tailSet	(	E	): Returns a view of the portion of this set whose elements are greater than or equal to fromElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range. Equivalent to tailSet(fromElement, true).
java.util.TreeSet.tailSet	(	E	boolean	): Returns a view of the portion of this set whose elements are greater than (or equal to, if inclusive is true) fromElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range.
java.util.TreeSet.writeObject	(	java.io.ObjectOutputStream	): Save the state of the TreeSet instance to a stream (that is, serialize it).
java.util.Tripwire: Utility class for detecting inadvertent uses of boxing in java.util classes. The detection is turned on or off based on whether the system property org.openjdk.java.util.stream.tripwire is considered true according to getBoolean(). This should normally be turned off for production use.
java.util.Tripwire.trip	(	Class	String	): Produces a log warning, using PlatformLogger.getLogger(className), using the supplied message. The class name of trippingClass will be used as the first parameter to the message.
java.util.UUID: A class that represents an immutable universally unique identifier (UUID). A UUID represents a 128-bit value.  There exist different variants of these global identifiers. The methods of this class are for manipulating the Leach-Salz variant, although the constructors allow the creation of any variant of UUID (described below).  The layout of a variant 2 (Leach-Salz) UUID is as follows: The most significant long consists of the following unsigned fields:  0xFFFFFFFF00000000 time_low 0x00000000FFFF0000 time_mid 0x000000000000F000 version 0x0000000000000FFF time_hi  The least significant long consists of the following unsigned fields:  0xC000000000000000 variant 0x3FFF000000000000 clock_seq 0x0000FFFFFFFFFFFF node   The variant field contains a value which identifies the layout of the UUID. The bit layout described above is valid only for a UUID with a variant value of 2, which indicates the Leach-Salz variant.  The version field holds a value that describes the type of this UUID. There are four different basic types of UUIDs: time-based, DCE security, name-based, and randomly generated UUIDs. These types have a version value of 1, 2, 3 and 4, respectively.  For more information including algorithms used to create UUIDs, see  RFC 4122: A Universally Unique IDentifier (UUID) URN Namespace, section 4.2 "Algorithms for Creating a Time-Based UUID".
java.util.UUID.UUID	(	long	long	): Constructs a new UUID using the specified data. mostSigBits is used for the most significant 64 bits of the UUID and leastSigBits becomes the least significant 64 bits of the UUID.
java.util.UUID.clockSequence	(	): The clock sequence value associated with this UUID.  The 14 bit clock sequence value is constructed from the clock sequence field of this UUID. The clock sequence field is used to guarantee temporal uniqueness in a time-based UUID.  The clockSequence value is only meaningful in a time-based UUID, which has version type 1. If this UUID is not a time-based UUID then this method throws UnsupportedOperationException.
java.util.UUID.compareTo	(	UUID	): Compares this UUID with the specified UUID.  The first of two UUIDs is greater than the second if the most significant field in which the UUIDs differ is greater for the first UUID.
java.util.UUID.digits	(	long	int	): Returns val represented by the specified number of hex digits. 
java.util.UUID.equals	(	Object	): Compares this object to the specified object. The result is true if and only if the argument is not null, is a UUID object, has the same variant, and contains the same value, bit for bit, as this UUID.
java.util.UUID.fromString	(	String	): Creates a UUID from the string standard representation as described in the toString method.
java.util.UUID.getLeastSignificantBits	(	): Returns the least significant 64 bits of this UUID's 128 bit value.
java.util.UUID.getMostSignificantBits	(	): Returns the most significant 64 bits of this UUID's 128 bit value.
java.util.UUID.hashCode	(	): Returns a hash code for this UUID.
java.util.UUID.nameUUIDFromBytes	(	byte[]	): Static factory to retrieve a type 3 (name based) UUID based on the specified byte array.
java.util.UUID.node	(	): The node value associated with this UUID.  The 48 bit node value is constructed from the node field of this UUID. This field is intended to hold the IEEE 802 address of the machine that generated this UUID to guarantee spatial uniqueness.  The node value is only meaningful in a time-based UUID, which has version type 1. If this UUID is not a time-based UUID then this method throws UnsupportedOperationException.
java.util.UUID.randomUUID	(	): Static factory to retrieve a type 4 (pseudo randomly generated) UUID. The UUID is generated using a cryptographically strong pseudo random number generator.
java.util.UUID.timestamp	(	): The timestamp value associated with this UUID.  The 60 bit timestamp value is constructed from the time_low, time_mid, and time_hi fields of this UUID. The resulting timestamp is measured in 100-nanosecond units since midnight, October 15, 1582 UTC.  The timestamp value is only meaningful in a time-based UUID, which has version type 1. If this UUID is not a time-based UUID then this method throws UnsupportedOperationException.
java.util.UUID.toString	(	): Returns a String object representing this UUID.  The UUID string representation is as described by this BNF:  UUID =  "-"  "-"  "-"  "-"  time_low = 4* time_mid = 2* time_high_and_version = 2* variant_and_sequence = 2* node = 6* hexOctet =  hexDigit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "a" | "b" | "c" | "d" | "e" | "f" | "A" | "B" | "C" | "D" | "E" | "F"
java.util.UUID.variant	(	): The variant number associated with this UUID. The variant number describes the layout of the UUID. The variant number has the following meaning:  0 Reserved for NCS backward compatibility 2 IETF RFC 4122 (Leach-Salz), used by this class 6 Reserved, Microsoft Corporation backward compatibility 7 Reserved for future definition 
java.util.UUID.version	(	): The version number associated with this UUID. The version number describes how this UUID was generated. The version number has the following meaning:  1 Time-based UUID 2 DCE security UUID 3 Name-based UUID 4 Randomly generated UUID 
java.util.UnknownFormatConversionException: Unchecked exception thrown when an unknown conversion is given.  Unless otherwise specified, passing a null argument to any method or constructor in this class will cause a NullPointerException to be thrown.
java.util.UnknownFormatConversionException.UnknownFormatConversionException	(	String	): Constructs an instance of this class with the unknown conversion.
java.util.UnknownFormatConversionException.getConversion	(	): Returns the unknown conversion.
java.util.UnknownFormatFlagsException: Unchecked exception thrown when an unknown flag is given.  Unless otherwise specified, passing a null argument to any method or constructor in this class will cause a NullPointerException to be thrown.
java.util.UnknownFormatFlagsException.UnknownFormatFlagsException	(	String	): Constructs an instance of this class with the specified flags.
java.util.UnknownFormatFlagsException.getFlags	(	): Returns the set of flags which contains an unknown flag.
java.util.Vector: The Vector class implements a growable array of objects. Like an array, it contains components that can be accessed using an integer index. However, the size of a Vector can grow or shrink as needed to accommodate adding and removing items after the Vector has been created. Each vector tries to optimize storage management by maintaining a capacity and a capacityIncrement. The capacity is always at least as large as the vector size; it is usually larger because as components are added to the vector, the vector's storage increases in chunks the size of capacityIncrement. An application can increase the capacity of a vector before inserting a large number of components; this reduces the amount of incremental reallocation.  The iterators returned by this class's iterator() and listIterator() methods are fail-fast: if the vector is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove() or add() methods, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. The Enumeration Enumerations returned by the elements() method are not fail-fast. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. As of the Java 2 platform v1.2, this class was retrofitted to implement the List interface, making it a member of the  Java Collections Framework. Unlike the new collection implementations, Vector is synchronized. If a thread-safe implementation is not needed, it is recommended to use ArrayList in place of Vector.
java.util.Vector.Itr: An optimized version of AbstractList.Itr
java.util.Vector.ListItr: An optimized version of AbstractList.ListItr
java.util.Vector.Vector	(	): Constructs an empty vector so that its internal data array has size 10 and its standard capacity increment is zero.
java.util.Vector.Vector	(	Collection	): Constructs a vector containing the elements of the specified collection, in the order they are returned by the collection's iterator.
java.util.Vector.Vector	(	int	): Constructs an empty vector with the specified initial capacity and with its capacity increment equal to zero.
java.util.Vector.Vector	(	int	int	): Constructs an empty vector with the specified initial capacity and capacity increment.
java.util.Vector.VectorSpliterator: Similar to ArrayList Spliterator 
java.util.Vector.VectorSpliterator.VectorSpliterator	(	Vector	Object[]	int	int	int	): Create new spliterator covering the given range 
java.util.Vector.add	(	E	): Appends the specified element to the end of this Vector.
java.util.Vector.add	(	int	E	): Inserts the specified element at the specified position in this Vector. Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices).
java.util.Vector.addAll	(	Collection	): Appends all of the elements in the specified Collection to the end of this Vector, in the order that they are returned by the specified Collection's Iterator. The behavior of this operation is undefined if the specified Collection is modified while the operation is in progress. (This implies that the behavior of this call is undefined if the specified Collection is this Vector, and this Vector is nonempty.)
java.util.Vector.addAll	(	int	Collection	): Inserts all of the elements in the specified Collection into this Vector at the specified position. Shifts the element currently at that position (if any) and any subsequent elements to the right (increases their indices). The new elements will appear in the Vector in the order that they are returned by the specified Collection's iterator.
java.util.Vector.addElement	(	E	): Adds the specified component to the end of this vector, increasing its size by one. The capacity of this vector is increased if its size becomes greater than its capacity. This method is identical in functionality to the add() add(E) method (which is part of the List interface).
java.util.Vector.capacity	(	): Returns the current capacity of this vector.
java.util.Vector.clear	(	): Removes all of the elements from this Vector. The Vector will be empty after this call returns (unless it throws an exception).
java.util.Vector.clone	(	): Returns a clone of this vector. The copy will contain a reference to a clone of the internal data array, not a reference to the original internal data array of this Vector object.
java.util.Vector.contains	(	Object	): Returns true if this vector contains the specified element. More formally, returns true if and only if this vector contains at least one element e such that (o==null ? e==null : o.equals(e)).
java.util.Vector.containsAll	(	Collection	): Returns true if this Vector contains all of the elements in the specified Collection.
java.util.Vector.copyInto	(	Object[]	): Copies the components of this vector into the specified array. The item at index k in this vector is copied into component k of anArray.
java.util.Vector.elementAt	(	int	): Returns the component at the specified index. This method is identical in functionality to the get() method (which is part of the List interface).
java.util.Vector.elements	(	): Returns an enumeration of the components of this vector. The returned Enumeration object will generate all items in this vector. The first item generated is the item at index 0, then the item at index 1, and so on.
java.util.Vector.ensureCapacity	(	int	): Increases the capacity of this vector, if necessary, to ensure that it can hold at least the number of components specified by the minimum capacity argument. If the current capacity of this vector is less than minCapacity, then its capacity is increased by replacing its internal data array, kept in the field elementData, with a larger one. The size of the new data array will be the old size plus capacityIncrement, unless the value of capacityIncrement is less than or equal to zero, in which case the new capacity will be twice the old capacity; but if this new size is still smaller than minCapacity, then the new capacity will be minCapacity.
java.util.Vector.ensureCapacityHelper	(	int	): This implements the unsynchronized semantics of ensureCapacity. Synchronized methods in this class can internally call this method for ensuring capacity without incurring the cost of an extra synchronization.
java.util.Vector.equals	(	Object	): Compares the specified Object with this Vector for equality. Returns true if and only if the specified Object is also a List, both Lists have the same size, and all corresponding pairs of elements in the two Lists are equal. (Two elements e1 and e2 are equal if (e1==null ? e2==null : e1.equals(e2)).) In other words, two Lists are defined to be equal if they contain the same elements in the same order.
java.util.Vector.firstElement	(	): Returns the first component (the item at index 0) of this vector.
java.util.Vector.get	(	int	): Returns the element at the specified position in this Vector.
java.util.Vector.hashCode	(	): Returns the hash code value for this Vector.
java.util.Vector.indexOf	(	Object	): Returns the index of the first occurrence of the specified element in this vector, or -1 if this vector does not contain the element. More formally, returns the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.
java.util.Vector.indexOf	(	Object	int	): Returns the index of the first occurrence of the specified element in this vector, searching forwards from index, or returns -1 if the element is not found. More formally, returns the lowest index i such that (i >= index && (o==null ? get(i)==null : o.equals(get(i)))), or -1 if there is no such index.
java.util.Vector.insertElementAt	(	E	int	): Inserts the specified object as a component in this vector at the specified index. Each component in this vector with an index greater or equal to the specified index is shifted upward to have an index one greater than the value it had previously. The index must be a value greater than or equal to 0 and less than or equal to the current size of the vector. (If the index is equal to the current size of the vector, the new element is appended to the Vector.) This method is identical in functionality to the add() add(int, E) method (which is part of the List interface). Note that the add method reverses the order of the parameters, to more closely match array usage.
java.util.Vector.isEmpty	(	): Tests if this vector has no components.
java.util.Vector.iterator	(	): Returns an iterator over the elements in this list in proper sequence. The returned iterator is fail-fast.
java.util.Vector.lastElement	(	): Returns the last component of the vector.
java.util.Vector.lastIndexOf	(	Object	): Returns the index of the last occurrence of the specified element in this vector, or -1 if this vector does not contain the element. More formally, returns the highest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.
java.util.Vector.lastIndexOf	(	Object	int	): Returns the index of the last occurrence of the specified element in this vector, searching backwards from index, or returns -1 if the element is not found. More formally, returns the highest index i such that (i <= index && (o==null ? get(i)==null : o.equals(get(i)))), or -1 if there is no such index.
java.util.Vector.listIterator	(	): Returns a list iterator over the elements in this list (in proper sequence). The returned list iterator is fail-fast.
java.util.Vector.listIterator	(	int	): Returns a list iterator over the elements in this list (in proper sequence), starting at the specified position in the list. The specified index indicates the first element that would be returned by an initial call to next. An initial call to previous would return the element with the specified index minus one. The returned list iterator is fail-fast.
java.util.Vector.remove	(	Object	): Removes the first occurrence of the specified element in this Vector If the Vector does not contain the element, it is unchanged. More formally, removes the element with the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))) (if such an element exists).
java.util.Vector.remove	(	int	): Removes the element at the specified position in this Vector. Shifts any subsequent elements to the left (subtracts one from their indices). Returns the element that was removed from the Vector.
java.util.Vector.removeAll	(	Collection	): Removes from this Vector all of its elements that are contained in the specified Collection.
java.util.Vector.removeAllElements	(	): Removes all components from this vector and sets its size to zero. This method is identical in functionality to the clear method (which is part of the List interface).
java.util.Vector.removeElement	(	Object	): Removes the first (lowest-indexed) occurrence of the argument from this vector. If the object is found in this vector, each component in the vector with an index greater or equal to the object's index is shifted downward to have an index one smaller than the value it had previously. This method is identical in functionality to the remove() method (which is part of the List interface).
java.util.Vector.removeElementAt	(	int	): Deletes the component at the specified index. Each component in this vector with an index greater or equal to the specified index is shifted downward to have an index one smaller than the value it had previously. The size of this vector is decreased by 1. The index must be a value greater than or equal to 0 and less than the current size of the vector. This method is identical in functionality to the remove() method (which is part of the List interface). Note that the remove method returns the old value that was stored at the specified position.
java.util.Vector.removeRange	(	int	int	): Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive. Shifts any succeeding elements to the left (reduces their index). This call shortens the list by (toIndex - fromIndex) elements. (If toIndex==fromIndex, this operation has no effect.)
java.util.Vector.retainAll	(	Collection	): Retains only the elements in this Vector that are contained in the specified Collection. In other words, removes from this Vector all of its elements that are not contained in the specified Collection.
java.util.Vector.set	(	int	E	): Replaces the element at the specified position in this Vector with the specified element.
java.util.Vector.setElementAt	(	E	int	): Sets the component at the specified index of this vector to be the specified object. The previous component at that position is discarded. The index must be a value greater than or equal to 0 and less than the current size of the vector. This method is identical in functionality to the set() set(int, E) method (which is part of the List interface). Note that the set method reverses the order of the parameters, to more closely match array usage. Note also that the set method returns the old value that was stored at the specified position.
java.util.Vector.setSize	(	int	): Sets the size of this vector. If the new size is greater than the current size, new null items are added to the end of the vector. If the new size is less than the current size, all components at index newSize and greater are discarded.
java.util.Vector.size	(	): Returns the number of components in this vector.
java.util.Vector.spliterator	(	): Creates a late-binding and fail-fast Spliterator over the elements in this list. The Spliterator reports SIZED, SUBSIZED, and ORDERED. Overriding implementations should document the reporting of additional characteristic values.
java.util.Vector.subList	(	int	int	): Returns a view of the portion of this List between fromIndex, inclusive, and toIndex, exclusive. (If fromIndex and toIndex are equal, the returned List is empty.) The returned List is backed by this List, so changes in the returned List are reflected in this List, and vice-versa. The returned List supports all of the optional List operations supported by this List. This method eliminates the need for explicit range operations (of the sort that commonly exist for arrays). Any operation that expects a List can be used as a range operation by operating on a subList view instead of a whole List. For example, the following idiom removes a range of elements from a List:  list.subList(from, to).clear();  Similar idioms may be constructed for indexOf and lastIndexOf, and all of the algorithms in the Collections class can be applied to a subList. The semantics of the List returned by this method become undefined if the backing list (i.e., this List) is structurally modified in any way other than via the returned List. (Structural modifications are those that change the size of the List, or otherwise perturb it in such a fashion that iterations in progress may yield incorrect results.)
java.util.Vector.toArray	(	): Returns an array containing all of the elements in this Vector in the correct order.
java.util.Vector.toArray	(	T[]	): Returns an array containing all of the elements in this Vector in the correct order; the runtime type of the returned array is that of the specified array. If the Vector fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this Vector. If the Vector fits in the specified array with room to spare (i.e., the array has more elements than the Vector), the element in the array immediately following the end of the Vector is set to null. (This is useful in determining the length of the Vector only if the caller knows that the Vector does not contain any null elements.)
java.util.Vector.toString	(	): Returns a string representation of this Vector, containing the String representation of each element.
java.util.Vector.trimToSize	(	): Trims the capacity of this vector to be the vector's current size. If the capacity of this vector is larger than its current size, then the capacity is changed to equal the size by replacing its internal data array, kept in the field elementData, with a smaller one. An application can use this operation to minimize the storage of a vector.
java.util.Vector.writeObject	(	java.io.ObjectOutputStream	): Save the state of the Vector instance to a stream (that is, serialize it). This method performs synchronization to ensure the consistency of the serialized data.
java.util.WeakHashMap: Hash table based implementation of the Map interface, with weak keys. An entry in a WeakHashMap will automatically be removed when its key is no longer in ordinary use. More precisely, the presence of a mapping for a given key will not prevent the key from being discarded by the garbage collector, that is, made finalizable, finalized, and then reclaimed. When a key has been discarded its entry is effectively removed from the map, so this class behaves somewhat differently from other Map implementations.  Both null values and the null key are supported. This class has performance characteristics similar to those of the HashMap class, and has the same efficiency parameters of initial capacity and load factor.  Like most collection classes, this class is not synchronized. A synchronized WeakHashMap may be constructed using the synchronizedMap Collections.synchronizedMap method.  This class is intended primarily for use with key objects whose equals methods test for object identity using the == operator. Once such a key is discarded it can never be recreated, so it is impossible to do a lookup of that key in a WeakHashMap at some later time and be surprised that its entry has been removed. This class will work perfectly well with key objects whose equals methods are not based upon object identity, such as String instances. With such recreatable key objects, however, the automatic removal of WeakHashMap entries whose keys have been discarded may prove to be confusing.  The behavior of the WeakHashMap class depends in part upon the actions of the garbage collector, so several familiar (though not required) Map invariants do not hold for this class. Because the garbage collector may discard keys at any time, a WeakHashMap may behave as though an unknown thread is silently removing entries. In particular, even if you synchronize on a WeakHashMap instance and invoke none of its mutator methods, it is possible for the size method to return smaller values over time, for the isEmpty method to return false and then true, for the containsKey method to return true and later false for a given key, for the get method to return a value for a given key but later return null, for the put method to return null and the remove method to return false for a key that previously appeared to be in the map, and for successive examinations of the key set, the value collection, and the entry set to yield successively smaller numbers of elements.  Each key object in a WeakHashMap is stored indirectly as the referent of a weak reference. Therefore a key will automatically be removed only after the weak references to it, both inside and outside of the map, have been cleared by the garbage collector.  Implementation note: The value objects in a WeakHashMap are held by ordinary strong references. Thus care should be taken to ensure that value objects do not strongly refer to their own keys, either directly or indirectly, since that will prevent the keys from being discarded. Note that a value object may refer indirectly to its key via the WeakHashMap itself; that is, a value object may strongly refer to some other key object whose associated value object, in turn, strongly refers to the key of the first value object. If the values in the map do not rely on the map holding strong references to them, one way to deal with this is to wrap values themselves within WeakReferences before inserting, as in: m.put(key, new WeakReference(value)), and then unwrapping upon each get. The iterators returned by the iterator method of the collections returned by all of this class's "collection view methods" are fail-fast: if the map is structurally modified at any time after the iterator is created, in any way except through the iterator's own remove method, the iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future. Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, generally speaking, impossible to make any hard guarantees in the presence of unsynchronized concurrent modification. Fail-fast iterators throw ConcurrentModificationException on a best-effort basis. Therefore, it would be wrong to write a program that depended on this exception for its correctness: the fail-fast behavior of iterators should be used only to detect bugs. This class is a member of the  Java Collections Framework.
java.util.WeakHashMap.Entry: The entries in this hash table extend WeakReference, using its main ref field as the key.
java.util.WeakHashMap.Entry.Entry	(	Object	V	ReferenceQueue	int	Entry	): Creates new entry.
java.util.WeakHashMap.HashIterator.nextEntry	(	): The common parts of next() across different types of iterators 
java.util.WeakHashMap.WeakHashMap	(	): Constructs a new, empty WeakHashMap with the default initial capacity (16) and load factor (0.75).
java.util.WeakHashMap.WeakHashMap	(	Map	): Constructs a new WeakHashMap with the same mappings as the specified map. The WeakHashMap is created with the default load factor (0.75) and an initial capacity sufficient to hold the mappings in the specified map.
java.util.WeakHashMap.WeakHashMap	(	int	): Constructs a new, empty WeakHashMap with the given initial capacity and the default load factor (0.75).
java.util.WeakHashMap.WeakHashMap	(	int	float	): Constructs a new, empty WeakHashMap with the given initial capacity and the given load factor.
java.util.WeakHashMap.WeakHashMapSpliterator: Similar form as other hash Spliterators, but skips dead elements.
java.util.WeakHashMap.clear	(	): Removes all of the mappings from this map. The map will be empty after this call returns.
java.util.WeakHashMap.containsKey	(	Object	): Returns true if this map contains a mapping for the specified key.
java.util.WeakHashMap.containsNullValue	(	): Special-case code for containsValue with null argument
java.util.WeakHashMap.containsValue	(	Object	): Returns true if this map maps one or more keys to the specified value.
java.util.WeakHashMap.entrySet	(	): Returns a Set view of the mappings contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation, or through the setValue operation on a map entry returned by the iterator) the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.WeakHashMap.eq	(	Object	Object	): Checks for equality of non-null reference x and possibly-null y. By default uses Object.equals.
java.util.WeakHashMap.expungeStaleEntries	(	): Expunges stale entries from the table.
java.util.WeakHashMap.get	(	Object	): Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that (key==null ? k==null : key.equals(k)), then this method returns v; otherwise it returns null. (There can be at most one such mapping.) A return value of null does not necessarily indicate that the map contains no mapping for the key; it's also possible that the map explicitly maps the key to null. The containsKey operation may be used to distinguish these two cases.
java.util.WeakHashMap.getEntry	(	Object	): Returns the entry associated with the specified key in this map. Returns null if the map contains no mapping for this key.
java.util.WeakHashMap.getTable	(	): Returns the table after first expunging stale entries.
java.util.WeakHashMap.hash	(	Object	): Retrieve object hash code and applies a supplemental hash function to the result hash, which defends against poor quality hash functions. This is critical because HashMap uses power-of-two length hash tables, that otherwise encounter collisions for hashCodes that do not differ in lower bits.
java.util.WeakHashMap.indexFor	(	int	int	): Returns index for hash code h.
java.util.WeakHashMap.isEmpty	(	): Returns true if this map contains no key-value mappings. This result is a snapshot, and may not reflect unprocessed entries that will be removed before next attempted access because they are no longer referenced.
java.util.WeakHashMap.keySet	(	): Returns a Set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. If the map is modified while an iteration over the set is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations.
java.util.WeakHashMap.maskNull	(	Object	): Use NULL_KEY for key if it is null.
java.util.WeakHashMap.put	(	K	V	): Associates the specified value with the specified key in this map. If the map previously contained a mapping for this key, the old value is replaced.
java.util.WeakHashMap.putAll	(	Map	): Copies all of the mappings from the specified map to this map. These mappings will replace any mappings that this map had for any of the keys currently in the specified map.
java.util.WeakHashMap.remove	(	Object	): Removes the mapping for a key from this weak hash map if it is present. More formally, if this map contains a mapping from key k to value v such that (key==null ? k==null : key.equals(k)), that mapping is removed. (The map can contain at most one such mapping.) Returns the value to which this map previously associated the key, or null if the map contained no mapping for the key. A return value of null does not necessarily indicate that the map contained no mapping for the key; it's also possible that the map explicitly mapped the key to null. The map will not contain a mapping for the specified key once the call returns.
java.util.WeakHashMap.removeMapping	(	Object	): Special version of remove needed by Entry set 
java.util.WeakHashMap.resize	(	int	): Rehashes the contents of this map into a new array with a larger capacity. This method is called automatically when the number of keys in this map reaches its threshold. If current capacity is MAXIMUM_CAPACITY, this method does not resize the map, but sets threshold to Integer.MAX_VALUE. This has the effect of preventing future calls.
java.util.WeakHashMap.size	(	): Returns the number of key-value mappings in this map. This result is a snapshot, and may not reflect unprocessed entries that will be removed before next attempted access because they are no longer referenced.
java.util.WeakHashMap.transfer	(	Entry[]	Entry[]	): Transfers all entries from src to dest tables 
java.util.WeakHashMap.unmaskNull	(	Object	): Returns internal representation of null key back to caller as null.
java.util.WeakHashMap.values	(	): Returns a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. If the map is modified while an iteration over the collection is in progress (except through the iterator's own remove operation), the results of the iteration are undefined. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations.
java.util.concurrent.AbstractExecutorService: Provides default implementations of ExecutorService execution methods. This class implements the submit, invokeAny and invokeAll methods using a RunnableFuture returned by newTaskFor, which defaults to the FutureTask class provided in this package. For example, the implementation of submit(Runnable) creates an associated RunnableFuture that is executed and returned. Subclasses may override the newTaskFor methods to return RunnableFuture implementations other than FutureTask. Extension example. Here is a sketch of a class that customizes ThreadPoolExecutor to use a CustomTask class instead of the default FutureTask:  public class CustomThreadPoolExecutor extends ThreadPoolExecutor static class CustomTask implements RunnableFuture {...} protected  RunnableFuture newTaskFor(Callable c) { return new CustomTask(c); } protected  RunnableFuture newTaskFor(Runnable r, V v) { return new CustomTask(r, v); } // ... add constructors, etc. }}
java.util.concurrent.AbstractExecutorService.doInvokeAny	(	Collection	boolean	long	): the main mechanics of invokeAny.
java.util.concurrent.AbstractExecutorService.newTaskFor	(	Callable	): Returns a RunnableFuture for the given callable task.
java.util.concurrent.AbstractExecutorService.newTaskFor	(	Runnable	T	): Returns a RunnableFuture for the given runnable and default value.
java.util.concurrent.AbstractExecutorService.submit	(	Callable	): Submits a value-returning task for execution and returns a Future representing the pending results of the task. The Future's get method will return the task's result upon successful completion.  If you would like to immediately block waiting for a task, you can use constructions of the form result = exec.submit(aCallable).get(); Note: The Executors class includes a set of methods that can convert some other common closure-like objects, for example, java.security.PrivilegedAction to Callable form so they can be submitted.
java.util.concurrent.AbstractExecutorService.submit	(	Runnable	): Submits a Runnable task for execution and returns a Future representing that task. The Future's get method will return null upon successful completion.
java.util.concurrent.AbstractExecutorService.submit	(	Runnable	T	): Submits a Runnable task for execution and returns a Future representing that task. The Future's get method will return the given result upon successful completion.
java.util.concurrent.ArrayBlockingQueue: A bounded BlockingQueue blocking queue backed by an array. This queue orders elements FIFO (first-in-first-out). The head of the queue is that element that has been on the queue the longest time. The tail of the queue is that element that has been on the queue the shortest time. New elements are inserted at the tail of the queue, and the queue retrieval operations obtain elements at the head of the queue. This is a classic "bounded buffer", in which a fixed-sized array holds elements inserted by producers and extracted by consumers. Once created, the capacity cannot be changed. Attempts to put an element into a full queue will result in the operation blocking; attempts to take an element from an empty queue will similarly block. This class supports an optional fairness policy for ordering waiting producer and consumer threads. By default, this ordering is not guaranteed. However, a queue constructed with fairness set to true grants threads access in FIFO order. Fairness generally decreases throughput but reduces variability and avoids starvation. This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces. This class is a member of the  Java Collections Framework.
java.util.concurrent.ArrayBlockingQueue.ArrayBlockingQueue	(	int	): Creates an ArrayBlockingQueue with the given (fixed) capacity and default access policy.
java.util.concurrent.ArrayBlockingQueue.ArrayBlockingQueue	(	int	boolean	): Creates an ArrayBlockingQueue with the given (fixed) capacity and the specified access policy.
java.util.concurrent.ArrayBlockingQueue.ArrayBlockingQueue	(	int	boolean	Collection	): Creates an ArrayBlockingQueue with the given (fixed) capacity, the specified access policy and initially containing the elements of the given collection, added in traversal order of the collection's iterator.
java.util.concurrent.ArrayBlockingQueue.Itr: Iterator for ArrayBlockingQueue. To maintain weak consistency with respect to puts and takes, we read ahead one slot, so as to not report hasNext true but then not have an element to return. We switch into "detached" mode (allowing prompt unlinking from itrs without help from the GC) when all indices are negative, or when hasNext returns false for the first time. This allows the iterator to track concurrent updates completely accurately, except for the corner case of the user calling Iterator.remove() after hasNext() returned false. Even in this case, we ensure that we don't remove the wrong element by keeping track of the expected element to remove, in lastItem. Yes, we may fail to remove lastItem from the queue if it moved due to an interleaved interior remove while in detached mode.
java.util.concurrent.ArrayBlockingQueue.Itr.detach	(	): Called when itrs should stop tracking this iterator, either because there are no more indices to update (cursor < 0 && nextIndex < 0 && lastRet < 0) or as a special exception, when lastRet >= 0, because hasNext() is about to return false for the first time. Call only from iterating thread.
java.util.concurrent.ArrayBlockingQueue.Itr.hasNext	(	): For performance reasons, we would like not to acquire a lock in hasNext in the common case. To allow for this, we only access fields (i.e. nextItem) that are not modified by update operations triggered by queue modifications.
java.util.concurrent.ArrayBlockingQueue.Itr.incorporateDequeues	(	): Adjusts indices to incorporate all dequeues since the last operation on this iterator. Call only from iterating thread.
java.util.concurrent.ArrayBlockingQueue.Itr.invalidated	(	int	int	long	int	): Returns true if index is invalidated by the given number of dequeues, starting from prevTakeIndex.
java.util.concurrent.ArrayBlockingQueue.Itr.removedAt	(	int	): Called whenever an interior remove (not at takeIndex) occurred.
java.util.concurrent.ArrayBlockingQueue.Itr.shutdown	(	): Called to notify the iterator that the queue is empty, or that it has fallen hopelessly behind, so that it should abandon any further iteration, except possibly to return one more element from next(), as promised by returning true from hasNext().
java.util.concurrent.ArrayBlockingQueue.Itr.takeIndexWrapped	(	): Called whenever takeIndex wraps around to zero.
java.util.concurrent.ArrayBlockingQueue.Itrs: Shared data between iterators and their queue, allowing queue modifications to update iterators when elements are removed. This adds a lot of complexity for the sake of correctly handling some uncommon operations, but the combination of circular-arrays and supporting interior removes (i.e., those not at head) would cause iterators to sometimes lose their places and/or (re)report elements they shouldn't. To avoid this, when a queue has one or more iterators, it keeps iterator state consistent by: (1) keeping track of the number of "cycles", that is, the number of times takeIndex has wrapped around to 0. (2) notifying all iterators via the callback removedAt whenever an interior element is removed (and thus other elements may be shifted). These suffice to eliminate iterator inconsistencies, but unfortunately add the secondary responsibility of maintaining the list of iterators. We track all active iterators in a simple linked list (accessed only when the queue's lock is held) of weak references to Itr. The list is cleaned up using 3 different mechanisms: (1) Whenever a new iterator is created, do some O(1) checking for stale list elements. (2) Whenever takeIndex wraps around to 0, check for iterators that have been unused for more than one wrap-around cycle. (3) Whenever the queue becomes empty, all iterators are notified and this entire data structure is discarded. So in addition to the removedAt callback that is necessary for correctness, iterators have the shutdown and takeIndexWrapped callbacks that help remove stale iterators from the list. Whenever a list element is examined, it is expunged if either the GC has determined that the iterator is discarded, or if the iterator reports that it is "detached" (does not need any further state updates). Overhead is maximal when takeIndex never advances, iterators are discarded before they are exhausted, and all removals are interior removes, in which case all stale iterators are discovered by the GC. But even in this case we don't increase the amortized complexity. Care must be taken to keep list sweeping methods from reentrantly invoking another such method, causing subtle corruption bugs.
java.util.concurrent.ArrayBlockingQueue.Itrs.Node: Node in a linked list of weak iterator references.
java.util.concurrent.ArrayBlockingQueue.Itrs.doSomeSweeping	(	boolean	): Sweeps itrs, looking for and expunging stale iterators. If at least one was found, tries harder to find more. Called only from iterating thread.
java.util.concurrent.ArrayBlockingQueue.Itrs.elementDequeued	(	): Called whenever an element has been dequeued (at takeIndex).
java.util.concurrent.ArrayBlockingQueue.Itrs.queueIsEmpty	(	): Called whenever the queue becomes empty. Notifies all active iterators that the queue is empty, clears all weak refs, and unlinks the itrs datastructure.
java.util.concurrent.ArrayBlockingQueue.Itrs.register	(	Itr	): Adds a new iterator to the linked list of tracked iterators.
java.util.concurrent.ArrayBlockingQueue.Itrs.removedAt	(	int	): Called whenever an interior remove (not at takeIndex) occurred. Notifies all iterators, and expunges any that are now stale.
java.util.concurrent.ArrayBlockingQueue.Itrs.takeIndexWrapped	(	): Called whenever takeIndex wraps around to 0. Notifies all iterators, and expunges any that are now stale.
java.util.concurrent.ArrayBlockingQueue.add	(	E	): Inserts the specified element at the tail of this queue if it is possible to do so immediately without exceeding the queue's capacity, returning true upon success and throwing an IllegalStateException if this queue is full.
java.util.concurrent.ArrayBlockingQueue.checkNotNull	(	Object	): Throws NullPointerException if argument is null.
java.util.concurrent.ArrayBlockingQueue.clear	(	): Atomically removes all of the elements from this queue. The queue will be empty after this call returns.
java.util.concurrent.ArrayBlockingQueue.contains	(	Object	): Returns true if this queue contains the specified element. More formally, returns true if and only if this queue contains at least one element e such that o.equals(e).
java.util.concurrent.ArrayBlockingQueue.dec	(	int	): Circularly decrement i.
java.util.concurrent.ArrayBlockingQueue.dequeue	(	): Extracts element at current take position, advances, and signals. Call only when holding lock.
java.util.concurrent.ArrayBlockingQueue.drainTo	(	Collection	): Removes all available elements from this queue and adds them to the given collection. This operation may be more efficient than repeatedly polling this queue. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.ArrayBlockingQueue.drainTo	(	Collection	int	): Removes at most the given number of available elements from this queue and adds them to the given collection. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.ArrayBlockingQueue.enqueue	(	E	): Inserts element at current put position, advances, and signals. Call only when holding lock.
java.util.concurrent.ArrayBlockingQueue.itemAt	(	int	): Returns item at index i.
java.util.concurrent.ArrayBlockingQueue.iterator	(	): Returns an iterator over the elements in this queue in proper sequence. The elements will be returned in order from first (head) to last (tail). The returned iterator is weakly consistent.
java.util.concurrent.ArrayBlockingQueue.offer	(	E	): Inserts the specified element at the tail of this queue if it is possible to do so immediately without exceeding the queue's capacity, returning true upon success and false if this queue is full. This method is generally preferable to method add, which can fail to insert an element only by throwing an exception.
java.util.concurrent.ArrayBlockingQueue.offer	(	E	long	TimeUnit	): Inserts the specified element at the tail of this queue, waiting up to the specified wait time for space to become available if the queue is full.
java.util.concurrent.ArrayBlockingQueue.put	(	E	): Inserts the specified element at the tail of this queue, waiting for space to become available if the queue is full.
java.util.concurrent.ArrayBlockingQueue.remainingCapacity	(	): Returns the number of additional elements that this queue can ideally (in the absence of memory or resource constraints) accept without blocking. This is always equal to the initial capacity of this queue less the current size of this queue. Note that you cannot always tell if an attempt to insert an element will succeed by inspecting remainingCapacity because it may be the case that another thread is about to insert or remove an element.
java.util.concurrent.ArrayBlockingQueue.remove	(	Object	): Removes a single instance of the specified element from this queue, if it is present. More formally, removes an element e such that o.equals(e), if this queue contains one or more such elements. Returns true if this queue contained the specified element (or equivalently, if this queue changed as a result of the call). Removal of interior elements in circular array based queues is an intrinsically slow and disruptive operation, so should be undertaken only in exceptional circumstances, ideally only when the queue is known not to be accessible by other threads.
java.util.concurrent.ArrayBlockingQueue.removeAt	(	int	): Deletes item at array index removeIndex. Utility for remove(Object) and iterator.remove. Call only when holding lock.
java.util.concurrent.ArrayBlockingQueue.size	(	): Returns the number of elements in this queue.
java.util.concurrent.ArrayBlockingQueue.spliterator	(	): Returns a Spliterator over the elements in this queue. The returned spliterator is weakly consistent. The Spliterator reports CONCURRENT, ORDERED, and NONNULL.
java.util.concurrent.ArrayBlockingQueue.toArray	(	): Returns an array containing all of the elements in this queue, in proper sequence. The returned array will be "safe" in that no references to it are maintained by this queue. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.concurrent.ArrayBlockingQueue.toArray	(	T[]	): Returns an array containing all of the elements in this queue, in proper sequence; the runtime type of the returned array is that of the specified array. If the queue fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this queue. If this queue fits in the specified array with room to spare (i.e., the array has more elements than this queue), the element in the array immediately following the end of the queue is set to null. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a queue known to contain only strings. The following code can be used to dump the queue into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.concurrent.BlockingDeque: A Deque that additionally supports blocking operations that wait for the deque to become non-empty when retrieving an element, and wait for space to become available in the deque when storing an element. BlockingDeque methods come in four forms, with different ways of handling operations that cannot be satisfied immediately, but may be satisfied at some point in the future: one throws an exception, the second returns a special value (either null or false, depending on the operation), the third blocks the current thread indefinitely until the operation can succeed, and the fourth blocks for only a given maximum time limit before giving up. These methods are summarized in the following table:  Summary of BlockingDeque methods   First Element (Head)    Throws exception Special value Blocks Times out   Insert addFirst addFirst(e) offerFirst() offerFirst(e) putFirst putFirst(e) offerFirst() offerFirst(e, time, unit)   Remove removeFirst removeFirst() pollFirst pollFirst() takeFirst takeFirst() pollFirst() pollFirst(time, unit)   Examine getFirst getFirst() peekFirst peekFirst() not applicable not applicable    Last Element (Tail)    Throws exception Special value Blocks Times out   Insert addLast addLast(e) offerLast() offerLast(e) putLast putLast(e) offerLast() offerLast(e, time, unit)   Remove removeLast() removeLast() pollLast() pollLast() takeLast takeLast() pollLast() pollLast(time, unit)   Examine getLast getLast() peekLast peekLast() not applicable not applicable   Like any BlockingQueue, a BlockingDeque is thread safe, does not permit null elements, and may (or may not) be capacity-constrained. A BlockingDeque implementation may be used directly as a FIFO BlockingQueue. The methods inherited from the BlockingQueue interface are precisely equivalent to BlockingDeque methods as indicated in the following table:  Comparison of BlockingQueue and BlockingDeque methods   BlockingQueue Method  Equivalent BlockingDeque Method    Insert   add() add(e) addLast() addLast(e)   offer() offer(e) offerLast() offerLast(e)   put() put(e) putLast() putLast(e)   offer() offer(e, time, unit) offerLast() offerLast(e, time, unit)    Remove   remove() remove() removeFirst() removeFirst()   poll() poll() pollFirst() pollFirst()   take() take() takeFirst() takeFirst()   poll() poll(time, unit) pollFirst() pollFirst(time, unit)    Examine   element() element() getFirst() getFirst()   peek() peek() peekFirst() peekFirst()   Memory consistency effects: As with other concurrent collections, actions in a thread prior to placing an object into a BlockingDeque happen-before actions subsequent to the access or removal of that element from the BlockingDeque in another thread. This interface is a member of the  Java Collections Framework.
java.util.concurrent.BlockingDeque.add	(	E	): Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque) if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an IllegalStateException if no space is currently available. When using a capacity-restricted deque, it is generally preferable to use offer(). This method is equivalent to addLast().
java.util.concurrent.BlockingDeque.addFirst	(	E	): Inserts the specified element at the front of this deque if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available. When using a capacity-restricted deque, it is generally preferable to use offerFirst().
java.util.concurrent.BlockingDeque.addLast	(	E	): Inserts the specified element at the end of this deque if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available. When using a capacity-restricted deque, it is generally preferable to use offerLast().
java.util.concurrent.BlockingDeque.contains	(	Object	): Returns true if this deque contains the specified element. More formally, returns true if and only if this deque contains at least one element e such that o.equals(e).
java.util.concurrent.BlockingDeque.element	(	): Retrieves, but does not remove, the head of the queue represented by this deque (in other words, the first element of this deque). This method differs from peek only in that it throws an exception if this deque is empty. This method is equivalent to getFirst().
java.util.concurrent.BlockingDeque.iterator	(	): Returns an iterator over the elements in this deque in proper sequence. The elements will be returned in order from first (head) to last (tail).
java.util.concurrent.BlockingDeque.offer	(	E	): Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque) if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available. When using a capacity-restricted deque, this method is generally preferable to the add method, which can fail to insert an element only by throwing an exception. This method is equivalent to offerLast().
java.util.concurrent.BlockingDeque.offer	(	E	long	TimeUnit	): Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque), waiting up to the specified wait time if necessary for space to become available. This method is equivalent to offerLast().
java.util.concurrent.BlockingDeque.offerFirst	(	E	): Inserts the specified element at the front of this deque if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available. When using a capacity-restricted deque, this method is generally preferable to the addFirst() method, which can fail to insert an element only by throwing an exception.
java.util.concurrent.BlockingDeque.offerFirst	(	E	long	TimeUnit	): Inserts the specified element at the front of this deque, waiting up to the specified wait time if necessary for space to become available.
java.util.concurrent.BlockingDeque.offerLast	(	E	): Inserts the specified element at the end of this deque if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available. When using a capacity-restricted deque, this method is generally preferable to the addLast() method, which can fail to insert an element only by throwing an exception.
java.util.concurrent.BlockingDeque.offerLast	(	E	long	TimeUnit	): Inserts the specified element at the end of this deque, waiting up to the specified wait time if necessary for space to become available.
java.util.concurrent.BlockingDeque.peek	(	): Retrieves, but does not remove, the head of the queue represented by this deque (in other words, the first element of this deque), or returns null if this deque is empty. This method is equivalent to peekFirst().
java.util.concurrent.BlockingDeque.poll	(	): Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque), or returns null if this deque is empty. This method is equivalent to pollFirst().
java.util.concurrent.BlockingDeque.poll	(	long	TimeUnit	): Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque), waiting up to the specified wait time if necessary for an element to become available. This method is equivalent to pollFirst().
java.util.concurrent.BlockingDeque.pollFirst	(	long	TimeUnit	): Retrieves and removes the first element of this deque, waiting up to the specified wait time if necessary for an element to become available.
java.util.concurrent.BlockingDeque.pollLast	(	long	TimeUnit	): Retrieves and removes the last element of this deque, waiting up to the specified wait time if necessary for an element to become available.
java.util.concurrent.BlockingDeque.push	(	E	): Pushes an element onto the stack represented by this deque (in other words, at the head of this deque) if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available. This method is equivalent to addFirst().
java.util.concurrent.BlockingDeque.put	(	E	): Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque), waiting if necessary for space to become available. This method is equivalent to putLast().
java.util.concurrent.BlockingDeque.putFirst	(	E	): Inserts the specified element at the front of this deque, waiting if necessary for space to become available.
java.util.concurrent.BlockingDeque.putLast	(	E	): Inserts the specified element at the end of this deque, waiting if necessary for space to become available.
java.util.concurrent.BlockingDeque.remove	(	): Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque). This method differs from poll only in that it throws an exception if this deque is empty. This method is equivalent to removeFirst().
java.util.concurrent.BlockingDeque.remove	(	Object	): Removes the first occurrence of the specified element from this deque. If the deque does not contain the element, it is unchanged. More formally, removes the first element e such that o.equals(e) (if such an element exists). Returns true if this deque contained the specified element (or equivalently, if this deque changed as a result of the call). This method is equivalent to removeFirstOccurrence().
java.util.concurrent.BlockingDeque.removeFirstOccurrence	(	Object	): Removes the first occurrence of the specified element from this deque. If the deque does not contain the element, it is unchanged. More formally, removes the first element e such that o.equals(e) (if such an element exists). Returns true if this deque contained the specified element (or equivalently, if this deque changed as a result of the call).
java.util.concurrent.BlockingDeque.removeLastOccurrence	(	Object	): Removes the last occurrence of the specified element from this deque. If the deque does not contain the element, it is unchanged. More formally, removes the last element e such that o.equals(e) (if such an element exists). Returns true if this deque contained the specified element (or equivalently, if this deque changed as a result of the call).
java.util.concurrent.BlockingDeque.size	(	): Returns the number of elements in this deque.
java.util.concurrent.BlockingDeque.take	(	): Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque), waiting if necessary until an element becomes available. This method is equivalent to takeFirst().
java.util.concurrent.BlockingDeque.takeFirst	(	): Retrieves and removes the first element of this deque, waiting if necessary until an element becomes available.
java.util.concurrent.BlockingDeque.takeLast	(	): Retrieves and removes the last element of this deque, waiting if necessary until an element becomes available.
java.util.concurrent.BlockingQueue: A java.util.Queue that additionally supports operations that wait for the queue to become non-empty when retrieving an element, and wait for space to become available in the queue when storing an element. BlockingQueue methods come in four forms, with different ways of handling operations that cannot be satisfied immediately, but may be satisfied at some point in the future: one throws an exception, the second returns a special value (either null or false, depending on the operation), the third blocks the current thread indefinitely until the operation can succeed, and the fourth blocks for only a given maximum time limit before giving up. These methods are summarized in the following table:  Summary of BlockingQueue methods   Throws exception Special value Blocks Times out   Insert add add(e) offer offer(e) put put(e) offer() offer(e, time, unit)   Remove remove remove() poll poll() take take() poll() poll(time, unit)   Examine element element() peek peek() not applicable not applicable   A BlockingQueue does not accept null elements. Implementations throw NullPointerException on attempts to add, put or offer a null. A null is used as a sentinel value to indicate failure of poll operations. A BlockingQueue may be capacity bounded. At any given time it may have a remainingCapacity beyond which no additional elements can be put without blocking. A BlockingQueue without any intrinsic capacity constraints always reports a remaining capacity of Integer.MAX_VALUE. BlockingQueue implementations are designed to be used primarily for producer-consumer queues, but additionally support the java.util.Collection interface. So, for example, it is possible to remove an arbitrary element from a queue using remove(x). However, such operations are in general not performed very efficiently, and are intended for only occasional use, such as when a queued message is cancelled. BlockingQueue implementations are thread-safe. All queuing methods achieve their effects atomically using internal locks or other forms of concurrency control. However, the bulk Collection operations addAll, containsAll, retainAll and removeAll are not necessarily performed atomically unless specified otherwise in an implementation. So it is possible, for example, for addAll(c) to fail (throwing an exception) after adding only some of the elements in c. A BlockingQueue does not intrinsically support any kind of "close" or "shutdown" operation to indicate that no more items will be added. The needs and usage of such features tend to be implementation-dependent. For example, a common tactic is for producers to insert special end-of-stream or poison objects, that are interpreted accordingly when taken by consumers.  Usage example, based on a typical producer-consumer scenario. Note that a BlockingQueue can safely be used with multiple producers and multiple consumers.  class Producer implements Runnable private final BlockingQueue queue; Producer(BlockingQueue q) { queue = q; } public void run() { try { while (true) { queue.put(produce()); } } catch (InterruptedException ex) { ... handle ...} } Object produce() { ... } } class Consumer implements Runnable { private final BlockingQueue queue; Consumer(BlockingQueue q) { queue = q; } public void run() { try { while (true) { consume(queue.take()); } } catch (InterruptedException ex) { ... handle ...} } void consume(Object x) { ... } } class Setup { void main() { BlockingQueue q = new SomeQueueImplementation(); Producer p = new Producer(q); Consumer c1 = new Consumer(q); Consumer c2 = new Consumer(q); new Thread(p).start(); new Thread(c1).start(); new Thread(c2).start(); } }} Memory consistency effects: As with other concurrent collections, actions in a thread prior to placing an object into a BlockingQueue happen-before actions subsequent to the access or removal of that element from the BlockingQueue in another thread. This interface is a member of the  Java Collections Framework.
java.util.concurrent.BlockingQueue.add	(	E	): Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and throwing an IllegalStateException if no space is currently available. When using a capacity-restricted queue, it is generally preferable to use offer().
java.util.concurrent.BlockingQueue.contains	(	Object	): Returns true if this queue contains the specified element. More formally, returns true if and only if this queue contains at least one element e such that o.equals(e).
java.util.concurrent.BlockingQueue.drainTo	(	Collection	): Removes all available elements from this queue and adds them to the given collection. This operation may be more efficient than repeatedly polling this queue. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.BlockingQueue.drainTo	(	Collection	int	): Removes at most the given number of available elements from this queue and adds them to the given collection. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.BlockingQueue.offer	(	E	): Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available. When using a capacity-restricted queue, this method is generally preferable to add, which can fail to insert an element only by throwing an exception.
java.util.concurrent.BlockingQueue.offer	(	E	long	TimeUnit	): Inserts the specified element into this queue, waiting up to the specified wait time if necessary for space to become available.
java.util.concurrent.BlockingQueue.poll	(	long	TimeUnit	): Retrieves and removes the head of this queue, waiting up to the specified wait time if necessary for an element to become available.
java.util.concurrent.BlockingQueue.put	(	E	): Inserts the specified element into this queue, waiting if necessary for space to become available.
java.util.concurrent.BlockingQueue.remainingCapacity	(	): Returns the number of additional elements that this queue can ideally (in the absence of memory or resource constraints) accept without blocking, or Integer.MAX_VALUE if there is no intrinsic limit. Note that you cannot always tell if an attempt to insert an element will succeed by inspecting remainingCapacity because it may be the case that another thread is about to insert or remove an element.
java.util.concurrent.BlockingQueue.remove	(	Object	): Removes a single instance of the specified element from this queue, if it is present. More formally, removes an element e such that o.equals(e), if this queue contains one or more such elements. Returns true if this queue contained the specified element (or equivalently, if this queue changed as a result of the call).
java.util.concurrent.BlockingQueue.take	(	): Retrieves and removes the head of this queue, waiting if necessary until an element becomes available.
java.util.concurrent.BrokenBarrierException: Exception thrown when a thread tries to wait upon a barrier that is in a broken state, or which enters the broken state while the thread is waiting.
java.util.concurrent.BrokenBarrierException.BrokenBarrierException	(	): Constructs a BrokenBarrierException with no specified detail message.
java.util.concurrent.BrokenBarrierException.BrokenBarrierException	(	String	): Constructs a BrokenBarrierException with the specified detail message.
java.util.concurrent.Callable: A task that returns a result and may throw an exception. Implementors define a single method with no arguments called call. The Callable interface is similar to java.lang.Runnable, in that both are designed for classes whose instances are potentially executed by another thread. A Runnable, however, does not return a result and cannot throw a checked exception. The Executors class contains utility methods to convert from other common forms to Callable classes.
java.util.concurrent.Callable.call	(	): Computes a result, or throws an exception if unable to do so.
java.util.concurrent.CancellationException: Exception indicating that the result of a value-producing task, such as a FutureTask, cannot be retrieved because the task was cancelled.
java.util.concurrent.CancellationException.CancellationException	(	): Constructs a CancellationException with no detail message.
java.util.concurrent.CancellationException.CancellationException	(	String	): Constructs a CancellationException with the specified detail message.
java.util.concurrent.CompletableFuture: A Future that may be explicitly completed (setting its value and status), and may be used as a CompletionStage, supporting dependent functions and actions that trigger upon its completion. When two or more threads attempt to complete, completeExceptionally, or cancel a CompletableFuture, only one of them succeeds. In addition to these and related methods for directly manipulating status and results, CompletableFuture implements interface CompletionStage with the following policies:  Actions supplied for dependent completions of non-async methods may be performed by the thread that completes the current CompletableFuture, or by any other caller of a completion method. All async methods without an explicit Executor argument are performed using the commonPool() (unless it does not support a parallelism level of at least two, in which case, a new Thread is created to run each task). To simplify monitoring, debugging, and tracking, all generated asynchronous tasks are instances of the marker interface AsynchronousCompletionTask.  All CompletionStage methods are implemented independently of other public methods, so the behavior of one method is not impacted by overrides of others in subclasses.   CompletableFuture also implements Future with the following policies:  Since (unlike FutureTask) this class has no direct control over the computation that causes it to be completed, cancellation is treated as just another form of exceptional completion. Method cancel has the same effect as completeExceptionally(new CancellationException()). Method isCompletedExceptionally can be used to determine if a CompletableFuture completed in any exceptional fashion. In case of exceptional completion with a CompletionException, methods get() and get() throw an ExecutionException with the same cause as held in the corresponding CompletionException. To simplify usage in most contexts, this class also defines methods join() and getNow that instead throw the CompletionException directly in these cases. 
java.util.concurrent.CompletableFuture.AsynchronousCompletionTask: A marker interface identifying asynchronous tasks produced by async methods. This may be useful for monitoring, debugging, and tracking asynchronous activities.
java.util.concurrent.CompletableFuture.BiCompletion: A Completion for an action with two sources 
java.util.concurrent.CompletableFuture.CoCompletion: A Completion delegating to a BiCompletion 
java.util.concurrent.CompletableFuture.CompletableFuture	(	): Creates a new incomplete CompletableFuture.
java.util.concurrent.CompletableFuture.CompletableFuture	(	Object	): Creates a new complete CompletableFuture with given encoded result.
java.util.concurrent.CompletableFuture.Completion.isLive	(	): Returns true if possibly still triggerable. Used by cleanStack. 
java.util.concurrent.CompletableFuture.Completion.tryFire	(	int	): Performs completion action if triggered, returning a dependent that may need propagation, if one exists.
java.util.concurrent.CompletableFuture.Signaller: Completion for recording and releasing a waiting thread. This class implements ManagedBlocker to avoid starvation when blocking actions pile up in ForkJoinPools.
java.util.concurrent.CompletableFuture.ThreadPerTaskExecutor: Fallback if ForkJoinPool.commonPool() cannot support parallelism 
java.util.concurrent.CompletableFuture.UniCompletion: A Completion with a source, dependent, and executor. 
java.util.concurrent.CompletableFuture.UniCompletion.claim	(	): Returns true if action can be run. Call only when known to be triggerable. Uses FJ tag bit to ensure that only one thread claims ownership. If async, starts as task -- a later call to tryFire will run action.
java.util.concurrent.CompletableFuture.allOf	(	CompletableFuture	): Returns a new CompletableFuture that is completed when all of the given CompletableFutures complete. If any of the given CompletableFutures complete exceptionally, then the returned CompletableFuture also does so, with a CompletionException holding this exception as its cause. Otherwise, the results, if any, of the given CompletableFutures are not reflected in the returned CompletableFuture, but may be obtained by inspecting them individually. If no CompletableFutures are provided, returns a CompletableFuture completed with the value null. Among the applications of this method is to await completion of a set of independent CompletableFutures before continuing a program, as in: CompletableFuture.allOf(c1, c2, c3).join();.
java.util.concurrent.CompletableFuture.andTree	(	CompletableFuture[]	int	int	): Recursively constructs a tree of completions. 
java.util.concurrent.CompletableFuture.anyOf	(	CompletableFuture	): Returns a new CompletableFuture that is completed when any of the given CompletableFutures complete, with the same result. Otherwise, if it completed exceptionally, the returned CompletableFuture also does so, with a CompletionException holding this exception as its cause. If no CompletableFutures are provided, returns an incomplete CompletableFuture.
java.util.concurrent.CompletableFuture.bipush	(	CompletableFuture	BiCompletion	): Pushes completion to this and b unless both done. 
java.util.concurrent.CompletableFuture.cancel	(	boolean	): If not already completed, completes this CompletableFuture with a CancellationException. Dependent CompletableFutures that have not already completed will also complete exceptionally, with a CompletionException caused by this CancellationException.
java.util.concurrent.CompletableFuture.cleanStack	(	): Traverses stack and unlinks dead Completions. 
java.util.concurrent.CompletableFuture.complete	(	T	): If not already completed, sets the value returned by get() and related methods to the given value.
java.util.concurrent.CompletableFuture.completeExceptionally	(	Throwable	): If not already completed, causes invocations of get() and related methods to throw the given exception.
java.util.concurrent.CompletableFuture.completeNull	(	): Completes with the null value, unless already completed. 
java.util.concurrent.CompletableFuture.completeRelay	(	Object	): Completes with r or a copy of r, unless already completed. If exceptional, r is first coerced to a CompletionException.
java.util.concurrent.CompletableFuture.completeThrowable	(	Throwable	): Completes with an exceptional result, unless already completed. 
java.util.concurrent.CompletableFuture.completeThrowable	(	Throwable	Object	): Completes with the given (non-null) exceptional result as a wrapped CompletionException unless it is one already, unless already completed. May complete with the given Object r (which must have been the result of a source future) if it is equivalent, i.e. if this is a simple propagation of an existing CompletionException.
java.util.concurrent.CompletableFuture.completeValue	(	T	): Completes with a non-exceptional result, unless already completed. 
java.util.concurrent.CompletableFuture.completedFuture	(	U	): Returns a new CompletableFuture that is already completed with the given value.
java.util.concurrent.CompletableFuture.encodeOutcome	(	T	Throwable	): Returns the encoding of the given arguments: if the exception is non-null, encodes as AltResult. Otherwise uses the given value, boxed as NIL if null.
java.util.concurrent.CompletableFuture.encodeRelay	(	Object	): Returns the encoding of a copied outcome; if exceptional, rewraps as a CompletionException, else returns argument.
java.util.concurrent.CompletableFuture.encodeThrowable	(	Throwable	): Returns the encoding of the given (non-null) exception as a wrapped CompletionException unless it is one already.
java.util.concurrent.CompletableFuture.encodeThrowable	(	Throwable	Object	): Returns the encoding of the given (non-null) exception as a wrapped CompletionException unless it is one already. May return the given Object r (which must have been the result of a source future) if it is equivalent, i.e. if this is a simple relay of an existing CompletionException.
java.util.concurrent.CompletableFuture.encodeValue	(	T	): Returns the encoding of the given non-exceptional value. 
java.util.concurrent.CompletableFuture.exceptionally	(	Function	): Returns a new CompletableFuture that is completed when this CompletableFuture completes, with the result of the given function of the exception triggering this CompletableFuture's completion when it completes exceptionally; otherwise, if this CompletableFuture completes normally, then the returned CompletableFuture also completes normally with the same value. Note: More flexible versions of this functionality are available using methods whenComplete and handle.
java.util.concurrent.CompletableFuture.get	(	): Waits if necessary for this future to complete, and then returns its result.
java.util.concurrent.CompletableFuture.get	(	long	TimeUnit	): Waits if necessary for at most the given time for this future to complete, and then returns its result, if available.
java.util.concurrent.CompletableFuture.getNow	(	T	): Returns the result value (or throws any encountered exception) if completed, else returns the given valueIfAbsent.
java.util.concurrent.CompletableFuture.getNumberOfDependents	(	): Returns the estimated number of CompletableFutures whose completions are awaiting completion of this CompletableFuture. This method is designed for use in monitoring system state, not for synchronization control.
java.util.concurrent.CompletableFuture.isCancelled	(	): Returns true if this CompletableFuture was cancelled before it completed normally.
java.util.concurrent.CompletableFuture.isCompletedExceptionally	(	): Returns true if this CompletableFuture completed exceptionally, in any way. Possible causes include cancellation, explicit invocation of completeExceptionally, and abrupt termination of a CompletionStage action.
java.util.concurrent.CompletableFuture.isDone	(	): Returns true if completed in any fashion: normally, exceptionally, or via cancellation.
java.util.concurrent.CompletableFuture.join	(	): Returns the result value when complete, or throws an (unchecked) exception if completed exceptionally. To better conform with the use of common functional forms, if a computation involved in the completion of this CompletableFuture threw an exception, this method throws an (unchecked) CompletionException with the underlying exception as its cause.
java.util.concurrent.CompletableFuture.obtrudeException	(	Throwable	): Forcibly causes subsequent invocations of method get() and related methods to throw the given exception, whether or not already completed. This method is designed for use only in error recovery actions, and even in such situations may result in ongoing dependent completions using established versus overwritten outcomes.
java.util.concurrent.CompletableFuture.obtrudeValue	(	T	): Forcibly sets or resets the value subsequently returned by method get() and related methods, whether or not already completed. This method is designed for use only in error recovery actions, and even in such situations may result in ongoing dependent completions using established versus overwritten outcomes.
java.util.concurrent.CompletableFuture.orTree	(	CompletableFuture[]	int	int	): Recursively constructs a tree of completions. 
java.util.concurrent.CompletableFuture.orpush	(	CompletableFuture	BiCompletion	): Pushes completion to this and b unless either done. 
java.util.concurrent.CompletableFuture.postComplete	(	): Pops and tries to trigger all reachable dependents. Call only when known to be done.
java.util.concurrent.CompletableFuture.postFire	(	CompletableFuture	CompletableFuture	int	): Post-processing after successful BiCompletion tryFire. 
java.util.concurrent.CompletableFuture.postFire	(	CompletableFuture	int	): Post-processing by dependent after successful UniCompletion tryFire. Tries to clean stack of source a, and then either runs postComplete or returns this to caller, depending on mode.
java.util.concurrent.CompletableFuture.push	(	UniCompletion	): Pushes the given completion (if it exists) unless done. 
java.util.concurrent.CompletableFuture.pushStack	(	Completion	): Unconditionally pushes c onto stack, retrying if necessary. 
java.util.concurrent.CompletableFuture.reportGet	(	Object	): Reports result using Future.get conventions.
java.util.concurrent.CompletableFuture.reportJoin	(	Object	): Decodes outcome to return result or throw unchecked exception.
java.util.concurrent.CompletableFuture.runAsync	(	Runnable	): Returns a new CompletableFuture that is asynchronously completed by a task running in the commonPool() after it runs the given action.
java.util.concurrent.CompletableFuture.runAsync	(	Runnable	Executor	): Returns a new CompletableFuture that is asynchronously completed by a task running in the given executor after it runs the given action.
java.util.concurrent.CompletableFuture.screenExecutor	(	Executor	): Null-checks user executor argument, and translates uses of commonPool to asyncPool in case parallelism disabled.
java.util.concurrent.CompletableFuture.supplyAsync	(	Supplier	): Returns a new CompletableFuture that is asynchronously completed by a task running in the commonPool() with the value obtained by calling the given Supplier.
java.util.concurrent.CompletableFuture.supplyAsync	(	Supplier	Executor	): Returns a new CompletableFuture that is asynchronously completed by a task running in the given executor with the value obtained by calling the given Supplier.
java.util.concurrent.CompletableFuture.timedGet	(	long	): Returns raw result after waiting, or null if interrupted, or throws TimeoutException on timeout.
java.util.concurrent.CompletableFuture.toCompletableFuture	(	): Returns this CompletableFuture.
java.util.concurrent.CompletableFuture.toString	(	): Returns a string identifying this CompletableFuture, as well as its completion state. The state, in brackets, contains the String "Completed Normally" or the String "Completed Exceptionally", or the String "Not completed" followed by the number of CompletableFutures dependent upon its completion, if any.
java.util.concurrent.CompletableFuture.tryPushStack	(	Completion	): Returns true if successfully pushed c onto stack. 
java.util.concurrent.CompletableFuture.waitingGet	(	boolean	): Returns raw result after waiting, or null if interruptible and interrupted.
java.util.concurrent.CompletionException: Exception thrown when an error or other exception is encountered in the course of completing a result or task.
java.util.concurrent.CompletionException.CompletionException	(	): Constructs a CompletionException with no detail message. The cause is not initialized, and may subsequently be initialized by a call to initCause().
java.util.concurrent.CompletionException.CompletionException	(	String	): Constructs a CompletionException with the specified detail message. The cause is not initialized, and may subsequently be initialized by a call to initCause().
java.util.concurrent.CompletionException.CompletionException	(	String	Throwable	): Constructs a CompletionException with the specified detail message and cause.
java.util.concurrent.CompletionException.CompletionException	(	Throwable	): Constructs a CompletionException with the specified cause. The detail message is set to (cause == null ? null : cause.toString()) (which typically contains the class and detail message of cause).
java.util.concurrent.CompletionService: A service that decouples the production of new asynchronous tasks from the consumption of the results of completed tasks. Producers submit tasks for execution. Consumers take completed tasks and process their results in the order they complete. A CompletionService can for example be used to manage asynchronous I/O, in which tasks that perform reads are submitted in one part of a program or system, and then acted upon in a different part of the program when the reads complete, possibly in a different order than they were requested. Typically, a CompletionService relies on a separate Executor to actually execute the tasks, in which case the CompletionService only manages an internal completion queue. The ExecutorCompletionService class provides an implementation of this approach. Memory consistency effects: Actions in a thread prior to submitting a task to a CompletionService happen-before actions taken by that task, which in turn happen-before actions following a successful return from the corresponding take().
java.util.concurrent.CompletionService.poll	(	): Retrieves and removes the Future representing the next completed task, or null if none are present.
java.util.concurrent.CompletionService.poll	(	long	TimeUnit	): Retrieves and removes the Future representing the next completed task, waiting if necessary up to the specified wait time if none are yet present.
java.util.concurrent.CompletionService.submit	(	Callable	): Submits a value-returning task for execution and returns a Future representing the pending results of the task. Upon completion, this task may be taken or polled.
java.util.concurrent.CompletionService.submit	(	Runnable	V	): Submits a Runnable task for execution and returns a Future representing that task. Upon completion, this task may be taken or polled.
java.util.concurrent.CompletionService.take	(	): Retrieves and removes the Future representing the next completed task, waiting if none are yet present.
java.util.concurrent.CompletionStage: A stage of a possibly asynchronous computation, that performs an action or computes a value when another CompletionStage completes. A stage completes upon termination of its computation, but this may in turn trigger other dependent stages. The functionality defined in this interface takes only a few basic forms, which expand out to a larger set of methods to capture a range of usage styles:  The computation performed by a stage may be expressed as a Function, Consumer, or Runnable (using methods with names including apply, accept, or run, respectively) depending on whether it requires arguments and/or produces results. For example, stage.thenApply(x -> square(x)).thenAccept(x -> System.out.print(x)).thenRun(() -> System.out.println()). An additional form (compose) applies functions of stages themselves, rather than their results.   One stage's execution may be triggered by completion of a single stage, or both of two stages, or either of two stages. Dependencies on a single stage are arranged using methods with prefix then. Those triggered by completion of both of two stages may combine their results or effects, using correspondingly named methods. Those triggered by either of two stages make no guarantees about which of the results or effects are used for the dependent stage's computation.  Dependencies among stages control the triggering of computations, but do not otherwise guarantee any particular ordering. Additionally, execution of a new stage's computations may be arranged in any of three ways: default execution, default asynchronous execution (using methods with suffix async that employ the stage's default asynchronous execution facility), or custom (via a supplied Executor). The execution properties of default and async modes are specified by CompletionStage implementations, not this interface. Methods with explicit Executor arguments may have arbitrary execution properties, and might not even support concurrent execution, but are arranged for processing in a way that accommodates asynchrony.  Two method forms support processing whether the triggering stage completed normally or exceptionally: Method whenComplete allows injection of an action regardless of outcome, otherwise preserving the outcome in its completion. Method handle additionally allows the stage to compute a replacement result that may enable further processing by other dependent stages. In all other cases, if a stage's computation terminates abruptly with an (unchecked) exception or error, then all dependent stages requiring its completion complete exceptionally as well, with a CompletionException holding the exception as its cause. If a stage is dependent on both of two stages, and both complete exceptionally, then the CompletionException may correspond to either one of these exceptions. If a stage is dependent on either of two others, and only one of them completes exceptionally, no guarantees are made about whether the dependent stage completes normally or exceptionally. In the case of method whenComplete, when the supplied action itself encounters an exception, then the stage exceptionally completes with this exception if not already completed exceptionally.  All methods adhere to the above triggering, execution, and exceptional completion specifications (which are not repeated in individual method specifications). Additionally, while arguments used to pass a completion result (that is, for parameters of type T) for methods accepting them may be null, passing a null value for any other parameter will result in a NullPointerException being thrown. This interface does not define methods for initially creating, forcibly completing normally or exceptionally, probing completion status or results, or awaiting completion of a stage. Implementations of CompletionStage may provide means of achieving such effects, as appropriate. Method toCompletableFuture enables interoperability among different implementations of this interface by providing a common conversion type.
java.util.concurrent.CompletionStage.acceptEither	(	CompletionStage	Consumer	): Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed with the corresponding result as argument to the supplied action. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.acceptEitherAsync	(	CompletionStage	Consumer	): Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed using this stage's default asynchronous execution facility, with the corresponding result as argument to the supplied action. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.acceptEitherAsync	(	CompletionStage	Consumer	Executor	): Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed using the supplied executor, with the corresponding result as argument to the supplied function. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.applyToEither	(	CompletionStage	Function	): Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed with the corresponding result as argument to the supplied function. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.applyToEitherAsync	(	CompletionStage	Function	): Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed using this stage's default asynchronous execution facility, with the corresponding result as argument to the supplied function. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.applyToEitherAsync	(	CompletionStage	Function	Executor	): Returns a new CompletionStage that, when either this or the other given stage complete normally, is executed using the supplied executor, with the corresponding result as argument to the supplied function. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.exceptionally	(	Function	): Returns a new CompletionStage that, when this stage completes exceptionally, is executed with this stage's exception as the argument to the supplied function. Otherwise, if this stage completes normally, then the returned stage also completes normally with the same value.
java.util.concurrent.CompletionStage.handle	(	BiFunction	): Returns a new CompletionStage that, when this stage completes either normally or exceptionally, is executed with this stage's result and exception as arguments to the supplied function. When this stage is complete, the given function is invoked with the result (or null if none) and the exception (or null if none) of this stage as arguments, and the function's result is used to complete the returned stage.
java.util.concurrent.CompletionStage.handleAsync	(	BiFunction	): Returns a new CompletionStage that, when this stage completes either normally or exceptionally, is executed using this stage's default asynchronous execution facility, with this stage's result and exception as arguments to the supplied function. When this stage is complete, the given function is invoked with the result (or null if none) and the exception (or null if none) of this stage as arguments, and the function's result is used to complete the returned stage.
java.util.concurrent.CompletionStage.handleAsync	(	BiFunction	Executor	): Returns a new CompletionStage that, when this stage completes either normally or exceptionally, is executed using the supplied executor, with this stage's result and exception as arguments to the supplied function. When this stage is complete, the given function is invoked with the result (or null if none) and the exception (or null if none) of this stage as arguments, and the function's result is used to complete the returned stage.
java.util.concurrent.CompletionStage.runAfterBoth	(	CompletionStage	Runnable	): Returns a new CompletionStage that, when this and the other given stage both complete normally, executes the given action. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.runAfterBothAsync	(	CompletionStage	Runnable	): Returns a new CompletionStage that, when this and the other given stage complete normally, executes the given action using this stage's default asynchronous execution facility. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.runAfterBothAsync	(	CompletionStage	Runnable	Executor	): Returns a new CompletionStage that, when this and the other given stage complete normally, executes the given action using the supplied executor. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.runAfterEither	(	CompletionStage	Runnable	): Returns a new CompletionStage that, when either this or the other given stage complete normally, executes the given action. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.runAfterEitherAsync	(	CompletionStage	Runnable	): Returns a new CompletionStage that, when either this or the other given stage complete normally, executes the given action using this stage's default asynchronous execution facility. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.runAfterEitherAsync	(	CompletionStage	Runnable	Executor	): Returns a new CompletionStage that, when either this or the other given stage complete normally, executes the given action using the supplied executor. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.thenAccept	(	Consumer	): Returns a new CompletionStage that, when this stage completes normally, is executed with this stage's result as the argument to the supplied action. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.thenAcceptAsync	(	Consumer	): Returns a new CompletionStage that, when this stage completes normally, is executed using this stage's default asynchronous execution facility, with this stage's result as the argument to the supplied action. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.thenAcceptAsync	(	Consumer	Executor	): Returns a new CompletionStage that, when this stage completes normally, is executed using the supplied Executor, with this stage's result as the argument to the supplied action. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.thenAcceptBoth	(	CompletionStage	BiConsumer	): Returns a new CompletionStage that, when this and the other given stage both complete normally, is executed with the two results as arguments to the supplied action. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.thenAcceptBothAsync	(	CompletionStage	BiConsumer	): Returns a new CompletionStage that, when this and the other given stage complete normally, is executed using this stage's default asynchronous execution facility, with the two results as arguments to the supplied action.
java.util.concurrent.CompletionStage.thenAcceptBothAsync	(	CompletionStage	BiConsumer	Executor	): Returns a new CompletionStage that, when this and the other given stage complete normally, is executed using the supplied executor, with the two results as arguments to the supplied function.
java.util.concurrent.CompletionStage.thenApply	(	Function	): Returns a new CompletionStage that, when this stage completes normally, is executed with this stage's result as the argument to the supplied function. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.thenApplyAsync	(	Function	): Returns a new CompletionStage that, when this stage completes normally, is executed using this stage's default asynchronous execution facility, with this stage's result as the argument to the supplied function. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.thenApplyAsync	(	Function	Executor	): Returns a new CompletionStage that, when this stage completes normally, is executed using the supplied Executor, with this stage's result as the argument to the supplied function. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.thenCombine	(	CompletionStage	BiFunction	): Returns a new CompletionStage that, when this and the other given stage both complete normally, is executed with the two results as arguments to the supplied function. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.thenCombineAsync	(	CompletionStage	BiFunction	): Returns a new CompletionStage that, when this and the other given stage complete normally, is executed using this stage's default asynchronous execution facility, with the two results as arguments to the supplied function. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.thenCombineAsync	(	CompletionStage	BiFunction	Executor	): Returns a new CompletionStage that, when this and the other given stage complete normally, is executed using the supplied executor, with the two results as arguments to the supplied function. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.thenCompose	(	Function	): Returns a new CompletionStage that, when this stage completes normally, is executed with this stage as the argument to the supplied function. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.thenComposeAsync	(	Function	): Returns a new CompletionStage that, when this stage completes normally, is executed using this stage's default asynchronous execution facility, with this stage as the argument to the supplied function. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.thenComposeAsync	(	Function	Executor	): Returns a new CompletionStage that, when this stage completes normally, is executed using the supplied Executor, with this stage's result as the argument to the supplied function. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.thenRun	(	Runnable	): Returns a new CompletionStage that, when this stage completes normally, executes the given action. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.thenRunAsync	(	Runnable	): Returns a new CompletionStage that, when this stage completes normally, executes the given action using this stage's default asynchronous execution facility. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.thenRunAsync	(	Runnable	Executor	): Returns a new CompletionStage that, when this stage completes normally, executes the given action using the supplied Executor. See the CompletionStage documentation for rules covering exceptional completion.
java.util.concurrent.CompletionStage.toCompletableFuture	(	): Returns a CompletableFuture maintaining the same completion properties as this stage. If this stage is already a CompletableFuture, this method may return this stage itself. Otherwise, invocation of this method may be equivalent in effect to thenApply(x -> x), but returning an instance of type CompletableFuture. A CompletionStage implementation that does not choose to interoperate with others may throw UnsupportedOperationException.
java.util.concurrent.CompletionStage.whenComplete	(	BiConsumer	): Returns a new CompletionStage with the same result or exception as this stage, that executes the given action when this stage completes. When this stage is complete, the given action is invoked with the result (or null if none) and the exception (or null if none) of this stage as arguments. The returned stage is completed when the action returns. If the supplied action itself encounters an exception, then the returned stage exceptionally completes with this exception unless this stage also completed exceptionally.
java.util.concurrent.CompletionStage.whenCompleteAsync	(	BiConsumer	): Returns a new CompletionStage with the same result or exception as this stage, that executes the given action using this stage's default asynchronous execution facility when this stage completes. When this stage is complete, the given action is invoked with the result (or null if none) and the exception (or null if none) of this stage as arguments. The returned stage is completed when the action returns. If the supplied action itself encounters an exception, then the returned stage exceptionally completes with this exception unless this stage also completed exceptionally.
java.util.concurrent.CompletionStage.whenCompleteAsync	(	BiConsumer	Executor	): Returns a new CompletionStage with the same result or exception as this stage, that executes the given action using the supplied Executor when this stage completes. When this stage is complete, the given action is invoked with the result (or null if none) and the exception (or null if none) of this stage as arguments. The returned stage is completed when the action returns. If the supplied action itself encounters an exception, then the returned stage exceptionally completes with this exception unless this stage also completed exceptionally.
java.util.concurrent.ConcurrentHashMap: A hash table supporting full concurrency of retrievals and high expected concurrency for updates. This class obeys the same functional specification as java.util.Hashtable, and includes versions of methods corresponding to each method of Hashtable. However, even though all operations are thread-safe, retrieval operations do not entail locking, and there is not any support for locking the entire table in a way that prevents all access. This class is fully interoperable with Hashtable in programs that rely on its thread safety but not on its synchronization details. Retrieval operations (including get) generally do not block, so may overlap with update operations (including put and remove). Retrievals reflect the results of the most recently completed update operations holding upon their onset. (More formally, an update operation for a given key bears a happens-before relation with any (non-null) retrieval for that key reporting the updated value.) For aggregate operations such as putAll and clear, concurrent retrievals may reflect insertion or removal of only some entries. Similarly, Iterators, Spliterators and Enumerations return elements reflecting the state of the hash table at some point at or since the creation of the iterator/enumeration. They do not throw java.util.ConcurrentModificationException ConcurrentModificationException. However, iterators are designed to be used by only one thread at a time. Bear in mind that the results of aggregate status methods including size, isEmpty, and containsValue are typically useful only when a map is not undergoing concurrent updates in other threads. Otherwise the results of these methods reflect transient states that may be adequate for monitoring or estimation purposes, but not for program control. The table is dynamically expanded when there are too many collisions (i.e., keys that have distinct hash codes but fall into the same slot modulo the table size), with the expected average effect of maintaining roughly two bins per mapping (corresponding to a 0.75 load factor threshold for resizing). There may be much variance around this average as mappings are added and removed, but overall, this maintains a commonly accepted time/space tradeoff for hash tables. However, resizing this or any other kind of hash table may be a relatively slow operation. When possible, it is a good idea to provide a size estimate as an optional initialCapacity constructor argument. An additional optional loadFactor constructor argument provides a further means of customizing initial table capacity by specifying the table density to be used in calculating the amount of space to allocate for the given number of elements. Also, for compatibility with previous versions of this class, constructors may optionally specify an expected concurrencyLevel as an additional hint for internal sizing. Note that using many keys with exactly the same hashCode() is a sure way to slow down performance of any hash table. To ameliorate impact, when keys are Comparable, this class may use comparison order among keys to help break ties. A Set projection of a ConcurrentHashMap may be created (using newKeySet() or newKeySet()), or viewed (using keySet() when only keys are of interest, and the mapped values are (perhaps transiently) not used or all take the same mapping value. A ConcurrentHashMap can be used as scalable frequency map (a form of histogram or multiset) by using java.util.concurrent.atomic.LongAdder values and initializing via computeIfAbsent. For example, to add a count to a ConcurrentHashMap freqs, you can use freqs.computeIfAbsent(k -> new LongAdder()).increment(); This class and its views and iterators implement all of the optional methods of the Map and Iterator interfaces. Like Hashtable but unlike HashMap, this class does not allow null to be used as a key or value. ConcurrentHashMaps support a set of sequential and parallel bulk operations that, unlike most Stream methods, are designed to be safely, and often sensibly, applied even with maps that are being concurrently updated by other threads; for example, when computing a snapshot summary of the values in a shared registry. There are three kinds of operation, each with four forms, accepting functions with Keys, Values, Entries, and (Key, Value) arguments and/or return values. Because the elements of a ConcurrentHashMap are not ordered in any particular way, and may be processed in different orders in different parallel executions, the correctness of supplied functions should not depend on any ordering, or on any other objects or values that may transiently change while computation is in progress; and except for forEach actions, should ideally be side-effect-free. Bulk operations on java.util.Map.Entry objects do not support method setValue.   forEach: Perform a given action on each element. A variant form applies a given transformation on each element before performing the action.  search: Return the first available non-null result of applying a given function on each element; skipping further search when a result is found.  reduce: Accumulate each element. The supplied reduction function cannot rely on ordering (more formally, it should be both associative and commutative). There are five variants:   Plain reductions. (There is not a form of this method for (key, value) function arguments since there is no corresponding return type.)  Mapped reductions that accumulate the results of a given function applied to each element.  Reductions to scalar doubles, longs, and ints, using a given basis value.    These bulk operations accept a parallelismThreshold argument. Methods proceed sequentially if the current map size is estimated to be less than the given threshold. Using a value of Long.MAX_VALUE suppresses all parallelism. Using a value of 1 results in maximal parallelism by partitioning into enough subtasks to fully utilize the commonPool() that is used for all parallel computations. Normally, you would initially choose one of these extreme values, and then measure performance of using in-between values that trade off overhead versus throughput. The concurrency properties of bulk operations follow from those of ConcurrentHashMap: Any non-null result returned from get(key) and related access methods bears a happens-before relation with the associated insertion or update. The result of any bulk operation reflects the composition of these per-element relations (but is not necessarily atomic with respect to the map as a whole unless it is somehow known to be quiescent). Conversely, because keys and values in the map are never null, null serves as a reliable atomic indicator of the current lack of any result. To maintain this property, null serves as an implicit basis for all non-scalar reduction operations. For the double, long, and int versions, the basis should be one that, when combined with any other value, returns that other value (more formally, it should be the identity element for the reduction). Most common reductions have these properties; for example, computing a sum with basis 0 or a minimum with basis MAX_VALUE. Search and transformation functions provided as arguments should similarly return null to indicate the lack of any result (in which case it is not used). In the case of mapped reductions, this also enables transformations to serve as filters, returning null (or, in the case of primitive specializations, the identity basis) if the element should not be combined. You can create compound transformations and filterings by composing them yourself under this "null means there is nothing there now" rule before using them in search or reduce operations. Methods accepting and/or returning Entry arguments maintain key-value associations. They may be useful for example when finding the key for the greatest value. Note that "plain" Entry arguments can be supplied using new AbstractMap.SimpleEntry(k,v). Bulk operations may complete abruptly, throwing an exception encountered in the application of a supplied function. Bear in mind when handling such exceptions that other concurrently executing functions could also have thrown exceptions, or would have done so if the first exception had not occurred. Speedups for parallel compared to sequential forms are common but not guaranteed. Parallel operations involving brief functions on small maps may execute more slowly than sequential forms if the underlying work to parallelize the computation is more expensive than the computation itself. Similarly, parallelization may not lead to much actual parallelism if all processors are busy performing unrelated tasks. All arguments to all task methods must be non-null. This class is a member of the  Java Collections Framework.
java.util.concurrent.ConcurrentHashMap.BaseIterator: Base of key, value, and entry Iterators. Adds fields to Traverser to support iterator.remove.
java.util.concurrent.ConcurrentHashMap.BulkTask: Base class for bulk tasks. Repeats some fields and code from class Traverser, because we need to subclass CountedCompleter.
java.util.concurrent.ConcurrentHashMap.BulkTask.advance	(	): Same as Traverser version
java.util.concurrent.ConcurrentHashMap.CollectionView: Base class for views.
java.util.concurrent.ConcurrentHashMap.CollectionView.clear	(	): Removes all of the elements from this view, by removing all the mappings from the map backing this view.
java.util.concurrent.ConcurrentHashMap.CollectionView.getMap	(	): Returns the map backing this view.
java.util.concurrent.ConcurrentHashMap.CollectionView.iterator	(	): Returns an iterator over the elements in this collection. The returned iterator is weakly consistent.
java.util.concurrent.ConcurrentHashMap.CollectionView.toString	(	): Returns a string representation of this collection. The string representation consists of the string representations of the collection's elements in the order they are returned by its iterator, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (comma and space). Elements are converted to strings as by valueOf().
java.util.concurrent.ConcurrentHashMap.ConcurrentHashMap	(	): Creates a new, empty map with the default initial table size (16).
java.util.concurrent.ConcurrentHashMap.ConcurrentHashMap	(	Map	): Creates a new map with the same mappings as the given map.
java.util.concurrent.ConcurrentHashMap.ConcurrentHashMap	(	int	): Creates a new, empty map with an initial table size accommodating the specified number of elements without the need to dynamically resize.
java.util.concurrent.ConcurrentHashMap.ConcurrentHashMap	(	int	float	): Creates a new, empty map with an initial table size based on the given number of elements (initialCapacity) and initial table density (loadFactor).
java.util.concurrent.ConcurrentHashMap.ConcurrentHashMap	(	int	float	int	): Creates a new, empty map with an initial table size based on the given number of elements (initialCapacity), table density (loadFactor), and number of concurrently updating threads (concurrencyLevel).
java.util.concurrent.ConcurrentHashMap.CounterCell: A padded cell for distributing counts. Adapted from LongAdder and Striped64. See their internal docs for explanation.
java.util.concurrent.ConcurrentHashMap.EntrySetView: A view of a ConcurrentHashMap as a Set of (key, value) entries. This class cannot be directly instantiated. See entrySet().
java.util.concurrent.ConcurrentHashMap.EntrySetView.iterator	(	): Returns an iterator over the elements in this collection. The returned iterator is weakly consistent.
java.util.concurrent.ConcurrentHashMap.ForwardingNode: A node inserted at head of bins during transfer operations.
java.util.concurrent.ConcurrentHashMap.KeySetView: A view of a ConcurrentHashMap as a Set of keys, in which additions may optionally be enabled by mapping to a common value. This class cannot be directly instantiated. See keySet() keySet(), keySet() keySet(V), newKeySet() newKeySet(), newKeySet() newKeySet(int).
java.util.concurrent.ConcurrentHashMap.KeySetView.add	(	K	): Adds the specified key to this set view by mapping the key to the default mapped value in the backing map, if defined.
java.util.concurrent.ConcurrentHashMap.KeySetView.addAll	(	Collection	): Adds all of the elements in the specified collection to this set, as if by calling add on each one.
java.util.concurrent.ConcurrentHashMap.KeySetView.contains	(	Object	): 
java.util.concurrent.ConcurrentHashMap.KeySetView.getMappedValue	(	): Returns the default mapped value for additions, or null if additions are not supported.
java.util.concurrent.ConcurrentHashMap.KeySetView.iterator	(	): Returns an iterator over the elements in this collection. The returned iterator is weakly consistent.
java.util.concurrent.ConcurrentHashMap.KeySetView.remove	(	Object	): Removes the key from this map view, by removing the key (and its corresponding value) from the backing map. This method does nothing if the key is not in the map.
java.util.concurrent.ConcurrentHashMap.MapEntry: Exported Entry for EntryIterator
java.util.concurrent.ConcurrentHashMap.MapEntry.setValue	(	V	): Sets our entry's value and writes through to the map. The value to return is somewhat arbitrary here. Since we do not necessarily track asynchronous changes, the most recent "previous" value could be different from what we return (or could even have been removed, in which case the put will re-establish). We do not and cannot guarantee more.
java.util.concurrent.ConcurrentHashMap.Node: Key-value entry. This class is never exported out as a user-mutable Map.Entry (i.e., one supporting setValue; see MapEntry below), but can be used for read-only traversals used in bulk tasks. Subclasses of Node with a negative hash field are special, and contain null keys and values (but are never exported). Otherwise, keys and vals are never null.
java.util.concurrent.ConcurrentHashMap.Node.find	(	int	Object	): Virtualized support for map.get(); overridden in subclasses.
java.util.concurrent.ConcurrentHashMap.ReservationNode: A place-holder node used in computeIfAbsent and compute
java.util.concurrent.ConcurrentHashMap.Segment: Stripped-down version of helper class used in previous version, declared for the sake of serialization compatibility
java.util.concurrent.ConcurrentHashMap.TableStack: Records the table, its length, and current traversal index for a traverser that must process a region of a forwarded table before proceeding with current table.
java.util.concurrent.ConcurrentHashMap.Traverser: Encapsulates traversal for methods such as containsValue; also serves as a base class for other iterators and spliterators. Method advance visits once each still-valid node that was reachable upon iterator construction. It might miss some that were added to a bin after the bin was visited, which is OK wrt consistency guarantees. Maintaining this property in the face of possible ongoing resizes requires a fair amount of bookkeeping state that is difficult to optimize away amidst volatile accesses. Even so, traversal maintains reasonable throughput. Normally, iteration proceeds bin-by-bin traversing lists. However, if the table has been resized, then all future steps must traverse both the bin at the current index as well as at (index + baseSize); and so on for further resizings. To paranoically cope with potential sharing by users of iterators across threads, iteration terminates if a bounds checks fails for a table read.
java.util.concurrent.ConcurrentHashMap.Traverser.advance	(	): Advances if possible, returning next valid node, or null if none.
java.util.concurrent.ConcurrentHashMap.Traverser.pushState	(	Node[]	int	int	): Saves traversal state upon encountering a forwarding node.
java.util.concurrent.ConcurrentHashMap.Traverser.recoverState	(	int	): Possibly pops traversal state.
java.util.concurrent.ConcurrentHashMap.TreeBin: TreeNodes used at the heads of bins. TreeBins do not hold user keys or values, but instead point to list of TreeNodes and their root. They also maintain a parasitic read-write lock forcing writers (who hold bin lock) to wait for readers (who do not) to complete before tree restructuring operations.
java.util.concurrent.ConcurrentHashMap.TreeBin.TreeBin	(	TreeNode	): Creates bin with initial set of nodes headed by b.
java.util.concurrent.ConcurrentHashMap.TreeBin.checkInvariants	(	TreeNode	): Recursive invariant check
java.util.concurrent.ConcurrentHashMap.TreeBin.contendedLock	(	): Possibly blocks awaiting root lock.
java.util.concurrent.ConcurrentHashMap.TreeBin.find	(	int	Object	): Returns matching node or null if none. Tries to search using tree comparisons from root, but continues linear search when lock not available.
java.util.concurrent.ConcurrentHashMap.TreeBin.lockRoot	(	): Acquires write lock for tree restructuring.
java.util.concurrent.ConcurrentHashMap.TreeBin.putTreeVal	(	int	K	V	): Finds or adds a node.
java.util.concurrent.ConcurrentHashMap.TreeBin.removeTreeNode	(	TreeNode	): Removes the given node, that must be present before this call. This is messier than typical red-black deletion code because we cannot swap the contents of an interior node with a leaf successor that is pinned by "next" pointers that are accessible independently of lock. So instead we swap the tree linkages.
java.util.concurrent.ConcurrentHashMap.TreeBin.tieBreakOrder	(	Object	Object	): Tie-breaking utility for ordering insertions when equal hashCodes and non-comparable. We don't require a total order, just a consistent insertion rule to maintain equivalence across rebalancings. Tie-breaking further than necessary simplifies testing a bit.
java.util.concurrent.ConcurrentHashMap.TreeBin.unlockRoot	(	): Releases write lock for tree restructuring.
java.util.concurrent.ConcurrentHashMap.TreeNode: Nodes for use in TreeBins
java.util.concurrent.ConcurrentHashMap.TreeNode.findTreeNode	(	int	Object	Class	): Returns the TreeNode (or null if not found) for the given key starting at given root.
java.util.concurrent.ConcurrentHashMap.ValuesView: A view of a ConcurrentHashMap as a Collection of values, in which additions are disabled. This class cannot be directly instantiated. See values().
java.util.concurrent.ConcurrentHashMap.addCount	(	long	int	): Adds to count, and if table is too small and not already resizing, initiates transfer. If already resizing, helps perform transfer if work is available. Rechecks occupancy after a transfer to see if another resize is already needed because resizings are lagging additions.
java.util.concurrent.ConcurrentHashMap.batchFor	(	long	): Computes initial batch value for bulk tasks. The returned value is approximately exp2 of the number of times (minus one) to split task by two before executing leaf action. This value is faster to compute and more convenient to use as a guide to splitting than is the depth, since it is used while dividing by two anyway.
java.util.concurrent.ConcurrentHashMap.clear	(	): Removes all of the mappings from this map.
java.util.concurrent.ConcurrentHashMap.comparableClassFor	(	Object	): Returns x's Class if it is of the form "class C implements Comparable", else null.
java.util.concurrent.ConcurrentHashMap.compareComparables	(	Class	Object	Object	): Returns k.compareTo(x) if x matches kc (k's screened comparable class), else 0.
java.util.concurrent.ConcurrentHashMap.compute	(	K	BiFunction	): Attempts to compute a mapping for the specified key and its current mapped value (or null if there is no current mapping). The entire method invocation is performed atomically. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this Map.
java.util.concurrent.ConcurrentHashMap.computeIfAbsent	(	K	Function	): If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless null. The entire method invocation is performed atomically, so the function is applied at most once per key. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this map.
java.util.concurrent.ConcurrentHashMap.computeIfPresent	(	K	BiFunction	): If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value. The entire method invocation is performed atomically. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this map.
java.util.concurrent.ConcurrentHashMap.contains	(	Object	): Legacy method testing if some key maps into the specified value in this table. This method is identical in functionality to containsValue(), and exists solely to ensure full compatibility with class java.util.Hashtable, which supported this method prior to introduction of the Java Collections framework.
java.util.concurrent.ConcurrentHashMap.containsKey	(	Object	): Tests if the specified object is a key in this table.
java.util.concurrent.ConcurrentHashMap.containsValue	(	Object	): Returns true if this map maps one or more keys to the specified value. Note: This method may require a full traversal of the map, and is much slower than method containsKey.
java.util.concurrent.ConcurrentHashMap.elements	(	): Returns an enumeration of the values in this table.
java.util.concurrent.ConcurrentHashMap.entrySet	(	): Returns a Set view of the mappings contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. The view's iterators and spliterators are weakly consistent. The view's spliterator reports CONCURRENT, DISTINCT, and NONNULL.
java.util.concurrent.ConcurrentHashMap.equals	(	Object	): Compares the specified object with this map for equality. Returns true if the given object is a map with the same mappings as this map. This operation may return misleading results if either map is concurrently modified during execution of this method.
java.util.concurrent.ConcurrentHashMap.forEach	(	long	BiConsumer	): Performs the given action for each (key, value).
java.util.concurrent.ConcurrentHashMap.forEach	(	long	BiFunction	Consumer	): Performs the given action for each non-null transformation of each (key, value).
java.util.concurrent.ConcurrentHashMap.forEachEntry	(	long	Consumer	): Performs the given action for each entry.
java.util.concurrent.ConcurrentHashMap.forEachEntry	(	long	Function	Consumer	): Performs the given action for each non-null transformation of each entry.
java.util.concurrent.ConcurrentHashMap.forEachKey	(	long	Consumer	): Performs the given action for each key.
java.util.concurrent.ConcurrentHashMap.forEachKey	(	long	Function	Consumer	): Performs the given action for each non-null transformation of each key.
java.util.concurrent.ConcurrentHashMap.forEachValue	(	long	Consumer	): Performs the given action for each value.
java.util.concurrent.ConcurrentHashMap.forEachValue	(	long	Function	Consumer	): Performs the given action for each non-null transformation of each value.
java.util.concurrent.ConcurrentHashMap.get	(	Object	): Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that key.equals(k), then this method returns v; otherwise it returns null. (There can be at most one such mapping.)
java.util.concurrent.ConcurrentHashMap.getOrDefault	(	Object	V	): Returns the value to which the specified key is mapped, or the given default value if this map contains no mapping for the key.
java.util.concurrent.ConcurrentHashMap.hashCode	(	): Returns the hash code value for this Map, i.e., the sum of, for each key-value pair in the map, key.hashCode() ^ value.hashCode().
java.util.concurrent.ConcurrentHashMap.helpTransfer	(	Node[]	Node	): Helps transfer if a resize is in progress.
java.util.concurrent.ConcurrentHashMap.initTable	(	): Initializes table, using the size recorded in sizeCtl.
java.util.concurrent.ConcurrentHashMap.isEmpty	(	): Returns true if this map contains no key-value mappings.
java.util.concurrent.ConcurrentHashMap.keySet	(	): Returns a Set view of the keys contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. The set supports element removal, which removes the corresponding mapping from this map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations. The view's iterators and spliterators are weakly consistent. The view's spliterator reports CONCURRENT, DISTINCT, and NONNULL.
java.util.concurrent.ConcurrentHashMap.keySet	(	V	): Returns a Set view of the keys in this map, using the given common mapped value for any additions (i.e., add and addAll()). This is of course only appropriate if it is acceptable to use the same value for all additions from this view.
java.util.concurrent.ConcurrentHashMap.keys	(	): Returns an enumeration of the keys in this table.
java.util.concurrent.ConcurrentHashMap.mappingCount	(	): Returns the number of mappings. This method should be used instead of size because a ConcurrentHashMap may contain more mappings than can be represented as an int. The value returned is an estimate; the actual count may differ if there are concurrent insertions or removals.
java.util.concurrent.ConcurrentHashMap.merge	(	K	V	BiFunction	): If the specified key is not already associated with a (non-null) value, associates it with the given value. Otherwise, replaces the value with the results of the given remapping function, or removes if null. The entire method invocation is performed atomically. Some attempted update operations on this map by other threads may be blocked while computation is in progress, so the computation should be short and simple, and must not attempt to update any other mappings of this Map.
java.util.concurrent.ConcurrentHashMap.newKeySet	(	): Creates a new Set backed by a ConcurrentHashMap from the given type to Boolean.TRUE.
java.util.concurrent.ConcurrentHashMap.newKeySet	(	int	): Creates a new Set backed by a ConcurrentHashMap from the given type to Boolean.TRUE.
java.util.concurrent.ConcurrentHashMap.put	(	K	V	): Maps the specified key to the specified value in this table. Neither the key nor the value can be null. The value can be retrieved by calling the get method with a key that is equal to the original key.
java.util.concurrent.ConcurrentHashMap.putAll	(	Map	): Copies all of the mappings from the specified map to this one. These mappings replace any mappings that this map had for any of the keys currently in the specified map.
java.util.concurrent.ConcurrentHashMap.putIfAbsent	(	K	V	): If the specified key is not already associated with a value (or is mapped to null) associates it with the given value and returns null, else returns the current value.
java.util.concurrent.ConcurrentHashMap.putVal	(	K	V	boolean	): Implementation for put and putIfAbsent 
java.util.concurrent.ConcurrentHashMap.readObject	(	java.io.ObjectInputStream	): Reconstitutes the instance from a stream (that is, deserializes it).
java.util.concurrent.ConcurrentHashMap.reduce	(	long	BiFunction	BiFunction	): Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap.reduceEntries	(	long	BiFunction	): Returns the result of accumulating all entries using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap.reduceEntries	(	long	Function	BiFunction	): Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap.reduceEntriesToDouble	(	long	ToDoubleFunction	double	DoubleBinaryOperator	): Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap.reduceEntriesToInt	(	long	ToIntFunction	int	IntBinaryOperator	): Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap.reduceEntriesToLong	(	long	ToLongFunction	long	LongBinaryOperator	): Returns the result of accumulating the given transformation of all entries using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap.reduceKeys	(	long	BiFunction	): Returns the result of accumulating all keys using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap.reduceKeys	(	long	Function	BiFunction	): Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap.reduceKeysToDouble	(	long	ToDoubleFunction	double	DoubleBinaryOperator	): Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap.reduceKeysToInt	(	long	ToIntFunction	int	IntBinaryOperator	): Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap.reduceKeysToLong	(	long	ToLongFunction	long	LongBinaryOperator	): Returns the result of accumulating the given transformation of all keys using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap.reduceToDouble	(	long	ToDoubleBiFunction	double	DoubleBinaryOperator	): Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap.reduceToInt	(	long	ToIntBiFunction	int	IntBinaryOperator	): Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap.reduceToLong	(	long	ToLongBiFunction	long	LongBinaryOperator	): Returns the result of accumulating the given transformation of all (key, value) pairs using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap.reduceValues	(	long	BiFunction	): Returns the result of accumulating all values using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap.reduceValues	(	long	Function	BiFunction	): Returns the result of accumulating the given transformation of all values using the given reducer to combine values, or null if none.
java.util.concurrent.ConcurrentHashMap.reduceValuesToDouble	(	long	ToDoubleFunction	double	DoubleBinaryOperator	): Returns the result of accumulating the given transformation of all values using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap.reduceValuesToInt	(	long	ToIntFunction	int	IntBinaryOperator	): Returns the result of accumulating the given transformation of all values using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap.reduceValuesToLong	(	long	ToLongFunction	long	LongBinaryOperator	): Returns the result of accumulating the given transformation of all values using the given reducer to combine values, and the given basis as an identity value.
java.util.concurrent.ConcurrentHashMap.remove	(	Object	): Removes the key (and its corresponding value) from this map. This method does nothing if the key is not in the map.
java.util.concurrent.ConcurrentHashMap.remove	(	Object	Object	): Removes the entry for the specified key only if it is currently mapped to the specified value.
java.util.concurrent.ConcurrentHashMap.replace	(	K	V	): Replaces the entry for the specified key only if it is currently mapped to some value.
java.util.concurrent.ConcurrentHashMap.replace	(	K	V	V	): Replaces the entry for the specified key only if currently mapped to the specified value.
java.util.concurrent.ConcurrentHashMap.replaceNode	(	Object	V	Object	): Implementation for the four public remove/replace methods: Replaces node value with v, conditional upon match of cv if non-null. If resulting value is null, delete.
java.util.concurrent.ConcurrentHashMap.resizeStamp	(	int	): Returns the stamp bits for resizing a table of size n. Must be negative when shifted left by RESIZE_STAMP_SHIFT.
java.util.concurrent.ConcurrentHashMap.search	(	long	BiFunction	): Returns a non-null result from applying the given search function on each (key, value), or null if none. Upon success, further element processing is suppressed and the results of any other parallel invocations of the search function are ignored.
java.util.concurrent.ConcurrentHashMap.searchEntries	(	long	Function	): Returns a non-null result from applying the given search function on each entry, or null if none. Upon success, further element processing is suppressed and the results of any other parallel invocations of the search function are ignored.
java.util.concurrent.ConcurrentHashMap.searchKeys	(	long	Function	): Returns a non-null result from applying the given search function on each key, or null if none. Upon success, further element processing is suppressed and the results of any other parallel invocations of the search function are ignored.
java.util.concurrent.ConcurrentHashMap.searchValues	(	long	Function	): Returns a non-null result from applying the given search function on each value, or null if none. Upon success, further element processing is suppressed and the results of any other parallel invocations of the search function are ignored.
java.util.concurrent.ConcurrentHashMap.size	(	): Returns the number of key-value mappings in this map. If the map contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
java.util.concurrent.ConcurrentHashMap.spread	(	int	): Spreads (XORs) higher bits of hash to lower and also forces top bit to 0. Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.) So we apply a transform that spreads the impact of higher bits downward. There is a tradeoff between speed, utility, and quality of bit-spreading. Because many common sets of hashes are already reasonably distributed (so don't benefit from spreading), and because we use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds.
java.util.concurrent.ConcurrentHashMap.tableSizeFor	(	int	): Returns a power of two table size for the given desired capacity. See Hackers Delight, sec 3.2
java.util.concurrent.ConcurrentHashMap.toString	(	): Returns a string representation of this map. The string representation consists of a list of key-value mappings (in no particular order) enclosed in braces (" "). Adjacent mappings are separated by the characters ", " (comma and space). Each key-value mapping is rendered as the key followed by an equals sign ("=") followed by the associated value.
java.util.concurrent.ConcurrentHashMap.transfer	(	Node[]	Node[]	): Moves and/or copies the nodes in each bin to new table. See above for explanation.
java.util.concurrent.ConcurrentHashMap.treeifyBin	(	Node[]	int	): Replaces all linked nodes in bin at given index unless table is too small, in which case resizes instead.
java.util.concurrent.ConcurrentHashMap.tryPresize	(	int	): Tries to presize table to accommodate the given number of elements.
java.util.concurrent.ConcurrentHashMap.untreeify	(	Node	): Returns a list on non-TreeNodes replacing those in given list.
java.util.concurrent.ConcurrentHashMap.values	(	): Returns a Collection view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. The collection supports element removal, which removes the corresponding mapping from this map, via the Iterator.remove, Collection.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations. The view's iterators and spliterators are weakly consistent. The view's spliterator reports CONCURRENT and NONNULL.
java.util.concurrent.ConcurrentHashMap.writeObject	(	java.io.ObjectOutputStream	): Saves the state of the ConcurrentHashMap instance to a stream (i.e., serializes it).
java.util.concurrent.ConcurrentLinkedDeque: An unbounded concurrent Deque deque based on linked nodes. Concurrent insertion, removal, and access operations execute safely across multiple threads. A ConcurrentLinkedDeque is an appropriate choice when many threads will share access to a common collection. Like most other concurrent collection implementations, this class does not permit the use of null elements. Iterators and spliterators are weakly consistent. Beware that, unlike in most collections, the size method is NOT a constant-time operation. Because of the asynchronous nature of these deques, determining the current number of elements requires a traversal of the elements, and so may report inaccurate results if this collection is modified during traversal. Additionally, the bulk operations addAll, removeAll, retainAll, containsAll, equals, and toArray are not guaranteed to be performed atomically. For example, an iterator operating concurrently with an addAll operation might view only some of the added elements. This class and its iterator implement all of the optional methods of the Deque and Iterator interfaces. Memory consistency effects: As with other concurrent collections, actions in a thread prior to placing an object into a ConcurrentLinkedDeque happen-before actions subsequent to the access or removal of that element from the ConcurrentLinkedDeque in another thread. This class is a member of the  Java Collections Framework.
java.util.concurrent.ConcurrentLinkedDeque.AbstractItr.advance	(	): Sets nextNode and nextItem to next valid node, or to null if no such.
java.util.concurrent.ConcurrentLinkedDeque.CLDSpliterator: A customized variant of Spliterators.IteratorSpliterator 
java.util.concurrent.ConcurrentLinkedDeque.ConcurrentLinkedDeque	(	): Constructs an empty deque.
java.util.concurrent.ConcurrentLinkedDeque.ConcurrentLinkedDeque	(	Collection	): Constructs a deque initially containing the elements of the given collection, added in traversal order of the collection's iterator.
java.util.concurrent.ConcurrentLinkedDeque.DescendingItr: Descending iterator 
java.util.concurrent.ConcurrentLinkedDeque.Itr: Forward iterator 
java.util.concurrent.ConcurrentLinkedDeque.Node.Node	(	E	): Constructs a new node. Uses relaxed write because item can only be seen after publication via casNext or casPrev.
java.util.concurrent.ConcurrentLinkedDeque.add	(	E	): Inserts the specified element at the tail of this deque. As the deque is unbounded, this method will never throw IllegalStateException or return false.
java.util.concurrent.ConcurrentLinkedDeque.addAll	(	Collection	): Appends all of the elements in the specified collection to the end of this deque, in the order that they are returned by the specified collection's iterator. Attempts to addAll of a deque to itself result in IllegalArgumentException.
java.util.concurrent.ConcurrentLinkedDeque.addFirst	(	E	): Inserts the specified element at the front of this deque. As the deque is unbounded, this method will never throw IllegalStateException.
java.util.concurrent.ConcurrentLinkedDeque.addLast	(	E	): Inserts the specified element at the end of this deque. As the deque is unbounded, this method will never throw IllegalStateException. This method is equivalent to add.
java.util.concurrent.ConcurrentLinkedDeque.checkNotNull	(	Object	): Throws NullPointerException if argument is null.
java.util.concurrent.ConcurrentLinkedDeque.clear	(	): Removes all of the elements from this deque.
java.util.concurrent.ConcurrentLinkedDeque.contains	(	Object	): Returns true if this deque contains at least one element e such that o.equals(e).
java.util.concurrent.ConcurrentLinkedDeque.descendingIterator	(	): Returns an iterator over the elements in this deque in reverse sequential order. The elements will be returned in order from last (tail) to first (head). The returned iterator is weakly consistent.
java.util.concurrent.ConcurrentLinkedDeque.element	(	): Retrieves, but does not remove, the head of the queue represented by this deque (in other words, the first element of this deque). This method differs from peek only in that it throws an exception if this deque is empty. This method is equivalent to getFirst().
java.util.concurrent.ConcurrentLinkedDeque.first	(	): Returns the first node, the unique node p for which: p.prev == null && p.next != p The returned node may or may not be logically deleted. Guarantees that head is set to the returned node.
java.util.concurrent.ConcurrentLinkedDeque.getFirst	(	): Retrieves, but does not remove, the first element of this deque. This method differs from peekFirst only in that it throws an exception if this deque is empty.
java.util.concurrent.ConcurrentLinkedDeque.getLast	(	): Retrieves, but does not remove, the last element of this deque. This method differs from peekLast only in that it throws an exception if this deque is empty.
java.util.concurrent.ConcurrentLinkedDeque.initHeadTail	(	Node	Node	): Initializes head and tail, ensuring invariants hold.
java.util.concurrent.ConcurrentLinkedDeque.isEmpty	(	): Returns true if this collection contains no elements.
java.util.concurrent.ConcurrentLinkedDeque.iterator	(	): Returns an iterator over the elements in this deque in proper sequence. The elements will be returned in order from first (head) to last (tail). The returned iterator is weakly consistent.
java.util.concurrent.ConcurrentLinkedDeque.last	(	): Returns the last node, the unique node p for which: p.next == null && p.prev != p The returned node may or may not be logically deleted. Guarantees that tail is set to the returned node.
java.util.concurrent.ConcurrentLinkedDeque.linkFirst	(	E	): Links e as first element.
java.util.concurrent.ConcurrentLinkedDeque.linkLast	(	E	): Links e as last element.
java.util.concurrent.ConcurrentLinkedDeque.offer	(	E	): Inserts the specified element at the tail of this deque. As the deque is unbounded, this method will never return false.
java.util.concurrent.ConcurrentLinkedDeque.offerFirst	(	E	): Inserts the specified element at the front of this deque. As the deque is unbounded, this method will never return false.
java.util.concurrent.ConcurrentLinkedDeque.offerLast	(	E	): Inserts the specified element at the end of this deque. As the deque is unbounded, this method will never return false. This method is equivalent to add.
java.util.concurrent.ConcurrentLinkedDeque.pop	(	): Pops an element from the stack represented by this deque. In other words, removes and returns the first element of this deque. This method is equivalent to removeFirst().
java.util.concurrent.ConcurrentLinkedDeque.pred	(	Node	): Returns the predecessor of p, or the last node if p.prev has been linked to self, which will only be true if traversing with a stale pointer that is now off the list.
java.util.concurrent.ConcurrentLinkedDeque.push	(	E	): Pushes an element onto the stack represented by this deque (in other words, at the head of this deque) if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available. This method is equivalent to addFirst.
java.util.concurrent.ConcurrentLinkedDeque.readObject	(	java.io.ObjectInputStream	): Reconstitutes this deque from a stream (that is, deserializes it).
java.util.concurrent.ConcurrentLinkedDeque.remove	(	): Retrieves and removes the head of the queue represented by this deque (in other words, the first element of this deque). This method differs from poll only in that it throws an exception if this deque is empty. This method is equivalent to removeFirst().
java.util.concurrent.ConcurrentLinkedDeque.remove	(	Object	): Removes the first element e such that o.equals(e), if such an element exists in this deque. If the deque does not contain the element, it is unchanged.
java.util.concurrent.ConcurrentLinkedDeque.removeFirst	(	): Retrieves and removes the first element of this deque. This method differs from pollFirst only in that it throws an exception if this deque is empty.
java.util.concurrent.ConcurrentLinkedDeque.removeFirstOccurrence	(	Object	): Removes the first element e such that o.equals(e), if such an element exists in this deque. If the deque does not contain the element, it is unchanged.
java.util.concurrent.ConcurrentLinkedDeque.removeLast	(	): Retrieves and removes the last element of this deque. This method differs from pollLast only in that it throws an exception if this deque is empty.
java.util.concurrent.ConcurrentLinkedDeque.removeLastOccurrence	(	Object	): Removes the last element e such that o.equals(e), if such an element exists in this deque. If the deque does not contain the element, it is unchanged.
java.util.concurrent.ConcurrentLinkedDeque.screenNullResult	(	E	): Returns element unless it is null, in which case throws NoSuchElementException.
java.util.concurrent.ConcurrentLinkedDeque.size	(	): Returns the number of elements in this deque. If this deque contains more than Integer.MAX_VALUE elements, it returns Integer.MAX_VALUE. Beware that, unlike in most collections, this method is NOT a constant-time operation. Because of the asynchronous nature of these deques, determining the current number of elements requires traversing them all to count them. Additionally, it is possible for the size to change during execution of this method, in which case the returned result will be inaccurate. Thus, this method is typically not very useful in concurrent applications.
java.util.concurrent.ConcurrentLinkedDeque.spliterator	(	): Returns a Spliterator over the elements in this deque. The returned spliterator is weakly consistent. The Spliterator reports CONCURRENT, ORDERED, and NONNULL.
java.util.concurrent.ConcurrentLinkedDeque.succ	(	Node	): Returns the successor of p, or the first node if p.next has been linked to self, which will only be true if traversing with a stale pointer that is now off the list.
java.util.concurrent.ConcurrentLinkedDeque.toArray	(	): Returns an array containing all of the elements in this deque, in proper sequence (from first to last element). The returned array will be "safe" in that no references to it are maintained by this deque. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.concurrent.ConcurrentLinkedDeque.toArray	(	T[]	): Returns an array containing all of the elements in this deque, in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array. If the deque fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this deque. If this deque fits in the specified array with room to spare (i.e., the array has more elements than this deque), the element in the array immediately following the end of the deque is set to null. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a deque known to contain only strings. The following code can be used to dump the deque into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.concurrent.ConcurrentLinkedDeque.toArrayList	(	): Creates an array list and fills it with elements of this list. Used by toArray.
java.util.concurrent.ConcurrentLinkedDeque.unlink	(	Node	): Unlinks non-null node x.
java.util.concurrent.ConcurrentLinkedDeque.unlinkFirst	(	Node	Node	): Unlinks non-null first node.
java.util.concurrent.ConcurrentLinkedDeque.unlinkLast	(	Node	Node	): Unlinks non-null last node.
java.util.concurrent.ConcurrentLinkedDeque.updateHead	(	): Guarantees that any node which was unlinked before a call to this method will be unreachable from head after it returns. Does not guarantee to eliminate slack, only that head will point to a node that was active while this method was running.
java.util.concurrent.ConcurrentLinkedDeque.updateTail	(	): Guarantees that any node which was unlinked before a call to this method will be unreachable from tail after it returns. Does not guarantee to eliminate slack, only that tail will point to a node that was active while this method was running.
java.util.concurrent.ConcurrentLinkedDeque.writeObject	(	java.io.ObjectOutputStream	): Saves this deque to a stream (that is, serializes it).
java.util.concurrent.ConcurrentLinkedQueue: An unbounded thread-safe Queue queue based on linked nodes. This queue orders elements FIFO (first-in-first-out). The head of the queue is that element that has been on the queue the longest time. The tail of the queue is that element that has been on the queue the shortest time. New elements are inserted at the tail of the queue, and the queue retrieval operations obtain elements at the head of the queue. A ConcurrentLinkedQueue is an appropriate choice when many threads will share access to a common collection. Like most other concurrent collection implementations, this class does not permit the use of null elements. This implementation employs an efficient non-blocking algorithm based on one described in  Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms by Maged M. Michael and Michael L. Scott. Iterators are weakly consistent, returning elements reflecting the state of the queue at some point at or since the creation of the iterator. They do not throw java.util.ConcurrentModificationException, and may proceed concurrently with other operations. Elements contained in the queue since the creation of the iterator will be returned exactly once. Beware that, unlike in most collections, the size method is NOT a constant-time operation. Because of the asynchronous nature of these queues, determining the current number of elements requires a traversal of the elements, and so may report inaccurate results if this collection is modified during traversal. Additionally, the bulk operations addAll, removeAll, retainAll, containsAll, equals, and toArray are not guaranteed to be performed atomically. For example, an iterator operating concurrently with an addAll operation might view only some of the added elements. This class and its iterator implement all of the optional methods of the Queue and Iterator interfaces. Memory consistency effects: As with other concurrent collections, actions in a thread prior to placing an object into a ConcurrentLinkedQueue happen-before actions subsequent to the access or removal of that element from the ConcurrentLinkedQueue in another thread. This class is a member of the  Java Collections Framework.
java.util.concurrent.ConcurrentLinkedQueue.CLQSpliterator: A customized variant of Spliterators.IteratorSpliterator 
java.util.concurrent.ConcurrentLinkedQueue.ConcurrentLinkedQueue	(	): Creates a ConcurrentLinkedQueue that is initially empty.
java.util.concurrent.ConcurrentLinkedQueue.ConcurrentLinkedQueue	(	Collection	): Creates a ConcurrentLinkedQueue initially containing the elements of the given collection, added in traversal order of the collection's iterator.
java.util.concurrent.ConcurrentLinkedQueue.Itr.advance	(	): Moves to next valid node and returns item to return for next(), or null if no such.
java.util.concurrent.ConcurrentLinkedQueue.Node.Node	(	E	): Constructs a new node. Uses relaxed write because item can only be seen after publication via casNext.
java.util.concurrent.ConcurrentLinkedQueue.add	(	E	): Inserts the specified element at the tail of this queue. As the queue is unbounded, this method will never throw IllegalStateException or return false.
java.util.concurrent.ConcurrentLinkedQueue.addAll	(	Collection	): Appends all of the elements in the specified collection to the end of this queue, in the order that they are returned by the specified collection's iterator. Attempts to addAll of a queue to itself result in IllegalArgumentException.
java.util.concurrent.ConcurrentLinkedQueue.checkNotNull	(	Object	): Throws NullPointerException if argument is null.
java.util.concurrent.ConcurrentLinkedQueue.contains	(	Object	): Returns true if this queue contains the specified element. More formally, returns true if and only if this queue contains at least one element e such that o.equals(e).
java.util.concurrent.ConcurrentLinkedQueue.first	(	): Returns the first live (non-deleted) node on list, or null if none. This is yet another variant of poll/peek; here returning the first node, not element. We could make peek() a wrapper around first(), but that would cost an extra volatile read of item, and the need to add a retry loop to deal with the possibility of losing a race to a concurrent poll().
java.util.concurrent.ConcurrentLinkedQueue.isEmpty	(	): Returns true if this queue contains no elements.
java.util.concurrent.ConcurrentLinkedQueue.iterator	(	): Returns an iterator over the elements in this queue in proper sequence. The elements will be returned in order from first (head) to last (tail). The returned iterator is weakly consistent.
java.util.concurrent.ConcurrentLinkedQueue.offer	(	E	): Inserts the specified element at the tail of this queue. As the queue is unbounded, this method will never return false.
java.util.concurrent.ConcurrentLinkedQueue.readObject	(	java.io.ObjectInputStream	): Reconstitutes this queue from a stream (that is, deserializes it).
java.util.concurrent.ConcurrentLinkedQueue.remove	(	Object	): Removes a single instance of the specified element from this queue, if it is present. More formally, removes an element e such that o.equals(e), if this queue contains one or more such elements. Returns true if this queue contained the specified element (or equivalently, if this queue changed as a result of the call).
java.util.concurrent.ConcurrentLinkedQueue.size	(	): Returns the number of elements in this queue. If this queue contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE. Beware that, unlike in most collections, this method is NOT a constant-time operation. Because of the asynchronous nature of these queues, determining the current number of elements requires an O(n) traversal. Additionally, if elements are added or removed during execution of this method, the returned result may be inaccurate. Thus, this method is typically not very useful in concurrent applications.
java.util.concurrent.ConcurrentLinkedQueue.spliterator	(	): Returns a Spliterator over the elements in this queue. The returned spliterator is weakly consistent. The Spliterator reports CONCURRENT, ORDERED, and NONNULL.
java.util.concurrent.ConcurrentLinkedQueue.succ	(	Node	): Returns the successor of p, or the head node if p.next has been linked to self, which will only be true if traversing with a stale pointer that is now off the list.
java.util.concurrent.ConcurrentLinkedQueue.toArray	(	): Returns an array containing all of the elements in this queue, in proper sequence. The returned array will be "safe" in that no references to it are maintained by this queue. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.concurrent.ConcurrentLinkedQueue.toArray	(	T[]	): Returns an array containing all of the elements in this queue, in proper sequence; the runtime type of the returned array is that of the specified array. If the queue fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this queue. If this queue fits in the specified array with room to spare (i.e., the array has more elements than this queue), the element in the array immediately following the end of the queue is set to null. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a queue known to contain only strings. The following code can be used to dump the queue into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.concurrent.ConcurrentLinkedQueue.updateHead	(	Node	Node	): Tries to CAS head to p. If successful, repoint old head to itself as sentinel for succ(), below.
java.util.concurrent.ConcurrentLinkedQueue.writeObject	(	java.io.ObjectOutputStream	): Saves this queue to a stream (that is, serializes it).
java.util.concurrent.ConcurrentMap: A java.util.Map providing thread safety and atomicity guarantees. Memory consistency effects: As with other concurrent collections, actions in a thread prior to placing an object into a ConcurrentMap as a key or value happen-before actions subsequent to the access or removal of that object from the ConcurrentMap in another thread. This interface is a member of the  Java Collections Framework.
java.util.concurrent.ConcurrentMap.compute	(	K	BiFunction	): Attempts to compute a mapping for the specified key and its current mapped value (or null if there is no current mapping). For example, to either create or append a String msg to a value mapping:  map.compute(key, (k, v) -> (v == null) ? msg : v.concat(msg)) (Method merge merge() is often simpler to use for such purposes.) If the function returns null, the mapping is removed (or remains absent if initially absent). If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.
java.util.concurrent.ConcurrentMap.computeIfAbsent	(	K	Function	): If the specified key is not already associated with a value (or is mapped to null), attempts to compute its value using the given mapping function and enters it into this map unless null. If the function returns null no mapping is recorded. If the function itself throws an (unchecked) exception, the exception is rethrown, and no mapping is recorded. The most common usage is to construct a new object serving as an initial mapped value or memoized result, as in:  map.computeIfAbsent(key, k -> new Value(f(k))); Or to implement a multi-value map, Map>, supporting multiple values per key:  map.computeIfAbsent(key, k -> new HashSet()).add(v);
java.util.concurrent.ConcurrentMap.computeIfPresent	(	K	BiFunction	): If the value for the specified key is present and non-null, attempts to compute a new mapping given the key and its current mapped value. If the function returns null, the mapping is removed. If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.
java.util.concurrent.ConcurrentMap.forEach	(	BiConsumer	): Performs the given action for each entry in this map until all entries have been processed or the action throws an exception. Unless otherwise specified by the implementing class, actions are performed in the order of entry set iteration (if an iteration order is specified.) Exceptions thrown by the action are relayed to the caller.
java.util.concurrent.ConcurrentMap.getOrDefault	(	Object	V	): Returns the value to which the specified key is mapped, or defaultValue if this map contains no mapping for the key.
java.util.concurrent.ConcurrentMap.merge	(	K	V	BiFunction	): If the specified key is not already associated with a value or is associated with null, associates it with the given non-null value. Otherwise, replaces the associated value with the results of the given remapping function, or removes if the result is null. This method may be of use when combining multiple mapped values for a key. For example, to either create or append a String msg to a value mapping:  map.merge(key, msg, String::concat) If the function returns null the mapping is removed. If the function itself throws an (unchecked) exception, the exception is rethrown, and the current mapping is left unchanged.
java.util.concurrent.ConcurrentMap.putIfAbsent	(	K	V	): If the specified key is not already associated with a value, associate it with the given value. This is equivalent to  if (!map.containsKey(key)) return map.put(key, value); else return map.get(key); except that the action is performed atomically.
java.util.concurrent.ConcurrentMap.remove	(	Object	Object	): Removes the entry for a key only if currently mapped to a given value. This is equivalent to  if (map.containsKey(key) && Objects.equals(map.get(key), value)) map.remove(key); return true; } else return false; } except that the action is performed atomically.
java.util.concurrent.ConcurrentMap.replace	(	K	V	): Replaces the entry for a key only if currently mapped to some value. This is equivalent to  if (map.containsKey(key)) return map.put(key, value); } else return null; } except that the action is performed atomically.
java.util.concurrent.ConcurrentMap.replace	(	K	V	V	): Replaces the entry for a key only if currently mapped to a given value. This is equivalent to  if (map.containsKey(key) && Objects.equals(map.get(key), oldValue)) map.put(key, newValue); return true; } else return false; } except that the action is performed atomically.
java.util.concurrent.ConcurrentMap.replaceAll	(	BiFunction	): Replaces each entry's value with the result of invoking the given function on that entry until all entries have been processed or the function throws an exception. Exceptions thrown by the function are relayed to the caller.
java.util.concurrent.ConcurrentNavigableMap: A ConcurrentMap supporting NavigableMap operations, and recursively so for its navigable sub-maps. This interface is a member of the  Java Collections Framework.
java.util.concurrent.ConcurrentNavigableMap.descendingKeySet	(	): Returns a reverse order NavigableSet view of the keys contained in this map. The set's iterator returns the keys in descending order. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations. The view's iterators and spliterators are weakly consistent.
java.util.concurrent.ConcurrentNavigableMap.descendingMap	(	): Returns a reverse order view of the mappings contained in this map. The descending map is backed by this map, so changes to the map are reflected in the descending map, and vice-versa. The returned map has an ordering equivalent to reverseOrder() Collections.reverseOrder (comparator()). The expression m.descendingMap().descendingMap() returns a view of m essentially equivalent to m.
java.util.concurrent.ConcurrentNavigableMap.headMap	(	K	): Returns a view of the portion of this map whose keys are strictly less than toKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range. Equivalent to headMap(toKey, false).
java.util.concurrent.ConcurrentNavigableMap.headMap	(	K	boolean	): Returns a view of the portion of this map whose keys are less than (or equal to, if inclusive is true) toKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range.
java.util.concurrent.ConcurrentNavigableMap.keySet	(	): Returns a NavigableSet view of the keys contained in this map. The set's iterator returns the keys in ascending order. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations. The view's iterators and spliterators are weakly consistent. This method is equivalent to method navigableKeySet.
java.util.concurrent.ConcurrentNavigableMap.navigableKeySet	(	): Returns a NavigableSet view of the keys contained in this map. The set's iterator returns the keys in ascending order. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations. The view's iterators and spliterators are weakly consistent.
java.util.concurrent.ConcurrentNavigableMap.subMap	(	K	K	): Returns a view of the portion of this map whose keys range from fromKey, inclusive, to toKey, exclusive. (If fromKey and toKey are equal, the returned map is empty.) The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range. Equivalent to subMap(fromKey, true, toKey, false).
java.util.concurrent.ConcurrentNavigableMap.subMap	(	K	boolean	K	boolean	): Returns a view of the portion of this map whose keys range from fromKey to toKey. If fromKey and toKey are equal, the returned map is empty unless fromInclusive and toInclusive are both true. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside of its range, or to construct a submap either of whose endpoints lie outside its range.
java.util.concurrent.ConcurrentNavigableMap.tailMap	(	K	): Returns a view of the portion of this map whose keys are greater than or equal to fromKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range. Equivalent to tailMap(fromKey, true).
java.util.concurrent.ConcurrentNavigableMap.tailMap	(	K	boolean	): Returns a view of the portion of this map whose keys are greater than (or equal to, if inclusive is true) fromKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range.
java.util.concurrent.ConcurrentSkipListMap: A scalable concurrent ConcurrentNavigableMap implementation. The map is sorted according to the Comparable natural ordering of its keys, or by a Comparator provided at map creation time, depending on which constructor is used. This class implements a concurrent variant of SkipLists providing expected average log(n) time cost for the containsKey, get, put and remove operations and their variants. Insertion, removal, update, and access operations safely execute concurrently by multiple threads. Iterators and spliterators are weakly consistent. Ascending key ordered views and their iterators are faster than descending ones. All Map.Entry pairs returned by methods in this class and its views represent snapshots of mappings at the time they were produced. They do not support the Entry.setValue method. (Note however that it is possible to change mappings in the associated map using put, putIfAbsent, or replace, depending on exactly which effect you need.) Beware that, unlike in most collections, the size method is not a constant-time operation. Because of the asynchronous nature of these maps, determining the current number of elements requires a traversal of the elements, and so may report inaccurate results if this collection is modified during traversal. Additionally, the bulk operations putAll, equals, toArray, containsValue, and clear are not guaranteed to be performed atomically. For example, an iterator operating concurrently with a putAll operation might view only some of the added elements. This class and its views and iterators implement all of the optional methods of the Map and Iterator interfaces. Like most other concurrent collections, this class does not permit the use of null keys or values because some null return values cannot be reliably distinguished from the absence of elements. This class is a member of the  Java Collections Framework.
java.util.concurrent.ConcurrentSkipListMap.CSLMSpliterator: Base class providing common structure for Spliterators. (Although not all that much common functionality; as usual for view classes, details annoyingly vary in key, value, and entry subclasses in ways that are not worth abstracting out for internal classes.) The basic split strategy is to recursively descend from top level, row by row, descending to next row when either split off, or the end of row is encountered. Control of the number of splits relies on some statistical estimation: The expected remaining number of elements of a skip list when advancing either across or down decreases by about 25%. To make this observation useful, we need to know initial size, which we don't. But we can just use Integer.MAX_VALUE so that we don't prematurely zero out while splitting.
java.util.concurrent.ConcurrentSkipListMap.ConcurrentSkipListMap	(	): Constructs a new, empty map, sorted according to the Comparable natural ordering of the keys.
java.util.concurrent.ConcurrentSkipListMap.ConcurrentSkipListMap	(	Comparator	): Constructs a new, empty map, sorted according to the specified comparator.
java.util.concurrent.ConcurrentSkipListMap.ConcurrentSkipListMap	(	Map	): Constructs a new map containing the same mappings as the given map, sorted according to the Comparable natural ordering of the keys.
java.util.concurrent.ConcurrentSkipListMap.ConcurrentSkipListMap	(	SortedMap	): Constructs a new map containing the same mappings and using the same ordering as the specified sorted map.
java.util.concurrent.ConcurrentSkipListMap.HeadIndex: Nodes heading each level keep track of their level.
java.util.concurrent.ConcurrentSkipListMap.Index: Index nodes represent the levels of the skip list. Note that even though both Nodes and Indexes have forward-pointing fields, they have different types and are handled in different ways, that can't nicely be captured by placing field in a shared abstract class.
java.util.concurrent.ConcurrentSkipListMap.Index.Index	(	Node	Index	Index	): Creates index node with given values.
java.util.concurrent.ConcurrentSkipListMap.Index.casRight	(	Index	Index	): compareAndSet right field
java.util.concurrent.ConcurrentSkipListMap.Index.indexesDeletedNode	(	): Returns true if the node this indexes has been deleted.
java.util.concurrent.ConcurrentSkipListMap.Index.link	(	Index	Index	): Tries to CAS newSucc as successor. To minimize races with unlink that may lose this index node, if the node being indexed is known to be deleted, it doesn't try to link in.
java.util.concurrent.ConcurrentSkipListMap.Index.unlink	(	Index	): Tries to CAS right field to skip over apparent successor succ. Fails (forcing a retraversal by caller) if this node is known to be deleted.
java.util.concurrent.ConcurrentSkipListMap.Iter: Base of iterator classes:
java.util.concurrent.ConcurrentSkipListMap.Iter.Iter	(	): Initializes ascending iterator for entire range. 
java.util.concurrent.ConcurrentSkipListMap.Iter.advance	(	): Advances next to higher entry. 
java.util.concurrent.ConcurrentSkipListMap.Node: Nodes hold keys and values, and are singly linked in sorted order, possibly with some intervening marker nodes. The list is headed by a dummy node accessible as head.node. The value field is declared only as Object because it takes special non-V values for marker and header nodes.
java.util.concurrent.ConcurrentSkipListMap.Node.Node	(	K	Object	Node	): Creates a new regular node.
java.util.concurrent.ConcurrentSkipListMap.Node.Node	(	Node	): Creates a new marker node. A marker is distinguished by having its value field point to itself. Marker nodes also have null keys, a fact that is exploited in a few places, but this doesn't distinguish markers from the base-level header node (head.node), which also has a null key.
java.util.concurrent.ConcurrentSkipListMap.Node.appendMarker	(	Node	): Tries to append a deletion marker to this node.
java.util.concurrent.ConcurrentSkipListMap.Node.casNext	(	Node	Node	): compareAndSet next field
java.util.concurrent.ConcurrentSkipListMap.Node.casValue	(	Object	Object	): compareAndSet value field
java.util.concurrent.ConcurrentSkipListMap.Node.createSnapshot	(	): Creates and returns a new SimpleImmutableEntry holding current mapping if this node holds a valid value, else null.
java.util.concurrent.ConcurrentSkipListMap.Node.getValidValue	(	): Returns value if this node contains a valid key-value pair, else null.
java.util.concurrent.ConcurrentSkipListMap.Node.helpDelete	(	Node	Node	): Helps out a deletion by appending marker or unlinking from predecessor. This is called during traversals when value field seen to be null.
java.util.concurrent.ConcurrentSkipListMap.Node.isBaseHeader	(	): Returns true if this node is the header of base-level list.
java.util.concurrent.ConcurrentSkipListMap.Node.isMarker	(	): Returns true if this node is a marker. This method isn't actually called in any current code checking for markers because callers will have already read value field and need to use that read (not another done here) and so directly test if value points to node.
java.util.concurrent.ConcurrentSkipListMap.SubMap: Submaps returned by ConcurrentSkipListMap submap operations represent a subrange of mappings of their underlying maps. Instances of this class support all methods of their underlying maps, differing in that mappings outside their range are ignored, and attempts to add mappings outside their ranges result in IllegalArgumentException. Instances of this class are constructed only using the subMap, headMap, and tailMap methods of their underlying maps.
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMap	(	ConcurrentSkipListMap	K	boolean	K	boolean	boolean	): Creates a new submap, initializing all fields.
java.util.concurrent.ConcurrentSkipListMap.SubMap.SubMapIter: Variant of main Iter class to traverse through submaps. Also serves as back-up Spliterator for views
java.util.concurrent.ConcurrentSkipListMap.SubMap.getNearEntry	(	K	int	): Submap version of ConcurrentSkipListMap.getNearEntry
java.util.concurrent.ConcurrentSkipListMap.SubMap.hiNode	(	Comparator	): Returns highest node. This node might not be in range, so most usages need to check bounds.
java.util.concurrent.ConcurrentSkipListMap.SubMap.highestKey	(	): Returns highest absolute key (ignoring directonality).
java.util.concurrent.ConcurrentSkipListMap.SubMap.isBeforeEnd	(	ConcurrentSkipListMap.Node	Comparator	): Returns true if node key is less than upper bound of range.
java.util.concurrent.ConcurrentSkipListMap.SubMap.loNode	(	Comparator	): Returns lowest node. This node might not be in range, so most usages need to check bounds.
java.util.concurrent.ConcurrentSkipListMap.SubMap.lowestKey	(	): Returns lowest absolute key (ignoring directonality).
java.util.concurrent.ConcurrentSkipListMap.SubMap.newSubMap	(	K	boolean	K	boolean	): Utility to create submaps, where given bounds override unbounded(null) ones and/or are checked against bounded ones.
java.util.concurrent.ConcurrentSkipListMap.buildFromSorted	(	SortedMap	): Streamlined bulk insertion to initialize from elements of given sorted map. Call only from constructor or clone method.
java.util.concurrent.ConcurrentSkipListMap.casHead	(	HeadIndex	HeadIndex	): compareAndSet head node
java.util.concurrent.ConcurrentSkipListMap.ceilingEntry	(	K	): Returns a key-value mapping associated with the least key greater than or equal to the given key, or null if there is no such entry. The returned entry does not support the Entry.setValue method.
java.util.concurrent.ConcurrentSkipListMap.ceilingKey	(	K	): Returns the least key greater than or equal to the given key, or null if there is no such key.
java.util.concurrent.ConcurrentSkipListMap.clear	(	): Removes all of the mappings from this map.
java.util.concurrent.ConcurrentSkipListMap.clearIndexToFirst	(	): Clears out index nodes associated with deleted first entry.
java.util.concurrent.ConcurrentSkipListMap.clone	(	): Returns a shallow copy of this ConcurrentSkipListMap instance. (The keys and values themselves are not cloned.)
java.util.concurrent.ConcurrentSkipListMap.compute	(	K	BiFunction	): Attempts to compute a mapping for the specified key and its current mapped value (or null if there is no current mapping). The function is NOT guaranteed to be applied once atomically.
java.util.concurrent.ConcurrentSkipListMap.computeIfAbsent	(	K	Function	): If the specified key is not already associated with a value, attempts to compute its value using the given mapping function and enters it into this map unless null. The function is NOT guaranteed to be applied once atomically only if the value is not present.
java.util.concurrent.ConcurrentSkipListMap.computeIfPresent	(	K	BiFunction	): If the value for the specified key is present, attempts to compute a new mapping given the key and its current mapped value. The function is NOT guaranteed to be applied once atomically.
java.util.concurrent.ConcurrentSkipListMap.containsKey	(	Object	): Returns true if this map contains a mapping for the specified key.
java.util.concurrent.ConcurrentSkipListMap.containsValue	(	Object	): Returns true if this map maps one or more keys to the specified value. This operation requires time linear in the map size. Additionally, it is possible for the map to change during execution of this method, in which case the returned result may be inaccurate.
java.util.concurrent.ConcurrentSkipListMap.cpr	(	Comparator	Object	Object	): Compares using comparator or natural ordering if null. Called only by methods that have performed required type checks.
java.util.concurrent.ConcurrentSkipListMap.doGet	(	Object	): Gets value for key. Almost the same as findNode, but returns the found value (to avoid retries during re-reads)
java.util.concurrent.ConcurrentSkipListMap.doPut	(	K	V	boolean	): Main insertion method. Adds element if not present, or replaces value if present and onlyIfAbsent is false.
java.util.concurrent.ConcurrentSkipListMap.doRemove	(	Object	Object	): Main deletion method. Locates node, nulls value, appends a deletion marker, unlinks predecessor, removes associated index nodes, and possibly reduces head index level. Index nodes are cleared out simply by calling findPredecessor. which unlinks indexes to deleted nodes found along path to key, which will include the indexes to this node. This is done unconditionally. We can't check beforehand whether there are index nodes because it might be the case that some or all indexes hadn't been inserted yet for this node during initial search for it, and we'd like to ensure lack of garbage retention, so must call to be sure.
java.util.concurrent.ConcurrentSkipListMap.doRemoveFirstEntry	(	): Removes first entry; returns its snapshot.
java.util.concurrent.ConcurrentSkipListMap.doRemoveLastEntry	(	): Removes last entry; returns its snapshot. Specialized variant of doRemove.
java.util.concurrent.ConcurrentSkipListMap.entrySet	(	): Returns a Set view of the mappings contained in this map. The set's iterator returns the entries in ascending key order. The set's spliterator additionally reports CONCURRENT, NONNULL, SORTED and ORDERED, with an encounter order that is ascending key order. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations. The view's iterators and spliterators are weakly consistent. The Map.Entry elements traversed by the iterator or spliterator do not support the setValue operation.
java.util.concurrent.ConcurrentSkipListMap.equals	(	Object	): Compares the specified object with this map for equality. Returns true if the given object is also a map and the two maps represent the same mappings. More formally, two maps m1 and m2 represent the same mappings if m1.entrySet().equals(m2.entrySet()). This operation may return misleading results if either map is concurrently modified during execution of this method.
java.util.concurrent.ConcurrentSkipListMap.findFirst	(	): Specialized variant of findNode to get first valid node.
java.util.concurrent.ConcurrentSkipListMap.findLast	(	): Specialized version of find to get last valid node.
java.util.concurrent.ConcurrentSkipListMap.findNear	(	K	int	Comparator	): Utility for ceiling, floor, lower, higher methods.
java.util.concurrent.ConcurrentSkipListMap.findNode	(	Object	): Returns node holding key or null if no such, clearing out any deleted nodes seen along the way. Repeatedly traverses at base-level looking for key starting at predecessor returned from findPredecessor, processing base-level deletions as encountered. Some callers rely on this side-effect of clearing deleted nodes. Restarts occur, at traversal step centered on node n, if: (1) After reading n's next field, n is no longer assumed predecessor b's current successor, which means that we don't have a consistent 3-node snapshot and so cannot unlink any subsequent deleted nodes encountered. (2) n's value field is null, indicating n is deleted, in which case we help out an ongoing structural deletion before retrying. Even though there are cases where such unlinking doesn't require restart, they aren't sorted out here because doing so would not usually outweigh cost of restarting. (3) n is a marker or n's predecessor's value field is null, indicating (among other possibilities) that findPredecessor returned a deleted node. We can't unlink the node because we don't know its predecessor, so rely on another call to findPredecessor to notice and return some earlier predecessor, which it will do. This check is only strictly needed at beginning of loop, (and the b.value check isn't strictly needed at all) but is done each iteration to help avoid contention with other threads by callers that will fail to be able to change links, and so will retry anyway. The traversal loops in doPut, doRemove, and findNear all include the same three kinds of checks. And specialized versions appear in findFirst, and findLast and their variants. They can't easily share code because each uses the reads of fields held in locals occurring in the orders they were performed.
java.util.concurrent.ConcurrentSkipListMap.findPredecessor	(	Object	Comparator	): Returns a base-level node with key strictly less than given key, or the base-level header if there is no such node. Also unlinks indexes to deleted nodes found along the way. Callers rely on this side-effect of clearing indices to deleted nodes.
java.util.concurrent.ConcurrentSkipListMap.findPredecessorOfLast	(	): Specialized variant of findPredecessor to get predecessor of last valid node. Needed when removing the last entry. It is possible that all successors of returned node will have been deleted upon return, in which case this method can be retried.
java.util.concurrent.ConcurrentSkipListMap.firstEntry	(	): Returns a key-value mapping associated with the least key in this map, or null if the map is empty. The returned entry does not support the Entry.setValue method.
java.util.concurrent.ConcurrentSkipListMap.firstKey	(	): Returns the first (lowest) key currently in this map.
java.util.concurrent.ConcurrentSkipListMap.floorEntry	(	K	): Returns a key-value mapping associated with the greatest key less than or equal to the given key, or null if there is no such key. The returned entry does not support the Entry.setValue method.
java.util.concurrent.ConcurrentSkipListMap.floorKey	(	K	): Returns the greatest key less than or equal to the given key, or null if there is no such key.
java.util.concurrent.ConcurrentSkipListMap.get	(	Object	): Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key. More formally, if this map contains a mapping from a key k to a value v such that key compares equal to k according to the map's ordering, then this method returns v; otherwise it returns null. (There can be at most one such mapping.)
java.util.concurrent.ConcurrentSkipListMap.getNear	(	K	int	): Returns SimpleImmutableEntry for results of findNear.
java.util.concurrent.ConcurrentSkipListMap.getOrDefault	(	Object	V	): Returns the value to which the specified key is mapped, or the given defaultValue if this map contains no mapping for the key.
java.util.concurrent.ConcurrentSkipListMap.headMap	(	K	): Returns a view of the portion of this map whose keys are strictly less than toKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range. Equivalent to headMap(toKey, false).
java.util.concurrent.ConcurrentSkipListMap.headMap	(	K	boolean	): Returns a view of the portion of this map whose keys are less than (or equal to, if inclusive is true) toKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range.
java.util.concurrent.ConcurrentSkipListMap.higherEntry	(	K	): Returns a key-value mapping associated with the least key strictly greater than the given key, or null if there is no such key. The returned entry does not support the Entry.setValue method.
java.util.concurrent.ConcurrentSkipListMap.higherKey	(	K	): Returns the least key strictly greater than the given key, or null if there is no such key.
java.util.concurrent.ConcurrentSkipListMap.initialize	(	): Initializes or resets state. Needed by constructors, clone, clear, readObject. and ConcurrentSkipListSet.clone. (Note that comparator must be separately initialized.)
java.util.concurrent.ConcurrentSkipListMap.isEmpty	(	): Returns true if this map contains no key-value mappings.
java.util.concurrent.ConcurrentSkipListMap.keySet	(	): Returns a NavigableSet view of the keys contained in this map. The set's iterator returns the keys in ascending order. The set's spliterator additionally reports CONCURRENT, NONNULL, SORTED and ORDERED, with an encounter order that is ascending key order. The spliterator's comparator (see getComparator()) is null if the map's comparator (see comparator()) is null. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the map's comparator. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa. The set supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Set.remove, removeAll, retainAll, and clear operations. It does not support the add or addAll operations. The view's iterators and spliterators are weakly consistent. This method is equivalent to method navigableKeySet.
java.util.concurrent.ConcurrentSkipListMap.lastEntry	(	): Returns a key-value mapping associated with the greatest key in this map, or null if the map is empty. The returned entry does not support the Entry.setValue method.
java.util.concurrent.ConcurrentSkipListMap.lastKey	(	): Returns the last (highest) key currently in this map.
java.util.concurrent.ConcurrentSkipListMap.lowerEntry	(	K	): Returns a key-value mapping associated with the greatest key strictly less than the given key, or null if there is no such key. The returned entry does not support the Entry.setValue method.
java.util.concurrent.ConcurrentSkipListMap.lowerKey	(	K	): Returns the greatest key strictly less than the given key, or null if there is no such key.
java.util.concurrent.ConcurrentSkipListMap.merge	(	K	V	BiFunction	): If the specified key is not already associated with a value, associates it with the given value. Otherwise, replaces the value with the results of the given remapping function, or removes if null. The function is NOT guaranteed to be applied once atomically.
java.util.concurrent.ConcurrentSkipListMap.pollFirstEntry	(	): Removes and returns a key-value mapping associated with the least key in this map, or null if the map is empty. The returned entry does not support the Entry.setValue method.
java.util.concurrent.ConcurrentSkipListMap.pollLastEntry	(	): Removes and returns a key-value mapping associated with the greatest key in this map, or null if the map is empty. The returned entry does not support the Entry.setValue method.
java.util.concurrent.ConcurrentSkipListMap.put	(	K	V	): Associates the specified value with the specified key in this map. If the map previously contained a mapping for the key, the old value is replaced.
java.util.concurrent.ConcurrentSkipListMap.putIfAbsent	(	K	V	): If the specified key is not already associated with a value (or is mapped to null) associates it with the given value and returns null, else returns the current value.
java.util.concurrent.ConcurrentSkipListMap.readObject	(	java.io.ObjectInputStream	): Reconstitutes this map from a stream (that is, deserializes it).
java.util.concurrent.ConcurrentSkipListMap.remove	(	Object	): Removes the mapping for the specified key from this map if present.
java.util.concurrent.ConcurrentSkipListMap.remove	(	Object	Object	): Removes the entry for the specified key only if it is currently mapped to the specified value.
java.util.concurrent.ConcurrentSkipListMap.replace	(	K	V	): Replaces the entry for the specified key only if it is currently mapped to some value.
java.util.concurrent.ConcurrentSkipListMap.replace	(	K	V	V	): Replaces the entry for the specified key only if currently mapped to the specified value.
java.util.concurrent.ConcurrentSkipListMap.size	(	): Returns the number of key-value mappings in this map. If this map contains more than Integer.MAX_VALUE elements, it returns Integer.MAX_VALUE. Beware that, unlike in most collections, this method is NOT a constant-time operation. Because of the asynchronous nature of these maps, determining the current number of elements requires traversing them all to count them. Additionally, it is possible for the size to change during execution of this method, in which case the returned result will be inaccurate. Thus, this method is typically not very useful in concurrent applications.
java.util.concurrent.ConcurrentSkipListMap.subMap	(	K	K	): Returns a view of the portion of this map whose keys range from fromKey, inclusive, to toKey, exclusive. (If fromKey and toKey are equal, the returned map is empty.) The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range. Equivalent to subMap(fromKey, true, toKey, false).
java.util.concurrent.ConcurrentSkipListMap.subMap	(	K	boolean	K	boolean	): Returns a view of the portion of this map whose keys range from fromKey to toKey. If fromKey and toKey are equal, the returned map is empty unless fromInclusive and toInclusive are both true. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside of its range, or to construct a submap either of whose endpoints lie outside its range.
java.util.concurrent.ConcurrentSkipListMap.tailMap	(	K	): Returns a view of the portion of this map whose keys are greater than or equal to fromKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range. Equivalent to tailMap(fromKey, true).
java.util.concurrent.ConcurrentSkipListMap.tailMap	(	K	boolean	): Returns a view of the portion of this map whose keys are greater than (or equal to, if inclusive is true) fromKey. The returned map is backed by this map, so changes in the returned map are reflected in this map, and vice-versa. The returned map supports all optional map operations that this map supports. The returned map will throw an IllegalArgumentException on an attempt to insert a key outside its range.
java.util.concurrent.ConcurrentSkipListMap.tryReduceLevel	(	): Possibly reduce head level if it has no nodes. This method can (rarely) make mistakes, in which case levels can disappear even though they are about to contain index nodes. This impacts performance, not correctness. To minimize mistakes as well as to reduce hysteresis, the level is reduced by one only if the topmost three levels look empty. Also, if the removed level looks non-empty after CAS, we try to change it back quick before anyone notices our mistake! (This trick works pretty well because this method will practically never make mistakes unless current thread stalls immediately before first CAS, in which case it is very unlikely to stall again immediately afterwards, so will recover.) We put up with all this rather than just let levels grow because otherwise, even a small map that has undergone a large number of insertions and removals will have a lot of levels, slowing down access more than would an occasional unwanted reduction.
java.util.concurrent.ConcurrentSkipListMap.values	(	): Returns a Collection view of the values contained in this map. The collection's iterator returns the values in ascending order of the corresponding keys. The collections's spliterator additionally reports CONCURRENT, NONNULL and ORDERED, with an encounter order that is ascending order of the corresponding keys. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa. The collection supports element removal, which removes the corresponding mapping from the map, via the Iterator.remove, Collection.remove, removeAll, retainAll and clear operations. It does not support the add or addAll operations. The view's iterators and spliterators are weakly consistent.
java.util.concurrent.ConcurrentSkipListMap.writeObject	(	java.io.ObjectOutputStream	): Saves this map to a stream (that is, serializes it).
java.util.concurrent.ConcurrentSkipListSet: A scalable concurrent NavigableSet implementation based on a ConcurrentSkipListMap. The elements of the set are kept sorted according to their Comparable natural ordering, or by a Comparator provided at set creation time, depending on which constructor is used. This implementation provides expected average log(n) time cost for the contains, add, and remove operations and their variants. Insertion, removal, and access operations safely execute concurrently by multiple threads. Iterators and spliterators are weakly consistent. Ascending ordered views and their iterators are faster than descending ones. Beware that, unlike in most collections, the size method is not a constant-time operation. Because of the asynchronous nature of these sets, determining the current number of elements requires a traversal of the elements, and so may report inaccurate results if this collection is modified during traversal. Additionally, the bulk operations addAll, removeAll, retainAll, containsAll, equals, and toArray are not guaranteed to be performed atomically. For example, an iterator operating concurrently with an addAll operation might view only some of the added elements. This class and its iterators implement all of the optional methods of the Set and Iterator interfaces. Like most other concurrent collection implementations, this class does not permit the use of null elements, because null arguments and return values cannot be reliably distinguished from the absence of elements. This class is a member of the  Java Collections Framework.
java.util.concurrent.ConcurrentSkipListSet.ConcurrentSkipListSet	(	): Constructs a new, empty set that orders its elements according to their Comparable natural ordering.
java.util.concurrent.ConcurrentSkipListSet.ConcurrentSkipListSet	(	Collection	): Constructs a new set containing the elements in the specified collection, that orders its elements according to their Comparable natural ordering.
java.util.concurrent.ConcurrentSkipListSet.ConcurrentSkipListSet	(	Comparator	): Constructs a new, empty set that orders its elements according to the specified comparator.
java.util.concurrent.ConcurrentSkipListSet.ConcurrentSkipListSet	(	ConcurrentNavigableMap	): For use by submaps
java.util.concurrent.ConcurrentSkipListSet.ConcurrentSkipListSet	(	SortedSet	): Constructs a new set containing the same elements and using the same ordering as the specified sorted set.
java.util.concurrent.ConcurrentSkipListSet.add	(	E	): Adds the specified element to this set if it is not already present. More formally, adds the specified element e to this set if the set contains no element e2 such that e.equals(e2). If this set already contains the element, the call leaves the set unchanged and returns false.
java.util.concurrent.ConcurrentSkipListSet.ceiling	(	E	): Returns the least element in this set greater than or equal to the given element, or null if there is no such element.
java.util.concurrent.ConcurrentSkipListSet.clear	(	): Removes all of the elements from this set.
java.util.concurrent.ConcurrentSkipListSet.clone	(	): Returns a shallow copy of this ConcurrentSkipListSet instance. (The elements themselves are not cloned.)
java.util.concurrent.ConcurrentSkipListSet.contains	(	Object	): Returns true if this set contains the specified element. More formally, returns true if and only if this set contains an element e such that o.equals(e).
java.util.concurrent.ConcurrentSkipListSet.descendingIterator	(	): Returns an iterator over the elements in this set in descending order.
java.util.concurrent.ConcurrentSkipListSet.descendingSet	(	): Returns a reverse order view of the elements contained in this set. The descending set is backed by this set, so changes to the set are reflected in the descending set, and vice-versa. The returned set has an ordering equivalent to reverseOrder() Collections.reverseOrder (comparator()). The expression s.descendingSet().descendingSet() returns a view of s essentially equivalent to s.
java.util.concurrent.ConcurrentSkipListSet.equals	(	Object	): Compares the specified object with this set for equality. Returns true if the specified object is also a set, the two sets have the same size, and every member of the specified set is contained in this set (or equivalently, every member of this set is contained in the specified set). This definition ensures that the equals method works properly across different implementations of the set interface.
java.util.concurrent.ConcurrentSkipListSet.first	(	): Returns the first (lowest) element currently in this set.
java.util.concurrent.ConcurrentSkipListSet.floor	(	E	): Returns the greatest element in this set less than or equal to the given element, or null if there is no such element.
java.util.concurrent.ConcurrentSkipListSet.headSet	(	E	): Returns a view of the portion of this set whose elements are strictly less than toElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range. Equivalent to headSet(toElement, false).
java.util.concurrent.ConcurrentSkipListSet.headSet	(	E	boolean	): Returns a view of the portion of this set whose elements are less than (or equal to, if inclusive is true) toElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range.
java.util.concurrent.ConcurrentSkipListSet.higher	(	E	): Returns the least element in this set strictly greater than the given element, or null if there is no such element.
java.util.concurrent.ConcurrentSkipListSet.isEmpty	(	): Returns true if this set contains no elements.
java.util.concurrent.ConcurrentSkipListSet.iterator	(	): Returns an iterator over the elements in this set in ascending order.
java.util.concurrent.ConcurrentSkipListSet.last	(	): Returns the last (highest) element currently in this set.
java.util.concurrent.ConcurrentSkipListSet.lower	(	E	): Returns the greatest element in this set strictly less than the given element, or null if there is no such element.
java.util.concurrent.ConcurrentSkipListSet.remove	(	Object	): Removes the specified element from this set if it is present. More formally, removes an element e such that o.equals(e), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)
java.util.concurrent.ConcurrentSkipListSet.removeAll	(	Collection	): Removes from this set all of its elements that are contained in the specified collection. If the specified collection is also a set, this operation effectively modifies this set so that its value is the asymmetric set difference of the two sets.
java.util.concurrent.ConcurrentSkipListSet.size	(	): Returns the number of elements in this set. If this set contains more than Integer.MAX_VALUE elements, it returns Integer.MAX_VALUE. Beware that, unlike in most collections, this method is NOT a constant-time operation. Because of the asynchronous nature of these sets, determining the current number of elements requires traversing them all to count them. Additionally, it is possible for the size to change during execution of this method, in which case the returned result will be inaccurate. Thus, this method is typically not very useful in concurrent applications.
java.util.concurrent.ConcurrentSkipListSet.spliterator	(	): Returns a Spliterator over the elements in this set. The Spliterator reports CONCURRENT, NONNULL, DISTINCT, SORTED and ORDERED, with an encounter order that is ascending order. Overriding implementations should document the reporting of additional characteristic values. The spliterator's comparator (see getComparator()) is null if the set's comparator (see comparator()) is null. Otherwise, the spliterator's comparator is the same as or imposes the same total ordering as the set's comparator.
java.util.concurrent.ConcurrentSkipListSet.subSet	(	E	E	): Returns a view of the portion of this set whose elements range from fromElement, inclusive, to toElement, exclusive. (If fromElement and toElement are equal, the returned set is empty.) The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range. Equivalent to subSet(fromElement, true, toElement, false).
java.util.concurrent.ConcurrentSkipListSet.subSet	(	E	boolean	E	boolean	): Returns a view of the portion of this set whose elements range from fromElement to toElement. If fromElement and toElement are equal, the returned set is empty unless fromInclusive and toInclusive are both true. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range.
java.util.concurrent.ConcurrentSkipListSet.tailSet	(	E	): Returns a view of the portion of this set whose elements are greater than or equal to fromElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range. Equivalent to tailSet(fromElement, true).
java.util.concurrent.ConcurrentSkipListSet.tailSet	(	E	boolean	): Returns a view of the portion of this set whose elements are greater than (or equal to, if inclusive is true) fromElement. The returned set is backed by this set, so changes in the returned set are reflected in this set, and vice-versa. The returned set supports all optional set operations that this set supports. The returned set will throw an IllegalArgumentException on an attempt to insert an element outside its range.
java.util.concurrent.CopyOnWriteArrayList: A thread-safe variant of java.util.ArrayList in which all mutative operations (add, set, and so on) are implemented by making a fresh copy of the underlying array. This is ordinarily too costly, but may be more efficient than alternatives when traversal operations vastly outnumber mutations, and is useful when you cannot or don't want to synchronize traversals, yet need to preclude interference among concurrent threads. The "snapshot" style iterator method uses a reference to the state of the array at the point that the iterator was created. This array never changes during the lifetime of the iterator, so interference is impossible and the iterator is guaranteed not to throw ConcurrentModificationException. The iterator will not reflect additions, removals, or changes to the list since the iterator was created. Element-changing operations on iterators themselves (remove, set, and add) are not supported. These methods throw UnsupportedOperationException. All elements are permitted, including null. Memory consistency effects: As with other concurrent collections, actions in a thread prior to placing an object into a CopyOnWriteArrayList happen-before actions subsequent to the access or removal of that element from the CopyOnWriteArrayList in another thread. This class is a member of the  Java Collections Framework.
java.util.concurrent.CopyOnWriteArrayList.COWIterator.add	(	E	): Not supported. Always throws UnsupportedOperationException.
java.util.concurrent.CopyOnWriteArrayList.COWIterator.remove	(	): Not supported. Always throws UnsupportedOperationException.
java.util.concurrent.CopyOnWriteArrayList.COWIterator.set	(	E	): Not supported. Always throws UnsupportedOperationException.
java.util.concurrent.CopyOnWriteArrayList.COWSubList: Sublist for CopyOnWriteArrayList. This class extends AbstractList merely for convenience, to avoid having to define addAll, etc. This doesn't hurt, but is wasteful. This class does not need or use modCount mechanics in AbstractList, but does need to check for concurrent modification using similar mechanics. On each operation, the array that we expect the backing list to use is checked and updated. Since we do this for all of the base operations invoked by those defined in AbstractList, all is well. While inefficient, this is not worth improving. The kinds of list operations inherited from AbstractList are already so slow on COW sublists that adding a bit more space/time doesn't seem even noticeable.
java.util.concurrent.CopyOnWriteArrayList.CopyOnWriteArrayList	(	): Creates an empty list.
java.util.concurrent.CopyOnWriteArrayList.CopyOnWriteArrayList	(	Collection	): Creates a list containing the elements of the specified collection, in the order they are returned by the collection's iterator.
java.util.concurrent.CopyOnWriteArrayList.CopyOnWriteArrayList	(	E[]	): Creates a list holding a copy of the given array.
java.util.concurrent.CopyOnWriteArrayList.add	(	E	): Appends the specified element to the end of this list.
java.util.concurrent.CopyOnWriteArrayList.add	(	int	E	): Inserts the specified element at the specified position in this list. Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices).
java.util.concurrent.CopyOnWriteArrayList.addAll	(	Collection	): Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's iterator.
java.util.concurrent.CopyOnWriteArrayList.addAll	(	int	Collection	): Inserts all of the elements in the specified collection into this list, starting at the specified position. Shifts the element currently at that position (if any) and any subsequent elements to the right (increases their indices). The new elements will appear in this list in the order that they are returned by the specified collection's iterator.
java.util.concurrent.CopyOnWriteArrayList.addAllAbsent	(	Collection	): Appends all of the elements in the specified collection that are not already contained in this list, to the end of this list, in the order that they are returned by the specified collection's iterator.
java.util.concurrent.CopyOnWriteArrayList.addIfAbsent	(	E	): Appends the element, if not present.
java.util.concurrent.CopyOnWriteArrayList.addIfAbsent	(	E	Object[]	): A version of addIfAbsent using the strong hint that given recent snapshot does not contain e.
java.util.concurrent.CopyOnWriteArrayList.clear	(	): Removes all of the elements from this list. The list will be empty after this call returns.
java.util.concurrent.CopyOnWriteArrayList.clone	(	): Returns a shallow copy of this list. (The elements themselves are not copied.)
java.util.concurrent.CopyOnWriteArrayList.contains	(	Object	): Returns true if this list contains the specified element. More formally, returns true if and only if this list contains at least one element e such that (o==null ? e==null : o.equals(e)).
java.util.concurrent.CopyOnWriteArrayList.containsAll	(	Collection	): Returns true if this list contains all of the elements of the specified collection.
java.util.concurrent.CopyOnWriteArrayList.eq	(	Object	Object	): Tests for equality, coping with nulls.
java.util.concurrent.CopyOnWriteArrayList.equals	(	Object	): Compares the specified object with this list for equality. Returns true if the specified object is the same object as this object, or if it is also a List and the sequence of elements returned by an iterator() over the specified list is the same as the sequence returned by an iterator over this list. The two sequences are considered to be the same if they have the same length and corresponding elements at the same position in the sequence are equal. Two elements e1 and e2 are considered equal if (e1==null ? e2==null : e1.equals(e2)).
java.util.concurrent.CopyOnWriteArrayList.get	(	int	): Returns the element at the specified position in this list.
java.util.concurrent.CopyOnWriteArrayList.getArray	(	): Gets the array. Non-private so as to also be accessible from CopyOnWriteArraySet class.
java.util.concurrent.CopyOnWriteArrayList.hashCode	(	): Returns the hash code value for this list. This implementation uses the definition in hashCode.
java.util.concurrent.CopyOnWriteArrayList.indexOf	(	E	int	): Returns the index of the first occurrence of the specified element in this list, searching forwards from index, or returns -1 if the element is not found. More formally, returns the lowest index i such that (i >= index && (e==null ? get(i)==null : e.equals(get(i)))), or -1 if there is no such index.
java.util.concurrent.CopyOnWriteArrayList.indexOf	(	Object	): Returns the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.
java.util.concurrent.CopyOnWriteArrayList.indexOf	(	Object	Object[]	int	int	): static version of indexOf, to allow repeated calls without needing to re-acquire array each time.
java.util.concurrent.CopyOnWriteArrayList.isEmpty	(	): Returns true if this list contains no elements.
java.util.concurrent.CopyOnWriteArrayList.iterator	(	): Returns an iterator over the elements in this list in proper sequence. The returned iterator provides a snapshot of the state of the list when the iterator was constructed. No synchronization is needed while traversing the iterator. The iterator does NOT support the remove method.
java.util.concurrent.CopyOnWriteArrayList.lastIndexOf	(	E	int	): Returns the index of the last occurrence of the specified element in this list, searching backwards from index, or returns -1 if the element is not found. More formally, returns the highest index i such that (i <= index && (e==null ? get(i)==null : e.equals(get(i)))), or -1 if there is no such index.
java.util.concurrent.CopyOnWriteArrayList.lastIndexOf	(	Object	): Returns the index of the last occurrence of the specified element in this list, or -1 if this list does not contain the element. More formally, returns the highest index i such that (o==null ? get(i)==null : o.equals(get(i))), or -1 if there is no such index.
java.util.concurrent.CopyOnWriteArrayList.lastIndexOf	(	Object	Object[]	int	): static version of lastIndexOf.
java.util.concurrent.CopyOnWriteArrayList.listIterator	(	): Returns a list iterator over the elements in this list (in proper sequence). The returned iterator provides a snapshot of the state of the list when the iterator was constructed. No synchronization is needed while traversing the iterator. The iterator does NOT support the remove, set or add methods.
java.util.concurrent.CopyOnWriteArrayList.listIterator	(	int	): Returns a list iterator over the elements in this list (in proper sequence), starting at the specified position in the list. The specified index indicates the first element that would be returned by an initial call to next. An initial call to previous would return the element with the specified index minus one. The returned iterator provides a snapshot of the state of the list when the iterator was constructed. No synchronization is needed while traversing the iterator. The iterator does NOT support the remove, set or add methods.
java.util.concurrent.CopyOnWriteArrayList.readObject	(	java.io.ObjectInputStream	): Reconstitutes this list from a stream (that is, deserializes it).
java.util.concurrent.CopyOnWriteArrayList.remove	(	Object	): Removes the first occurrence of the specified element from this list, if it is present. If this list does not contain the element, it is unchanged. More formally, removes the element with the lowest index i such that (o==null ? get(i)==null : o.equals(get(i))) (if such an element exists). Returns true if this list contained the specified element (or equivalently, if this list changed as a result of the call).
java.util.concurrent.CopyOnWriteArrayList.remove	(	Object	Object[]	int	): A version of remove(Object) using the strong hint that given recent snapshot contains o at the given index.
java.util.concurrent.CopyOnWriteArrayList.remove	(	int	): Removes the element at the specified position in this list. Shifts any subsequent elements to the left (subtracts one from their indices). Returns the element that was removed from the list.
java.util.concurrent.CopyOnWriteArrayList.removeAll	(	Collection	): Removes from this list all of its elements that are contained in the specified collection. This is a particularly expensive operation in this class because of the need for an internal temporary array.
java.util.concurrent.CopyOnWriteArrayList.removeRange	(	int	int	): Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive. Shifts any succeeding elements to the left (reduces their index). This call shortens the list by (toIndex - fromIndex) elements. (If toIndex==fromIndex, this operation has no effect.)
java.util.concurrent.CopyOnWriteArrayList.retainAll	(	Collection	): Retains only the elements in this list that are contained in the specified collection. In other words, removes from this list all of its elements that are not contained in the specified collection.
java.util.concurrent.CopyOnWriteArrayList.set	(	int	E	): Replaces the element at the specified position in this list with the specified element.
java.util.concurrent.CopyOnWriteArrayList.setArray	(	Object[]	): Sets the array.
java.util.concurrent.CopyOnWriteArrayList.size	(	): Returns the number of elements in this list.
java.util.concurrent.CopyOnWriteArrayList.spliterator	(	): Returns a Spliterator over the elements in this list. The Spliterator reports IMMUTABLE, ORDERED, SIZED, and SUBSIZED. The spliterator provides a snapshot of the state of the list when the spliterator was constructed. No synchronization is needed while operating on the spliterator.
java.util.concurrent.CopyOnWriteArrayList.subList	(	int	int	): Returns a view of the portion of this list between fromIndex, inclusive, and toIndex, exclusive. The returned list is backed by this list, so changes in the returned list are reflected in this list. The semantics of the list returned by this method become undefined if the backing list (i.e., this list) is modified in any way other than via the returned list.
java.util.concurrent.CopyOnWriteArrayList.toArray	(	): Returns an array containing all of the elements in this list in proper sequence (from first to last element). The returned array will be "safe" in that no references to it are maintained by this list. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.concurrent.CopyOnWriteArrayList.toArray	(	T	): Returns an array containing all of the elements in this list in proper sequence (from first to last element); the runtime type of the returned array is that of the specified array. If the list fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this list. If this list fits in the specified array with room to spare (i.e., the array has more elements than this list), the element in the array immediately following the end of the list is set to null. (This is useful in determining the length of this list only if the caller knows that this list does not contain any null elements.) Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a list known to contain only strings. The following code can be used to dump the list into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.concurrent.CopyOnWriteArrayList.toString	(	): Returns a string representation of this list. The string representation consists of the string representations of the list's elements in the order they are returned by its iterator, enclosed in square brackets ("[]"). Adjacent elements are separated by the characters ", " (comma and space). Elements are converted to strings as by valueOf().
java.util.concurrent.CopyOnWriteArrayList.writeObject	(	java.io.ObjectOutputStream	): Saves this list to a stream (that is, serializes it).
java.util.concurrent.CopyOnWriteArraySet: A java.util.Set that uses an internal CopyOnWriteArrayList for all of its operations. Thus, it shares the same basic properties:  It is best suited for applications in which set sizes generally stay small, read-only operations vastly outnumber mutative operations, and you need to prevent interference among threads during traversal. It is thread-safe. Mutative operations (add, set, remove, etc.) are expensive since they usually entail copying the entire underlying array. Iterators do not support the mutative remove operation. Traversal via iterators is fast and cannot encounter interference from other threads. Iterators rely on unchanging snapshots of the array at the time the iterators were constructed.  Sample Usage. The following code sketch uses a copy-on-write set to maintain a set of Handler objects that perform some action upon state updates.  class Handler { void handle(); ... } class X { private final CopyOnWriteArraySet handlers = new CopyOnWriteArraySet(); public void addHandler(Handler h) { handlers.add(h); } private long internalState; private synchronized void changeState() { internalState = ...; } public void update() { changeState(); for (Handler handler : handlers) handler.handle(); } }} This class is a member of the  Java Collections Framework.
java.util.concurrent.CopyOnWriteArraySet.CopyOnWriteArraySet	(	): Creates an empty set.
java.util.concurrent.CopyOnWriteArraySet.CopyOnWriteArraySet	(	Collection	): Creates a set containing all of the elements of the specified collection.
java.util.concurrent.CopyOnWriteArraySet.add	(	E	): Adds the specified element to this set if it is not already present. More formally, adds the specified element e to this set if the set contains no element e2 such that (e==null ? e2==null : e.equals(e2)). If this set already contains the element, the call leaves the set unchanged and returns false.
java.util.concurrent.CopyOnWriteArraySet.addAll	(	Collection	): Adds all of the elements in the specified collection to this set if they're not already present. If the specified collection is also a set, the addAll operation effectively modifies this set so that its value is the union of the two sets. The behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.CopyOnWriteArraySet.clear	(	): Removes all of the elements from this set. The set will be empty after this call returns.
java.util.concurrent.CopyOnWriteArraySet.contains	(	Object	): Returns true if this set contains the specified element. More formally, returns true if and only if this set contains an element e such that (o==null ? e==null : o.equals(e)).
java.util.concurrent.CopyOnWriteArraySet.containsAll	(	Collection	): Returns true if this set contains all of the elements of the specified collection. If the specified collection is also a set, this method returns true if it is a subset of this set.
java.util.concurrent.CopyOnWriteArraySet.eq	(	Object	Object	): Tests for equality, coping with nulls.
java.util.concurrent.CopyOnWriteArraySet.equals	(	Object	): Compares the specified object with this set for equality. Returns true if the specified object is the same object as this object, or if it is also a Set and the elements returned by an iterator() over the specified set are the same as the elements returned by an iterator over this set. More formally, the two iterators are considered to return the same elements if they return the same number of elements and for every element e1 returned by the iterator over the specified set, there is an element e2 returned by the iterator over this set such that (e1==null ? e2==null : e1.equals(e2)).
java.util.concurrent.CopyOnWriteArraySet.isEmpty	(	): Returns true if this set contains no elements.
java.util.concurrent.CopyOnWriteArraySet.iterator	(	): Returns an iterator over the elements contained in this set in the order in which these elements were added. The returned iterator provides a snapshot of the state of the set when the iterator was constructed. No synchronization is needed while traversing the iterator. The iterator does NOT support the remove method.
java.util.concurrent.CopyOnWriteArraySet.remove	(	Object	): Removes the specified element from this set if it is present. More formally, removes an element e such that (o==null ? e==null : o.equals(e)), if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)
java.util.concurrent.CopyOnWriteArraySet.removeAll	(	Collection	): Removes from this set all of its elements that are contained in the specified collection. If the specified collection is also a set, this operation effectively modifies this set so that its value is the asymmetric set difference of the two sets.
java.util.concurrent.CopyOnWriteArraySet.retainAll	(	Collection	): Retains only the elements in this set that are contained in the specified collection. In other words, removes from this set all of its elements that are not contained in the specified collection. If the specified collection is also a set, this operation effectively modifies this set so that its value is the intersection of the two sets.
java.util.concurrent.CopyOnWriteArraySet.size	(	): Returns the number of elements in this set.
java.util.concurrent.CopyOnWriteArraySet.spliterator	(	): Returns a Spliterator over the elements in this set in the order in which these elements were added. The Spliterator reports IMMUTABLE, DISTINCT, SIZED, and SUBSIZED. The spliterator provides a snapshot of the state of the set when the spliterator was constructed. No synchronization is needed while operating on the spliterator.
java.util.concurrent.CopyOnWriteArraySet.toArray	(	): Returns an array containing all of the elements in this set. If this set makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. The returned array will be "safe" in that no references to it are maintained by this set. (In other words, this method must allocate a new array even if this set is backed by an array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.concurrent.CopyOnWriteArraySet.toArray	(	T[]	): Returns an array containing all of the elements in this set; the runtime type of the returned array is that of the specified array. If the set fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this set. If this set fits in the specified array with room to spare (i.e., the array has more elements than this set), the element in the array immediately following the end of the set is set to null. (This is useful in determining the length of this set only if the caller knows that this set does not contain any null elements.) If this set makes any guarantees as to what order its elements are returned by its iterator, this method must return the elements in the same order. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a set known to contain only strings. The following code can be used to dump the set into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.concurrent.CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes. A CountDownLatch is initialized with a given count. The await methods block until the current count reaches zero due to invocations of the countDown method, after which all waiting threads are released and any subsequent invocations of await return immediately. This is a one-shot phenomenon -- the count cannot be reset. If you need a version that resets the count, consider using a CyclicBarrier. A CountDownLatch is a versatile synchronization tool and can be used for a number of purposes. A CountDownLatch initialized with a count of one serves as a simple on/off latch, or gate: all threads invoking await wait at the gate until it is opened by a thread invoking countDown. A CountDownLatch initialized to N can be used to make one thread wait until N threads have completed some action, or some action has been completed N times. A useful property of a CountDownLatch is that it doesn't require that threads calling countDown wait for the count to reach zero before proceeding, it simply prevents any thread from proceeding past an await until all threads could pass. Sample usage: Here is a pair of classes in which a group of worker threads use two countdown latches:  The first is a start signal that prevents any worker from proceeding until the driver is ready for them to proceed; The second is a completion signal that allows the driver to wait until all workers have completed.   class Driver { // ... void main() throws InterruptedException { CountDownLatch startSignal = new CountDownLatch(1); CountDownLatch doneSignal = new CountDownLatch(N); for (int i = 0; i < N; ++i) // create and start threads new Thread(new Worker(startSignal, doneSignal)).start(); doSomethingElse(); // don't let run yet startSignal.countDown(); // let all threads proceed doSomethingElse(); doneSignal.await(); // wait for all to finish } } class Worker implements Runnable { private final CountDownLatch startSignal; private final CountDownLatch doneSignal; Worker(CountDownLatch startSignal, CountDownLatch doneSignal) { this.startSignal = startSignal; this.doneSignal = doneSignal; } public void run() { try { startSignal.await(); doWork(); doneSignal.countDown(); } catch (InterruptedException ex) {} // return; } void doWork() { ... } }} Another typical usage would be to divide a problem into N parts, describe each part with a Runnable that executes that portion and counts down on the latch, and queue all the Runnables to an Executor. When all sub-parts are complete, the coordinating thread will be able to pass through await. (When threads must repeatedly count down in this way, instead use a CyclicBarrier.)  class Driver2 { // ... void main() throws InterruptedException { CountDownLatch doneSignal = new CountDownLatch(N); Executor e = ... for (int i = 0; i < N; ++i) // create and start threads e.execute(new WorkerRunnable(doneSignal, i)); doneSignal.await(); // wait for all to finish } } class WorkerRunnable implements Runnable { private final CountDownLatch doneSignal; private final int i; WorkerRunnable(CountDownLatch doneSignal, int i) { this.doneSignal = doneSignal; this.i = i; } public void run() { try { doWork(i); doneSignal.countDown(); } catch (InterruptedException ex) {} // return; } void doWork() { ... } }} Memory consistency effects: Until the count reaches zero, actions in a thread prior to calling countDown() happen-before actions following a successful return from a corresponding await() in another thread.
java.util.concurrent.CountDownLatch.CountDownLatch	(	int	): Constructs a CountDownLatch initialized with the given count.
java.util.concurrent.CountDownLatch.Sync: Synchronization control For CountDownLatch. Uses AQS state to represent count.
java.util.concurrent.CountDownLatch.await	(	): Causes the current thread to wait until the latch has counted down to zero, unless the thread is interrupt interrupted. If the current count is zero then this method returns immediately. If the current count is greater than zero then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happen:  The count reaches zero due to invocations of the countDown method; or Some other thread interrupt interrupts the current thread.  If the current thread:  has its interrupted status set on entry to this method; or is interrupt interrupted while waiting,  then InterruptedException is thrown and the current thread's interrupted status is cleared.
java.util.concurrent.CountDownLatch.await	(	long	TimeUnit	): Causes the current thread to wait until the latch has counted down to zero, unless the thread is interrupt interrupted, or the specified waiting time elapses. If the current count is zero then this method returns immediately with the value true. If the current count is greater than zero then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happen:  The count reaches zero due to invocations of the countDown method; or Some other thread interrupt interrupts the current thread; or The specified waiting time elapses.  If the count reaches zero then the method returns with the value true. If the current thread:  has its interrupted status set on entry to this method; or is interrupt interrupted while waiting,  then InterruptedException is thrown and the current thread's interrupted status is cleared. If the specified waiting time elapses then the value false is returned. If the time is less than or equal to zero, the method will not wait at all.
java.util.concurrent.CountDownLatch.countDown	(	): Decrements the count of the latch, releasing all waiting threads if the count reaches zero. If the current count is greater than zero then it is decremented. If the new count is zero then all waiting threads are re-enabled for thread scheduling purposes. If the current count equals zero then nothing happens.
java.util.concurrent.CountDownLatch.getCount	(	): Returns the current count. This method is typically used for debugging and testing purposes.
java.util.concurrent.CountDownLatch.toString	(	): Returns a string identifying this latch, as well as its state. The state, in brackets, includes the String "Count =" followed by the current count.
java.util.concurrent.CountedCompleter: A ForkJoinTask with a completion action performed when triggered and there are no remaining pending actions. CountedCompleters are in general more robust in the presence of subtask stalls and blockage than are other forms of ForkJoinTasks, but are less intuitive to program. Uses of CountedCompleter are similar to those of other completion based components (such as java.nio.channels.CompletionHandler) except that multiple pending completions may be necessary to trigger the completion action onCompletion(), not just one. Unless initialized otherwise, the getPendingCount pending count starts at zero, but may be (atomically) changed using methods setPendingCount, addToPendingCount, and compareAndSetPendingCount. Upon invocation of tryComplete, if the pending action count is nonzero, it is decremented; otherwise, the completion action is performed, and if this completer itself has a completer, the process is continued with its completer. As is the case with related synchronization components such as java.util.concurrent.Phaser Phaser and java.util.concurrent.Semaphore Semaphore, these methods affect only internal counts; they do not establish any further internal bookkeeping. In particular, the identities of pending tasks are not maintained. As illustrated below, you can create subclasses that do record some or all pending tasks or their results when needed. As illustrated below, utility methods supporting customization of completion traversals are also provided. However, because CountedCompleters provide only basic synchronization mechanisms, it may be useful to create further abstract subclasses that maintain linkages, fields, and additional support methods appropriate for a set of related usages. A concrete CountedCompleter class must define method compute, that should in most cases (as illustrated below), invoke tryComplete() once before returning. The class may also optionally override method onCompletion() to perform an action upon normal completion, and method onExceptionalCompletion() to perform an action upon any exception. CountedCompleters most often do not bear results, in which case they are normally declared as CountedCompleter, and will always return null as a result value. In other cases, you should override method getRawResult to provide a result from join(), invoke(), and related methods. In general, this method should return the value of a field (or a function of one or more fields) of the CountedCompleter object that holds the result upon completion. Method setRawResult by default plays no role in CountedCompleters. It is possible, but rarely applicable, to override this method to maintain other objects or fields holding result data. A CountedCompleter that does not itself have a completer (i.e., one for which getCompleter returns null) can be used as a regular ForkJoinTask with this added functionality. However, any completer that in turn has another completer serves only as an internal helper for other computations, so its own task status (as reported in methods such as isDone) is arbitrary; this status changes only upon explicit invocations of complete, cancel, completeExceptionally() or upon exceptional completion of method compute. Upon any exceptional completion, the exception may be relayed to a task's completer (and its completer, and so on), if one exists and it has not otherwise already completed. Similarly, cancelling an internal CountedCompleter has only a local effect on that completer, so is not often useful. Sample Usages. Parallel recursive decomposition. CountedCompleters may be arranged in trees similar to those often used with RecursiveActions, although the constructions involved in setting them up typically vary. Here, the completer of each task is its parent in the computation tree. Even though they entail a bit more bookkeeping, CountedCompleters may be better choices when applying a possibly time-consuming operation (that cannot be further subdivided) to each element of an array or collection; especially when the operation takes a significantly different amount of time to complete for some elements than others, either because of intrinsic variation (for example I/O) or auxiliary effects such as garbage collection. Because CountedCompleters provide their own continuations, other threads need not block waiting to perform them. For example, here is an initial version of a class that uses divide-by-two recursive decomposition to divide work into single pieces (leaf tasks). Even when work is split into individual calls, tree-based techniques are usually preferable to directly forking leaf tasks, because they reduce inter-thread communication and improve load balancing. In the recursive case, the second of each pair of subtasks to finish triggers completion of its parent (because no result combination is performed, the default no-op implementation of method onCompletion is not overridden). A static utility method sets up the base task and invokes it (here, implicitly using the commonPool()).  class MyOperation { void apply(E e) { ... } } class ForEach extends CountedCompleter { public static  void forEach(E[] array, MyOperation op) { new ForEach(null, array, op, 0, array.length).invoke(); } final E[] array; final MyOperation op; final int lo, hi; ForEach(CountedCompleter p, E[] array, MyOperation op, int lo, int hi) { super(p); this.array = array; this.op = op; this.lo = lo; this.hi = hi; } public void compute() { // version 1 if (hi - lo >= 2) { int mid = (lo + hi) >>> 1; setPendingCount(2); // must set pending count before fork new ForEach(this, array, op, mid, hi).fork(); // right child new ForEach(this, array, op, lo, mid).fork(); // left child } else if (hi > lo) op.apply(array[lo]); tryComplete(); } }} This design can be improved by noticing that in the recursive case, the task has nothing to do after forking its right task, so can directly invoke its left task before returning. (This is an analog of tail recursion removal.) Also, because the task returns upon executing its left task (rather than falling through to invoke tryComplete) the pending count is set to one:  class ForEach ... public void compute() // version 2 if (hi - lo >= 2) { int mid = (lo + hi) >>> 1; setPendingCount(1); // only one pending new ForEach(this, array, op, mid, hi).fork(); // right child new ForEach(this, array, op, lo, mid).compute(); // direct invoke } else { if (hi > lo) op.apply(array[lo]); tryComplete(); } } } As a further improvement, notice that the left task need not even exist. Instead of creating a new one, we can iterate using the original task, and add a pending count for each fork. Additionally, because no task in this tree implements an onCompletion() method, tryComplete() can be replaced with propagateCompletion.  class ForEach ... public void compute() // version 3 int l = lo, h = hi; while (h - l >= 2) { int mid = (l + h) >>> 1; addToPendingCount(1); new ForEach(this, array, op, mid, h).fork(); // right child h = mid; } if (h > l) op.apply(array[l]); propagateCompletion(); } } Additional improvements of such classes might entail precomputing pending counts so that they can be established in constructors, specializing classes for leaf steps, subdividing by say, four, instead of two per iteration, and using an adaptive threshold instead of always subdividing down to single elements. Searching. A tree of CountedCompleters can search for a value or property in different parts of a data structure, and report a result in an java.util.concurrent.atomic.AtomicReference AtomicReference as soon as one is found. The others can poll the result to avoid unnecessary work. (You could additionally cancel other tasks, but it is usually simpler and more efficient to just let them notice that the result is set and if so skip further processing.) Illustrating again with an array using full partitioning (again, in practice, leaf tasks will almost always process more than one element):  class Searcher extends CountedCompleter final E[] array; final AtomicReference result; final int lo, hi; Searcher(CountedCompleter p, E[] array, AtomicReference result, int lo, int hi) { super(p); this.array = array; this.result = result; this.lo = lo; this.hi = hi; } public E getRawResult() { return result.get(); } public void compute() { // similar to ForEach version 3 int l = lo, h = hi; while (result.get() == null && h >= l) { if (h - l >= 2) { int mid = (l + h) >>> 1; addToPendingCount(1); new Searcher(this, array, result, mid, h).fork(); h = mid; } else { E x = array[l]; if (matches(x) && result.compareAndSet(null, x)) quietlyCompleteRoot(); // root task is now joinable break; } } tryComplete(); // normally complete whether or not found } boolean matches(E e) { ... } // return true if found public static  E search(E[] array) { return new Searcher(null, array, new AtomicReference(), 0, array.length).invoke(); } }} In this example, as well as others in which tasks have no other effects except to compareAndSet a common result, the trailing unconditional invocation of tryComplete could be made conditional (if (result.get() == null) tryComplete();) because no further bookkeeping is required to manage completions once the root task completes. Recording subtasks. CountedCompleter tasks that combine results of multiple subtasks usually need to access these results in method onCompletion(). As illustrated in the following class (that performs a simplified form of map-reduce where mappings and reductions are all of type E), one way to do this in divide and conquer designs is to have each subtask record its sibling, so that it can be accessed in method onCompletion. This technique applies to reductions in which the order of combining left and right results does not matter; ordered reductions require explicit left/right designations. Variants of other streamlinings seen in the above examples may also apply.  class MyMapper { E apply(E v) { ... } } class MyReducer { E apply(E x, E y) { ... } } class MapReducer extends CountedCompleter { final E[] array; final MyMapper mapper; final MyReducer reducer; final int lo, hi; MapReducer sibling; E result; MapReducer(CountedCompleter p, E[] array, MyMapper mapper, MyReducer reducer, int lo, int hi) { super(p); this.array = array; this.mapper = mapper; this.reducer = reducer; this.lo = lo; this.hi = hi; } public void compute() { if (hi - lo >= 2) { int mid = (lo + hi) >>> 1; MapReducer left = new MapReducer(this, array, mapper, reducer, lo, mid); MapReducer right = new MapReducer(this, array, mapper, reducer, mid, hi); left.sibling = right; right.sibling = left; setPendingCount(1); // only right is pending right.fork(); left.compute(); // directly execute left } else { if (hi > lo) result = mapper.apply(array[lo]); tryComplete(); } } public void onCompletion(CountedCompleter caller) { if (caller != this) { MapReducer child = (MapReducer)caller; MapReducer sib = child.sibling; if (sib == null || sib.result == null) result = child.result; else result = reducer.apply(child.result, sib.result); } } public E getRawResult() { return result; } public static  E mapReduce(E[] array, MyMapper mapper, MyReducer reducer) { return new MapReducer(null, array, mapper, reducer, 0, array.length).invoke(); } }} Here, method onCompletion takes a form common to many completion designs that combine results. This callback-style method is triggered once per task, in either of the two different contexts in which the pending count is, or becomes, zero: (1) by a task itself, if its pending count is zero upon invocation of tryComplete, or (2) by any of its subtasks when they complete and decrement the pending count to zero. The caller argument distinguishes cases. Most often, when the caller is this, no action is necessary. Otherwise the caller argument can be used (usually via a cast) to supply a value (and/or links to other values) to be combined. Assuming proper use of pending counts, the actions inside onCompletion occur (once) upon completion of a task and its subtasks. No additional synchronization is required within this method to ensure thread safety of accesses to fields of this task or other completed tasks. Completion Traversals. If using onCompletion to process completions is inapplicable or inconvenient, you can use methods firstComplete and nextComplete to create custom traversals. For example, to define a MapReducer that only splits out right-hand tasks in the form of the third ForEach example, the completions must cooperatively reduce along unexhausted subtask links, which can be done as follows:  class MapReducer extends CountedCompleter { // version 2 final E[] array; final MyMapper mapper; final MyReducer reducer; final int lo, hi; MapReducer forks, next; // record subtask forks in list E result; MapReducer(CountedCompleter p, E[] array, MyMapper mapper, MyReducer reducer, int lo, int hi, MapReducer next) { super(p); this.array = array; this.mapper = mapper; this.reducer = reducer; this.lo = lo; this.hi = hi; this.next = next; } public void compute() { int l = lo, h = hi; while (h - l >= 2) { int mid = (l + h) >>> 1; addToPendingCount(1); (forks = new MapReducer(this, array, mapper, reducer, mid, h, forks)).fork(); h = mid; } if (h > l) result = mapper.apply(array[l]); // process completions by reducing along and advancing subtask links for (CountedCompleter c = firstComplete(); c != null; c = c.nextComplete()) { for (MapReducer t = (MapReducer)c, s = t.forks; s != null; s = t.forks = s.next) t.result = reducer.apply(t.result, s.result); } } public E getRawResult() { return result; } public static  E mapReduce(E[] array, MyMapper mapper, MyReducer reducer) { return new MapReducer(null, array, mapper, reducer, 0, array.length, null).invoke(); } }} Triggers. Some CountedCompleters are themselves never forked, but instead serve as bits of plumbing in other designs; including those in which the completion of one or more async tasks triggers another async task. For example:  class HeaderBuilder extends CountedCompleter<...> { ... } class BodyBuilder extends CountedCompleter<...> { ... } class PacketSender extends CountedCompleter<...> { PacketSender(...) { super(null, 1); ... } // trigger on second completion public void compute() { } // never called public void onCompletion(CountedCompleter caller) { sendPacket(); } } // sample use: PacketSender p = new PacketSender(); new HeaderBuilder(p, ...).fork(); new BodyBuilder(p, ...).fork(); }
java.util.concurrent.CountedCompleter.CountedCompleter	(	): Creates a new CountedCompleter with no completer and an initial pending count of zero.
java.util.concurrent.CountedCompleter.CountedCompleter	(	CountedCompleter	): Creates a new CountedCompleter with the given completer and an initial pending count of zero.
java.util.concurrent.CountedCompleter.CountedCompleter	(	CountedCompleter	int	): Creates a new CountedCompleter with the given completer and initial pending count.
java.util.concurrent.CountedCompleter.addToPendingCount	(	int	): Adds (atomically) the given value to the pending count.
java.util.concurrent.CountedCompleter.compareAndSetPendingCount	(	int	int	): Sets (atomically) the pending count to the given count only if it currently holds the given expected value.
java.util.concurrent.CountedCompleter.complete	(	T	): Regardless of pending count, invokes onCompletion(), marks this task as complete and further triggers tryComplete on this task's completer, if one exists. The given rawResult is used as an argument to setRawResult before invoking onCompletion() or marking this task as complete; its value is meaningful only for classes overriding setRawResult. This method does not modify the pending count. This method may be useful when forcing completion as soon as any one (versus all) of several subtask results are obtained. However, in the common (and recommended) case in which setRawResult is not overridden, this effect can be obtained more simply using quietlyCompleteRoot();.
java.util.concurrent.CountedCompleter.compute	(	): The main computation performed by this task.
java.util.concurrent.CountedCompleter.decrementPendingCountUnlessZero	(	): If the pending count is nonzero, (atomically) decrements it.
java.util.concurrent.CountedCompleter.exec	(	): Implements execution conventions for CountedCompleters.
java.util.concurrent.CountedCompleter.firstComplete	(	): If this task's pending count is zero, returns this task; otherwise decrements its pending count and returns null. This method is designed to be used with nextComplete in completion traversal loops.
java.util.concurrent.CountedCompleter.getCompleter	(	): Returns the completer established in this task's constructor, or null if none.
java.util.concurrent.CountedCompleter.getPendingCount	(	): Returns the current pending count.
java.util.concurrent.CountedCompleter.getRawResult	(	): Returns the result of the computation. By default returns null, which is appropriate for Void actions, but in other cases should be overridden, almost always to return a field or function of a field that holds the result upon completion.
java.util.concurrent.CountedCompleter.getRoot	(	): Returns the root of the current computation; i.e., this task if it has no completer, else its completer's root.
java.util.concurrent.CountedCompleter.helpComplete	(	int	): If this task has not completed, attempts to process at most the given number of other unprocessed tasks for which this task is on the completion path, if any are known to exist.
java.util.concurrent.CountedCompleter.internalPropagateException	(	Throwable	): Supports ForkJoinTask exception propagation.
java.util.concurrent.CountedCompleter.nextComplete	(	): If this task does not have a completer, invokes quietlyComplete and returns null. Or, if the completer's pending count is non-zero, decrements that pending count and returns null. Otherwise, returns the completer. This method can be used as part of a completion traversal loop for homogeneous task hierarchies:  for (CountedCompleter c = firstComplete(); c != null; c = c.nextComplete()) // ... process c ... }}
java.util.concurrent.CountedCompleter.onCompletion	(	CountedCompleter	): Performs an action when method tryComplete is invoked and the pending count is zero, or when the unconditional method complete is invoked. By default, this method does nothing. You can distinguish cases by checking the identity of the given caller argument. If not equal to this, then it is typically a subtask that may contain results (and/or links to other results) to combine.
java.util.concurrent.CountedCompleter.onExceptionalCompletion	(	Throwable	CountedCompleter	): Performs an action when method completeExceptionally() is invoked or method compute throws an exception, and this task has not already otherwise completed normally. On entry to this method, this task isCompletedAbnormally. The return value of this method controls further propagation: If true and this task has a completer that has not completed, then that completer is also completed exceptionally, with the same exception as this completer. The default implementation of this method does nothing except return true.
java.util.concurrent.CountedCompleter.propagateCompletion	(	): Equivalent to tryComplete but does not invoke onCompletion() along the completion path: If the pending count is nonzero, decrements the count; otherwise, similarly tries to complete this task's completer, if one exists, else marks this task as complete. This method may be useful in cases where onCompletion should not, or need not, be invoked for each completer in a computation.
java.util.concurrent.CountedCompleter.quietlyCompleteRoot	(	): Equivalent to getRoot().quietlyComplete().
java.util.concurrent.CountedCompleter.setPendingCount	(	int	): Sets the pending count to the given value.
java.util.concurrent.CountedCompleter.setRawResult	(	T	): A method that result-bearing CountedCompleters may optionally use to help maintain result data. By default, does nothing. Overrides are not recommended. However, if this method is overridden to update existing objects or fields, then it must in general be defined to be thread-safe.
java.util.concurrent.CountedCompleter.tryComplete	(	): If the pending count is nonzero, decrements the count; otherwise invokes onCompletion() and then similarly tries to complete this task's completer, if one exists, else marks this task as complete.
java.util.concurrent.CyclicBarrier: A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point. CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other. The barrier is called cyclic because it can be re-used after the waiting threads are released. A CyclicBarrier supports an optional Runnable command that is run once per barrier point, after the last thread in the party arrives, but before any threads are released. This barrier action is useful for updating shared-state before any of the parties continue. Sample usage: Here is an example of using a barrier in a parallel decomposition design:  class Solver final int N; final float[][] data; final CyclicBarrier barrier; class Worker implements Runnable { int myRow; Worker(int row) { myRow = row; } public void run() { while (!done()) { processRow(myRow); try { barrier.await(); } catch (InterruptedException ex) { return; } catch (BrokenBarrierException ex) { return; } } } } public Solver(float[][] matrix) { data = matrix; N = matrix.length; Runnable barrierAction = new Runnable() { public void run() { mergeRows(...); }}; barrier = new CyclicBarrier(N, barrierAction); List threads = new ArrayList(N); for (int i = 0; i < N; i++) { Thread thread = new Thread(new Worker(i)); threads.add(thread); thread.start(); } // wait until done for (Thread thread : threads) thread.join(); } }} Here, each worker thread processes a row of the matrix then waits at the barrier until all rows have been processed. When all rows are processed the supplied Runnable barrier action is executed and merges the rows. If the merger determines that a solution has been found then done() will return true and each worker will terminate. If the barrier action does not rely on the parties being suspended when it is executed, then any of the threads in the party could execute that action when it is released. To facilitate this, each invocation of await returns the arrival index of that thread at the barrier. You can then choose which thread should execute the barrier action, for example:  if (barrier.await() == 0) // log the completion of this iteration }} The CyclicBarrier uses an all-or-none breakage model for failed synchronization attempts: If a thread leaves a barrier point prematurely because of interruption, failure, or timeout, all other threads waiting at that barrier point will also leave abnormally via BrokenBarrierException (or InterruptedException if they too were interrupted at about the same time). Memory consistency effects: Actions in a thread prior to calling await() happen-before actions that are part of the barrier action, which in turn happen-before actions following a successful return from the corresponding await() in other threads.
java.util.concurrent.CyclicBarrier.CyclicBarrier	(	int	): Creates a new CyclicBarrier that will trip when the given number of parties (threads) are waiting upon it, and does not perform a predefined action when the barrier is tripped.
java.util.concurrent.CyclicBarrier.CyclicBarrier	(	int	Runnable	): Creates a new CyclicBarrier that will trip when the given number of parties (threads) are waiting upon it, and which will execute the given barrier action when the barrier is tripped, performed by the last thread entering the barrier.
java.util.concurrent.CyclicBarrier.Generation: Each use of the barrier is represented as a generation instance. The generation changes whenever the barrier is tripped, or is reset. There can be many generations associated with threads using the barrier - due to the non-deterministic way the lock may be allocated to waiting threads - but only one of these can be active at a time (the one to which count applies) and all the rest are either broken or tripped. There need not be an active generation if there has been a break but no subsequent reset.
java.util.concurrent.CyclicBarrier.await	(	): Waits until all getParties parties have invoked await on this barrier. If the current thread is not the last to arrive then it is disabled for thread scheduling purposes and lies dormant until one of the following things happens:  The last thread arrives; or Some other thread interrupt interrupts the current thread; or Some other thread interrupt interrupts one of the other waiting threads; or Some other thread times out while waiting for barrier; or Some other thread invokes reset on this barrier.  If the current thread:  has its interrupted status set on entry to this method; or is interrupt interrupted while waiting  then InterruptedException is thrown and the current thread's interrupted status is cleared. If the barrier is reset while any thread is waiting, or if the barrier isBroken is broken when await is invoked, or while any thread is waiting, then BrokenBarrierException is thrown. If any thread is interrupt interrupted while waiting, then all other waiting threads will throw BrokenBarrierException and the barrier is placed in the broken state. If the current thread is the last thread to arrive, and a non-null barrier action was supplied in the constructor, then the current thread runs the action before allowing the other threads to continue. If an exception occurs during the barrier action then that exception will be propagated in the current thread and the barrier is placed in the broken state.
java.util.concurrent.CyclicBarrier.await	(	long	TimeUnit	): Waits until all getParties parties have invoked await on this barrier, or the specified waiting time elapses. If the current thread is not the last to arrive then it is disabled for thread scheduling purposes and lies dormant until one of the following things happens:  The last thread arrives; or The specified timeout elapses; or Some other thread interrupt interrupts the current thread; or Some other thread interrupt interrupts one of the other waiting threads; or Some other thread times out while waiting for barrier; or Some other thread invokes reset on this barrier.  If the current thread:  has its interrupted status set on entry to this method; or is interrupt interrupted while waiting  then InterruptedException is thrown and the current thread's interrupted status is cleared. If the specified waiting time elapses then TimeoutException is thrown. If the time is less than or equal to zero, the method will not wait at all. If the barrier is reset while any thread is waiting, or if the barrier isBroken is broken when await is invoked, or while any thread is waiting, then BrokenBarrierException is thrown. If any thread is interrupt interrupted while waiting, then all other waiting threads will throw BrokenBarrierException and the barrier is placed in the broken state. If the current thread is the last thread to arrive, and a non-null barrier action was supplied in the constructor, then the current thread runs the action before allowing the other threads to continue. If an exception occurs during the barrier action then that exception will be propagated in the current thread and the barrier is placed in the broken state.
java.util.concurrent.CyclicBarrier.breakBarrier	(	): Sets current barrier generation as broken and wakes up everyone. Called only while holding lock.
java.util.concurrent.CyclicBarrier.dowait	(	boolean	long	): Main barrier code, covering the various policies.
java.util.concurrent.CyclicBarrier.getNumberWaiting	(	): Returns the number of parties currently waiting at the barrier. This method is primarily useful for debugging and assertions.
java.util.concurrent.CyclicBarrier.getParties	(	): Returns the number of parties required to trip this barrier.
java.util.concurrent.CyclicBarrier.isBroken	(	): Queries if this barrier is in a broken state.
java.util.concurrent.CyclicBarrier.nextGeneration	(	): Updates state on barrier trip and wakes up everyone. Called only while holding lock.
java.util.concurrent.CyclicBarrier.reset	(	): Resets the barrier to its initial state. If any parties are currently waiting at the barrier, they will return with a BrokenBarrierException. Note that resets after a breakage has occurred for other reasons can be complicated to carry out; threads need to re-synchronize in some other way, and choose one to perform the reset. It may be preferable to instead create a new barrier for subsequent use.
java.util.concurrent.DelayQueue: An unbounded BlockingQueue blocking queue of Delayed elements, in which an element can only be taken when its delay has expired. The head of the queue is that Delayed element whose delay expired furthest in the past. If no delay has expired there is no head and poll will return null. Expiration occurs when an element's getDelay(TimeUnit.NANOSECONDS) method returns a value less than or equal to zero. Even though unexpired elements cannot be removed using take or poll, they are otherwise treated as normal elements. For example, the size method returns the count of both expired and unexpired elements. This queue does not permit null elements. This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces. The Iterator provided in method iterator() is not guaranteed to traverse the elements of the DelayQueue in any particular order. This class is a member of the  Java Collections Framework.
java.util.concurrent.DelayQueue.DelayQueue	(	): Creates a new DelayQueue that is initially empty.
java.util.concurrent.DelayQueue.DelayQueue	(	Collection	): Creates a DelayQueue initially containing the elements of the given collection of Delayed instances.
java.util.concurrent.DelayQueue.Itr: Snapshot iterator that works off copy of underlying q array.
java.util.concurrent.DelayQueue.add	(	E	): Inserts the specified element into this delay queue.
java.util.concurrent.DelayQueue.clear	(	): Atomically removes all of the elements from this delay queue. The queue will be empty after this call returns. Elements with an unexpired delay are not waited for; they are simply discarded from the queue.
java.util.concurrent.DelayQueue.drainTo	(	Collection	): Removes all available elements from this queue and adds them to the given collection. This operation may be more efficient than repeatedly polling this queue. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.DelayQueue.drainTo	(	Collection	int	): Removes at most the given number of available elements from this queue and adds them to the given collection. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.DelayQueue.iterator	(	): Returns an iterator over all the elements (both expired and unexpired) in this queue. The iterator does not return the elements in any particular order. The returned iterator is weakly consistent.
java.util.concurrent.DelayQueue.offer	(	E	): Inserts the specified element into this delay queue.
java.util.concurrent.DelayQueue.offer	(	E	long	TimeUnit	): Inserts the specified element into this delay queue. As the queue is unbounded this method will never block.
java.util.concurrent.DelayQueue.peek	(	): Retrieves, but does not remove, the head of this queue, or returns null if this queue is empty. Unlike poll, if no expired elements are available in the queue, this method returns the element that will expire next, if one exists.
java.util.concurrent.DelayQueue.peekExpired	(	): Returns first element only if it is expired. Used only by drainTo. Call only when holding lock.
java.util.concurrent.DelayQueue.poll	(	): Retrieves and removes the head of this queue, or returns null if this queue has no elements with an expired delay.
java.util.concurrent.DelayQueue.poll	(	long	TimeUnit	): Retrieves and removes the head of this queue, waiting if necessary until an element with an expired delay is available on this queue, or the specified wait time expires.
java.util.concurrent.DelayQueue.put	(	E	): Inserts the specified element into this delay queue. As the queue is unbounded this method will never block.
java.util.concurrent.DelayQueue.remainingCapacity	(	): Always returns Integer.MAX_VALUE because a DelayQueue is not capacity constrained.
java.util.concurrent.DelayQueue.remove	(	Object	): Removes a single instance of the specified element from this queue, if it is present, whether or not it has expired.
java.util.concurrent.DelayQueue.removeEQ	(	Object	): Identity-based version for use in Itr.remove
java.util.concurrent.DelayQueue.take	(	): Retrieves and removes the head of this queue, waiting if necessary until an element with an expired delay is available on this queue.
java.util.concurrent.DelayQueue.toArray	(	): Returns an array containing all of the elements in this queue. The returned array elements are in no particular order. The returned array will be "safe" in that no references to it are maintained by this queue. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.concurrent.DelayQueue.toArray	(	T[]	): Returns an array containing all of the elements in this queue; the runtime type of the returned array is that of the specified array. The returned array elements are in no particular order. If the queue fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this queue. If this queue fits in the specified array with room to spare (i.e., the array has more elements than this queue), the element in the array immediately following the end of the queue is set to null. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. The following code can be used to dump a delay queue into a newly allocated array of Delayed:  Delayed[] a = q.toArray(new Delayed[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.concurrent.Delayed: A mix-in style interface for marking objects that should be acted upon after a given delay. An implementation of this interface must define a compareTo method that provides an ordering consistent with its getDelay method.
java.util.concurrent.Delayed.getDelay	(	TimeUnit	): Returns the remaining delay associated with this object, in the given time unit.
java.util.concurrent.Exchanger: A synchronization point at which threads can pair and swap elements within pairs. Each thread presents some object on entry to the exchange method, matches with a partner thread, and receives its partner's object on return. An Exchanger may be viewed as a bidirectional form of a SynchronousQueue. Exchangers may be useful in applications such as genetic algorithms and pipeline designs. Sample Usage: Here are the highlights of a class that uses an Exchanger to swap buffers between threads so that the thread filling the buffer gets a freshly emptied one when it needs it, handing off the filled one to the thread emptying the buffer.  class FillAndEmpty Exchanger exchanger = new Exchanger(); DataBuffer initialEmptyBuffer = ... a made-up type DataBuffer initialFullBuffer = ... class FillingLoop implements Runnable { public void run() { DataBuffer currentBuffer = initialEmptyBuffer; try { while (currentBuffer != null) { addToBuffer(currentBuffer); if (currentBuffer.isFull()) currentBuffer = exchanger.exchange(currentBuffer); } } catch (InterruptedException ex) { ... handle ... } } } class EmptyingLoop implements Runnable { public void run() { DataBuffer currentBuffer = initialFullBuffer; try { while (currentBuffer != null) { takeFromBuffer(currentBuffer); if (currentBuffer.isEmpty()) currentBuffer = exchanger.exchange(currentBuffer); } } catch (InterruptedException ex) { ... handle ...} } } void start() { new Thread(new FillingLoop()).start(); new Thread(new EmptyingLoop()).start(); } }} Memory consistency effects: For each pair of threads that successfully exchange objects via an Exchanger, actions prior to the exchange() in each thread happen-before those subsequent to a return from the corresponding exchange() in the other thread.
java.util.concurrent.Exchanger.Exchanger	(	): Creates a new Exchanger.
java.util.concurrent.Exchanger.Node: Nodes hold partially exchanged data, plus other per-thread bookkeeping. Padded via @sun.misc.Contended to reduce memory contention.
java.util.concurrent.Exchanger.Participant: The corresponding thread local class 
java.util.concurrent.Exchanger.arenaExchange	(	Object	boolean	long	): Exchange function when arenas enabled. See above for explanation.
java.util.concurrent.Exchanger.exchange	(	V	): Waits for another thread to arrive at this exchange point (unless the current thread is interrupt interrupted), and then transfers the given object to it, receiving its object in return. If another thread is already waiting at the exchange point then it is resumed for thread scheduling purposes and receives the object passed in by the current thread. The current thread returns immediately, receiving the object passed to the exchange by that other thread. If no other thread is already waiting at the exchange then the current thread is disabled for thread scheduling purposes and lies dormant until one of two things happens:  Some other thread enters the exchange; or Some other thread interrupt interrupts the current thread.  If the current thread:  has its interrupted status set on entry to this method; or is interrupt interrupted while waiting for the exchange,  then InterruptedException is thrown and the current thread's interrupted status is cleared.
java.util.concurrent.Exchanger.exchange	(	V	long	TimeUnit	): Waits for another thread to arrive at this exchange point (unless the current thread is interrupt interrupted or the specified waiting time elapses), and then transfers the given object to it, receiving its object in return. If another thread is already waiting at the exchange point then it is resumed for thread scheduling purposes and receives the object passed in by the current thread. The current thread returns immediately, receiving the object passed to the exchange by that other thread. If no other thread is already waiting at the exchange then the current thread is disabled for thread scheduling purposes and lies dormant until one of three things happens:  Some other thread enters the exchange; or Some other thread interrupt interrupts the current thread; or The specified waiting time elapses.  If the current thread:  has its interrupted status set on entry to this method; or is interrupt interrupted while waiting for the exchange,  then InterruptedException is thrown and the current thread's interrupted status is cleared. If the specified waiting time elapses then TimeoutException is thrown. If the time is less than or equal to zero, the method will not wait at all.
java.util.concurrent.Exchanger.slotExchange	(	Object	boolean	long	): Exchange function used until arenas enabled. See above for explanation.
java.util.concurrent.ExecutionException: Exception thrown when attempting to retrieve the result of a task that aborted by throwing an exception. This exception can be inspected using the getCause() method.
java.util.concurrent.ExecutionException.ExecutionException	(	): Constructs an ExecutionException with no detail message. The cause is not initialized, and may subsequently be initialized by a call to initCause().
java.util.concurrent.ExecutionException.ExecutionException	(	String	): Constructs an ExecutionException with the specified detail message. The cause is not initialized, and may subsequently be initialized by a call to initCause().
java.util.concurrent.ExecutionException.ExecutionException	(	String	Throwable	): Constructs an ExecutionException with the specified detail message and cause.
java.util.concurrent.ExecutionException.ExecutionException	(	Throwable	): Constructs an ExecutionException with the specified cause. The detail message is set to (cause == null ? null : cause.toString()) (which typically contains the class and detail message of cause).
java.util.concurrent.Executor: An object that executes submitted Runnable tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc. An Executor is normally used instead of explicitly creating threads. For example, rather than invoking new Thread(new(RunnableTask())).start() for each of a set of tasks, you might use:  Executor executor = anExecutor; executor.execute(new RunnableTask1()); executor.execute(new RunnableTask2()); ...  However, the Executor interface does not strictly require that execution be asynchronous. In the simplest case, an executor can run the submitted task immediately in the caller's thread:  class DirectExecutor implements Executor public void execute(Runnable r) { r.run(); } }} More typically, tasks are executed in some thread other than the caller's thread. The executor below spawns a new thread for each task.  class ThreadPerTaskExecutor implements Executor public void execute(Runnable r) { new Thread(r).start(); } }} Many Executor implementations impose some sort of limitation on how and when tasks are scheduled. The executor below serializes the submission of tasks to a second executor, illustrating a composite executor.  class SerialExecutor implements Executor final Queue tasks = new ArrayDeque(); final Executor executor; Runnable active; SerialExecutor(Executor executor) { this.executor = executor; } public synchronized void execute(final Runnable r) { tasks.offer(new Runnable() { public void run() { try { r.run(); } finally { scheduleNext(); } } }); if (active == null) { scheduleNext(); } } protected synchronized void scheduleNext() { if ((active = tasks.poll()) != null) { executor.execute(active); } } }} The Executor implementations provided in this package implement ExecutorService, which is a more extensive interface. The ThreadPoolExecutor class provides an extensible thread pool implementation. The Executors class provides convenient factory methods for these Executors. Memory consistency effects: Actions in a thread prior to submitting a Runnable object to an Executor happen-before its execution begins, perhaps in another thread.
java.util.concurrent.Executor.execute	(	Runnable	): Executes the given command at some time in the future. The command may execute in a new thread, in a pooled thread, or in the calling thread, at the discretion of the Executor implementation.
java.util.concurrent.ExecutorCompletionService: A CompletionService that uses a supplied Executor to execute tasks. This class arranges that submitted tasks are, upon completion, placed on a queue accessible using take. The class is lightweight enough to be suitable for transient use when processing groups of tasks.  Usage Examples. Suppose you have a set of solvers for a certain problem, each returning a value of some type Result, and would like to run them concurrently, processing the results of each of them that return a non-null value, in some method use(Result r). You could write this as:  void solve(Executor e, Collection> solvers) throws InterruptedException, ExecutionException CompletionService ecs = new ExecutorCompletionService(e); for (Callable s : solvers) ecs.submit(s); int n = solvers.size(); for (int i = 0; i < n; ++i) { Result r = ecs.take().get(); if (r != null) use(r); } }} Suppose instead that you would like to use the first non-null result of the set of tasks, ignoring any that encounter exceptions, and cancelling all other tasks when the first one is ready:  void solve(Executor e, Collection> solvers) throws InterruptedException CompletionService ecs = new ExecutorCompletionService(e); int n = solvers.size(); List> futures = new ArrayList>(n); Result result = null; try { for (Callable s : solvers) futures.add(ecs.submit(s)); for (int i = 0; i < n; ++i) { try { Result r = ecs.take().get(); if (r != null) { result = r; break; } } catch (ExecutionException ignore) {} } } finally { for (Future f : futures) f.cancel(true); } if (result != null) use(result); }}
java.util.concurrent.ExecutorCompletionService.ExecutorCompletionService	(	Executor	): Creates an ExecutorCompletionService using the supplied executor for base task execution and a LinkedBlockingQueue as a completion queue.
java.util.concurrent.ExecutorCompletionService.ExecutorCompletionService	(	Executor	BlockingQueue	): Creates an ExecutorCompletionService using the supplied executor for base task execution and the supplied queue as its completion queue.
java.util.concurrent.ExecutorCompletionService.QueueingFuture: FutureTask extension to enqueue upon completion
java.util.concurrent.ExecutorService: An Executor that provides methods to manage termination and methods that can produce a Future for tracking progress of one or more asynchronous tasks. An ExecutorService can be shut down, which will cause it to reject new tasks. Two different methods are provided for shutting down an ExecutorService. The shutdown method will allow previously submitted tasks to execute before terminating, while the shutdownNow method prevents waiting tasks from starting and attempts to stop currently executing tasks. Upon termination, an executor has no tasks actively executing, no tasks awaiting execution, and no new tasks can be submitted. An unused ExecutorService should be shut down to allow reclamation of its resources. Method submit extends base method execute() by creating and returning a Future that can be used to cancel execution and/or wait for completion. Methods invokeAny and invokeAll perform the most commonly useful forms of bulk execution, executing a collection of tasks and then waiting for at least one, or all, to complete. (Class ExecutorCompletionService can be used to write customized variants of these methods.) The Executors class provides factory methods for the executor services provided in this package. Usage Examples Here is a sketch of a network service in which threads in a thread pool service incoming requests. It uses the preconfigured newFixedThreadPool factory method:  class NetworkService implements Runnable private final ServerSocket serverSocket; private final ExecutorService pool; public NetworkService(int port, int poolSize) throws IOException { serverSocket = new ServerSocket(port); pool = Executors.newFixedThreadPool(poolSize); } public void run() { // run the service try { for (;;) { pool.execute(new Handler(serverSocket.accept())); } } catch (IOException ex) { pool.shutdown(); } } } class Handler implements Runnable { private final Socket socket; Handler(Socket socket) { this.socket = socket; } public void run() { // read and service request on socket } }} The following method shuts down an ExecutorService in two phases, first by calling shutdown to reject incoming tasks, and then calling shutdownNow, if necessary, to cancel any lingering tasks:  void shutdownAndAwaitTermination(ExecutorService pool) pool.shutdown(); // Disable new tasks from being submitted try { // Wait a while for existing tasks to terminate if (!pool.awaitTermination(60, TimeUnit.SECONDS)) { pool.shutdownNow(); // Cancel currently executing tasks // Wait a while for tasks to respond to being cancelled if (!pool.awaitTermination(60, TimeUnit.SECONDS)) System.err.println("Pool did not terminate"); } } catch (InterruptedException ie) { // (Re-)Cancel if current thread also interrupted pool.shutdownNow(); // Preserve interrupt status Thread.currentThread().interrupt(); } }} Memory consistency effects: Actions in a thread prior to the submission of a Runnable or Callable task to an ExecutorService happen-before any actions taken by that task, which in turn happen-before the result is retrieved via Future.get().
java.util.concurrent.ExecutorService.awaitTermination	(	long	TimeUnit	): Blocks until all tasks have completed execution after a shutdown request, or the timeout occurs, or the current thread is interrupted, whichever happens first.
java.util.concurrent.ExecutorService.invokeAll	(	Collection	): Executes the given tasks, returning a list of Futures holding their status and results when all complete. isDone is true for each element of the returned list. Note that a completed task could have terminated either normally or by throwing an exception. The results of this method are undefined if the given collection is modified while this operation is in progress.
java.util.concurrent.ExecutorService.invokeAll	(	Collection	long	TimeUnit	): Executes the given tasks, returning a list of Futures holding their status and results when all complete or the timeout expires, whichever happens first. isDone is true for each element of the returned list. Upon return, tasks that have not completed are cancelled. Note that a completed task could have terminated either normally or by throwing an exception. The results of this method are undefined if the given collection is modified while this operation is in progress.
java.util.concurrent.ExecutorService.invokeAny	(	Collection	): Executes the given tasks, returning the result of one that has completed successfully (i.e., without throwing an exception), if any do. Upon normal or exceptional return, tasks that have not completed are cancelled. The results of this method are undefined if the given collection is modified while this operation is in progress.
java.util.concurrent.ExecutorService.invokeAny	(	Collection	long	TimeUnit	): Executes the given tasks, returning the result of one that has completed successfully (i.e., without throwing an exception), if any do before the given timeout elapses. Upon normal or exceptional return, tasks that have not completed are cancelled. The results of this method are undefined if the given collection is modified while this operation is in progress.
java.util.concurrent.ExecutorService.isShutdown	(	): Returns true if this executor has been shut down.
java.util.concurrent.ExecutorService.isTerminated	(	): Returns true if all tasks have completed following shut down. Note that isTerminated is never true unless either shutdown or shutdownNow was called first.
java.util.concurrent.ExecutorService.shutdown	(	): Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted. Invocation has no additional effect if already shut down. This method does not wait for previously submitted tasks to complete execution. Use awaitTermination to do that.
java.util.concurrent.ExecutorService.shutdownNow	(	): Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution. This method does not wait for actively executing tasks to terminate. Use awaitTermination to do that. There are no guarantees beyond best-effort attempts to stop processing actively executing tasks. For example, typical implementations will cancel via interrupt, so any task that fails to respond to interrupts may never terminate.
java.util.concurrent.ExecutorService.submit	(	Callable	): Submits a value-returning task for execution and returns a Future representing the pending results of the task. The Future's get method will return the task's result upon successful completion.  If you would like to immediately block waiting for a task, you can use constructions of the form result = exec.submit(aCallable).get(); Note: The Executors class includes a set of methods that can convert some other common closure-like objects, for example, java.security.PrivilegedAction to Callable form so they can be submitted.
java.util.concurrent.ExecutorService.submit	(	Runnable	): Submits a Runnable task for execution and returns a Future representing that task. The Future's get method will return null upon successful completion.
java.util.concurrent.ExecutorService.submit	(	Runnable	T	): Submits a Runnable task for execution and returns a Future representing that task. The Future's get method will return the given result upon successful completion.
java.util.concurrent.Executors: Factory and utility methods for Executor, ExecutorService, ScheduledExecutorService, ThreadFactory, and Callable classes defined in this package. This class supports the following kinds of methods:   Methods that create and return an ExecutorService set up with commonly useful configuration settings.  Methods that create and return a ScheduledExecutorService set up with commonly useful configuration settings.  Methods that create and return a "wrapped" ExecutorService, that disables reconfiguration by making implementation-specific methods inaccessible.  Methods that create and return a ThreadFactory that sets newly created threads to a known state.  Methods that create and return a Callable out of other closure-like forms, so they can be used in execution methods requiring Callable. 
java.util.concurrent.Executors.DefaultThreadFactory: The default thread factory
java.util.concurrent.Executors.DelegatedExecutorService: A wrapper class that exposes only the ExecutorService methods of an ExecutorService implementation.
java.util.concurrent.Executors.DelegatedScheduledExecutorService: A wrapper class that exposes only the ScheduledExecutorService methods of a ScheduledExecutorService implementation.
java.util.concurrent.Executors.Executors	(	): Cannot instantiate. 
java.util.concurrent.Executors.PrivilegedCallable: A callable that runs under established access control settings
java.util.concurrent.Executors.PrivilegedCallableUsingCurrentClassLoader: A callable that runs under established access control settings and current ClassLoader
java.util.concurrent.Executors.PrivilegedThreadFactory: Thread factory capturing access control context and class loader
java.util.concurrent.Executors.RunnableAdapter: A callable that runs given task and returns given result
java.util.concurrent.Executors.callable	(	PrivilegedAction	): Returns a Callable object that, when called, runs the given privileged action and returns its result.
java.util.concurrent.Executors.callable	(	PrivilegedExceptionAction	): Returns a Callable object that, when called, runs the given privileged exception action and returns its result.
java.util.concurrent.Executors.callable	(	Runnable	): Returns a Callable object that, when called, runs the given task and returns null.
java.util.concurrent.Executors.callable	(	Runnable	T	): Returns a Callable object that, when called, runs the given task and returns the given result. This can be useful when applying methods requiring a Callable to an otherwise resultless action.
java.util.concurrent.Executors.defaultThreadFactory	(	): Returns a default thread factory used to create new threads. This factory creates all new threads used by an Executor in the same ThreadGroup. If there is a java.lang.SecurityManager, it uses the group of getSecurityManager, else the group of the thread invoking this defaultThreadFactory method. Each new thread is created as a non-daemon thread with priority set to the smaller of Thread.NORM_PRIORITY and the maximum priority permitted in the thread group. New threads have names accessible via getName of pool-N-thread-M, where N is the sequence number of this factory, and M is the sequence number of the thread created by this factory.
java.util.concurrent.Executors.newCachedThreadPool	(	): Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available. These pools will typically improve the performance of programs that execute many short-lived asynchronous tasks. Calls to execute will reuse previously constructed threads if available. If no existing thread is available, a new thread will be created and added to the pool. Threads that have not been used for sixty seconds are terminated and removed from the cache. Thus, a pool that remains idle for long enough will not consume any resources. Note that pools with similar properties but different details (for example, timeout parameters) may be created using ThreadPoolExecutor constructors.
java.util.concurrent.Executors.newCachedThreadPool	(	ThreadFactory	): Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available, and uses the provided ThreadFactory to create new threads when needed.
java.util.concurrent.Executors.newFixedThreadPool	(	int	): Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue. At any point, at most nThreads threads will be active processing tasks. If additional tasks are submitted when all threads are active, they will wait in the queue until a thread is available. If any thread terminates due to a failure during execution prior to shutdown, a new one will take its place if needed to execute subsequent tasks. The threads in the pool will exist until it is explicitly shutdown.
java.util.concurrent.Executors.newFixedThreadPool	(	int	ThreadFactory	): Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue, using the provided ThreadFactory to create new threads when needed. At any point, at most nThreads threads will be active processing tasks. If additional tasks are submitted when all threads are active, they will wait in the queue until a thread is available. If any thread terminates due to a failure during execution prior to shutdown, a new one will take its place if needed to execute subsequent tasks. The threads in the pool will exist until it is explicitly shutdown .
java.util.concurrent.Executors.newScheduledThreadPool	(	int	): Creates a thread pool that can schedule commands to run after a given delay, or to execute periodically.
java.util.concurrent.Executors.newScheduledThreadPool	(	int	ThreadFactory	): Creates a thread pool that can schedule commands to run after a given delay, or to execute periodically.
java.util.concurrent.Executors.newSingleThreadExecutor	(	): Creates an Executor that uses a single worker thread operating off an unbounded queue. (Note however that if this single thread terminates due to a failure during execution prior to shutdown, a new one will take its place if needed to execute subsequent tasks.) Tasks are guaranteed to execute sequentially, and no more than one task will be active at any given time. Unlike the otherwise equivalent newFixedThreadPool(1) the returned executor is guaranteed not to be reconfigurable to use additional threads.
java.util.concurrent.Executors.newSingleThreadExecutor	(	ThreadFactory	): Creates an Executor that uses a single worker thread operating off an unbounded queue, and uses the provided ThreadFactory to create a new thread when needed. Unlike the otherwise equivalent newFixedThreadPool(1, threadFactory) the returned executor is guaranteed not to be reconfigurable to use additional threads.
java.util.concurrent.Executors.newSingleThreadScheduledExecutor	(	): Creates a single-threaded executor that can schedule commands to run after a given delay, or to execute periodically. (Note however that if this single thread terminates due to a failure during execution prior to shutdown, a new one will take its place if needed to execute subsequent tasks.) Tasks are guaranteed to execute sequentially, and no more than one task will be active at any given time. Unlike the otherwise equivalent newScheduledThreadPool(1) the returned executor is guaranteed not to be reconfigurable to use additional threads.
java.util.concurrent.Executors.newSingleThreadScheduledExecutor	(	ThreadFactory	): Creates a single-threaded executor that can schedule commands to run after a given delay, or to execute periodically. (Note however that if this single thread terminates due to a failure during execution prior to shutdown, a new one will take its place if needed to execute subsequent tasks.) Tasks are guaranteed to execute sequentially, and no more than one task will be active at any given time. Unlike the otherwise equivalent newScheduledThreadPool(1, threadFactory) the returned executor is guaranteed not to be reconfigurable to use additional threads.
java.util.concurrent.Executors.newWorkStealingPool	(	): Creates a work-stealing thread pool using all availableProcessors available processors as its target parallelism level.
java.util.concurrent.Executors.newWorkStealingPool	(	int	): Creates a thread pool that maintains enough threads to support the given parallelism level, and may use multiple queues to reduce contention. The parallelism level corresponds to the maximum number of threads actively engaged in, or available to engage in, task processing. The actual number of threads may grow and shrink dynamically. A work-stealing pool makes no guarantees about the order in which submitted tasks are executed.
java.util.concurrent.Executors.privilegedCallable	(	Callable	): Returns a Callable object that will, when called, execute the given callable under the current access control context. This method should normally be invoked within an doPrivileged AccessController.doPrivileged action to create callables that will, if possible, execute under the selected permission settings holding within that action; or if not possible, throw an associated AccessControlException.
java.util.concurrent.Executors.privilegedCallableUsingCurrentClassLoader	(	Callable	): Returns a Callable object that will, when called, execute the given callable under the current access control context, with the current context class loader as the context class loader. This method should normally be invoked within an doPrivileged AccessController.doPrivileged action to create callables that will, if possible, execute under the selected permission settings holding within that action; or if not possible, throw an associated AccessControlException.
java.util.concurrent.Executors.privilegedThreadFactory	(	): Returns a thread factory used to create new threads that have the same permissions as the current thread. This factory creates threads with the same settings as defaultThreadFactory, additionally setting the AccessControlContext and contextClassLoader of new threads to be the same as the thread invoking this privilegedThreadFactory method. A new privilegedThreadFactory can be created within an doPrivileged AccessController.doPrivileged action setting the current thread's access control context to create threads with the selected permission settings holding within that action. Note that while tasks running within such threads will have the same access control and class loader settings as the current thread, they need not have the same java.lang.ThreadLocal or java.lang.InheritableThreadLocal values. If necessary, particular values of thread locals can be set or reset before any task runs in ThreadPoolExecutor subclasses using beforeExecute(). Also, if it is necessary to initialize worker threads to have the same InheritableThreadLocal settings as some other designated thread, you can create a custom ThreadFactory in which that thread waits for and services requests to create others that will inherit its values.
java.util.concurrent.Executors.unconfigurableExecutorService	(	ExecutorService	): Returns an object that delegates all defined ExecutorService methods to the given executor, but not any other methods that might otherwise be accessible using casts. This provides a way to safely "freeze" configuration and disallow tuning of a given concrete implementation.
java.util.concurrent.Executors.unconfigurableScheduledExecutorService	(	ScheduledExecutorService	): Returns an object that delegates all defined ScheduledExecutorService methods to the given executor, but not any other methods that might otherwise be accessible using casts. This provides a way to safely "freeze" configuration and disallow tuning of a given concrete implementation.
java.util.concurrent.ForkJoinPool: An ExecutorService for running ForkJoinTasks. A ForkJoinPool provides the entry point for submissions from non-ForkJoinTask clients, as well as management and monitoring operations. A ForkJoinPool differs from other kinds of ExecutorService mainly by virtue of employing work-stealing: all threads in the pool attempt to find and execute tasks submitted to the pool and/or created by other active tasks (eventually blocking waiting for work if none exist). This enables efficient processing when most tasks spawn other subtasks (as do most ForkJoinTasks), as well as when many small tasks are submitted to the pool from external clients. Especially when setting asyncMode to true in constructors, ForkJoinPools may also be appropriate for use with event-style tasks that are never joined. A static commonPool() is available and appropriate for most applications. The common pool is used by any ForkJoinTask that is not explicitly submitted to a specified pool. Using the common pool normally reduces resource usage (its threads are slowly reclaimed during periods of non-use, and reinstated upon subsequent use). For applications that require separate or custom pools, a ForkJoinPool may be constructed with a given target parallelism level; by default, equal to the number of available processors. The pool attempts to maintain enough active (or available) threads by dynamically adding, suspending, or resuming internal worker threads, even if some tasks are stalled waiting to join others. However, no such adjustments are guaranteed in the face of blocked I/O or other unmanaged synchronization. The nested ManagedBlocker interface enables extension of the kinds of synchronization accommodated. In addition to execution and lifecycle control methods, this class provides status check methods (for example getStealCount) that are intended to aid in developing, tuning, and monitoring fork/join applications. Also, method toString returns indications of pool state in a convenient form for informal monitoring. As is the case with other ExecutorServices, there are three main task execution methods summarized in the following table. These are designed to be used primarily by clients not already engaged in fork/join computations in the current pool. The main forms of these methods accept instances of ForkJoinTask, but overloaded forms also allow mixed execution of plain Runnable- or Callable- based activities as well. However, tasks that are already executing in a pool should normally instead use the within-computation forms listed in the table unless using async event-style tasks that are not usually joined, in which case there is little difference among choice of methods.  Summary of task execution methods    Call from non-fork/join clients  Call from within fork/join computations    Arrange async execution  execute()  fork    Await and obtain result  invoke()  invoke    Arrange exec and obtain Future  submit()  fork (ForkJoinTasks are Futures)   The common pool is by default constructed with default parameters, but these may be controlled by setting three getProperty system properties:  java.util.concurrent.ForkJoinPool.common.parallelism - the parallelism level, a non-negative integer java.util.concurrent.ForkJoinPool.common.threadFactory - the class name of a ForkJoinWorkerThreadFactory java.util.concurrent.ForkJoinPool.common.exceptionHandler - the class name of a UncaughtExceptionHandler  If a SecurityManager is present and no factory is specified, then the default pool uses a factory supplying threads that have no Permissions enabled. The system class loader is used to load these classes. Upon any error in establishing these settings, default parameters are used. It is possible to disable or limit the use of threads in the common pool by setting the parallelism property to zero, and/or using a factory that may return null. However doing so may cause unjoined tasks to never be executed. Implementation notes: This implementation restricts the maximum number of running threads to 32767. Attempts to create pools with greater than the maximum number result in IllegalArgumentException. This implementation rejects submitted tasks (that is, by throwing RejectedExecutionException) only when the pool is shut down or internal resources have been exhausted.
java.util.concurrent.ForkJoinPool.DefaultForkJoinWorkerThreadFactory: Default ForkJoinWorkerThreadFactory implementation; creates a new ForkJoinWorkerThread.
java.util.concurrent.ForkJoinPool.EmptyTask: Class for artificial tasks that are used to replace the target of local joins if they are removed from an interior queue slot in WorkQueue.tryRemoveAndExec. We don't need the proxy to actually do anything beyond having a unique identity.
java.util.concurrent.ForkJoinPool.ForkJoinPool	(	): Creates a ForkJoinPool with parallelism equal to availableProcessors, using the defaultForkJoinWorkerThreadFactory default thread factory, no UncaughtExceptionHandler, and non-async LIFO processing mode.
java.util.concurrent.ForkJoinPool.ForkJoinPool	(	int	): Creates a ForkJoinPool with the indicated parallelism level, the defaultForkJoinWorkerThreadFactory default thread factory, no UncaughtExceptionHandler, and non-async LIFO processing mode.
java.util.concurrent.ForkJoinPool.ForkJoinPool	(	int	ForkJoinWorkerThreadFactory	UncaughtExceptionHandler	boolean	): Creates a ForkJoinPool with the given parameters.
java.util.concurrent.ForkJoinPool.ForkJoinPool	(	int	ForkJoinWorkerThreadFactory	UncaughtExceptionHandler	int	String	): Creates a ForkJoinPool with the given parameters, without any security checks or parameter validation. Invoked directly by makeCommonPool.
java.util.concurrent.ForkJoinPool.ForkJoinWorkerThreadFactory: Factory for creating new ForkJoinWorkerThreads. A ForkJoinWorkerThreadFactory must be defined and used for ForkJoinWorkerThread subclasses that extend base functionality or initialize threads with different contexts.
java.util.concurrent.ForkJoinPool.ForkJoinWorkerThreadFactory.newThread	(	ForkJoinPool	): Returns a new worker thread operating in the given pool.
java.util.concurrent.ForkJoinPool.InnocuousForkJoinWorkerThreadFactory: Factory for innocuous worker threads
java.util.concurrent.ForkJoinPool.ManagedBlocker: Interface for extending managed parallelism for tasks running in ForkJoinPools. A ManagedBlocker provides two methods. Method isReleasable must return true if blocking is not necessary. Method block blocks the current thread if necessary (perhaps internally invoking isReleasable before actually blocking). These actions are performed by any thread invoking managedBlock(). The unusual methods in this API accommodate synchronizers that may, but don't usually, block for long periods. Similarly, they allow more efficient internal handling of cases in which additional workers may be, but usually are not, needed to ensure sufficient parallelism. Toward this end, implementations of method isReleasable must be amenable to repeated invocation. For example, here is a ManagedBlocker based on a ReentrantLock:  class ManagedLocker implements ManagedBlocker final ReentrantLock lock; boolean hasLock = false; ManagedLocker(ReentrantLock lock) { this.lock = lock; } public boolean block() { if (!hasLock) lock.lock(); return true; } public boolean isReleasable() { return hasLock || (hasLock = lock.tryLock()); } }} Here is a class that possibly blocks waiting for an item on a given queue:  class QueueTaker implements ManagedBlocker final BlockingQueue queue; volatile E item = null; QueueTaker(BlockingQueue q) { this.queue = q; } public boolean block() throws InterruptedException { if (item == null) item = queue.take(); return true; } public boolean isReleasable() { return item != null || (item = queue.poll()) != null; } public E getItem() { // call after pool.managedBlock completes return item; } }}
java.util.concurrent.ForkJoinPool.ManagedBlocker.block	(	): Possibly blocks the current thread, for example waiting for a lock or condition.
java.util.concurrent.ForkJoinPool.ManagedBlocker.isReleasable	(	): Returns true if blocking is unnecessary.
java.util.concurrent.ForkJoinPool.WorkQueue: Queues supporting work-stealing as well as external task submission. See above for descriptions and algorithms. Performance on most platforms is very sensitive to placement of instances of both WorkQueues and their arrays -- we absolutely do not want multiple WorkQueue instances or multiple queue arrays sharing cache lines. The @Contended annotation alerts JVMs to try to keep instances apart.
java.util.concurrent.ForkJoinPool.WorkQueue.cancelAll	(	): Removes and cancels all known tasks, ignoring any exceptions.
java.util.concurrent.ForkJoinPool.WorkQueue.execLocalTasks	(	): Removes and executes all local tasks. If LIFO, invokes pollAndExecAll. Otherwise implements a specialized pop loop to exec until empty.
java.util.concurrent.ForkJoinPool.WorkQueue.getPoolIndex	(	): Returns an exportable index (used by ForkJoinWorkerThread).
java.util.concurrent.ForkJoinPool.WorkQueue.growArray	(	): Initializes or doubles the capacity of array. Call either by owner or with lock held -- it is OK for base, but not top, to move while resizings are in progress.
java.util.concurrent.ForkJoinPool.WorkQueue.isApparentlyUnblocked	(	): Returns true if owned and not known to be blocked.
java.util.concurrent.ForkJoinPool.WorkQueue.isEmpty	(	): Provides a more accurate estimate of whether this queue has any tasks than does queueSize, by checking whether a near-empty queue has at least one unclaimed task.
java.util.concurrent.ForkJoinPool.WorkQueue.nextLocalTask	(	): Takes next task, if one exists, in order specified by mode.
java.util.concurrent.ForkJoinPool.WorkQueue.peek	(	): Returns next task, if one exists, in order specified by mode.
java.util.concurrent.ForkJoinPool.WorkQueue.poll	(	): Takes next task, if one exists, in FIFO order.
java.util.concurrent.ForkJoinPool.WorkQueue.pollAndExecAll	(	): Polls and runs tasks until empty.
java.util.concurrent.ForkJoinPool.WorkQueue.pollAndExecCC	(	CountedCompleter	): Steals and runs a task in the same CC computation as the given task if one exists and can be taken without contention. Otherwise returns a checksum/control value for use by method helpComplete.
java.util.concurrent.ForkJoinPool.WorkQueue.pollAt	(	int	): Takes a task in FIFO order if b is base of queue and a task can be claimed without contention. Specialized versions appear in ForkJoinPool methods scan and helpStealer.
java.util.concurrent.ForkJoinPool.WorkQueue.pop	(	): Takes next task, if one exists, in LIFO order. Call only by owner in unshared queues.
java.util.concurrent.ForkJoinPool.WorkQueue.popCC	(	CountedCompleter	int	): Pops task if in the same CC computation as the given task, in either shared or owned mode. Used only by helpComplete.
java.util.concurrent.ForkJoinPool.WorkQueue.push	(	ForkJoinTask	): Pushes a task. Call only by owner in unshared queues. (The shared-queue version is embedded in method externalPush.)
java.util.concurrent.ForkJoinPool.WorkQueue.queueSize	(	): Returns the approximate number of tasks in the queue.
java.util.concurrent.ForkJoinPool.WorkQueue.runTask	(	ForkJoinTask	): Executes the given task and any remaining local tasks.
java.util.concurrent.ForkJoinPool.WorkQueue.transferStealCount	(	ForkJoinPool	): Adds steal count to pool stealCounter if it exists, and resets.
java.util.concurrent.ForkJoinPool.WorkQueue.tryRemoveAndExec	(	ForkJoinTask	): If present, removes from queue and executes the given task, or any other cancelled task. Used only by awaitJoin.
java.util.concurrent.ForkJoinPool.WorkQueue.tryUnpush	(	ForkJoinTask	): Pops the given task only if it is at the current top. (A shared version is available only via FJP.tryExternalUnpush)
java.util.concurrent.ForkJoinPool.awaitJoin	(	WorkQueue	ForkJoinTask	long	): Helps and/or blocks until the given task is done or timeout.
java.util.concurrent.ForkJoinPool.awaitQuiescence	(	long	TimeUnit	): If called by a ForkJoinTask operating in this pool, equivalent in effect to helpQuiesce. Otherwise, waits and/or attempts to assist performing tasks until this pool isQuiescent or the indicated timeout elapses.
java.util.concurrent.ForkJoinPool.awaitRunStateLock	(	): Spins and/or blocks until runstate lock is available. See above for explanation.
java.util.concurrent.ForkJoinPool.awaitTermination	(	long	TimeUnit	): Blocks until all tasks have completed execution after a shutdown request, or the timeout occurs, or the current thread is interrupted, whichever happens first. Because the commonPool() never terminates until program shutdown, when applied to the common pool, this method is equivalent to awaitQuiescence() but always returns false.
java.util.concurrent.ForkJoinPool.awaitWork	(	WorkQueue	int	): Possibly blocks worker w waiting for a task to steal, or returns false if the worker should terminate. If inactivating w has caused the pool to become quiescent, checks for pool termination, and, so long as this is not the only worker, waits for up to a given duration. On timeout, if ctl has not changed, terminates the worker, which will in turn wake up another worker to possibly repeat this process.
java.util.concurrent.ForkJoinPool.checkPermission	(	): If there is a security manager, makes sure caller has permission to modify threads.
java.util.concurrent.ForkJoinPool.commonPool	(	): Returns the common pool instance. This pool is statically constructed; its run state is unaffected by attempts to shutdown or shutdownNow. However this pool and any ongoing processing are automatically terminated upon program exit. Any program that relies on asynchronous task processing to complete before program termination should invoke commonPool().awaitQuiescence, before exit.
java.util.concurrent.ForkJoinPool.commonSubmitterQueue	(	): Returns common pool queue for an external thread.
java.util.concurrent.ForkJoinPool.createWorker	(	): Tries to construct and start one worker. Assumes that total count has already been incremented as a reservation. Invokes deregisterWorker on any failure.
java.util.concurrent.ForkJoinPool.deregisterWorker	(	ForkJoinWorkerThread	Throwable	): Final callback from terminating worker, as well as upon failure to construct or start a worker. Removes record of worker from array, and adjusts counts. If pool is shutting down, tries to complete termination.
java.util.concurrent.ForkJoinPool.drainTasksTo	(	Collection	): Removes all available unexecuted submitted and forked tasks from scheduling queues and adds them to the given collection, without altering their execution status. These may include artificially generated or wrapped tasks. This method is designed to be invoked only when the pool is known to be quiescent. Invocations at other times may not remove all tasks. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. The behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.ForkJoinPool.execute	(	ForkJoinTask	): Arranges for (asynchronous) execution of the given task.
java.util.concurrent.ForkJoinPool.execute	(	Runnable	): Executes the given command at some time in the future. The command may execute in a new thread, in a pooled thread, or in the calling thread, at the discretion of the Executor implementation.
java.util.concurrent.ForkJoinPool.externalHelpComplete	(	CountedCompleter	int	): Performs helpComplete for an external submitter.
java.util.concurrent.ForkJoinPool.externalPush	(	ForkJoinTask	): Tries to add the given task to a submission queue at submitter's current queue. Only the (vastly) most common path is directly handled in this method, while screening for need for externalSubmit.
java.util.concurrent.ForkJoinPool.externalSubmit	(	ForkJoinTask	): Full version of externalPush, handling uncommon cases, as well as performing secondary initialization upon the first submission of the first task to the pool. It also detects first submission by an external thread and creates a new shared queue if the one at index if empty or contended.
java.util.concurrent.ForkJoinPool.findNonEmptyStealQueue	(	): Returns a (probably) non-empty steal queue, if one is found during a scan, else null. This method must be retried by caller if, by the time it tries to use the queue, it is empty.
java.util.concurrent.ForkJoinPool.getActiveThreadCount	(	): Returns an estimate of the number of threads that are currently stealing or executing tasks. This method may overestimate the number of active threads.
java.util.concurrent.ForkJoinPool.getAsyncMode	(	): Returns true if this pool uses local first-in-first-out scheduling mode for forked tasks that are never joined.
java.util.concurrent.ForkJoinPool.getCommonPoolParallelism	(	): Returns the targeted parallelism level of the common pool.
java.util.concurrent.ForkJoinPool.getFactory	(	): Returns the factory used for constructing new workers.
java.util.concurrent.ForkJoinPool.getParallelism	(	): Returns the targeted parallelism level of this pool.
java.util.concurrent.ForkJoinPool.getPoolSize	(	): Returns the number of worker threads that have started but not yet terminated. The result returned by this method may differ from getParallelism when threads are created to maintain parallelism when others are cooperatively blocked.
java.util.concurrent.ForkJoinPool.getQueuedSubmissionCount	(	): Returns an estimate of the number of tasks submitted to this pool that have not yet begun executing. This method may take time proportional to the number of submissions.
java.util.concurrent.ForkJoinPool.getQueuedTaskCount	(	): Returns an estimate of the total number of tasks currently held in queues by worker threads (but not including tasks submitted to the pool that have not begun executing). This value is only an approximation, obtained by iterating across all threads in the pool. This method may be useful for tuning task granularities.
java.util.concurrent.ForkJoinPool.getRunningThreadCount	(	): Returns an estimate of the number of worker threads that are not blocked waiting to join tasks or for other managed synchronization. This method may overestimate the number of running threads.
java.util.concurrent.ForkJoinPool.getStealCount	(	): Returns an estimate of the total number of tasks stolen from one thread's work queue by another. The reported value underestimates the actual total number of steals when the pool is not quiescent. This value may be useful for monitoring and tuning fork/join programs: in general, steal counts should be high enough to keep threads busy, but low enough to avoid overhead and contention across threads.
java.util.concurrent.ForkJoinPool.getSurplusQueuedTaskCount	(	): Returns a cheap heuristic guide for task partitioning when programmers, frameworks, tools, or languages have little or no idea about task granularity. In essence, by offering this method, we ask users only about tradeoffs in overhead vs expected throughput and its variance, rather than how finely to partition tasks. In a steady state strict (tree-structured) computation, each thread makes available for stealing enough tasks for other threads to remain active. Inductively, if all threads play by the same rules, each thread should make available only a constant number of tasks. The minimum useful constant is just 1. But using a value of 1 would require immediate replenishment upon each steal to maintain enough tasks, which is infeasible. Further, partitionings/granularities of offered tasks should minimize steal rates, which in general means that threads nearer the top of computation tree should generate more than those nearer the bottom. In perfect steady state, each thread is at approximately the same level of computation tree. However, producing extra tasks amortizes the uncertainty of progress and diffusion assumptions. So, users will want to use values larger (but not much larger) than 1 to both smooth over transient shortages and hedge against uneven progress; as traded off against the cost of extra task overhead. We leave the user to pick a threshold value to compare with the results of this call to guide decisions, but recommend values such as 3. When all threads are active, it is on average OK to estimate surplus strictly locally. In steady-state, if one thread is maintaining say 2 surplus tasks, then so are others. So we can just use estimated queue length. However, this strategy alone leads to serious mis-estimates in some non-steady-state conditions (ramp-up, ramp-down, other stalls). We can detect many of these by further considering the number of "idle" threads, that are known to have zero queued tasks, so compensate by a factor of (#idle/#active) threads.
java.util.concurrent.ForkJoinPool.getUncaughtExceptionHandler	(	): Returns the handler for internal worker threads that terminate due to unrecoverable errors encountered while executing tasks.
java.util.concurrent.ForkJoinPool.hasQueuedSubmissions	(	): Returns true if there are any tasks submitted to this pool that have not yet begun executing.
java.util.concurrent.ForkJoinPool.helpComplete	(	WorkQueue	CountedCompleter	int	): Tries to steal and run tasks within the target's computation. Uses a variant of the top-level algorithm, restricted to tasks with the given task as ancestor: It prefers taking and running eligible tasks popped from the worker's own queue (via popCC). Otherwise it scans others, randomly moving on contention or execution, deciding to give up based on a checksum (via return codes frob pollAndExecCC). The maxTasks argument supports external usages; internal calls use zero, allowing unbounded steps (external calls trap non-positive values).
java.util.concurrent.ForkJoinPool.helpQuiescePool	(	WorkQueue	): Runs tasks until isQuiescent(). We piggyback on active count ctl maintenance, but rather than blocking when tasks cannot be found, we rescan until all others cannot find tasks either.
java.util.concurrent.ForkJoinPool.helpStealer	(	WorkQueue	ForkJoinTask	): Tries to locate and execute tasks for a stealer of the given task, or in turn one of its stealers, Traces currentSteal -> currentJoin links looking for a thread working on a descendant of the given task and with a non-empty queue to steal back and execute tasks from. The first call to this method upon a waiting join will often entail scanning/search, (which is OK because the joiner has nothing better to do), but this method leaves hints in workers to speed up subsequent calls.
java.util.concurrent.ForkJoinPool.invoke	(	ForkJoinTask	): Performs the given task, returning its result upon completion. If the computation encounters an unchecked Exception or Error, it is rethrown as the outcome of this invocation. Rethrown exceptions behave in the same way as regular exceptions, but, when possible, contain stack traces (as displayed for example using ex.printStackTrace()) of both the current thread as well as the thread actually encountering the exception; minimally only the latter.
java.util.concurrent.ForkJoinPool.invokeAll	(	Collection	): 
java.util.concurrent.ForkJoinPool.isQuiescent	(	): Returns true if all worker threads are currently idle. An idle worker is one that cannot obtain a task to execute because none are available to steal from other threads, and there are no pending submissions to the pool. This method is conservative; it might not return true immediately upon idleness of all threads, but will eventually become true if threads remain inactive.
java.util.concurrent.ForkJoinPool.isShutdown	(	): Returns true if this pool has been shut down.
java.util.concurrent.ForkJoinPool.isTerminated	(	): Returns true if all tasks have completed following shut down.
java.util.concurrent.ForkJoinPool.isTerminating	(	): Returns true if the process of termination has commenced but not yet completed. This method may be useful for debugging. A return of true reported a sufficient period after shutdown may indicate that submitted tasks have ignored or suppressed interruption, or are waiting for I/O, causing this executor not to properly terminate. (See the advisory notes for class ForkJoinTask stating that tasks should not normally entail blocking operations. But if they do, they must abort them on interrupt.)
java.util.concurrent.ForkJoinPool.lockRunState	(	): Acquires the runState lock; returns current (locked) runState.
java.util.concurrent.ForkJoinPool.makeCommonPool	(	): Creates and returns the common pool, respecting user settings specified via system properties.
java.util.concurrent.ForkJoinPool.managedBlock	(	ManagedBlocker	): Runs the given possibly blocking task. When inForkJoinPool() running in a ForkJoinPool, this method possibly arranges for a spare thread to be activated if necessary to ensure sufficient parallelism while the current thread is blocked in block blocker.block(). This method repeatedly calls blocker.isReleasable() and blocker.block() until either method returns true. Every call to blocker.block() is preceded by a call to blocker.isReleasable() that returned false. If not running in a ForkJoinPool, this method is behaviorally equivalent to  while (!blocker.isReleasable()) if (blocker.block()) break; If running in a ForkJoinPool, the pool may first be expanded to ensure sufficient parallelism available during the call to blocker.block().
java.util.concurrent.ForkJoinPool.nextPoolId	(	): Returns the next sequence number. We don't expect this to ever contend, so use simple builtin sync.
java.util.concurrent.ForkJoinPool.nextTaskFor	(	WorkQueue	): Gets and removes a local or stolen task for the given worker.
java.util.concurrent.ForkJoinPool.pollSubmission	(	): Removes and returns the next unexecuted submission if one is available. This method may be useful in extensions to this class that re-assign work in systems with multiple pools.
java.util.concurrent.ForkJoinPool.quiesceCommonPool	(	): Waits and/or attempts to assist performing tasks indefinitely until the commonPool() isQuiescent.
java.util.concurrent.ForkJoinPool.registerWorker	(	ForkJoinWorkerThread	): Callback from ForkJoinWorkerThread constructor to establish and record its WorkQueue.
java.util.concurrent.ForkJoinPool.runWorker	(	WorkQueue	): Top-level runloop for workers, called by ForkJoinWorkerThread.run.
java.util.concurrent.ForkJoinPool.scan	(	WorkQueue	int	): Scans for and tries to steal a top-level task. Scans start at a random location, randomly moving on apparent contention, otherwise continuing linearly until reaching two consecutive empty passes over all queues with the same checksum (summing each base index of each queue, that moves on each steal), at which point the worker tries to inactivate and then re-scans, attempting to re-activate (itself or some other worker) if finding a task; otherwise returning null to await work. Scans otherwise touch as little memory as possible, to reduce disruption on other scanning threads.
java.util.concurrent.ForkJoinPool.shutdown	(	): Possibly initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted. Invocation has no effect on execution state if this is the commonPool(), and no additional effect if already shut down. Tasks that are in the process of being submitted concurrently during the course of this method may or may not be rejected.
java.util.concurrent.ForkJoinPool.shutdownNow	(	): Possibly attempts to cancel and/or stop all tasks, and reject all subsequently submitted tasks. Invocation has no effect on execution state if this is the commonPool(), and no additional effect if already shut down. Otherwise, tasks that are in the process of being submitted or executed concurrently during the course of this method may or may not be rejected. This method cancels both existing and unexecuted tasks, in order to permit termination in the presence of task dependencies. So the method always returns an empty list (unlike the case for some other Executors).
java.util.concurrent.ForkJoinPool.signalWork	(	WorkQueue[]	WorkQueue	): Tries to create or activate a worker if too few are active.
java.util.concurrent.ForkJoinPool.submit	(	Callable	): Submits a value-returning task for execution and returns a Future representing the pending results of the task. The Future's get method will return the task's result upon successful completion.  If you would like to immediately block waiting for a task, you can use constructions of the form result = exec.submit(aCallable).get(); Note: The Executors class includes a set of methods that can convert some other common closure-like objects, for example, java.security.PrivilegedAction to Callable form so they can be submitted.
java.util.concurrent.ForkJoinPool.submit	(	ForkJoinTask	): Submits a ForkJoinTask for execution.
java.util.concurrent.ForkJoinPool.submit	(	Runnable	): Submits a Runnable task for execution and returns a Future representing that task. The Future's get method will return null upon successful completion.
java.util.concurrent.ForkJoinPool.submit	(	Runnable	T	): Submits a Runnable task for execution and returns a Future representing that task. The Future's get method will return the given result upon successful completion.
java.util.concurrent.ForkJoinPool.toString	(	): Returns a string identifying this pool, as well as its state, including indications of run state, parallelism level, and worker and task counts.
java.util.concurrent.ForkJoinPool.tryAddWorker	(	long	): Tries to add one worker, incrementing ctl counts before doing so, relying on createWorker to back out on failure.
java.util.concurrent.ForkJoinPool.tryCompensate	(	WorkQueue	): Tries to decrement active count (sometimes implicitly) and possibly release or create a compensating worker in preparation for blocking. Returns false (retryable by caller), on contention, detected staleness, instability, or termination.
java.util.concurrent.ForkJoinPool.tryExternalUnpush	(	ForkJoinTask	): Performs tryUnpush for an external submitter: Finds queue, locks if apparently non-empty, validates upon locking, and adjusts top. Each check can fail but rarely does.
java.util.concurrent.ForkJoinPool.tryRelease	(	long	WorkQueue	long	): Signals and releases worker v if it is top of idle worker stack. This performs a one-shot version of signalWork only if there is (apparently) at least one idle worker.
java.util.concurrent.ForkJoinPool.tryTerminate	(	boolean	boolean	): Possibly initiates and/or completes termination.
java.util.concurrent.ForkJoinPool.unlockRunState	(	int	int	): Unlocks and sets runState to newRunState.
java.util.concurrent.ForkJoinTask: Abstract base class for tasks that run within a ForkJoinPool. A ForkJoinTask is a thread-like entity that is much lighter weight than a normal thread. Huge numbers of tasks and subtasks may be hosted by a small number of actual threads in a ForkJoinPool, at the price of some usage limitations. A "main" ForkJoinTask begins execution when it is explicitly submitted to a ForkJoinPool, or, if not already engaged in a ForkJoin computation, commenced in the commonPool() via fork, invoke, or related methods. Once started, it will usually in turn start other subtasks. As indicated by the name of this class, many programs using ForkJoinTask employ only methods fork and join, or derivatives such as invokeAll(). However, this class also provides a number of other methods that can come into play in advanced usages, as well as extension mechanics that allow support of new forms of fork/join processing. A ForkJoinTask is a lightweight form of Future. The efficiency of ForkJoinTasks stems from a set of restrictions (that are only partially statically enforceable) reflecting their main use as computational tasks calculating pure functions or operating on purely isolated objects. The primary coordination mechanisms are fork, that arranges asynchronous execution, and join, that doesn't proceed until the task's result has been computed. Computations should ideally avoid synchronized methods or blocks, and should minimize other blocking synchronization apart from joining other tasks or using synchronizers such as Phasers that are advertised to cooperate with fork/join scheduling. Subdividable tasks should also not perform blocking I/O, and should ideally access variables that are completely independent of those accessed by other running tasks. These guidelines are loosely enforced by not permitting checked exceptions such as IOExceptions to be thrown. However, computations may still encounter unchecked exceptions, that are rethrown to callers attempting to join them. These exceptions may additionally include RejectedExecutionException stemming from internal resource exhaustion, such as failure to allocate internal task queues. Rethrown exceptions behave in the same way as regular exceptions, but, when possible, contain stack traces (as displayed for example using ex.printStackTrace()) of both the thread that initiated the computation as well as the thread actually encountering the exception; minimally only the latter. It is possible to define and use ForkJoinTasks that may block, but doing do requires three further considerations: (1) Completion of few if any other tasks should be dependent on a task that blocks on external synchronization or I/O. Event-style async tasks that are never joined (for example, those subclassing CountedCompleter) often fall into this category. (2) To minimize resource impact, tasks should be small; ideally performing only the (possibly) blocking action. (3) Unless the ForkJoinPool.ManagedBlocker API is used, or the number of possibly blocked tasks is known to be less than the pool's getParallelism level, the pool cannot guarantee that enough threads will be available to ensure progress or good performance. The primary method for awaiting completion and extracting results of a task is join, but there are several variants: The get methods support interruptible and/or timed waits for completion and report results using Future conventions. Method invoke is semantically equivalent to fork(); join() but always attempts to begin execution in the current thread. The "quiet" forms of these methods do not extract results or report exceptions. These may be useful when a set of tasks are being executed, and you need to delay processing of results or exceptions until all complete. Method invokeAll (available in multiple versions) performs the most common form of parallel invocation: forking a set of tasks and joining them all. In the most typical usages, a fork-join pair act like a call (fork) and return (join) from a parallel recursive function. As is the case with other forms of recursive calls, returns (joins) should be performed innermost-first. For example, a.fork(); b.fork(); b.join(); a.join(); is likely to be substantially more efficient than joining a before b. The execution status of tasks may be queried at several levels of detail: isDone is true if a task completed in any way (including the case where a task was cancelled without executing); isCompletedNormally is true if a task completed without cancellation or encountering an exception; isCancelled is true if the task was cancelled (in which case getException returns a java.util.concurrent.CancellationException); and isCompletedAbnormally is true if a task was either cancelled or encountered an exception, in which case getException will return either the encountered exception or java.util.concurrent.CancellationException. The ForkJoinTask class is not usually directly subclassed. Instead, you subclass one of the abstract classes that support a particular style of fork/join processing, typically RecursiveAction for most computations that do not return results, RecursiveTask for those that do, and CountedCompleter for those in which completed actions trigger other actions. Normally, a concrete ForkJoinTask subclass declares fields comprising its parameters, established in a constructor, and then defines a compute method that somehow uses the control methods supplied by this base class. Method join and its variants are appropriate for use only when completion dependencies are acyclic; that is, the parallel computation can be described as a directed acyclic graph (DAG). Otherwise, executions may encounter a form of deadlock as tasks cyclically wait for each other. However, this framework supports other methods and techniques (for example the use of Phaser, helpQuiesce, and complete) that may be of use in constructing custom subclasses for problems that are not statically structured as DAGs. To support such usages, a ForkJoinTask may be atomically tagged with a short value using setForkJoinTaskTag or compareAndSetForkJoinTaskTag and checked using getForkJoinTaskTag. The ForkJoinTask implementation does not use these protected methods or tags for any purpose, but they may be of use in the construction of specialized subclasses. For example, parallel graph traversals can use the supplied methods to avoid revisiting nodes/tasks that have already been processed. (Method names for tagging are bulky in part to encourage definition of methods that reflect their usage patterns.) Most base support methods are final, to prevent overriding of implementations that are intrinsically tied to the underlying lightweight task scheduling framework. Developers creating new basic styles of fork/join processing should minimally implement protected methods exec, setRawResult, and getRawResult, while also introducing an abstract computational method that can be implemented in its subclasses, possibly relying on other protected methods provided by this class. ForkJoinTasks should perform relatively small amounts of computation. Large tasks should be split into smaller subtasks, usually via recursive decomposition. As a very rough rule of thumb, a task should perform more than 100 and less than 10000 basic computational steps, and should avoid indefinite looping. If tasks are too big, then parallelism cannot improve throughput. If too small, then memory and internal task maintenance overhead may overwhelm processing. This class provides adapt methods for Runnable and Callable, that may be of use when mixing execution of ForkJoinTasks with other kinds of tasks. When all tasks are of this form, consider using a pool constructed in asyncMode. ForkJoinTasks are Serializable, which enables them to be used in extensions such as remote execution frameworks. It is sensible to serialize tasks only before or after, but not during, execution. Serialization is not relied on during execution itself.
java.util.concurrent.ForkJoinTask.AdaptedCallable: Adaptor for Callables
java.util.concurrent.ForkJoinTask.AdaptedRunnable: Adaptor for Runnables. This implements RunnableFuture to be compliant with AbstractExecutorService constraints when used in ForkJoinPool.
java.util.concurrent.ForkJoinTask.AdaptedRunnableAction: Adaptor for Runnables without results
java.util.concurrent.ForkJoinTask.ExceptionNode: Key-value nodes for exception table. The chained hash table uses identity comparisons, full locking, and weak references for keys. The table has a fixed capacity because it only maintains task exceptions long enough for joiners to access them, so should never become very large for sustained periods. However, since we do not know when the last joiner completes, we must use weak references and expunge them. We do so on each operation (hence full locking). Also, some thread in any ForkJoinPool will call helpExpungeStaleExceptions when its pool becomes isQuiescent.
java.util.concurrent.ForkJoinTask.RunnableExecuteAction: Adaptor for Runnables in which failure forces worker exception
java.util.concurrent.ForkJoinTask.adapt	(	Callable	): Returns a new ForkJoinTask that performs the call method of the given Callable as its action, and returns its result upon join, translating any checked exceptions encountered into RuntimeException.
java.util.concurrent.ForkJoinTask.adapt	(	Runnable	): Returns a new ForkJoinTask that performs the run method of the given Runnable as its action, and returns a null result upon join.
java.util.concurrent.ForkJoinTask.adapt	(	Runnable	T	): Returns a new ForkJoinTask that performs the run method of the given Runnable as its action, and returns the given result upon join.
java.util.concurrent.ForkJoinTask.cancel	(	boolean	): Attempts to cancel execution of this task. This attempt will fail if the task has already completed or could not be cancelled for some other reason. If successful, and this task has not started when cancel is called, execution of this task is suppressed. After this method returns successfully, unless there is an intervening call to reinitialize, subsequent calls to isCancelled, isDone, and cancel will return true and calls to join and related methods will result in CancellationException. This method may be overridden in subclasses, but if so, must still ensure that these properties hold. In particular, the cancel method itself must not throw exceptions. This method is designed to be invoked by other tasks. To terminate the current task, you can just return or throw an unchecked exception from its computation method, or invoke completeExceptionally().
java.util.concurrent.ForkJoinTask.cancelIgnoringExceptions	(	ForkJoinTask	): Cancels, ignoring any exceptions thrown by cancel. Used during worker and pool shutdown. Cancel is spec'ed not to throw any exceptions, but if it does anyway, we have no recourse during shutdown, so guard against this case.
java.util.concurrent.ForkJoinTask.clearExceptionalCompletion	(	): Removes exception node and clears status.
java.util.concurrent.ForkJoinTask.compareAndSetForkJoinTaskTag	(	short	short	): Atomically conditionally sets the tag value for this task. Among other applications, tags can be used as visit markers in tasks operating on graphs, as in methods that check: if (task.compareAndSetForkJoinTaskTag((short)0, (short)1)) before processing, otherwise exiting because the node has already been visited.
java.util.concurrent.ForkJoinTask.complete	(	V	): Completes this task, and if not already aborted or cancelled, returning the given value as the result of subsequent invocations of join and related operations. This method may be used to provide results for asynchronous tasks, or to provide alternative handling for tasks that would not otherwise complete normally. Its use in other situations is discouraged. This method is overridable, but overridden versions must invoke super implementation to maintain guarantees.
java.util.concurrent.ForkJoinTask.completeExceptionally	(	Throwable	): Completes this task abnormally, and if not already aborted or cancelled, causes it to throw the given exception upon join and related operations. This method may be used to induce exceptions in asynchronous tasks, or to force completion of tasks that would not otherwise complete. Its use in other situations is discouraged. This method is overridable, but overridden versions must invoke super implementation to maintain guarantees.
java.util.concurrent.ForkJoinTask.doExec	(	): Primary execution method for stolen tasks. Unless done, calls exec and records status if completed, but doesn't wait for completion otherwise.
java.util.concurrent.ForkJoinTask.doInvoke	(	): Implementation for invoke, quietlyInvoke.
java.util.concurrent.ForkJoinTask.doJoin	(	): Implementation for join, get, quietlyJoin. Directly handles only cases of already-completed, external wait, and unfork+exec. Others are relayed to ForkJoinPool.awaitJoin.
java.util.concurrent.ForkJoinTask.exec	(	): Immediately performs the base action of this task and returns true if, upon return from this method, this task is guaranteed to have completed normally. This method may return false otherwise, to indicate that this task is not necessarily complete (or is not known to be complete), for example in asynchronous actions that require explicit invocations of completion methods. This method may also throw an (unchecked) exception to indicate abnormal exit. This method is designed to support extensions, and should not in general be called otherwise.
java.util.concurrent.ForkJoinTask.expungeStaleExceptions	(	): Poll stale refs and remove them. Call only while holding lock.
java.util.concurrent.ForkJoinTask.externalAwaitDone	(	): Blocks a non-worker-thread until completion.
java.util.concurrent.ForkJoinTask.externalInterruptibleAwaitDone	(	): Blocks a non-worker-thread until completion or interruption.
java.util.concurrent.ForkJoinTask.fork	(	): Arranges to asynchronously execute this task in the pool the current task is running in, if applicable, or using the commonPool() if not inForkJoinPool. While it is not necessarily enforced, it is a usage error to fork a task more than once unless it has completed and been reinitialized. Subsequent modifications to the state of this task or any data it operates on are not necessarily consistently observable by any thread other than the one executing it unless preceded by a call to join or related methods, or a call to isDone returning true.
java.util.concurrent.ForkJoinTask.get	(	): Waits if necessary for the computation to complete, and then retrieves its result.
java.util.concurrent.ForkJoinTask.get	(	long	TimeUnit	): Waits if necessary for at most the given time for the computation to complete, and then retrieves its result, if available.
java.util.concurrent.ForkJoinTask.getException	(	): Returns the exception thrown by the base computation, or a CancellationException if cancelled, or null if none or if the method has not yet completed.
java.util.concurrent.ForkJoinTask.getForkJoinTaskTag	(	): Returns the tag for this task.
java.util.concurrent.ForkJoinTask.getPool	(	): Returns the pool hosting the current task execution, or null if this task is executing outside of any ForkJoinPool.
java.util.concurrent.ForkJoinTask.getQueuedTaskCount	(	): Returns an estimate of the number of tasks that have been forked by the current worker thread but not yet executed. This value may be useful for heuristic decisions about whether to fork other tasks.
java.util.concurrent.ForkJoinTask.getRawResult	(	): Returns the result that would be returned by join, even if this task completed abnormally, or null if this task is not known to have been completed. This method is designed to aid debugging, as well as to support extensions. Its use in any other context is discouraged.
java.util.concurrent.ForkJoinTask.getSurplusQueuedTaskCount	(	): Returns an estimate of how many more locally queued tasks are held by the current worker thread than there are other worker threads that might steal them, or zero if this thread is not operating in a ForkJoinPool. This value may be useful for heuristic decisions about whether to fork other tasks. In many usages of ForkJoinTasks, at steady state, each worker should aim to maintain a small constant surplus (for example, 3) of tasks, and to process computations locally if this threshold is exceeded.
java.util.concurrent.ForkJoinTask.getThrowableException	(	): Returns a rethrowable exception for the given task, if available. To provide accurate stack traces, if the exception was not thrown by the current thread, we try to create a new exception of the same type as the one thrown, but with the recorded exception as its cause. If there is no such constructor, we instead try to use a no-arg constructor, followed by initCause, to the same effect. If none of these apply, or any fail due to other exceptions, we return the recorded exception, which is still correct, although it may contain a misleading stack trace.
java.util.concurrent.ForkJoinTask.helpExpungeStaleExceptions	(	): If lock is available, poll stale refs and remove them. Called from ForkJoinPool when pools become quiescent.
java.util.concurrent.ForkJoinTask.helpQuiesce	(	): Possibly executes tasks until the pool hosting the current task isQuiescent is quiescent. This method may be of use in designs in which many tasks are forked, but none are explicitly joined, instead executing them until all are processed.
java.util.concurrent.ForkJoinTask.inForkJoinPool	(	): Returns true if the current thread is a ForkJoinWorkerThread executing as a ForkJoinPool computation.
java.util.concurrent.ForkJoinTask.internalPropagateException	(	Throwable	): Hook for exception propagation support for tasks with completers.
java.util.concurrent.ForkJoinTask.internalWait	(	long	): If not done, sets SIGNAL status and performs Object.wait(timeout). This task may or may not be done on exit. Ignores interrupts.
java.util.concurrent.ForkJoinTask.invoke	(	): Commences performing this task, awaits its completion if necessary, and returns its result, or throws an (unchecked) RuntimeException or Error if the underlying computation did so.
java.util.concurrent.ForkJoinTask.invokeAll	(	Collection	): Forks all tasks in the specified collection, returning when isDone holds for each task or an (unchecked) exception is encountered, in which case the exception is rethrown. If more than one task encounters an exception, then this method throws any one of these exceptions. If any task encounters an exception, others may be cancelled. However, the execution status of individual tasks is not guaranteed upon exceptional return. The status of each task may be obtained using getException() and related methods to check if they have been cancelled, completed normally or exceptionally, or left unprocessed.
java.util.concurrent.ForkJoinTask.invokeAll	(	ForkJoinTask	): Forks the given tasks, returning when isDone holds for each task or an (unchecked) exception is encountered, in which case the exception is rethrown. If more than one task encounters an exception, then this method throws any one of these exceptions. If any task encounters an exception, others may be cancelled. However, the execution status of individual tasks is not guaranteed upon exceptional return. The status of each task may be obtained using getException() and related methods to check if they have been cancelled, completed normally or exceptionally, or left unprocessed.
java.util.concurrent.ForkJoinTask.invokeAll	(	ForkJoinTask	ForkJoinTask	): Forks the given tasks, returning when isDone holds for each task or an (unchecked) exception is encountered, in which case the exception is rethrown. If more than one task encounters an exception, then this method throws any one of these exceptions. If any task encounters an exception, the other may be cancelled. However, the execution status of individual tasks is not guaranteed upon exceptional return. The status of each task may be obtained using getException() and related methods to check if they have been cancelled, completed normally or exceptionally, or left unprocessed.
java.util.concurrent.ForkJoinTask.isCompletedAbnormally	(	): Returns true if this task threw an exception or was cancelled.
java.util.concurrent.ForkJoinTask.isCompletedNormally	(	): Returns true if this task completed without throwing an exception and was not cancelled.
java.util.concurrent.ForkJoinTask.join	(	): Returns the result of the computation when it isDone is done. This method differs from get() in that abnormal completion results in RuntimeException or Error, not ExecutionException, and that interrupts of the calling thread do not cause the method to abruptly return by throwing InterruptedException.
java.util.concurrent.ForkJoinTask.peekNextLocalTask	(	): Returns, but does not unschedule or execute, a task queued by the current thread but not yet executed, if one is immediately available. There is no guarantee that this task will actually be polled or executed next. Conversely, this method may return null even if a task exists but cannot be accessed without contention with other threads. This method is designed primarily to support extensions, and is unlikely to be useful otherwise.
java.util.concurrent.ForkJoinTask.pollNextLocalTask	(	): Unschedules and returns, without executing, the next task queued by the current thread but not yet executed, if the current thread is operating in a ForkJoinPool. This method is designed primarily to support extensions, and is unlikely to be useful otherwise.
java.util.concurrent.ForkJoinTask.pollTask	(	): If the current thread is operating in a ForkJoinPool, unschedules and returns, without executing, the next task queued by the current thread but not yet executed, if one is available, or if not available, a task that was forked by some other thread, if available. Availability may be transient, so a null result does not necessarily imply quiescence of the pool this task is operating in. This method is designed primarily to support extensions, and is unlikely to be useful otherwise.
java.util.concurrent.ForkJoinTask.quietlyComplete	(	): Completes this task normally without setting a value. The most recent value established by setRawResult (or null by default) will be returned as the result of subsequent invocations of join and related operations.
java.util.concurrent.ForkJoinTask.quietlyInvoke	(	): Commences performing this task and awaits its completion if necessary, without returning its result or throwing its exception.
java.util.concurrent.ForkJoinTask.quietlyJoin	(	): Joins this task, without returning its result or throwing its exception. This method may be useful when processing collections of tasks when some have been cancelled or otherwise known to have aborted.
java.util.concurrent.ForkJoinTask.readObject	(	java.io.ObjectInputStream	): Reconstitutes this task from a stream (that is, deserializes it).
java.util.concurrent.ForkJoinTask.recordExceptionalCompletion	(	Throwable	): Records exception and sets status.
java.util.concurrent.ForkJoinTask.reinitialize	(	): Resets the internal bookkeeping state of this task, allowing a subsequent fork. This method allows repeated reuse of this task, but only if reuse occurs when this task has either never been forked, or has been forked, then completed and all outstanding joins of this task have also completed. Effects under any other usage conditions are not guaranteed. This method may be useful when executing pre-constructed trees of subtasks in loops. Upon completion of this method, isDone() reports false, and getException() reports null. However, the value returned by getRawResult is unaffected. To clear this value, you can invoke setRawResult(null).
java.util.concurrent.ForkJoinTask.reportException	(	int	): Throws exception, if any, associated with the given status.
java.util.concurrent.ForkJoinTask.rethrow	(	Throwable	): A version of "sneaky throw" to relay exceptions
java.util.concurrent.ForkJoinTask.setCompletion	(	int	): Marks completion and wakes up threads waiting to join this task.
java.util.concurrent.ForkJoinTask.setExceptionalCompletion	(	Throwable	): Records exception and possibly propagates.
java.util.concurrent.ForkJoinTask.setForkJoinTaskTag	(	short	): Atomically sets the tag value for this task.
java.util.concurrent.ForkJoinTask.setRawResult	(	V	): Forces the given value to be returned as a result. This method is designed to support extensions, and should not in general be called otherwise.
java.util.concurrent.ForkJoinTask.tryUnfork	(	): Tries to unschedule this task for execution. This method will typically (but is not guaranteed to) succeed if this task is the most recently forked task by the current thread, and has not commenced executing in another thread. This method may be useful when arranging alternative local processing of tasks that could have been, but were not, stolen.
java.util.concurrent.ForkJoinTask.uncheckedThrow	(	Throwable	): The sneaky part of sneaky throw, relying on generics limitations to evade compiler complaints about rethrowing unchecked exceptions
java.util.concurrent.ForkJoinTask.writeObject	(	java.io.ObjectOutputStream	): Saves this task to a stream (that is, serializes it).
java.util.concurrent.ForkJoinWorkerThread: A thread managed by a ForkJoinPool, which executes ForkJoinTasks. This class is subclassable solely for the sake of adding functionality -- there are no overridable methods dealing with scheduling or execution. However, you can override initialization and termination methods surrounding the main task processing loop. If you do create such a subclass, you will also need to supply a custom ForkJoinPool.ForkJoinWorkerThreadFactory to ForkJoinPool use it in a ForkJoinPool.
java.util.concurrent.ForkJoinWorkerThread.ForkJoinWorkerThread	(	ForkJoinPool	): Creates a ForkJoinWorkerThread operating in the given pool.
java.util.concurrent.ForkJoinWorkerThread.ForkJoinWorkerThread	(	ForkJoinPool	ThreadGroup	AccessControlContext	): Version for InnocuousForkJoinWorkerThread
java.util.concurrent.ForkJoinWorkerThread.InnocuousForkJoinWorkerThread: A worker thread that has no permissions, is not a member of any user-defined ThreadGroup, and erases all ThreadLocals after running each top-level task.
java.util.concurrent.ForkJoinWorkerThread.InnocuousForkJoinWorkerThread.createThreadGroup	(	): Returns a new group with the system ThreadGroup (the topmost, parent-less group) as parent. Uses Unsafe to traverse Thread.group and ThreadGroup.parent fields.
java.util.concurrent.ForkJoinWorkerThread.afterTopLevelExec	(	): Non-public hook method for InnocuousForkJoinWorkerThread
java.util.concurrent.ForkJoinWorkerThread.eraseThreadLocals	(	): Erases ThreadLocals by nulling out Thread maps.
java.util.concurrent.ForkJoinWorkerThread.getPool	(	): Returns the pool hosting this thread.
java.util.concurrent.ForkJoinWorkerThread.getPoolIndex	(	): Returns the unique index number of this thread in its pool. The returned value ranges from zero to the maximum number of threads (minus one) that may exist in the pool, and does not change during the lifetime of the thread. This method may be useful for applications that track status or collect results per-worker-thread rather than per-task.
java.util.concurrent.ForkJoinWorkerThread.onStart	(	): Initializes internal state after construction but before processing any tasks. If you override this method, you must invoke super.onStart() at the beginning of the method. Initialization requires care: Most fields must have legal default values, to ensure that attempted accesses from other threads work correctly even before this thread starts processing tasks.
java.util.concurrent.ForkJoinWorkerThread.onTermination	(	Throwable	): Performs cleanup associated with termination of this worker thread. If you override this method, you must invoke super.onTermination at the end of the overridden method.
java.util.concurrent.ForkJoinWorkerThread.run	(	): This method is required to be public, but should never be called explicitly. It performs the main run loop to execute ForkJoinTasks.
java.util.concurrent.Future: A Future represents the result of an asynchronous computation. Methods are provided to check if the computation is complete, to wait for its completion, and to retrieve the result of the computation. The result can only be retrieved using method get when the computation has completed, blocking if necessary until it is ready. Cancellation is performed by the cancel method. Additional methods are provided to determine if the task completed normally or was cancelled. Once a computation has completed, the computation cannot be cancelled. If you would like to use a Future for the sake of cancellability but not provide a usable result, you can declare types of the form Future and return null as a result of the underlying task.  Sample Usage (Note that the following classes are all made-up.)  interface ArchiveSearcher { String search(String target); } class App { ExecutorService executor = ... ArchiveSearcher searcher = ... void showSearch(final String target) throws InterruptedException { Future future = executor.submit(new Callable() { public String call() { return searcher.search(target); }}); displayOtherThings(); // do other things while searching try { displayText(future.get()); // use future } catch (ExecutionException ex) { cleanup(); return; } } }} The FutureTask class is an implementation of Future that implements Runnable, and so may be executed by an Executor. For example, the above construction with submit could be replaced by:  FutureTask future = new FutureTask(new Callable() public String call() { return searcher.search(target); }}); executor.execute(future);} Memory consistency effects: Actions taken by the asynchronous computation  happen-before actions following the corresponding Future.get() in another thread.
java.util.concurrent.Future.cancel	(	boolean	): Attempts to cancel execution of this task. This attempt will fail if the task has already completed, has already been cancelled, or could not be cancelled for some other reason. If successful, and this task has not started when cancel is called, this task should never run. If the task has already started, then the mayInterruptIfRunning parameter determines whether the thread executing this task should be interrupted in an attempt to stop the task. After this method returns, subsequent calls to isDone will always return true. Subsequent calls to isCancelled will always return true if this method returned true.
java.util.concurrent.Future.get	(	): Waits if necessary for the computation to complete, and then retrieves its result.
java.util.concurrent.Future.get	(	long	TimeUnit	): Waits if necessary for at most the given time for the computation to complete, and then retrieves its result, if available.
java.util.concurrent.Future.isCancelled	(	): Returns true if this task was cancelled before it completed normally.
java.util.concurrent.Future.isDone	(	): Returns true if this task completed. Completion may be due to normal termination, an exception, or cancellation -- in all of these cases, this method will return true.
java.util.concurrent.FutureTask: A cancellable asynchronous computation. This class provides a base implementation of Future, with methods to start and cancel a computation, query to see if the computation is complete, and retrieve the result of the computation. The result can only be retrieved when the computation has completed; the get methods will block if the computation has not yet completed. Once the computation has completed, the computation cannot be restarted or cancelled (unless the computation is invoked using runAndReset). A FutureTask can be used to wrap a Callable or Runnable object. Because FutureTask implements Runnable, a FutureTask can be submitted to an Executor for execution. In addition to serving as a standalone class, this class provides protected functionality that may be useful when creating customized task classes.
java.util.concurrent.FutureTask.FutureTask	(	Callable	): Creates a FutureTask that will, upon running, execute the given Callable.
java.util.concurrent.FutureTask.FutureTask	(	Runnable	V	): Creates a FutureTask that will, upon running, execute the given Runnable, and arrange that get will return the given result on successful completion.
java.util.concurrent.FutureTask.WaitNode: Simple linked list nodes to record waiting threads in a Treiber stack. See other classes such as Phaser and SynchronousQueue for more detailed explanation.
java.util.concurrent.FutureTask.awaitDone	(	boolean	long	): Awaits completion or aborts on interrupt or timeout.
java.util.concurrent.FutureTask.done	(	): Protected method invoked when this task transitions to state isDone (whether normally or via cancellation). The default implementation does nothing. Subclasses may override this method to invoke completion callbacks or perform bookkeeping. Note that you can query status inside the implementation of this method to determine whether this task has been cancelled.
java.util.concurrent.FutureTask.finishCompletion	(	): Removes and signals all waiting threads, invokes done(), and nulls out callable.
java.util.concurrent.FutureTask.get	(	): Waits if necessary for the computation to complete, and then retrieves its result.
java.util.concurrent.FutureTask.get	(	long	TimeUnit	): Waits if necessary for at most the given time for the computation to complete, and then retrieves its result, if available.
java.util.concurrent.FutureTask.handlePossibleCancellationInterrupt	(	int	): Ensures that any interrupt from a possible cancel(true) is only delivered to a task while in run or runAndReset.
java.util.concurrent.FutureTask.removeWaiter	(	WaitNode	): Tries to unlink a timed-out or interrupted wait node to avoid accumulating garbage. Internal nodes are simply unspliced without CAS since it is harmless if they are traversed anyway by releasers. To avoid effects of unsplicing from already removed nodes, the list is retraversed in case of an apparent race. This is slow when there are a lot of nodes, but we don't expect lists to be long enough to outweigh higher-overhead schemes.
java.util.concurrent.FutureTask.report	(	int	): Returns result or throws exception for completed task.
java.util.concurrent.FutureTask.runAndReset	(	): Executes the computation without setting its result, and then resets this future to initial state, failing to do so if the computation encounters an exception or is cancelled. This is designed for use with tasks that intrinsically execute more than once.
java.util.concurrent.FutureTask.set	(	V	): Sets the result of this future to the given value unless this future has already been set or has been cancelled. This method is invoked internally by the run method upon successful completion of the computation.
java.util.concurrent.FutureTask.setException	(	Throwable	): Causes this future to report an ExecutionException with the given throwable as its cause, unless this future has already been set or has been cancelled. This method is invoked internally by the run method upon failure of the computation.
java.util.concurrent.LinkedBlockingDeque: An optionally-bounded BlockingDeque blocking deque based on linked nodes. The optional capacity bound constructor argument serves as a way to prevent excessive expansion. The capacity, if unspecified, is equal to MAX_VALUE. Linked nodes are dynamically created upon each insertion unless this would bring the deque above capacity. Most operations run in constant time (ignoring time spent blocking). Exceptions include remove(), removeFirstOccurrence, removeLastOccurrence, contains , iterator iterator.remove(), and the bulk operations, all of which run in linear time. This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces. This class is a member of the  Java Collections Framework.
java.util.concurrent.LinkedBlockingDeque.AbstractItr: Base class for Iterators for LinkedBlockingDeque
java.util.concurrent.LinkedBlockingDeque.AbstractItr.advance	(	): Advances next.
java.util.concurrent.LinkedBlockingDeque.AbstractItr.succ	(	Node	): Returns the successor node of the given non-null, but possibly previously deleted, node.
java.util.concurrent.LinkedBlockingDeque.DescendingItr: Descending iterator 
java.util.concurrent.LinkedBlockingDeque.Itr: Forward iterator 
java.util.concurrent.LinkedBlockingDeque.LBDSpliterator: A customized variant of Spliterators.IteratorSpliterator 
java.util.concurrent.LinkedBlockingDeque.LinkedBlockingDeque	(	): Creates a LinkedBlockingDeque with a capacity of MAX_VALUE.
java.util.concurrent.LinkedBlockingDeque.LinkedBlockingDeque	(	Collection	): Creates a LinkedBlockingDeque with a capacity of MAX_VALUE, initially containing the elements of the given collection, added in traversal order of the collection's iterator.
java.util.concurrent.LinkedBlockingDeque.LinkedBlockingDeque	(	int	): Creates a LinkedBlockingDeque with the given (fixed) capacity.
java.util.concurrent.LinkedBlockingDeque.Node: Doubly-linked list node class 
java.util.concurrent.LinkedBlockingDeque.add	(	E	): Inserts the specified element at the end of this deque unless it would violate capacity restrictions. When using a capacity-restricted deque, it is generally preferable to use method offer(). This method is equivalent to addLast.
java.util.concurrent.LinkedBlockingDeque.addFirst	(	E	): Inserts the specified element at the front of this deque if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available. When using a capacity-restricted deque, it is generally preferable to use offerFirst().
java.util.concurrent.LinkedBlockingDeque.addLast	(	E	): Inserts the specified element at the end of this deque if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available. When using a capacity-restricted deque, it is generally preferable to use offerLast().
java.util.concurrent.LinkedBlockingDeque.clear	(	): Atomically removes all of the elements from this deque. The deque will be empty after this call returns.
java.util.concurrent.LinkedBlockingDeque.contains	(	Object	): Returns true if this deque contains the specified element. More formally, returns true if and only if this deque contains at least one element e such that o.equals(e).
java.util.concurrent.LinkedBlockingDeque.descendingIterator	(	): Returns an iterator over the elements in this deque in reverse sequential order. The elements will be returned in order from last (tail) to first (head). The returned iterator is weakly consistent.
java.util.concurrent.LinkedBlockingDeque.drainTo	(	Collection	): Removes all available elements from this queue and adds them to the given collection. This operation may be more efficient than repeatedly polling this queue. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.LinkedBlockingDeque.drainTo	(	Collection	int	): Removes at most the given number of available elements from this queue and adds them to the given collection. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.LinkedBlockingDeque.element	(	): Retrieves, but does not remove, the head of the queue represented by this deque. This method differs from peek only in that it throws an exception if this deque is empty. This method is equivalent to getFirst().
java.util.concurrent.LinkedBlockingDeque.getFirst	(	): Retrieves, but does not remove, the first element of this deque. This method differs from peekFirst only in that it throws an exception if this deque is empty.
java.util.concurrent.LinkedBlockingDeque.getLast	(	): Retrieves, but does not remove, the last element of this deque. This method differs from peekLast only in that it throws an exception if this deque is empty.
java.util.concurrent.LinkedBlockingDeque.iterator	(	): Returns an iterator over the elements in this deque in proper sequence. The elements will be returned in order from first (head) to last (tail). The returned iterator is weakly consistent.
java.util.concurrent.LinkedBlockingDeque.linkFirst	(	Node	): Links node as first element, or returns false if full.
java.util.concurrent.LinkedBlockingDeque.linkLast	(	Node	): Links node as last element, or returns false if full.
java.util.concurrent.LinkedBlockingDeque.offer	(	E	): Inserts the specified element into this queue if it is possible to do so immediately without violating capacity restrictions. When using a capacity-restricted queue, this method is generally preferable to add, which can fail to insert an element only by throwing an exception.
java.util.concurrent.LinkedBlockingDeque.offer	(	E	long	TimeUnit	): Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque), waiting up to the specified wait time if necessary for space to become available. This method is equivalent to offerLast().
java.util.concurrent.LinkedBlockingDeque.offerFirst	(	E	): Inserts the specified element at the front of this deque if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available. When using a capacity-restricted deque, this method is generally preferable to the addFirst() method, which can fail to insert an element only by throwing an exception.
java.util.concurrent.LinkedBlockingDeque.offerFirst	(	E	long	TimeUnit	): Inserts the specified element at the front of this deque, waiting up to the specified wait time if necessary for space to become available.
java.util.concurrent.LinkedBlockingDeque.offerLast	(	E	): Inserts the specified element at the end of this deque if it is possible to do so immediately without violating capacity restrictions, returning true upon success and false if no space is currently available. When using a capacity-restricted deque, this method is generally preferable to the addLast() method, which can fail to insert an element only by throwing an exception.
java.util.concurrent.LinkedBlockingDeque.offerLast	(	E	long	TimeUnit	): Inserts the specified element at the end of this deque, waiting up to the specified wait time if necessary for space to become available.
java.util.concurrent.LinkedBlockingDeque.pop	(	): Pops an element from the stack represented by this deque. In other words, removes and returns the first element of this deque. This method is equivalent to removeFirst().
java.util.concurrent.LinkedBlockingDeque.push	(	E	): Pushes an element onto the stack represented by this deque (in other words, at the head of this deque) if it is possible to do so immediately without violating capacity restrictions, throwing an IllegalStateException if no space is currently available. This method is equivalent to addFirst().
java.util.concurrent.LinkedBlockingDeque.put	(	E	): Inserts the specified element into the queue represented by this deque (in other words, at the tail of this deque), waiting if necessary for space to become available. This method is equivalent to putLast().
java.util.concurrent.LinkedBlockingDeque.putFirst	(	E	): Inserts the specified element at the front of this deque, waiting if necessary for space to become available.
java.util.concurrent.LinkedBlockingDeque.putLast	(	E	): Inserts the specified element at the end of this deque, waiting if necessary for space to become available.
java.util.concurrent.LinkedBlockingDeque.readObject	(	java.io.ObjectInputStream	): Reconstitutes this deque from a stream (that is, deserializes it).
java.util.concurrent.LinkedBlockingDeque.remainingCapacity	(	): Returns the number of additional elements that this deque can ideally (in the absence of memory or resource constraints) accept without blocking. This is always equal to the initial capacity of this deque less the current size of this deque. Note that you cannot always tell if an attempt to insert an element will succeed by inspecting remainingCapacity because it may be the case that another thread is about to insert or remove an element.
java.util.concurrent.LinkedBlockingDeque.remove	(	): Retrieves and removes the head of the queue represented by this deque. This method differs from poll only in that it throws an exception if this deque is empty. This method is equivalent to removeFirst().
java.util.concurrent.LinkedBlockingDeque.remove	(	Object	): Removes the first occurrence of the specified element from this deque. If the deque does not contain the element, it is unchanged. More formally, removes the first element e such that o.equals(e) (if such an element exists). Returns true if this deque contained the specified element (or equivalently, if this deque changed as a result of the call). This method is equivalent to removeFirstOccurrence().
java.util.concurrent.LinkedBlockingDeque.removeFirst	(	): Retrieves and removes the first element of this deque. This method differs from pollFirst only in that it throws an exception if this deque is empty.
java.util.concurrent.LinkedBlockingDeque.removeLast	(	): Retrieves and removes the last element of this deque. This method differs from pollLast only in that it throws an exception if this deque is empty.
java.util.concurrent.LinkedBlockingDeque.size	(	): Returns the number of elements in this deque.
java.util.concurrent.LinkedBlockingDeque.spliterator	(	): Returns a Spliterator over the elements in this deque. The returned spliterator is weakly consistent. The Spliterator reports CONCURRENT, ORDERED, and NONNULL.
java.util.concurrent.LinkedBlockingDeque.toArray	(	): Returns an array containing all of the elements in this deque, in proper sequence (from first to last element). The returned array will be "safe" in that no references to it are maintained by this deque. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.concurrent.LinkedBlockingDeque.toArray	(	T[]	): Returns an array containing all of the elements in this deque, in proper sequence; the runtime type of the returned array is that of the specified array. If the deque fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this deque. If this deque fits in the specified array with room to spare (i.e., the array has more elements than this deque), the element in the array immediately following the end of the deque is set to null. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a deque known to contain only strings. The following code can be used to dump the deque into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.concurrent.LinkedBlockingDeque.unlink	(	Node	): Unlinks x.
java.util.concurrent.LinkedBlockingDeque.unlinkFirst	(	): Removes and returns first element, or null if empty.
java.util.concurrent.LinkedBlockingDeque.unlinkLast	(	): Removes and returns last element, or null if empty.
java.util.concurrent.LinkedBlockingDeque.writeObject	(	java.io.ObjectOutputStream	): Saves this deque to a stream (that is, serializes it).
java.util.concurrent.LinkedBlockingQueue: An optionally-bounded BlockingQueue blocking queue based on linked nodes. This queue orders elements FIFO (first-in-first-out). The head of the queue is that element that has been on the queue the longest time. The tail of the queue is that element that has been on the queue the shortest time. New elements are inserted at the tail of the queue, and the queue retrieval operations obtain elements at the head of the queue. Linked queues typically have higher throughput than array-based queues but less predictable performance in most concurrent applications. The optional capacity bound constructor argument serves as a way to prevent excessive queue expansion. The capacity, if unspecified, is equal to MAX_VALUE. Linked nodes are dynamically created upon each insertion unless this would bring the queue above capacity. This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces. This class is a member of the  Java Collections Framework.
java.util.concurrent.LinkedBlockingQueue.Itr.nextNode	(	Node	): Returns the next live successor of p, or null if no such. Unlike other traversal methods, iterators need to handle both: - dequeued nodes (p.next == p) - (possibly multiple) interior removed nodes (p.item == null)
java.util.concurrent.LinkedBlockingQueue.LBQSpliterator: A customized variant of Spliterators.IteratorSpliterator 
java.util.concurrent.LinkedBlockingQueue.LinkedBlockingQueue	(	): Creates a LinkedBlockingQueue with a capacity of MAX_VALUE.
java.util.concurrent.LinkedBlockingQueue.LinkedBlockingQueue	(	Collection	): Creates a LinkedBlockingQueue with a capacity of MAX_VALUE, initially containing the elements of the given collection, added in traversal order of the collection's iterator.
java.util.concurrent.LinkedBlockingQueue.LinkedBlockingQueue	(	int	): Creates a LinkedBlockingQueue with the given (fixed) capacity.
java.util.concurrent.LinkedBlockingQueue.Node: Linked list node class
java.util.concurrent.LinkedBlockingQueue.clear	(	): Atomically removes all of the elements from this queue. The queue will be empty after this call returns.
java.util.concurrent.LinkedBlockingQueue.contains	(	Object	): Returns true if this queue contains the specified element. More formally, returns true if and only if this queue contains at least one element e such that o.equals(e).
java.util.concurrent.LinkedBlockingQueue.dequeue	(	): Removes a node from head of queue.
java.util.concurrent.LinkedBlockingQueue.drainTo	(	Collection	): Removes all available elements from this queue and adds them to the given collection. This operation may be more efficient than repeatedly polling this queue. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.LinkedBlockingQueue.drainTo	(	Collection	int	): Removes at most the given number of available elements from this queue and adds them to the given collection. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.LinkedBlockingQueue.enqueue	(	Node	): Links node at end of queue.
java.util.concurrent.LinkedBlockingQueue.fullyLock	(	): Locks to prevent both puts and takes.
java.util.concurrent.LinkedBlockingQueue.fullyUnlock	(	): Unlocks to allow both puts and takes.
java.util.concurrent.LinkedBlockingQueue.iterator	(	): Returns an iterator over the elements in this queue in proper sequence. The elements will be returned in order from first (head) to last (tail). The returned iterator is weakly consistent.
java.util.concurrent.LinkedBlockingQueue.offer	(	E	): Inserts the specified element at the tail of this queue if it is possible to do so immediately without exceeding the queue's capacity, returning true upon success and false if this queue is full. When using a capacity-restricted queue, this method is generally preferable to method add, which can fail to insert an element only by throwing an exception.
java.util.concurrent.LinkedBlockingQueue.offer	(	E	long	TimeUnit	): Inserts the specified element at the tail of this queue, waiting if necessary up to the specified wait time for space to become available.
java.util.concurrent.LinkedBlockingQueue.put	(	E	): Inserts the specified element at the tail of this queue, waiting if necessary for space to become available.
java.util.concurrent.LinkedBlockingQueue.readObject	(	java.io.ObjectInputStream	): Reconstitutes this queue from a stream (that is, deserializes it).
java.util.concurrent.LinkedBlockingQueue.remainingCapacity	(	): Returns the number of additional elements that this queue can ideally (in the absence of memory or resource constraints) accept without blocking. This is always equal to the initial capacity of this queue less the current size of this queue. Note that you cannot always tell if an attempt to insert an element will succeed by inspecting remainingCapacity because it may be the case that another thread is about to insert or remove an element.
java.util.concurrent.LinkedBlockingQueue.remove	(	Object	): Removes a single instance of the specified element from this queue, if it is present. More formally, removes an element e such that o.equals(e), if this queue contains one or more such elements. Returns true if this queue contained the specified element (or equivalently, if this queue changed as a result of the call).
java.util.concurrent.LinkedBlockingQueue.signalNotEmpty	(	): Signals a waiting take. Called only from put/offer (which do not otherwise ordinarily lock takeLock.)
java.util.concurrent.LinkedBlockingQueue.signalNotFull	(	): Signals a waiting put. Called only from take/poll.
java.util.concurrent.LinkedBlockingQueue.size	(	): Returns the number of elements in this queue.
java.util.concurrent.LinkedBlockingQueue.spliterator	(	): Returns a Spliterator over the elements in this queue. The returned spliterator is weakly consistent. The Spliterator reports CONCURRENT, ORDERED, and NONNULL.
java.util.concurrent.LinkedBlockingQueue.toArray	(	): Returns an array containing all of the elements in this queue, in proper sequence. The returned array will be "safe" in that no references to it are maintained by this queue. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.concurrent.LinkedBlockingQueue.toArray	(	T[]	): Returns an array containing all of the elements in this queue, in proper sequence; the runtime type of the returned array is that of the specified array. If the queue fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this queue. If this queue fits in the specified array with room to spare (i.e., the array has more elements than this queue), the element in the array immediately following the end of the queue is set to null. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a queue known to contain only strings. The following code can be used to dump the queue into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.concurrent.LinkedBlockingQueue.unlink	(	Node	Node	): Unlinks interior Node p with predecessor trail.
java.util.concurrent.LinkedBlockingQueue.writeObject	(	java.io.ObjectOutputStream	): Saves this queue to a stream (that is, serializes it).
java.util.concurrent.LinkedTransferQueue: An unbounded TransferQueue based on linked nodes. This queue orders elements FIFO (first-in-first-out) with respect to any given producer. The head of the queue is that element that has been on the queue the longest time for some producer. The tail of the queue is that element that has been on the queue the shortest time for some producer. Beware that, unlike in most collections, the size method is NOT a constant-time operation. Because of the asynchronous nature of these queues, determining the current number of elements requires a traversal of the elements, and so may report inaccurate results if this collection is modified during traversal. Additionally, the bulk operations addAll, removeAll, retainAll, containsAll, equals, and toArray are not guaranteed to be performed atomically. For example, an iterator operating concurrently with an addAll operation might view only some of the added elements. This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces. Memory consistency effects: As with other concurrent collections, actions in a thread prior to placing an object into a LinkedTransferQueue happen-before actions subsequent to the access or removal of that element from the LinkedTransferQueue in another thread. This class is a member of the  Java Collections Framework.
java.util.concurrent.LinkedTransferQueue.Itr.advance	(	Node	): Moves to next node after prev, or first node if prev null.
java.util.concurrent.LinkedTransferQueue.LTQSpliterator: A customized variant of Spliterators.IteratorSpliterator 
java.util.concurrent.LinkedTransferQueue.LinkedTransferQueue	(	): Creates an initially empty LinkedTransferQueue.
java.util.concurrent.LinkedTransferQueue.LinkedTransferQueue	(	Collection	): Creates a LinkedTransferQueue initially containing the elements of the given collection, added in traversal order of the collection's iterator.
java.util.concurrent.LinkedTransferQueue.Node: Queue nodes. Uses Object, not E, for items to allow forgetting them after use. Relies heavily on Unsafe mechanics to minimize unnecessary ordering constraints: Writes that are intrinsically ordered wrt other accesses or CASes use simple relaxed forms.
java.util.concurrent.LinkedTransferQueue.Node.Node	(	Object	boolean	): Constructs a new node. Uses relaxed write because item can only be seen after publication via casNext.
java.util.concurrent.LinkedTransferQueue.Node.cannotPrecede	(	boolean	): Returns true if a node with the given mode cannot be appended to this node because this node is unmatched and has opposite data mode.
java.util.concurrent.LinkedTransferQueue.Node.forgetContents	(	): Sets item to self and waiter to null, to avoid garbage retention after matching or cancelling. Uses relaxed writes because order is already constrained in the only calling contexts: item is forgotten only after volatile/atomic mechanics that extract items. Similarly, clearing waiter follows either CAS or return from park (if ever parked; else we don't care).
java.util.concurrent.LinkedTransferQueue.Node.forgetNext	(	): Links node to itself to avoid garbage retention. Called only after CASing head field, so uses relaxed write.
java.util.concurrent.LinkedTransferQueue.Node.isMatched	(	): Returns true if this node has been matched, including the case of artificial matches due to cancellation.
java.util.concurrent.LinkedTransferQueue.Node.isUnmatchedRequest	(	): Returns true if this is an unmatched request node.
java.util.concurrent.LinkedTransferQueue.Node.tryMatchData	(	): Tries to artificially match a data node -- used by remove.
java.util.concurrent.LinkedTransferQueue.add	(	E	): Inserts the specified element at the tail of this queue. As the queue is unbounded, this method will never throw IllegalStateException or return false.
java.util.concurrent.LinkedTransferQueue.awaitMatch	(	Node	Node	E	boolean	long	): Spins/yields/blocks until node s is matched or caller gives up.
java.util.concurrent.LinkedTransferQueue.contains	(	Object	): Returns true if this queue contains the specified element. More formally, returns true if and only if this queue contains at least one element e such that o.equals(e).
java.util.concurrent.LinkedTransferQueue.countOfMode	(	boolean	): Traverses and counts unmatched nodes of the given mode. Used by methods size and getWaitingConsumerCount.
java.util.concurrent.LinkedTransferQueue.drainTo	(	Collection	): Removes all available elements from this queue and adds them to the given collection. This operation may be more efficient than repeatedly polling this queue. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.LinkedTransferQueue.drainTo	(	Collection	int	): Removes at most the given number of available elements from this queue and adds them to the given collection. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.LinkedTransferQueue.findAndRemove	(	Object	): Main implementation of remove(Object)
java.util.concurrent.LinkedTransferQueue.firstDataItem	(	): Returns the item in the first unmatched node with isData; or null if none. Used by peek.
java.util.concurrent.LinkedTransferQueue.firstDataNode	(	): Version of firstOfMode used by Spliterator. Callers must recheck if the returned node's item field is null or self-linked before using.
java.util.concurrent.LinkedTransferQueue.firstOfMode	(	boolean	): Returns the first unmatched node of the given mode, or null if none. Used by methods isEmpty, hasWaitingConsumer.
java.util.concurrent.LinkedTransferQueue.isEmpty	(	): Returns true if this queue contains no elements.
java.util.concurrent.LinkedTransferQueue.iterator	(	): Returns an iterator over the elements in this queue in proper sequence. The elements will be returned in order from first (head) to last (tail). The returned iterator is weakly consistent.
java.util.concurrent.LinkedTransferQueue.offer	(	E	): Inserts the specified element at the tail of this queue. As the queue is unbounded, this method will never return false.
java.util.concurrent.LinkedTransferQueue.offer	(	E	long	TimeUnit	): Inserts the specified element at the tail of this queue. As the queue is unbounded, this method will never block or return false.
java.util.concurrent.LinkedTransferQueue.put	(	E	): Inserts the specified element at the tail of this queue. As the queue is unbounded, this method will never block.
java.util.concurrent.LinkedTransferQueue.readObject	(	java.io.ObjectInputStream	): Reconstitutes this queue from a stream (that is, deserializes it).
java.util.concurrent.LinkedTransferQueue.remainingCapacity	(	): Always returns Integer.MAX_VALUE because a LinkedTransferQueue is not capacity constrained.
java.util.concurrent.LinkedTransferQueue.remove	(	Object	): Removes a single instance of the specified element from this queue, if it is present. More formally, removes an element e such that o.equals(e), if this queue contains one or more such elements. Returns true if this queue contained the specified element (or equivalently, if this queue changed as a result of the call).
java.util.concurrent.LinkedTransferQueue.size	(	): Returns the number of elements in this queue. If this queue contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE. Beware that, unlike in most collections, this method is NOT a constant-time operation. Because of the asynchronous nature of these queues, determining the current number of elements requires an O(n) traversal.
java.util.concurrent.LinkedTransferQueue.spinsFor	(	Node	boolean	): Returns spin/yield value for a node with given predecessor and data mode. See above for explanation.
java.util.concurrent.LinkedTransferQueue.spliterator	(	): Returns a Spliterator over the elements in this queue. The returned spliterator is weakly consistent. The Spliterator reports CONCURRENT, ORDERED, and NONNULL.
java.util.concurrent.LinkedTransferQueue.succ	(	Node	): Returns the successor of p, or the head node if p.next has been linked to self, which will only be true if traversing with a stale pointer that is now off the list.
java.util.concurrent.LinkedTransferQueue.sweep	(	): Unlinks matched (typically cancelled) nodes encountered in a traversal from head.
java.util.concurrent.LinkedTransferQueue.transfer	(	E	): Transfers the element to a consumer, waiting if necessary to do so. More precisely, transfers the specified element immediately if there exists a consumer already waiting to receive it (in take or timed poll()), else inserts the specified element at the tail of this queue and waits until the element is received by a consumer.
java.util.concurrent.LinkedTransferQueue.tryAppend	(	Node	boolean	): Tries to append node s as tail.
java.util.concurrent.LinkedTransferQueue.tryTransfer	(	E	): Transfers the element to a waiting consumer immediately, if possible. More precisely, transfers the specified element immediately if there exists a consumer already waiting to receive it (in take or timed poll()), otherwise returning false without enqueuing the element.
java.util.concurrent.LinkedTransferQueue.tryTransfer	(	E	long	TimeUnit	): Transfers the element to a consumer if it is possible to do so before the timeout elapses. More precisely, transfers the specified element immediately if there exists a consumer already waiting to receive it (in take or timed poll()), else inserts the specified element at the tail of this queue and waits until the element is received by a consumer, returning false if the specified wait time elapses before the element can be transferred.
java.util.concurrent.LinkedTransferQueue.unsplice	(	Node	Node	): Unsplices (now or later) the given deleted/cancelled node with the given predecessor.
java.util.concurrent.LinkedTransferQueue.writeObject	(	java.io.ObjectOutputStream	): Saves this queue to a stream (that is, serializes it).
java.util.concurrent.LinkedTransferQueue.xfer	(	E	boolean	int	long	): Implements all queuing methods. See above for explanation.
java.util.concurrent.Phaser: A reusable synchronization barrier, similar in functionality to java.util.concurrent.CyclicBarrier CyclicBarrier and java.util.concurrent.CountDownLatch CountDownLatch but supporting more flexible usage. Registration. Unlike the case for other barriers, the number of parties registered to synchronize on a phaser may vary over time. Tasks may be registered at any time (using methods register, bulkRegister, or forms of constructors establishing initial numbers of parties), and optionally deregistered upon any arrival (using arriveAndDeregister). As is the case with most basic synchronization constructs, registration and deregistration affect only internal counts; they do not establish any further internal bookkeeping, so tasks cannot query whether they are registered. (However, you can introduce such bookkeeping by subclassing this class.) Synchronization. Like a CyclicBarrier, a Phaser may be repeatedly awaited. Method arriveAndAwaitAdvance has effect analogous to await CyclicBarrier.await. Each generation of a phaser has an associated phase number. The phase number starts at zero, and advances when all parties arrive at the phaser, wrapping around to zero after reaching Integer.MAX_VALUE. The use of phase numbers enables independent control of actions upon arrival at a phaser and upon awaiting others, via two kinds of methods that may be invoked by any registered party:   Arrival. Methods arrive and arriveAndDeregister record arrival. These methods do not block, but return an associated arrival phase number; that is, the phase number of the phaser to which the arrival applied. When the final party for a given phase arrives, an optional action is performed and the phase advances. These actions are performed by the party triggering a phase advance, and are arranged by overriding method onAdvance(), which also controls termination. Overriding this method is similar to, but more flexible than, providing a barrier action to a CyclicBarrier.  Waiting. Method awaitAdvance requires an argument indicating an arrival phase number, and returns when the phaser advances to (or is already at) a different phase. Unlike similar constructions using CyclicBarrier, method awaitAdvance continues to wait even if the waiting thread is interrupted. Interruptible and timeout versions are also available, but exceptions encountered while tasks wait interruptibly or with timeout do not change the state of the phaser. If necessary, you can perform any associated recovery within handlers of those exceptions, often after invoking forceTermination. Phasers may also be used by tasks executing in a ForkJoinPool, which will ensure sufficient parallelism to execute tasks when others are blocked waiting for a phase to advance.  Termination. A phaser may enter a termination state, that may be checked using method isTerminated. Upon termination, all synchronization methods immediately return without waiting for advance, as indicated by a negative return value. Similarly, attempts to register upon termination have no effect. Termination is triggered when an invocation of onAdvance returns true. The default implementation returns true if a deregistration has caused the number of registered parties to become zero. As illustrated below, when phasers control actions with a fixed number of iterations, it is often convenient to override this method to cause termination when the current phase number reaches a threshold. Method forceTermination is also available to abruptly release waiting threads and allow them to terminate. Tiering. Phasers may be tiered (i.e., constructed in tree structures) to reduce contention. Phasers with large numbers of parties that would otherwise experience heavy synchronization contention costs may instead be set up so that groups of sub-phasers share a common parent. This may greatly increase throughput even though it incurs greater per-operation overhead. In a tree of tiered phasers, registration and deregistration of child phasers with their parent are managed automatically. Whenever the number of registered parties of a child phaser becomes non-zero (as established in the Phaser() constructor, register, or bulkRegister), the child phaser is registered with its parent. Whenever the number of registered parties becomes zero as the result of an invocation of arriveAndDeregister, the child phaser is deregistered from its parent. Monitoring. While synchronization methods may be invoked only by registered parties, the current state of a phaser may be monitored by any caller. At any given moment there are getRegisteredParties parties in total, of which getArrivedParties have arrived at the current phase (getPhase). When the remaining (getUnarrivedParties) parties arrive, the phase advances. The values returned by these methods may reflect transient states and so are not in general useful for synchronization control. Method toString returns snapshots of these state queries in a form convenient for informal monitoring. Sample usages: A Phaser may be used instead of a CountDownLatch to control a one-shot action serving a variable number of parties. The typical idiom is for the method setting this up to first register, then start the actions, then deregister, as in:  void runTasks(List tasks) final Phaser phaser = new Phaser(1); // "1" to register self // create and start threads for (final Runnable task : tasks) { phaser.register(); new Thread() { public void run() { phaser.arriveAndAwaitAdvance(); // await all creation task.run(); } }.start(); } // allow threads to start and deregister self phaser.arriveAndDeregister(); }} One way to cause a set of threads to repeatedly perform actions for a given number of iterations is to override onAdvance:  void startTasks(List tasks, final int iterations) final Phaser phaser = new Phaser() { protected boolean onAdvance(int phase, int registeredParties) { return phase >= iterations || registeredParties == 0; } }; phaser.register(); for (final Runnable task : tasks) { phaser.register(); new Thread() { public void run() { do { task.run(); phaser.arriveAndAwaitAdvance(); } while (!phaser.isTerminated()); } }.start(); } phaser.arriveAndDeregister(); // deregister self, don't wait }} If the main task must later await termination, it may re-register and then execute a similar loop:  // ... phaser.register(); while (!phaser.isTerminated()) phaser.arriveAndAwaitAdvance(); Related constructions may be used to await particular phase numbers in contexts where you are sure that the phase will never wrap around Integer.MAX_VALUE. For example:  void awaitPhase(Phaser phaser, int phase) int p = phaser.register(); // assumes caller not already registered while (p < phase) { if (phaser.isTerminated()) // ... deal with unexpected termination else p = phaser.arriveAndAwaitAdvance(); } phaser.arriveAndDeregister(); }} To create a set of n tasks using a tree of phasers, you could use code of the following form, assuming a Task class with a constructor accepting a Phaser that it registers with upon construction. After invocation of build(new Task[n], 0, n, new Phaser()), these tasks could then be started, for example by submitting to a pool:  void build(Task[] tasks, int lo, int hi, Phaser ph) if (hi - lo > TASKS_PER_PHASER) { for (int i = lo; i < hi; i += TASKS_PER_PHASER) { int j = Math.min(i + TASKS_PER_PHASER, hi); build(tasks, i, j, new Phaser(ph)); } } else { for (int i = lo; i < hi; ++i) tasks[i] = new Task(ph); // assumes new Task(ph) performs ph.register() } }} The best value of TASKS_PER_PHASER depends mainly on expected synchronization rates. A value as low as four may be appropriate for extremely small per-phase task bodies (thus high rates), or up to hundreds for extremely large ones. Implementation notes: This implementation restricts the maximum number of parties to 65535. Attempts to register additional parties result in IllegalStateException. However, you can and should create tiered phasers to accommodate arbitrarily large sets of participants.
java.util.concurrent.Phaser.Phaser	(	): Creates a new phaser with no initially registered parties, no parent, and initial phase number 0. Any thread using this phaser will need to first register for it.
java.util.concurrent.Phaser.Phaser	(	Phaser	): Equivalent to Phaser() Phaser(parent, 0).
java.util.concurrent.Phaser.Phaser	(	Phaser	int	): Creates a new phaser with the given parent and number of registered unarrived parties. When the given parent is non-null and the given number of parties is greater than zero, this child phaser is registered with its parent.
java.util.concurrent.Phaser.Phaser	(	int	): Creates a new phaser with the given number of registered unarrived parties, no parent, and initial phase number 0.
java.util.concurrent.Phaser.QNode: Wait nodes for Treiber stack representing wait queue
java.util.concurrent.Phaser.abortWait	(	int	): Variant of releaseWaiters that additionally tries to remove any nodes no longer waiting for advance due to timeout or interrupt. Currently, nodes are removed only if they are at head of queue, which suffices to reduce memory footprint in most usages.
java.util.concurrent.Phaser.arrive	(	): Arrives at this phaser, without waiting for others to arrive. It is a usage error for an unregistered party to invoke this method. However, this error may result in an IllegalStateException only upon some subsequent operation on this phaser, if ever.
java.util.concurrent.Phaser.arriveAndAwaitAdvance	(	): Arrives at this phaser and awaits others. Equivalent in effect to awaitAdvance(arrive()). If you need to await with interruption or timeout, you can arrange this with an analogous construction using one of the other forms of the awaitAdvance method. If instead you need to deregister upon arrival, use awaitAdvance(arriveAndDeregister()). It is a usage error for an unregistered party to invoke this method. However, this error may result in an IllegalStateException only upon some subsequent operation on this phaser, if ever.
java.util.concurrent.Phaser.arriveAndDeregister	(	): Arrives at this phaser and deregisters from it without waiting for others to arrive. Deregistration reduces the number of parties required to advance in future phases. If this phaser has a parent, and deregistration causes this phaser to have zero parties, this phaser is also deregistered from its parent. It is a usage error for an unregistered party to invoke this method. However, this error may result in an IllegalStateException only upon some subsequent operation on this phaser, if ever.
java.util.concurrent.Phaser.awaitAdvance	(	int	): Awaits the phase of this phaser to advance from the given phase value, returning immediately if the current phase is not equal to the given phase value or this phaser is terminated.
java.util.concurrent.Phaser.awaitAdvanceInterruptibly	(	int	): Awaits the phase of this phaser to advance from the given phase value, throwing InterruptedException if interrupted while waiting, or returning immediately if the current phase is not equal to the given phase value or this phaser is terminated.
java.util.concurrent.Phaser.awaitAdvanceInterruptibly	(	int	long	TimeUnit	): Awaits the phase of this phaser to advance from the given phase value or the given timeout to elapse, throwing InterruptedException if interrupted while waiting, or returning immediately if the current phase is not equal to the given phase value or this phaser is terminated.
java.util.concurrent.Phaser.badArrive	(	long	): Returns message string for bounds exceptions on arrival.
java.util.concurrent.Phaser.badRegister	(	long	): Returns message string for bounds exceptions on registration.
java.util.concurrent.Phaser.bulkRegister	(	int	): Adds the given number of new unarrived parties to this phaser. If an ongoing invocation of onAdvance is in progress, this method may await its completion before returning. If this phaser has a parent, and the given number of parties is greater than zero, and this phaser previously had no registered parties, this child phaser is also registered with its parent. If this phaser is terminated, the attempt to register has no effect, and a negative value is returned.
java.util.concurrent.Phaser.doArrive	(	int	): Main implementation for methods arrive and arriveAndDeregister. Manually tuned to speed up and minimize race windows for the common case of just decrementing unarrived field.
java.util.concurrent.Phaser.doRegister	(	int	): Implementation of register, bulkRegister
java.util.concurrent.Phaser.forceTermination	(	): Forces this phaser to enter termination state. Counts of registered parties are unaffected. If this phaser is a member of a tiered set of phasers, then all of the phasers in the set are terminated. If this phaser is already terminated, this method has no effect. This method may be useful for coordinating recovery after one or more tasks encounter unexpected exceptions.
java.util.concurrent.Phaser.getArrivedParties	(	): Returns the number of registered parties that have arrived at the current phase of this phaser. If this phaser has terminated, the returned value is meaningless and arbitrary.
java.util.concurrent.Phaser.getParent	(	): Returns the parent of this phaser, or null if none.
java.util.concurrent.Phaser.getPhase	(	): Returns the current phase number. The maximum phase number is Integer.MAX_VALUE, after which it restarts at zero. Upon termination, the phase number is negative, in which case the prevailing phase prior to termination may be obtained via getPhase() + Integer.MIN_VALUE.
java.util.concurrent.Phaser.getRegisteredParties	(	): Returns the number of parties registered at this phaser.
java.util.concurrent.Phaser.getRoot	(	): Returns the root ancestor of this phaser, which is the same as this phaser if it has no parent.
java.util.concurrent.Phaser.getUnarrivedParties	(	): Returns the number of registered parties that have not yet arrived at the current phase of this phaser. If this phaser has terminated, the returned value is meaningless and arbitrary.
java.util.concurrent.Phaser.internalAwaitAdvance	(	int	QNode	): Possibly blocks and waits for phase to advance unless aborted. Call only on root phaser.
java.util.concurrent.Phaser.isTerminated	(	): Returns true if this phaser has been terminated.
java.util.concurrent.Phaser.onAdvance	(	int	int	): Overridable method to perform an action upon impending phase advance, and to control termination. This method is invoked upon arrival of the party advancing this phaser (when all other waiting parties are dormant). If this method returns true, this phaser will be set to a final termination state upon advance, and subsequent calls to isTerminated will return true. Any (unchecked) Exception or Error thrown by an invocation of this method is propagated to the party attempting to advance this phaser, in which case no advance occurs. The arguments to this method provide the state of the phaser prevailing for the current transition. The effects of invoking arrival, registration, and waiting methods on this phaser from within onAdvance are unspecified and should not be relied on. If this phaser is a member of a tiered set of phasers, then onAdvance is invoked only for its root phaser on each advance. To support the most common use cases, the default implementation of this method returns true when the number of registered parties has become zero as the result of a party invoking arriveAndDeregister. You can disable this behavior, thus enabling continuation upon future registrations, by overriding this method to always return false:  Phaser phaser = new Phaser() protected boolean onAdvance(int phase, int parties) { return false; } }}
java.util.concurrent.Phaser.reconcileState	(	): Resolves lagged phase propagation from root if necessary. Reconciliation normally occurs when root has advanced but subphasers have not yet done so, in which case they must finish their own advance by setting unarrived to parties (or if parties is zero, resetting to unregistered EMPTY state).
java.util.concurrent.Phaser.register	(	): Adds a new unarrived party to this phaser. If an ongoing invocation of onAdvance is in progress, this method may await its completion before returning. If this phaser has a parent, and this phaser previously had no registered parties, this child phaser is also registered with its parent. If this phaser is terminated, the attempt to register has no effect, and a negative value is returned.
java.util.concurrent.Phaser.releaseWaiters	(	int	): Removes and signals threads from queue for phase.
java.util.concurrent.Phaser.stateToString	(	long	): Implementation of toString and string-based error messages
java.util.concurrent.Phaser.toString	(	): Returns a string identifying this phaser, as well as its state. The state, in brackets, includes the String "phase = " followed by the phase number, "parties = " followed by the number of registered parties, and "arrived = " followed by the number of arrived parties.
java.util.concurrent.PriorityBlockingQueue: An unbounded BlockingQueue blocking queue that uses the same ordering rules as class PriorityQueue and supplies blocking retrieval operations. While this queue is logically unbounded, attempted additions may fail due to resource exhaustion (causing OutOfMemoryError). This class does not permit null elements. A priority queue relying on Comparable natural ordering also does not permit insertion of non-comparable objects (doing so results in ClassCastException). This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces. The Iterator provided in method iterator() is not guaranteed to traverse the elements of the PriorityBlockingQueue in any particular order. If you need ordered traversal, consider using Arrays.sort(pq.toArray()). Also, method drainTo can be used to remove some or all elements in priority order and place them in another collection. Operations on this class make no guarantees about the ordering of elements with equal priority. If you need to enforce an ordering, you can define custom classes or comparators that use a secondary key to break ties in primary priority values. For example, here is a class that applies first-in-first-out tie-breaking to comparable elements. To use it, you would insert a new FIFOEntry(anEntry) instead of a plain entry object.  class FIFOEntry> implements Comparable> static final AtomicLong seq = new AtomicLong(0); final long seqNum; final E entry; public FIFOEntry(E entry) { seqNum = seq.getAndIncrement(); this.entry = entry; } public E getEntry() { return entry; } public int compareTo(FIFOEntry other) { int res = entry.compareTo(other.entry); if (res == 0 && other.entry != this.entry) res = (seqNum < other.seqNum ? -1 : 1); return res; } }} This class is a member of the  Java Collections Framework.
java.util.concurrent.PriorityBlockingQueue.Itr: Snapshot iterator that works off copy of underlying q array.
java.util.concurrent.PriorityBlockingQueue.PriorityBlockingQueue	(	): Creates a PriorityBlockingQueue with the default initial capacity (11) that orders its elements according to their Comparable natural ordering.
java.util.concurrent.PriorityBlockingQueue.PriorityBlockingQueue	(	Collection	): Creates a PriorityBlockingQueue containing the elements in the specified collection. If the specified collection is a SortedSet or a PriorityQueue, this priority queue will be ordered according to the same ordering. Otherwise, this priority queue will be ordered according to the Comparable natural ordering of its elements.
java.util.concurrent.PriorityBlockingQueue.PriorityBlockingQueue	(	int	): Creates a PriorityBlockingQueue with the specified initial capacity that orders its elements according to their Comparable natural ordering.
java.util.concurrent.PriorityBlockingQueue.PriorityBlockingQueue	(	int	Comparator	): Creates a PriorityBlockingQueue with the specified initial capacity that orders its elements according to the specified comparator.
java.util.concurrent.PriorityBlockingQueue.add	(	E	): Inserts the specified element into this priority queue.
java.util.concurrent.PriorityBlockingQueue.clear	(	): Atomically removes all of the elements from this queue. The queue will be empty after this call returns.
java.util.concurrent.PriorityBlockingQueue.comparator	(	): Returns the comparator used to order the elements in this queue, or null if this queue uses the Comparable natural ordering of its elements.
java.util.concurrent.PriorityBlockingQueue.contains	(	Object	): Returns true if this queue contains the specified element. More formally, returns true if and only if this queue contains at least one element e such that o.equals(e).
java.util.concurrent.PriorityBlockingQueue.dequeue	(	): Mechanics for poll(). Call only while holding lock.
java.util.concurrent.PriorityBlockingQueue.drainTo	(	Collection	): Removes all available elements from this queue and adds them to the given collection. This operation may be more efficient than repeatedly polling this queue. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.PriorityBlockingQueue.drainTo	(	Collection	int	): Removes at most the given number of available elements from this queue and adds them to the given collection. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.PriorityBlockingQueue.heapify	(	): Establishes the heap invariant (described above) in the entire tree, assuming nothing about the order of the elements prior to the call.
java.util.concurrent.PriorityBlockingQueue.iterator	(	): Returns an iterator over the elements in this queue. The iterator does not return the elements in any particular order. The returned iterator is weakly consistent.
java.util.concurrent.PriorityBlockingQueue.offer	(	E	): Inserts the specified element into this priority queue. As the queue is unbounded, this method will never return false.
java.util.concurrent.PriorityBlockingQueue.offer	(	E	long	TimeUnit	): Inserts the specified element into this priority queue. As the queue is unbounded, this method will never block or return false.
java.util.concurrent.PriorityBlockingQueue.put	(	E	): Inserts the specified element into this priority queue. As the queue is unbounded, this method will never block.
java.util.concurrent.PriorityBlockingQueue.readObject	(	java.io.ObjectInputStream	): Reconstitutes this queue from a stream (that is, deserializes it).
java.util.concurrent.PriorityBlockingQueue.remainingCapacity	(	): Always returns Integer.MAX_VALUE because a PriorityBlockingQueue is not capacity constrained.
java.util.concurrent.PriorityBlockingQueue.remove	(	Object	): Removes a single instance of the specified element from this queue, if it is present. More formally, removes an element e such that o.equals(e), if this queue contains one or more such elements. Returns true if and only if this queue contained the specified element (or equivalently, if this queue changed as a result of the call).
java.util.concurrent.PriorityBlockingQueue.removeAt	(	int	): Removes the ith element from queue.
java.util.concurrent.PriorityBlockingQueue.removeEQ	(	Object	): Identity-based version for use in Itr.remove
java.util.concurrent.PriorityBlockingQueue.siftDownComparable	(	int	T	Object[]	int	): Inserts item x at position k, maintaining heap invariant by demoting x down the tree repeatedly until it is less than or equal to its children or is a leaf.
java.util.concurrent.PriorityBlockingQueue.siftUpComparable	(	int	T	Object[]	): Inserts item x at position k, maintaining heap invariant by promoting x up the tree until it is greater than or equal to its parent, or is the root. To simplify and speed up coercions and comparisons. the Comparable and Comparator versions are separated into different methods that are otherwise identical. (Similarly for siftDown.) These methods are static, with heap state as arguments, to simplify use in light of possible comparator exceptions.
java.util.concurrent.PriorityBlockingQueue.spliterator	(	): Returns a Spliterator over the elements in this queue. The returned spliterator is weakly consistent. The Spliterator reports SIZED and NONNULL.
java.util.concurrent.PriorityBlockingQueue.toArray	(	): Returns an array containing all of the elements in this queue. The returned array elements are in no particular order. The returned array will be "safe" in that no references to it are maintained by this queue. (In other words, this method must allocate a new array). The caller is thus free to modify the returned array. This method acts as bridge between array-based and collection-based APIs.
java.util.concurrent.PriorityBlockingQueue.toArray	(	T[]	): Returns an array containing all of the elements in this queue; the runtime type of the returned array is that of the specified array. The returned array elements are in no particular order. If the queue fits in the specified array, it is returned therein. Otherwise, a new array is allocated with the runtime type of the specified array and the size of this queue. If this queue fits in the specified array with room to spare (i.e., the array has more elements than this queue), the element in the array immediately following the end of the queue is set to null. Like the toArray() method, this method acts as bridge between array-based and collection-based APIs. Further, this method allows precise control over the runtime type of the output array, and may, under certain circumstances, be used to save allocation costs. Suppose x is a queue known to contain only strings. The following code can be used to dump the queue into a newly allocated array of String:  String[] y = x.toArray(new String[0]); Note that toArray(new Object[0]) is identical in function to toArray().
java.util.concurrent.PriorityBlockingQueue.tryGrow	(	Object[]	int	): Tries to grow array to accommodate at least one more element (but normally expand by about 50%), giving up (allowing retry) on contention (which we expect to be rare). Call only while holding lock.
java.util.concurrent.PriorityBlockingQueue.writeObject	(	java.io.ObjectOutputStream	): Saves this queue to a stream (that is, serializes it). For compatibility with previous version of this class, elements are first copied to a java.util.PriorityQueue, which is then serialized.
java.util.concurrent.RecursiveAction: A recursive resultless ForkJoinTask. This class establishes conventions to parameterize resultless actions as Void ForkJoinTasks. Because null is the only valid value of type Void, methods such as join always return null upon completion. Sample Usages. Here is a simple but complete ForkJoin sort that sorts a given long[] array:  static class SortTask extends RecursiveAction final long[] array; final int lo, hi; SortTask(long[] array, int lo, int hi) { this.array = array; this.lo = lo; this.hi = hi; } SortTask(long[] array) { this(array, 0, array.length); } protected void compute() { if (hi - lo < THRESHOLD) sortSequentially(lo, hi); else { int mid = (lo + hi) >>> 1; invokeAll(new SortTask(array, lo, mid), new SortTask(array, mid, hi)); merge(lo, mid, hi); } } // implementation details follow: static final int THRESHOLD = 1000; void sortSequentially(int lo, int hi) { Arrays.sort(array, lo, hi); } void merge(int lo, int mid, int hi) { long[] buf = Arrays.copyOfRange(array, lo, mid); for (int i = 0, j = lo, k = mid; i < buf.length; j++) array[j] = (k == hi || buf[i] < array[k]) ? buf[i++] : array[k++]; } }} You could then sort anArray by creating new SortTask(anArray) and invoking it in a ForkJoinPool. As a more concrete simple example, the following task increments each element of an array:  class IncrementTask extends RecursiveAction final long[] array; final int lo, hi; IncrementTask(long[] array, int lo, int hi) { this.array = array; this.lo = lo; this.hi = hi; } protected void compute() { if (hi - lo < THRESHOLD) { for (int i = lo; i < hi; ++i) array[i]++; } else { int mid = (lo + hi) >>> 1; invokeAll(new IncrementTask(array, lo, mid), new IncrementTask(array, mid, hi)); } } }} The following example illustrates some refinements and idioms that may lead to better performance: RecursiveActions need not be fully recursive, so long as they maintain the basic divide-and-conquer approach. Here is a class that sums the squares of each element of a double array, by subdividing out only the right-hand-sides of repeated divisions by two, and keeping track of them with a chain of next references. It uses a dynamic threshold based on method getSurplusQueuedTaskCount, but counterbalances potential excess partitioning by directly performing leaf actions on unstolen tasks rather than further subdividing.  double sumOfSquares(ForkJoinPool pool, double[] array) int n = array.length; Applyer a = new Applyer(array, 0, n, null); pool.invoke(a); return a.result; } class Applyer extends RecursiveAction { final double[] array; final int lo, hi; double result; Applyer next; // keeps track of right-hand-side tasks Applyer(double[] array, int lo, int hi, Applyer next) { this.array = array; this.lo = lo; this.hi = hi; this.next = next; } double atLeaf(int l, int h) { double sum = 0; for (int i = l; i < h; ++i) // perform leftmost base step sum += array[i] * array[i]; return sum; } protected void compute() { int l = lo; int h = hi; Applyer right = null; while (h - l > 1 && getSurplusQueuedTaskCount() <= 3) { int mid = (l + h) >>> 1; right = new Applyer(array, mid, h, right); right.fork(); h = mid; } double sum = atLeaf(l, h); while (right != null) { if (right.tryUnfork()) // directly calculate if not stolen sum += right.atLeaf(right.lo, right.hi); else { right.join(); sum += right.result; } right = right.next; } result = sum; } }}
java.util.concurrent.RecursiveAction.compute	(	): The main computation performed by this task.
java.util.concurrent.RecursiveAction.exec	(	): Implements execution conventions for RecursiveActions.
java.util.concurrent.RecursiveAction.getRawResult	(	): Always returns null.
java.util.concurrent.RecursiveAction.setRawResult	(	Void	): Requires null completion value.
java.util.concurrent.RecursiveTask: A recursive result-bearing ForkJoinTask. For a classic example, here is a task computing Fibonacci numbers:  class Fibonacci extends RecursiveTask final int n; Fibonacci(int n) { this.n = n; } Integer compute() { if (n <= 1) return n; Fibonacci f1 = new Fibonacci(n - 1); f1.fork(); Fibonacci f2 = new Fibonacci(n - 2); return f2.compute() + f1.join(); } }} However, besides being a dumb way to compute Fibonacci functions (there is a simple fast linear algorithm that you'd use in practice), this is likely to perform poorly because the smallest subtasks are too small to be worthwhile splitting up. Instead, as is the case for nearly all fork/join applications, you'd pick some minimum granularity size (for example 10 here) for which you always sequentially solve rather than subdividing.
java.util.concurrent.RecursiveTask.compute	(	): The main computation performed by this task.
java.util.concurrent.RecursiveTask.exec	(	): Implements execution conventions for RecursiveTask.
java.util.concurrent.RejectedExecutionException: Exception thrown by an Executor when a task cannot be accepted for execution.
java.util.concurrent.RejectedExecutionException.RejectedExecutionException	(	): Constructs a RejectedExecutionException with no detail message. The cause is not initialized, and may subsequently be initialized by a call to initCause().
java.util.concurrent.RejectedExecutionException.RejectedExecutionException	(	String	): Constructs a RejectedExecutionException with the specified detail message. The cause is not initialized, and may subsequently be initialized by a call to initCause().
java.util.concurrent.RejectedExecutionException.RejectedExecutionException	(	String	Throwable	): Constructs a RejectedExecutionException with the specified detail message and cause.
java.util.concurrent.RejectedExecutionException.RejectedExecutionException	(	Throwable	): Constructs a RejectedExecutionException with the specified cause. The detail message is set to (cause == null ? null : cause.toString()) (which typically contains the class and detail message of cause).
java.util.concurrent.RejectedExecutionHandler: A handler for tasks that cannot be executed by a ThreadPoolExecutor.
java.util.concurrent.RejectedExecutionHandler.rejectedExecution	(	Runnable	ThreadPoolExecutor	): Method that may be invoked by a ThreadPoolExecutor when execute cannot accept a task. This may occur when no more threads or queue slots are available because their bounds would be exceeded, or upon shutdown of the Executor. In the absence of other alternatives, the method may throw an unchecked RejectedExecutionException, which will be propagated to the caller of execute.
java.util.concurrent.RunnableFuture: A Future that is Runnable. Successful execution of the run method causes completion of the Future and allows access to its results.
java.util.concurrent.RunnableFuture.run	(	): Sets this Future to the result of its computation unless it has been cancelled.
java.util.concurrent.RunnableScheduledFuture: A ScheduledFuture that is Runnable. Successful execution of the run method causes completion of the Future and allows access to its results.
java.util.concurrent.RunnableScheduledFuture.isPeriodic	(	): Returns true if this task is periodic. A periodic task may re-run according to some schedule. A non-periodic task can be run only once.
java.util.concurrent.ScheduledExecutorService: An ExecutorService that can schedule commands to run after a given delay, or to execute periodically. The schedule methods create tasks with various delays and return a task object that can be used to cancel or check execution. The scheduleAtFixedRate and scheduleWithFixedDelay methods create and execute tasks that run periodically until cancelled. Commands submitted using the execute() and ExecutorService submit methods are scheduled with a requested delay of zero. Zero and negative delays (but not periods) are also allowed in schedule methods, and are treated as requests for immediate execution. All schedule methods accept relative delays and periods as arguments, not absolute times or dates. It is a simple matter to transform an absolute time represented as a java.util.Date to the required form. For example, to schedule at a certain future date, you can use: schedule(task, date.getTime() - System.currentTimeMillis(), TimeUnit.MILLISECONDS). Beware however that expiration of a relative delay need not coincide with the current Date at which the task is enabled due to network time synchronization protocols, clock drift, or other factors. The Executors class provides convenient factory methods for the ScheduledExecutorService implementations provided in this package. Usage Example Here is a class with a method that sets up a ScheduledExecutorService to beep every ten seconds for an hour:  import static java.util.concurrent.TimeUnit.*; class BeeperControl private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1); public void beepForAnHour() { final Runnable beeper = new Runnable() { public void run() { System.out.println("beep"); } }; final ScheduledFuture beeperHandle = scheduler.scheduleAtFixedRate(beeper, 10, 10, SECONDS); scheduler.schedule(new Runnable() { public void run() { beeperHandle.cancel(true); } }, 60 * 60, SECONDS); } }}
java.util.concurrent.ScheduledExecutorService.schedule	(	Callable	long	TimeUnit	): Creates and executes a ScheduledFuture that becomes enabled after the given delay.
java.util.concurrent.ScheduledExecutorService.schedule	(	Runnable	long	TimeUnit	): Creates and executes a one-shot action that becomes enabled after the given delay.
java.util.concurrent.ScheduledExecutorService.scheduleAtFixedRate	(	Runnable	long	long	TimeUnit	): Creates and executes a periodic action that becomes enabled first after the given initial delay, and subsequently with the given period; that is executions will commence after initialDelay then initialDelay+period, then initialDelay + 2 * period, and so on. If any execution of the task encounters an exception, subsequent executions are suppressed. Otherwise, the task will only terminate via cancellation or termination of the executor. If any execution of this task takes longer than its period, then subsequent executions may start late, but will not concurrently execute.
java.util.concurrent.ScheduledExecutorService.scheduleWithFixedDelay	(	Runnable	long	long	TimeUnit	): Creates and executes a periodic action that becomes enabled first after the given initial delay, and subsequently with the given delay between the termination of one execution and the commencement of the next. If any execution of the task encounters an exception, subsequent executions are suppressed. Otherwise, the task will only terminate via cancellation or termination of the executor.
java.util.concurrent.ScheduledFuture: A delayed result-bearing action that can be cancelled. Usually a scheduled future is the result of scheduling a task with a ScheduledExecutorService.
java.util.concurrent.ScheduledThreadPoolExecutor: A ThreadPoolExecutor that can additionally schedule commands to run after a given delay, or to execute periodically. This class is preferable to java.util.Timer when multiple worker threads are needed, or when the additional flexibility or capabilities of ThreadPoolExecutor (which this class extends) are required. Delayed tasks execute no sooner than they are enabled, but without any real-time guarantees about when, after they are enabled, they will commence. Tasks scheduled for exactly the same execution time are enabled in first-in-first-out (FIFO) order of submission. When a submitted task is cancelled before it is run, execution is suppressed. By default, such a cancelled task is not automatically removed from the work queue until its delay elapses. While this enables further inspection and monitoring, it may also cause unbounded retention of cancelled tasks. To avoid this, set setRemoveOnCancelPolicy to true, which causes tasks to be immediately removed from the work queue at time of cancellation. Successive executions of a task scheduled via scheduleAtFixedRate or scheduleWithFixedDelay do not overlap. While different executions may be performed by different threads, the effects of prior executions happen-before those of subsequent ones. While this class inherits from ThreadPoolExecutor, a few of the inherited tuning methods are not useful for it. In particular, because it acts as a fixed-sized pool using corePoolSize threads and an unbounded queue, adjustments to maximumPoolSize have no useful effect. Additionally, it is almost never a good idea to set corePoolSize to zero or use allowCoreThreadTimeOut because this may leave the pool without threads to handle tasks once they become eligible to run. Extension notes: This class overrides the execute() and submit() methods to generate internal ScheduledFuture objects to control per-task delays and scheduling. To preserve functionality, any further overrides of these methods in subclasses must invoke superclass versions, which effectively disables additional task customization. However, this class provides alternative protected extension method decorateTask (one version each for Runnable and Callable) that can be used to customize the concrete task types used to execute commands entered via execute, submit, schedule, scheduleAtFixedRate, and scheduleWithFixedDelay. By default, a ScheduledThreadPoolExecutor uses a task type extending FutureTask. However, this may be modified or replaced using subclasses of the form:  public class CustomScheduledExecutor extends ScheduledThreadPoolExecutor static class CustomTask implements RunnableScheduledFuture { ... } protected  RunnableScheduledFuture decorateTask( Runnable r, RunnableScheduledFuture task) { return new CustomTask(r, task); } protected  RunnableScheduledFuture decorateTask( Callable c, RunnableScheduledFuture task) { return new CustomTask(c, task); } // ... add constructors, etc. }}
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue: Specialized delay queue. To mesh with TPE declarations, this class must be declared as a BlockingQueue even though it can only hold RunnableScheduledFutures.
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue.Itr: Snapshot iterator that works off copy of underlying q array.
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue.finishPoll	(	RunnableScheduledFuture	): Performs common bookkeeping for poll and take: Replaces first element with last and sifts it down. Call only when holding lock.
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue.grow	(	): Resizes the heap array. Call only when holding lock.
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue.indexOf	(	Object	): Finds index of given object, or -1 if absent.
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue.peekExpired	(	): Returns first element only if it is expired. Used only by drainTo. Call only when holding lock.
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue.setIndex	(	RunnableScheduledFuture	int	): Sets f's heapIndex if it is a ScheduledFutureTask.
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue.siftDown	(	int	RunnableScheduledFuture	): Sifts element added at top down to its heap-ordered spot. Call only when holding lock.
java.util.concurrent.ScheduledThreadPoolExecutor.DelayedWorkQueue.siftUp	(	int	RunnableScheduledFuture	): Sifts element added at bottom up to its heap-ordered spot. Call only when holding lock.
java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask.ScheduledFutureTask	(	Callable	long	): Creates a one-shot action with given nanoTime-based trigger time.
java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask.ScheduledFutureTask	(	Runnable	V	long	): Creates a one-shot action with given nanoTime-based trigger time.
java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask.ScheduledFutureTask	(	Runnable	V	long	long	): Creates a periodic action with given nano time and period.
java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask.isPeriodic	(	): Returns true if this is a periodic (not a one-shot) action.
java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask.run	(	): Overrides FutureTask version so as to reset/requeue if periodic.
java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledFutureTask.setNextRunTime	(	): Sets the next time to run for a periodic task.
java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledThreadPoolExecutor	(	int	): Creates a new ScheduledThreadPoolExecutor with the given core pool size.
java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledThreadPoolExecutor	(	int	RejectedExecutionHandler	): Creates a new ScheduledThreadPoolExecutor with the given initial parameters.
java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledThreadPoolExecutor	(	int	ThreadFactory	): Creates a new ScheduledThreadPoolExecutor with the given initial parameters.
java.util.concurrent.ScheduledThreadPoolExecutor.ScheduledThreadPoolExecutor	(	int	ThreadFactory	RejectedExecutionHandler	): Creates a new ScheduledThreadPoolExecutor with the given initial parameters.
java.util.concurrent.ScheduledThreadPoolExecutor.canRunInCurrentRunState	(	boolean	): Returns true if can run a task given current run state and run-after-shutdown parameters.
java.util.concurrent.ScheduledThreadPoolExecutor.decorateTask	(	Callable	RunnableScheduledFuture	): Modifies or replaces the task used to execute a callable. This method can be used to override the concrete class used for managing internal tasks. The default implementation simply returns the given task.
java.util.concurrent.ScheduledThreadPoolExecutor.decorateTask	(	Runnable	RunnableScheduledFuture	): Modifies or replaces the task used to execute a runnable. This method can be used to override the concrete class used for managing internal tasks. The default implementation simply returns the given task.
java.util.concurrent.ScheduledThreadPoolExecutor.delayedExecute	(	RunnableScheduledFuture	): Main execution method for delayed or periodic tasks. If pool is shut down, rejects the task. Otherwise adds task to queue and starts a thread, if necessary, to run it. (We cannot prestart the thread to run the task because the task (probably) shouldn't be run yet.) If the pool is shut down while the task is being added, cancel and remove it if required by state and run-after-shutdown parameters.
java.util.concurrent.ScheduledThreadPoolExecutor.execute	(	Runnable	): Executes command with zero required delay. This has effect equivalent to schedule() schedule(command, 0, anyUnit). Note that inspections of the queue and of the list returned by shutdownNow will access the zero-delayed ScheduledFuture, not the command itself. A consequence of the use of ScheduledFuture objects is that afterExecute is always called with a null second Throwable argument, even if the command terminated abruptly. Instead, the Throwable thrown by such a task can be obtained via get.
java.util.concurrent.ScheduledThreadPoolExecutor.getContinueExistingPeriodicTasksAfterShutdownPolicy	(	): Gets the policy on whether to continue executing existing periodic tasks even when this executor has been shutdown. In this case, these tasks will only terminate upon shutdownNow or after setting the policy to false when already shutdown. This value is by default false.
java.util.concurrent.ScheduledThreadPoolExecutor.getExecuteExistingDelayedTasksAfterShutdownPolicy	(	): Gets the policy on whether to execute existing delayed tasks even when this executor has been shutdown. In this case, these tasks will only terminate upon shutdownNow, or after setting the policy to false when already shutdown. This value is by default true.
java.util.concurrent.ScheduledThreadPoolExecutor.getQueue	(	): Returns the task queue used by this executor. Each element of this queue is a ScheduledFuture, including those tasks submitted using execute which are for scheduling purposes used as the basis of a zero-delay ScheduledFuture. Iteration over this queue is not guaranteed to traverse tasks in the order in which they will execute.
java.util.concurrent.ScheduledThreadPoolExecutor.getRemoveOnCancelPolicy	(	): Gets the policy on whether cancelled tasks should be immediately removed from the work queue at time of cancellation. This value is by default false.
java.util.concurrent.ScheduledThreadPoolExecutor.now	(	): Returns current nanosecond time.
java.util.concurrent.ScheduledThreadPoolExecutor.onShutdown	(	): Cancels and clears the queue of all tasks that should not be run due to shutdown policy. Invoked within super.shutdown.
java.util.concurrent.ScheduledThreadPoolExecutor.overflowFree	(	long	): Constrains the values of all delays in the queue to be within Long.MAX_VALUE of each other, to avoid overflow in compareTo. This may occur if a task is eligible to be dequeued, but has not yet been, while some other task is added with a delay of Long.MAX_VALUE.
java.util.concurrent.ScheduledThreadPoolExecutor.reExecutePeriodic	(	RunnableScheduledFuture	): Requeues a periodic task unless current run state precludes it. Same idea as delayedExecute except drops task rather than rejecting.
java.util.concurrent.ScheduledThreadPoolExecutor.schedule	(	Callable	long	TimeUnit	): Creates and executes a ScheduledFuture that becomes enabled after the given delay.
java.util.concurrent.ScheduledThreadPoolExecutor.schedule	(	Runnable	long	TimeUnit	): Creates and executes a one-shot action that becomes enabled after the given delay.
java.util.concurrent.ScheduledThreadPoolExecutor.scheduleAtFixedRate	(	Runnable	long	long	TimeUnit	): Creates and executes a periodic action that becomes enabled first after the given initial delay, and subsequently with the given period; that is executions will commence after initialDelay then initialDelay+period, then initialDelay + 2 * period, and so on. If any execution of the task encounters an exception, subsequent executions are suppressed. Otherwise, the task will only terminate via cancellation or termination of the executor. If any execution of this task takes longer than its period, then subsequent executions may start late, but will not concurrently execute.
java.util.concurrent.ScheduledThreadPoolExecutor.scheduleWithFixedDelay	(	Runnable	long	long	TimeUnit	): Creates and executes a periodic action that becomes enabled first after the given initial delay, and subsequently with the given delay between the termination of one execution and the commencement of the next. If any execution of the task encounters an exception, subsequent executions are suppressed. Otherwise, the task will only terminate via cancellation or termination of the executor.
java.util.concurrent.ScheduledThreadPoolExecutor.setContinueExistingPeriodicTasksAfterShutdownPolicy	(	boolean	): Sets the policy on whether to continue executing existing periodic tasks even when this executor has been shutdown. In this case, these tasks will only terminate upon shutdownNow or after setting the policy to false when already shutdown. This value is by default false.
java.util.concurrent.ScheduledThreadPoolExecutor.setExecuteExistingDelayedTasksAfterShutdownPolicy	(	boolean	): Sets the policy on whether to execute existing delayed tasks even when this executor has been shutdown. In this case, these tasks will only terminate upon shutdownNow, or after setting the policy to false when already shutdown. This value is by default true.
java.util.concurrent.ScheduledThreadPoolExecutor.setRemoveOnCancelPolicy	(	boolean	): Sets the policy on whether cancelled tasks should be immediately removed from the work queue at time of cancellation. This value is by default false.
java.util.concurrent.ScheduledThreadPoolExecutor.shutdown	(	): Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted. Invocation has no additional effect if already shut down. This method does not wait for previously submitted tasks to complete execution. Use awaitTermination to do that. If the ExecuteExistingDelayedTasksAfterShutdownPolicy has been set false, existing delayed tasks whose delays have not yet elapsed are cancelled. And unless the ContinueExistingPeriodicTasksAfterShutdownPolicy has been set true, future executions of existing periodic tasks will be cancelled.
java.util.concurrent.ScheduledThreadPoolExecutor.shutdownNow	(	): Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution. This method does not wait for actively executing tasks to terminate. Use awaitTermination to do that. There are no guarantees beyond best-effort attempts to stop processing actively executing tasks. This implementation cancels tasks via interrupt, so any task that fails to respond to interrupts may never terminate.
java.util.concurrent.ScheduledThreadPoolExecutor.submit	(	Callable	): Submits a value-returning task for execution and returns a Future representing the pending results of the task. The Future's get method will return the task's result upon successful completion.  If you would like to immediately block waiting for a task, you can use constructions of the form result = exec.submit(aCallable).get(); Note: The Executors class includes a set of methods that can convert some other common closure-like objects, for example, java.security.PrivilegedAction to Callable form so they can be submitted.
java.util.concurrent.ScheduledThreadPoolExecutor.submit	(	Runnable	): Submits a Runnable task for execution and returns a Future representing that task. The Future's get method will return null upon successful completion.
java.util.concurrent.ScheduledThreadPoolExecutor.submit	(	Runnable	T	): Submits a Runnable task for execution and returns a Future representing that task. The Future's get method will return the given result upon successful completion.
java.util.concurrent.ScheduledThreadPoolExecutor.triggerTime	(	long	): Returns the trigger time of a delayed action.
java.util.concurrent.ScheduledThreadPoolExecutor.triggerTime	(	long	TimeUnit	): Returns the trigger time of a delayed action.
java.util.concurrent.Semaphore: A counting semaphore. Conceptually, a semaphore maintains a set of permits. Each acquire blocks if necessary until a permit is available, and then takes it. Each release adds a permit, potentially releasing a blocking acquirer. However, no actual permit objects are used; the Semaphore just keeps a count of the number available and acts accordingly. Semaphores are often used to restrict the number of threads than can access some (physical or logical) resource. For example, here is a class that uses a semaphore to control access to a pool of items:  class Pool private static final int MAX_AVAILABLE = 100; private final Semaphore available = new Semaphore(MAX_AVAILABLE, true); public Object getItem() throws InterruptedException { available.acquire(); return getNextAvailableItem(); } public void putItem(Object x) { if (markAsUnused(x)) available.release(); } // Not a particularly efficient data structure; just for demo protected Object[] items = ... whatever kinds of items being managed protected boolean[] used = new boolean[MAX_AVAILABLE]; protected synchronized Object getNextAvailableItem() { for (int i = 0; i < MAX_AVAILABLE; ++i) { if (!used[i]) { used[i] = true; return items[i]; } } return null; // not reached } protected synchronized boolean markAsUnused(Object item) { for (int i = 0; i < MAX_AVAILABLE; ++i) { if (item == items[i]) { if (used[i]) { used[i] = false; return true; } else return false; } } return false; } }} Before obtaining an item each thread must acquire a permit from the semaphore, guaranteeing that an item is available for use. When the thread has finished with the item it is returned back to the pool and a permit is returned to the semaphore, allowing another thread to acquire that item. Note that no synchronization lock is held when acquire is called as that would prevent an item from being returned to the pool. The semaphore encapsulates the synchronization needed to restrict access to the pool, separately from any synchronization needed to maintain the consistency of the pool itself. A semaphore initialized to one, and which is used such that it only has at most one permit available, can serve as a mutual exclusion lock. This is more commonly known as a binary semaphore, because it only has two states: one permit available, or zero permits available. When used in this way, the binary semaphore has the property (unlike many java.util.concurrent.locks.Lock implementations), that the "lock" can be released by a thread other than the owner (as semaphores have no notion of ownership). This can be useful in some specialized contexts, such as deadlock recovery.  The constructor for this class optionally accepts a fairness parameter. When set false, this class makes no guarantees about the order in which threads acquire permits. In particular, barging is permitted, that is, a thread invoking acquire can be allocated a permit ahead of a thread that has been waiting - logically the new thread places itself at the head of the queue of waiting threads. When fairness is set true, the semaphore guarantees that threads invoking any of the acquire() methods are selected to obtain permits in the order in which their invocation of those methods was processed (first-in-first-out; FIFO). Note that FIFO ordering necessarily applies to specific internal points of execution within these methods. So, it is possible for one thread to invoke acquire before another, but reach the ordering point after the other, and similarly upon return from the method. Also note that the untimed tryAcquire() methods do not honor the fairness setting, but will take any permits that are available. Generally, semaphores used to control resource access should be initialized as fair, to ensure that no thread is starved out from accessing a resource. When using semaphores for other kinds of synchronization control, the throughput advantages of non-fair ordering often outweigh fairness considerations. This class also provides convenience methods to acquire() and release() multiple permits at a time. Beware of the increased risk of indefinite postponement when these methods are used without fairness set true. Memory consistency effects: Actions in a thread prior to calling a "release" method such as release() happen-before actions following a successful "acquire" method such as acquire() in another thread.
java.util.concurrent.Semaphore.FairSync: Fair version
java.util.concurrent.Semaphore.NonfairSync: NonFair version
java.util.concurrent.Semaphore.Semaphore	(	int	): Creates a Semaphore with the given number of permits and nonfair fairness setting.
java.util.concurrent.Semaphore.Semaphore	(	int	boolean	): Creates a Semaphore with the given number of permits and the given fairness setting.
java.util.concurrent.Semaphore.Sync: Synchronization implementation for semaphore. Uses AQS state to represent permits. Subclassed into fair and nonfair versions.
java.util.concurrent.Semaphore.acquire	(	): Acquires a permit from this semaphore, blocking until one is available, or the thread is interrupt interrupted. Acquires a permit, if one is available and returns immediately, reducing the number of available permits by one. If no permit is available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:  Some other thread invokes the release method for this semaphore and the current thread is next to be assigned a permit; or Some other thread interrupt interrupts the current thread.  If the current thread:  has its interrupted status set on entry to this method; or is interrupt interrupted while waiting for a permit,  then InterruptedException is thrown and the current thread's interrupted status is cleared.
java.util.concurrent.Semaphore.acquire	(	int	): Acquires the given number of permits from this semaphore, blocking until all are available, or the thread is interrupt interrupted. Acquires the given number of permits, if they are available, and returns immediately, reducing the number of available permits by the given amount. If insufficient permits are available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:  Some other thread invokes one of the release() methods for this semaphore, the current thread is next to be assigned permits and the number of available permits satisfies this request; or Some other thread interrupt interrupts the current thread.  If the current thread:  has its interrupted status set on entry to this method; or is interrupt interrupted while waiting for a permit,  then InterruptedException is thrown and the current thread's interrupted status is cleared. Any permits that were to be assigned to this thread are instead assigned to other threads trying to acquire permits, as if permits had been made available by a call to release().
java.util.concurrent.Semaphore.acquireUninterruptibly	(	): Acquires a permit from this semaphore, blocking until one is available. Acquires a permit, if one is available and returns immediately, reducing the number of available permits by one. If no permit is available then the current thread becomes disabled for thread scheduling purposes and lies dormant until some other thread invokes the release method for this semaphore and the current thread is next to be assigned a permit. If the current thread is interrupt interrupted while waiting for a permit then it will continue to wait, but the time at which the thread is assigned a permit may change compared to the time it would have received the permit had no interruption occurred. When the thread does return from this method its interrupt status will be set.
java.util.concurrent.Semaphore.acquireUninterruptibly	(	int	): Acquires the given number of permits from this semaphore, blocking until all are available. Acquires the given number of permits, if they are available, and returns immediately, reducing the number of available permits by the given amount. If insufficient permits are available then the current thread becomes disabled for thread scheduling purposes and lies dormant until some other thread invokes one of the release() methods for this semaphore, the current thread is next to be assigned permits and the number of available permits satisfies this request. If the current thread is interrupt interrupted while waiting for permits then it will continue to wait and its position in the queue is not affected. When the thread does return from this method its interrupt status will be set.
java.util.concurrent.Semaphore.availablePermits	(	): Returns the current number of permits available in this semaphore. This method is typically used for debugging and testing purposes.
java.util.concurrent.Semaphore.drainPermits	(	): Acquires and returns all permits that are immediately available.
java.util.concurrent.Semaphore.getQueueLength	(	): Returns an estimate of the number of threads waiting to acquire. The value is only an estimate because the number of threads may change dynamically while this method traverses internal data structures. This method is designed for use in monitoring of the system state, not for synchronization control.
java.util.concurrent.Semaphore.getQueuedThreads	(	): Returns a collection containing threads that may be waiting to acquire. Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate. The elements of the returned collection are in no particular order. This method is designed to facilitate construction of subclasses that provide more extensive monitoring facilities.
java.util.concurrent.Semaphore.hasQueuedThreads	(	): Queries whether any threads are waiting to acquire. Note that because cancellations may occur at any time, a true return does not guarantee that any other thread will ever acquire. This method is designed primarily for use in monitoring of the system state.
java.util.concurrent.Semaphore.isFair	(	): Returns true if this semaphore has fairness set true.
java.util.concurrent.Semaphore.reducePermits	(	int	): Shrinks the number of available permits by the indicated reduction. This method can be useful in subclasses that use semaphores to track resources that become unavailable. This method differs from acquire in that it does not block waiting for permits to become available.
java.util.concurrent.Semaphore.release	(	): Releases a permit, returning it to the semaphore. Releases a permit, increasing the number of available permits by one. If any threads are trying to acquire a permit, then one is selected and given the permit that was just released. That thread is (re)enabled for thread scheduling purposes. There is no requirement that a thread that releases a permit must have acquired that permit by calling acquire. Correct usage of a semaphore is established by programming convention in the application.
java.util.concurrent.Semaphore.release	(	int	): Releases the given number of permits, returning them to the semaphore. Releases the given number of permits, increasing the number of available permits by that amount. If any threads are trying to acquire permits, then one is selected and given the permits that were just released. If the number of available permits satisfies that thread's request then that thread is (re)enabled for thread scheduling purposes; otherwise the thread will wait until sufficient permits are available. If there are still permits available after this thread's request has been satisfied, then those permits are assigned in turn to other threads trying to acquire permits. There is no requirement that a thread that releases a permit must have acquired that permit by calling acquire. Correct usage of a semaphore is established by programming convention in the application.
java.util.concurrent.Semaphore.toString	(	): Returns a string identifying this semaphore, as well as its state. The state, in brackets, includes the String "Permits =" followed by the number of permits.
java.util.concurrent.Semaphore.tryAcquire	(	): Acquires a permit from this semaphore, only if one is available at the time of invocation. Acquires a permit, if one is available and returns immediately, with the value true, reducing the number of available permits by one. If no permit is available then this method will return immediately with the value false. Even when this semaphore has been set to use a fair ordering policy, a call to tryAcquire() will immediately acquire a permit if one is available, whether or not other threads are currently waiting. This "barging" behavior can be useful in certain circumstances, even though it breaks fairness. If you want to honor the fairness setting, then use tryAcquire() tryAcquire(0, TimeUnit.SECONDS) which is almost equivalent (it also detects interruption).
java.util.concurrent.Semaphore.tryAcquire	(	int	): Acquires the given number of permits from this semaphore, only if all are available at the time of invocation. Acquires the given number of permits, if they are available, and returns immediately, with the value true, reducing the number of available permits by the given amount. If insufficient permits are available then this method will return immediately with the value false and the number of available permits is unchanged. Even when this semaphore has been set to use a fair ordering policy, a call to tryAcquire will immediately acquire a permit if one is available, whether or not other threads are currently waiting. This "barging" behavior can be useful in certain circumstances, even though it breaks fairness. If you want to honor the fairness setting, then use tryAcquire() tryAcquire(permits, 0, TimeUnit.SECONDS) which is almost equivalent (it also detects interruption).
java.util.concurrent.Semaphore.tryAcquire	(	int	long	TimeUnit	): Acquires the given number of permits from this semaphore, if all become available within the given waiting time and the current thread has not been interrupt interrupted. Acquires the given number of permits, if they are available and returns immediately, with the value true, reducing the number of available permits by the given amount. If insufficient permits are available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:  Some other thread invokes one of the release() methods for this semaphore, the current thread is next to be assigned permits and the number of available permits satisfies this request; or Some other thread interrupt interrupts the current thread; or The specified waiting time elapses.  If the permits are acquired then the value true is returned. If the current thread:  has its interrupted status set on entry to this method; or is interrupt interrupted while waiting to acquire the permits,  then InterruptedException is thrown and the current thread's interrupted status is cleared. Any permits that were to be assigned to this thread, are instead assigned to other threads trying to acquire permits, as if the permits had been made available by a call to release(). If the specified waiting time elapses then the value false is returned. If the time is less than or equal to zero, the method will not wait at all. Any permits that were to be assigned to this thread, are instead assigned to other threads trying to acquire permits, as if the permits had been made available by a call to release().
java.util.concurrent.Semaphore.tryAcquire	(	long	TimeUnit	): Acquires a permit from this semaphore, if one becomes available within the given waiting time and the current thread has not been interrupt interrupted. Acquires a permit, if one is available and returns immediately, with the value true, reducing the number of available permits by one. If no permit is available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:  Some other thread invokes the release method for this semaphore and the current thread is next to be assigned a permit; or Some other thread interrupt interrupts the current thread; or The specified waiting time elapses.  If a permit is acquired then the value true is returned. If the current thread:  has its interrupted status set on entry to this method; or is interrupt interrupted while waiting to acquire a permit,  then InterruptedException is thrown and the current thread's interrupted status is cleared. If the specified waiting time elapses then the value false is returned. If the time is less than or equal to zero, the method will not wait at all.
java.util.concurrent.SynchronousQueue: A BlockingQueue blocking queue in which each insert operation must wait for a corresponding remove operation by another thread, and vice versa. A synchronous queue does not have any internal capacity, not even a capacity of one. You cannot peek at a synchronous queue because an element is only present when you try to remove it; you cannot insert an element (using any method) unless another thread is trying to remove it; you cannot iterate as there is nothing to iterate. The head of the queue is the element that the first queued inserting thread is trying to add to the queue; if there is no such queued thread then no element is available for removal and poll() will return null. For purposes of other Collection methods (for example contains), a SynchronousQueue acts as an empty collection. This queue does not permit null elements. Synchronous queues are similar to rendezvous channels used in CSP and Ada. They are well suited for handoff designs, in which an object running in one thread must sync up with an object running in another thread in order to hand it some information, event, or task. This class supports an optional fairness policy for ordering waiting producer and consumer threads. By default, this ordering is not guaranteed. However, a queue constructed with fairness set to true grants threads access in FIFO order. This class and its iterator implement all of the optional methods of the Collection and Iterator interfaces. This class is a member of the  Java Collections Framework.
java.util.concurrent.SynchronousQueue.SynchronousQueue	(	): Creates a SynchronousQueue with nonfair access policy.
java.util.concurrent.SynchronousQueue.SynchronousQueue	(	boolean	): Creates a SynchronousQueue with the specified fairness policy.
java.util.concurrent.SynchronousQueue.TransferQueue: Dual Queue 
java.util.concurrent.SynchronousQueue.TransferQueue.QNode: Node class for TransferQueue. 
java.util.concurrent.SynchronousQueue.TransferQueue.QNode.isOffList	(	): Returns true if this node is known to be off the queue because its next pointer has been forgotten due to an advanceHead operation.
java.util.concurrent.SynchronousQueue.TransferQueue.QNode.tryCancel	(	Object	): Tries to cancel by CAS'ing ref to this as item.
java.util.concurrent.SynchronousQueue.TransferQueue.advanceHead	(	QNode	QNode	): Tries to cas nh as new head; if successful, unlink old head's next node to avoid garbage retention.
java.util.concurrent.SynchronousQueue.TransferQueue.advanceTail	(	QNode	QNode	): Tries to cas nt as new tail.
java.util.concurrent.SynchronousQueue.TransferQueue.awaitFulfill	(	QNode	E	boolean	long	): Spins/blocks until node s is fulfilled.
java.util.concurrent.SynchronousQueue.TransferQueue.casCleanMe	(	QNode	QNode	): Tries to CAS cleanMe slot.
java.util.concurrent.SynchronousQueue.TransferQueue.clean	(	QNode	QNode	): Gets rid of cancelled node s with original predecessor pred.
java.util.concurrent.SynchronousQueue.TransferQueue.transfer	(	E	boolean	long	): Puts or takes an item.
java.util.concurrent.SynchronousQueue.TransferStack: Dual stack 
java.util.concurrent.SynchronousQueue.TransferStack.SNode: Node class for TransferStacks. 
java.util.concurrent.SynchronousQueue.TransferStack.SNode.tryCancel	(	): Tries to cancel a wait by matching node to itself.
java.util.concurrent.SynchronousQueue.TransferStack.SNode.tryMatch	(	SNode	): Tries to match node s to this node, if so, waking up thread. Fulfillers call tryMatch to identify their waiters. Waiters block until they have been matched.
java.util.concurrent.SynchronousQueue.TransferStack.awaitFulfill	(	SNode	boolean	long	): Spins/blocks until node s is matched by a fulfill operation.
java.util.concurrent.SynchronousQueue.TransferStack.clean	(	SNode	): Unlinks s from the stack.
java.util.concurrent.SynchronousQueue.TransferStack.isFulfilling	(	int	): Returns true if m has fulfilling bit set. 
java.util.concurrent.SynchronousQueue.TransferStack.shouldSpin	(	SNode	): Returns true if node s is at head or there is an active fulfiller.
java.util.concurrent.SynchronousQueue.TransferStack.snode	(	SNode	Object	SNode	int	): Creates or resets fields of a node. Called only from transfer where the node to push on stack is lazily created and reused when possible to help reduce intervals between reads and CASes of head and to avoid surges of garbage when CASes to push nodes fail due to contention.
java.util.concurrent.SynchronousQueue.TransferStack.transfer	(	E	boolean	long	): Puts or takes an item.
java.util.concurrent.SynchronousQueue.Transferer: Shared internal API for dual stacks and queues.
java.util.concurrent.SynchronousQueue.Transferer.transfer	(	E	boolean	long	): Performs a put or take.
java.util.concurrent.SynchronousQueue.clear	(	): Does nothing. A SynchronousQueue has no internal capacity.
java.util.concurrent.SynchronousQueue.contains	(	Object	): Always returns false. A SynchronousQueue has no internal capacity.
java.util.concurrent.SynchronousQueue.containsAll	(	Collection	): Returns false unless the given collection is empty. A SynchronousQueue has no internal capacity.
java.util.concurrent.SynchronousQueue.drainTo	(	Collection	): Removes all available elements from this queue and adds them to the given collection. This operation may be more efficient than repeatedly polling this queue. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.SynchronousQueue.drainTo	(	Collection	int	): Removes at most the given number of available elements from this queue and adds them to the given collection. A failure encountered while attempting to add elements to collection c may result in elements being in neither, either or both collections when the associated exception is thrown. Attempts to drain a queue to itself result in IllegalArgumentException. Further, the behavior of this operation is undefined if the specified collection is modified while the operation is in progress.
java.util.concurrent.SynchronousQueue.isEmpty	(	): Always returns true. A SynchronousQueue has no internal capacity.
java.util.concurrent.SynchronousQueue.iterator	(	): Returns an empty iterator in which hasNext always returns false.
java.util.concurrent.SynchronousQueue.offer	(	E	): Inserts the specified element into this queue, if another thread is waiting to receive it.
java.util.concurrent.SynchronousQueue.offer	(	E	long	TimeUnit	): Inserts the specified element into this queue, waiting if necessary up to the specified wait time for another thread to receive it.
java.util.concurrent.SynchronousQueue.peek	(	): Always returns null. A SynchronousQueue does not return elements unless actively waited on.
java.util.concurrent.SynchronousQueue.poll	(	): Retrieves and removes the head of this queue, if another thread is currently making an element available.
java.util.concurrent.SynchronousQueue.poll	(	long	TimeUnit	): Retrieves and removes the head of this queue, waiting if necessary up to the specified wait time, for another thread to insert it.
java.util.concurrent.SynchronousQueue.put	(	E	): Adds the specified element to this queue, waiting if necessary for another thread to receive it.
java.util.concurrent.SynchronousQueue.readObject	(	java.io.ObjectInputStream	): Reconstitutes this queue from a stream (that is, deserializes it).
java.util.concurrent.SynchronousQueue.remainingCapacity	(	): Always returns zero. A SynchronousQueue has no internal capacity.
java.util.concurrent.SynchronousQueue.remove	(	Object	): Always returns false. A SynchronousQueue has no internal capacity.
java.util.concurrent.SynchronousQueue.removeAll	(	Collection	): Always returns false. A SynchronousQueue has no internal capacity.
java.util.concurrent.SynchronousQueue.retainAll	(	Collection	): Always returns false. A SynchronousQueue has no internal capacity.
java.util.concurrent.SynchronousQueue.size	(	): Always returns zero. A SynchronousQueue has no internal capacity.
java.util.concurrent.SynchronousQueue.spliterator	(	): Returns an empty spliterator in which calls to trySplit() always return null.
java.util.concurrent.SynchronousQueue.take	(	): Retrieves and removes the head of this queue, waiting if necessary for another thread to insert it.
java.util.concurrent.SynchronousQueue.toArray	(	): Returns a zero-length array.
java.util.concurrent.SynchronousQueue.toArray	(	T[]	): Sets the zeroeth element of the specified array to null (if the array has non-zero length) and returns it.
java.util.concurrent.SynchronousQueue.writeObject	(	java.io.ObjectOutputStream	): Saves this queue to a stream (that is, serializes it).
java.util.concurrent.ThreadFactory: An object that creates new threads on demand. Using thread factories removes hardwiring of calls to Thread() new Thread, enabling applications to use special thread subclasses, priorities, etc.  The simplest implementation of this interface is just:  class SimpleThreadFactory implements ThreadFactory public Thread newThread(Runnable r) { return new Thread(r); } }} The defaultThreadFactory method provides a more useful simple implementation, that sets the created thread context to known values before returning it.
java.util.concurrent.ThreadFactory.newThread	(	Runnable	): Constructs a new Thread. Implementations may also initialize priority, name, daemon status, ThreadGroup, etc.
java.util.concurrent.ThreadLocalRandom: A random number generator isolated to the current thread. Like the global java.util.Random generator used by the java.lang.Math class, a ThreadLocalRandom is initialized with an internally generated seed that may not otherwise be modified. When applicable, use of ThreadLocalRandom rather than shared Random objects in concurrent programs will typically encounter much less overhead and contention. Use of ThreadLocalRandom is particularly appropriate when multiple tasks (for example, each a ForkJoinTask) use random numbers in parallel in thread pools. Usages of this class should typically be of the form: ThreadLocalRandom.current().nextX(...) (where X is Int, Long, etc). When all usages are of this form, it is never possible to accidently share a ThreadLocalRandom across multiple threads. This class also provides additional commonly used bounded random generation methods. Instances of ThreadLocalRandom are not cryptographically secure. Consider instead using java.security.SecureRandom in security-sensitive applications. Additionally, default-constructed instances do not use a cryptographically random seed unless the getProperty system property java.util.secureRandomSeed is set to true.
java.util.concurrent.ThreadLocalRandom.RandomDoublesSpliterator: Spliterator for double streams.
java.util.concurrent.ThreadLocalRandom.RandomIntsSpliterator: Spliterator for int streams. We multiplex the four int versions into one class by treating a bound less than origin as unbounded, and also by treating "infinite" as equivalent to Long.MAX_VALUE. For splits, it uses the standard divide-by-two approach. The long and double versions of this class are identical except for types.
java.util.concurrent.ThreadLocalRandom.RandomLongsSpliterator: Spliterator for long streams.
java.util.concurrent.ThreadLocalRandom.ThreadLocalRandom	(	): Constructor used only for static singleton 
java.util.concurrent.ThreadLocalRandom.advanceProbe	(	int	): Pseudo-randomly advances and records the given probe value for the given thread.
java.util.concurrent.ThreadLocalRandom.current	(	): Returns the current thread's ThreadLocalRandom.
java.util.concurrent.ThreadLocalRandom.doubles	(	): Returns an effectively unlimited stream of pseudorandom double values, each between zero (inclusive) and one (exclusive).
java.util.concurrent.ThreadLocalRandom.doubles	(	double	double	): Returns an effectively unlimited stream of pseudorandom double values, each conforming to the given origin (inclusive) and bound (exclusive).
java.util.concurrent.ThreadLocalRandom.doubles	(	long	): Returns a stream producing the given streamSize number of pseudorandom double values, each between zero (inclusive) and one (exclusive).
java.util.concurrent.ThreadLocalRandom.doubles	(	long	double	double	): Returns a stream producing the given streamSize number of pseudorandom double values, each conforming to the given origin (inclusive) and bound (exclusive).
java.util.concurrent.ThreadLocalRandom.getProbe	(	): Returns the probe value for the current thread without forcing initialization. Note that invoking ThreadLocalRandom.current() can be used to force initialization on zero return.
java.util.concurrent.ThreadLocalRandom.internalNextDouble	(	double	double	): The form of nextDouble used by DoubleStream Spliterators.
java.util.concurrent.ThreadLocalRandom.internalNextInt	(	int	int	): The form of nextInt used by IntStream Spliterators. Exactly the same as long version, except for types.
java.util.concurrent.ThreadLocalRandom.internalNextLong	(	long	long	): The form of nextLong used by LongStream Spliterators. If origin is greater than bound, acts as unbounded form of nextLong, else as bounded form.
java.util.concurrent.ThreadLocalRandom.ints	(	): Returns an effectively unlimited stream of pseudorandom int values.
java.util.concurrent.ThreadLocalRandom.ints	(	int	int	): Returns an effectively unlimited stream of pseudorandom int values, each conforming to the given origin (inclusive) and bound (exclusive).
java.util.concurrent.ThreadLocalRandom.ints	(	long	): Returns a stream producing the given streamSize number of pseudorandom int values.
java.util.concurrent.ThreadLocalRandom.ints	(	long	int	int	): Returns a stream producing the given streamSize number of pseudorandom int values, each conforming to the given origin (inclusive) and bound (exclusive).
java.util.concurrent.ThreadLocalRandom.localInit	(	): Initialize Thread fields for the current thread. Called only when Thread.threadLocalRandomProbe is zero, indicating that a thread local seed value needs to be generated. Note that even though the initialization is purely thread-local, we need to rely on (static) atomic generators to initialize the values.
java.util.concurrent.ThreadLocalRandom.longs	(	): Returns an effectively unlimited stream of pseudorandom long values.
java.util.concurrent.ThreadLocalRandom.longs	(	long	): Returns a stream producing the given streamSize number of pseudorandom long values.
java.util.concurrent.ThreadLocalRandom.longs	(	long	long	): Returns an effectively unlimited stream of pseudorandom long values, each conforming to the given origin (inclusive) and bound (exclusive).
java.util.concurrent.ThreadLocalRandom.longs	(	long	long	long	): Returns a stream producing the given streamSize number of pseudorandom long, each conforming to the given origin (inclusive) and bound (exclusive).
java.util.concurrent.ThreadLocalRandom.nextBoolean	(	): Returns a pseudorandom boolean value.
java.util.concurrent.ThreadLocalRandom.nextDouble	(	): Returns a pseudorandom double value between zero (inclusive) and one (exclusive).
java.util.concurrent.ThreadLocalRandom.nextDouble	(	double	): Returns a pseudorandom double value between 0.0 (inclusive) and the specified bound (exclusive).
java.util.concurrent.ThreadLocalRandom.nextDouble	(	double	double	): Returns a pseudorandom double value between the specified origin (inclusive) and bound (exclusive).
java.util.concurrent.ThreadLocalRandom.nextFloat	(	): Returns a pseudorandom float value between zero (inclusive) and one (exclusive).
java.util.concurrent.ThreadLocalRandom.nextInt	(	): Returns a pseudorandom int value.
java.util.concurrent.ThreadLocalRandom.nextInt	(	int	): Returns a pseudorandom int value between zero (inclusive) and the specified bound (exclusive).
java.util.concurrent.ThreadLocalRandom.nextInt	(	int	int	): Returns a pseudorandom int value between the specified origin (inclusive) and the specified bound (exclusive).
java.util.concurrent.ThreadLocalRandom.nextLong	(	): Returns a pseudorandom long value.
java.util.concurrent.ThreadLocalRandom.nextLong	(	long	): Returns a pseudorandom long value between zero (inclusive) and the specified bound (exclusive).
java.util.concurrent.ThreadLocalRandom.nextLong	(	long	long	): Returns a pseudorandom long value between the specified origin (inclusive) and the specified bound (exclusive).
java.util.concurrent.ThreadLocalRandom.nextSecondarySeed	(	): Returns the pseudo-randomly initialized or updated secondary seed.
java.util.concurrent.ThreadLocalRandom.readResolve	(	): Returns the current() thread's ThreadLocalRandom.
java.util.concurrent.ThreadLocalRandom.setSeed	(	long	): Throws UnsupportedOperationException. Setting seeds in this generator is not supported.
java.util.concurrent.ThreadLocalRandom.writeObject	(	java.io.ObjectOutputStream	): Saves the ThreadLocalRandom to a stream (that is, serializes it).
java.util.concurrent.ThreadPoolExecutor: An ExecutorService that executes each submitted task using one of possibly several pooled threads, normally configured using Executors factory methods. Thread pools address two different problems: they usually provide improved performance when executing large numbers of asynchronous tasks, due to reduced per-task invocation overhead, and they provide a means of bounding and managing the resources, including threads, consumed when executing a collection of tasks. Each ThreadPoolExecutor also maintains some basic statistics, such as the number of completed tasks. To be useful across a wide range of contexts, this class provides many adjustable parameters and extensibility hooks. However, programmers are urged to use the more convenient Executors factory methods newCachedThreadPool (unbounded thread pool, with automatic thread reclamation), newFixedThreadPool (fixed size thread pool) and newSingleThreadExecutor (single background thread), that preconfigure settings for the most common usage scenarios. Otherwise, use the following guide when manually configuring and tuning this class:  Core and maximum pool sizes A ThreadPoolExecutor will automatically adjust the pool size (see getPoolSize) according to the bounds set by corePoolSize (see getCorePoolSize) and maximumPoolSize (see getMaximumPoolSize). When a new task is submitted in method execute(), and fewer than corePoolSize threads are running, a new thread is created to handle the request, even if other worker threads are idle. If there are more than corePoolSize but less than maximumPoolSize threads running, a new thread will be created only if the queue is full. By setting corePoolSize and maximumPoolSize the same, you create a fixed-size thread pool. By setting maximumPoolSize to an essentially unbounded value such as Integer.MAX_VALUE, you allow the pool to accommodate an arbitrary number of concurrent tasks. Most typically, core and maximum pool sizes are set only upon construction, but they may also be changed dynamically using setCorePoolSize and setMaximumPoolSize.  On-demand construction By default, even core threads are initially created and started only when new tasks arrive, but this can be overridden dynamically using method prestartCoreThread or prestartAllCoreThreads. You probably want to prestart threads if you construct the pool with a non-empty queue.  Creating new threads New threads are created using a ThreadFactory. If not otherwise specified, a defaultThreadFactory is used, that creates threads to all be in the same ThreadGroup and with the same NORM_PRIORITY priority and non-daemon status. By supplying a different ThreadFactory, you can alter the thread's name, thread group, priority, daemon status, etc. If a ThreadFactory fails to create a thread when asked by returning null from newThread, the executor will continue, but might not be able to execute any tasks. Threads should possess the "modifyThread" RuntimePermission. If worker threads or other threads using the pool do not possess this permission, service may be degraded: configuration changes may not take effect in a timely manner, and a shutdown pool may remain in a state in which termination is possible but not completed. Keep-alive times If the pool currently has more than corePoolSize threads, excess threads will be terminated if they have been idle for more than the keepAliveTime (see getKeepAliveTime()). This provides a means of reducing resource consumption when the pool is not being actively used. If the pool becomes more active later, new threads will be constructed. This parameter can also be changed dynamically using method setKeepAliveTime(). Using a value of Long.MAX_VALUE NANOSECONDS effectively disables idle threads from ever terminating prior to shut down. By default, the keep-alive policy applies only when there are more than corePoolSize threads. But method allowCoreThreadTimeOut() can be used to apply this time-out policy to core threads as well, so long as the keepAliveTime value is non-zero.  Queuing Any BlockingQueue may be used to transfer and hold submitted tasks. The use of this queue interacts with pool sizing:   If fewer than corePoolSize threads are running, the Executor always prefers adding a new thread rather than queuing.  If corePoolSize or more threads are running, the Executor always prefers queuing a request rather than adding a new thread.  If a request cannot be queued, a new thread is created unless this would exceed maximumPoolSize, in which case, the task will be rejected.  There are three general strategies for queuing:    Direct handoffs. A good default choice for a work queue is a SynchronousQueue that hands off tasks to threads without otherwise holding them. Here, an attempt to queue a task will fail if no threads are immediately available to run it, so a new thread will be constructed. This policy avoids lockups when handling sets of requests that might have internal dependencies. Direct handoffs generally require unbounded maximumPoolSizes to avoid rejection of new submitted tasks. This in turn admits the possibility of unbounded thread growth when commands continue to arrive on average faster than they can be processed.   Unbounded queues. Using an unbounded queue (for example a LinkedBlockingQueue without a predefined capacity) will cause new tasks to wait in the queue when all corePoolSize threads are busy. Thus, no more than corePoolSize threads will ever be created. (And the value of the maximumPoolSize therefore doesn't have any effect.) This may be appropriate when each task is completely independent of others, so tasks cannot affect each others execution; for example, in a web page server. While this style of queuing can be useful in smoothing out transient bursts of requests, it admits the possibility of unbounded work queue growth when commands continue to arrive on average faster than they can be processed.  Bounded queues. A bounded queue (for example, an ArrayBlockingQueue) helps prevent resource exhaustion when used with finite maximumPoolSizes, but can be more difficult to tune and control. Queue sizes and maximum pool sizes may be traded off for each other: Using large queues and small pools minimizes CPU usage, OS resources, and context-switching overhead, but can lead to artificially low throughput. If tasks frequently block (for example if they are I/O bound), a system may be able to schedule time for more threads than you otherwise allow. Use of small queues generally requires larger pool sizes, which keeps CPUs busier but may encounter unacceptable scheduling overhead, which also decreases throughput.    Rejected tasks New tasks submitted in method execute() will be rejected when the Executor has been shut down, and also when the Executor uses finite bounds for both maximum threads and work queue capacity, and is saturated. In either case, the execute method invokes the rejectedExecution() method of its RejectedExecutionHandler. Four predefined handler policies are provided:   In the default ThreadPoolExecutor.AbortPolicy, the handler throws a runtime RejectedExecutionException upon rejection.   In ThreadPoolExecutor.CallerRunsPolicy, the thread that invokes execute itself runs the task. This provides a simple feedback control mechanism that will slow down the rate that new tasks are submitted.   In ThreadPoolExecutor.DiscardPolicy, a task that cannot be executed is simply dropped.  In ThreadPoolExecutor.DiscardOldestPolicy, if the executor is not shut down, the task at the head of the work queue is dropped, and then execution is retried (which can fail again, causing this to be repeated.)   It is possible to define and use other kinds of RejectedExecutionHandler classes. Doing so requires some care especially when policies are designed to work only under particular capacity or queuing policies.  Hook methods This class provides protected overridable beforeExecute() and afterExecute() methods that are called before and after execution of each task. These can be used to manipulate the execution environment; for example, reinitializing ThreadLocals, gathering statistics, or adding log entries. Additionally, method terminated can be overridden to perform any special processing that needs to be done once the Executor has fully terminated. If hook or callback methods throw exceptions, internal worker threads may in turn fail and abruptly terminate. Queue maintenance Method getQueue() allows access to the work queue for purposes of monitoring and debugging. Use of this method for any other purpose is strongly discouraged. Two supplied methods, remove() and purge are available to assist in storage reclamation when large numbers of queued tasks become cancelled. Finalization A pool that is no longer referenced in a program AND has no remaining threads will be shutdown automatically. If you would like to ensure that unreferenced pools are reclaimed even if users forget to call shutdown, then you must arrange that unused threads eventually die, by setting appropriate keep-alive times, using a lower bound of zero core threads and/or setting allowCoreThreadTimeOut().   Extension example. Most extensions of this class override one or more of the protected hook methods. For example, here is a subclass that adds a simple pause/resume feature:  class PausableThreadPoolExecutor extends ThreadPoolExecutor private boolean isPaused; private ReentrantLock pauseLock = new ReentrantLock(); private Condition unpaused = pauseLock.newCondition(); public PausableThreadPoolExecutor(...) { super(...); } protected void beforeExecute(Thread t, Runnable r) { super.beforeExecute(t, r); pauseLock.lock(); try { while (isPaused) unpaused.await(); } catch (InterruptedException ie) { t.interrupt(); } finally { pauseLock.unlock(); } } public void pause() { pauseLock.lock(); try { isPaused = true; } finally { pauseLock.unlock(); } } public void resume() { pauseLock.lock(); try { isPaused = false; unpaused.signalAll(); } finally { pauseLock.unlock(); } } }}
java.util.concurrent.ThreadPoolExecutor.AbortPolicy: A handler for rejected tasks that throws a RejectedExecutionException.
java.util.concurrent.ThreadPoolExecutor.AbortPolicy.AbortPolicy	(	): Creates an AbortPolicy.
java.util.concurrent.ThreadPoolExecutor.AbortPolicy.rejectedExecution	(	Runnable	ThreadPoolExecutor	): Always throws RejectedExecutionException.
java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy: A handler for rejected tasks that runs the rejected task directly in the calling thread of the execute method, unless the executor has been shut down, in which case the task is discarded.
java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy.CallerRunsPolicy	(	): Creates a CallerRunsPolicy.
java.util.concurrent.ThreadPoolExecutor.CallerRunsPolicy.rejectedExecution	(	Runnable	ThreadPoolExecutor	): Executes task r in the caller's thread, unless the executor has been shut down, in which case the task is discarded.
java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy: A handler for rejected tasks that discards the oldest unhandled request and then retries execute, unless the executor is shut down, in which case the task is discarded.
java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy.DiscardOldestPolicy	(	): Creates a DiscardOldestPolicy for the given executor.
java.util.concurrent.ThreadPoolExecutor.DiscardOldestPolicy.rejectedExecution	(	Runnable	ThreadPoolExecutor	): Obtains and ignores the next task that the executor would otherwise execute, if one is immediately available, and then retries execution of task r, unless the executor is shut down, in which case task r is instead discarded.
java.util.concurrent.ThreadPoolExecutor.DiscardPolicy: A handler for rejected tasks that silently discards the rejected task.
java.util.concurrent.ThreadPoolExecutor.DiscardPolicy.DiscardPolicy	(	): Creates a DiscardPolicy.
java.util.concurrent.ThreadPoolExecutor.DiscardPolicy.rejectedExecution	(	Runnable	ThreadPoolExecutor	): Does nothing, which has the effect of discarding task r.
java.util.concurrent.ThreadPoolExecutor.ThreadPoolExecutor	(	int	int	long	TimeUnit	BlockingQueue	): Creates a new ThreadPoolExecutor with the given initial parameters and default thread factory and rejected execution handler. It may be more convenient to use one of the Executors factory methods instead of this general purpose constructor.
java.util.concurrent.ThreadPoolExecutor.ThreadPoolExecutor	(	int	int	long	TimeUnit	BlockingQueue	RejectedExecutionHandler	): Creates a new ThreadPoolExecutor with the given initial parameters and default thread factory.
java.util.concurrent.ThreadPoolExecutor.ThreadPoolExecutor	(	int	int	long	TimeUnit	BlockingQueue	ThreadFactory	): Creates a new ThreadPoolExecutor with the given initial parameters and default rejected execution handler.
java.util.concurrent.ThreadPoolExecutor.ThreadPoolExecutor	(	int	int	long	TimeUnit	BlockingQueue	ThreadFactory	RejectedExecutionHandler	): Creates a new ThreadPoolExecutor with the given initial parameters.
java.util.concurrent.ThreadPoolExecutor.Worker: Class Worker mainly maintains interrupt control state for threads running tasks, along with other minor bookkeeping. This class opportunistically extends AbstractQueuedSynchronizer to simplify acquiring and releasing a lock surrounding each task execution. This protects against interrupts that are intended to wake up a worker thread waiting for a task from instead interrupting a task being run. We implement a simple non-reentrant mutual exclusion lock rather than use ReentrantLock because we do not want worker tasks to be able to reacquire the lock when they invoke pool control methods like setCorePoolSize. Additionally, to suppress interrupts until the thread actually starts running tasks, we initialize lock state to a negative value, and clear it upon start (in runWorker).
java.util.concurrent.ThreadPoolExecutor.Worker.Worker	(	Runnable	): Creates with given first task and thread from ThreadFactory.
java.util.concurrent.ThreadPoolExecutor.Worker.run	(	): Delegates main run loop to outer runWorker 
java.util.concurrent.ThreadPoolExecutor.addWorker	(	Runnable	boolean	): Checks if a new worker can be added with respect to current pool state and the given bound (either core or maximum). If so, the worker count is adjusted accordingly, and, if possible, a new worker is created and started, running firstTask as its first task. This method returns false if the pool is stopped or eligible to shut down. It also returns false if the thread factory fails to create a thread when asked. If the thread creation fails, either due to the thread factory returning null, or due to an exception (typically OutOfMemoryError in Thread.start()), we roll back cleanly.
java.util.concurrent.ThreadPoolExecutor.addWorkerFailed	(	Worker	): Rolls back the worker thread creation. - removes worker from workers, if present - decrements worker count - rechecks for termination, in case the existence of this worker was holding up termination
java.util.concurrent.ThreadPoolExecutor.advanceRunState	(	int	): Transitions runState to given target, or leaves it alone if already at least the given target.
java.util.concurrent.ThreadPoolExecutor.afterExecute	(	Runnable	Throwable	): Method invoked upon completion of execution of the given Runnable. This method is invoked by the thread that executed the task. If non-null, the Throwable is the uncaught RuntimeException or Error that caused execution to terminate abruptly. This implementation does nothing, but may be customized in subclasses. Note: To properly nest multiple overridings, subclasses should generally invoke super.afterExecute at the beginning of this method. Note: When actions are enclosed in tasks (such as FutureTask) either explicitly or via methods such as submit, these task objects catch and maintain computational exceptions, and so they do not cause abrupt termination, and the internal exceptions are not passed to this method. If you would like to trap both kinds of failures in this method, you can further probe for such cases, as in this sample subclass that prints either the direct cause or the underlying exception if a task has been aborted:  class ExtendedExecutor extends ThreadPoolExecutor // ... protected void afterExecute(Runnable r, Throwable t) { super.afterExecute(r, t); if (t == null && r instanceof Future) { try { Object result = ((Future) r).get(); } catch (CancellationException ce) { t = ce; } catch (ExecutionException ee) { t = ee.getCause(); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); // ignore/reset } } if (t != null) System.out.println(t); } }}
java.util.concurrent.ThreadPoolExecutor.allowCoreThreadTimeOut	(	boolean	): Sets the policy governing whether core threads may time out and terminate if no tasks arrive within the keep-alive time, being replaced if needed when new tasks arrive. When false, core threads are never terminated due to lack of incoming tasks. When true, the same keep-alive policy applying to non-core threads applies also to core threads. To avoid continual thread replacement, the keep-alive time must be greater than zero when setting true. This method should in general be called before the pool is actively used.
java.util.concurrent.ThreadPoolExecutor.allowsCoreThreadTimeOut	(	): Returns true if this pool allows core threads to time out and terminate if no tasks arrive within the keepAlive time, being replaced if needed when new tasks arrive. When true, the same keep-alive policy applying to non-core threads applies also to core threads. When false (the default), core threads are never terminated due to lack of incoming tasks.
java.util.concurrent.ThreadPoolExecutor.beforeExecute	(	Thread	Runnable	): Method invoked prior to executing the given Runnable in the given thread. This method is invoked by thread t that will execute task r, and may be used to re-initialize ThreadLocals, or to perform logging. This implementation does nothing, but may be customized in subclasses. Note: To properly nest multiple overridings, subclasses should generally invoke super.beforeExecute at the end of this method.
java.util.concurrent.ThreadPoolExecutor.checkShutdownAccess	(	): If there is a security manager, makes sure caller has permission to shut down threads in general (see shutdownPerm). If this passes, additionally makes sure the caller is allowed to interrupt each worker thread. This might not be true even if first check passed, if the SecurityManager treats some threads specially.
java.util.concurrent.ThreadPoolExecutor.compareAndDecrementWorkerCount	(	int	): Attempts to CAS-decrement the workerCount field of ctl.
java.util.concurrent.ThreadPoolExecutor.compareAndIncrementWorkerCount	(	int	): Attempts to CAS-increment the workerCount field of ctl.
java.util.concurrent.ThreadPoolExecutor.decrementWorkerCount	(	): Decrements the workerCount field of ctl. This is called only on abrupt termination of a thread (see processWorkerExit). Other decrements are performed within getTask.
java.util.concurrent.ThreadPoolExecutor.drainQueue	(	): Drains the task queue into a new list, normally using drainTo. But if the queue is a DelayQueue or any other kind of queue for which poll or drainTo may fail to remove some elements, it deletes them one by one.
java.util.concurrent.ThreadPoolExecutor.ensurePrestart	(	): Same as prestartCoreThread except arranges that at least one thread is started even if corePoolSize is 0.
java.util.concurrent.ThreadPoolExecutor.execute	(	Runnable	): Executes the given task sometime in the future. The task may execute in a new thread or in an existing pooled thread. If the task cannot be submitted for execution, either because this executor has been shutdown or because its capacity has been reached, the task is handled by the current RejectedExecutionHandler.
java.util.concurrent.ThreadPoolExecutor.finalize	(	): Invokes shutdown when this executor is no longer referenced and it has no threads.
java.util.concurrent.ThreadPoolExecutor.getActiveCount	(	): Returns the approximate number of threads that are actively executing tasks.
java.util.concurrent.ThreadPoolExecutor.getCompletedTaskCount	(	): Returns the approximate total number of tasks that have completed execution. Because the states of tasks and threads may change dynamically during computation, the returned value is only an approximation, but one that does not ever decrease across successive calls.
java.util.concurrent.ThreadPoolExecutor.getCorePoolSize	(	): Returns the core number of threads.
java.util.concurrent.ThreadPoolExecutor.getKeepAliveTime	(	TimeUnit	): Returns the thread keep-alive time, which is the amount of time that threads in excess of the core pool size may remain idle before being terminated.
java.util.concurrent.ThreadPoolExecutor.getLargestPoolSize	(	): Returns the largest number of threads that have ever simultaneously been in the pool.
java.util.concurrent.ThreadPoolExecutor.getMaximumPoolSize	(	): Returns the maximum allowed number of threads.
java.util.concurrent.ThreadPoolExecutor.getPoolSize	(	): Returns the current number of threads in the pool.
java.util.concurrent.ThreadPoolExecutor.getQueue	(	): Returns the task queue used by this executor. Access to the task queue is intended primarily for debugging and monitoring. This queue may be in active use. Retrieving the task queue does not prevent queued tasks from executing.
java.util.concurrent.ThreadPoolExecutor.getRejectedExecutionHandler	(	): Returns the current handler for unexecutable tasks.
java.util.concurrent.ThreadPoolExecutor.getTask	(	): Performs blocking or timed wait for a task, depending on current configuration settings, or returns null if this worker must exit because of any of: 1. There are more than maximumPoolSize workers (due to a call to setMaximumPoolSize). 2. The pool is stopped. 3. The pool is shutdown and the queue is empty. 4. This worker timed out waiting for a task, and timed-out workers are subject to termination (that is, allowCoreThreadTimeOut || workerCount > corePoolSize) both before and after the timed wait, and if the queue is non-empty, this worker is not the last thread in the pool.
java.util.concurrent.ThreadPoolExecutor.getTaskCount	(	): Returns the approximate total number of tasks that have ever been scheduled for execution. Because the states of tasks and threads may change dynamically during computation, the returned value is only an approximation.
java.util.concurrent.ThreadPoolExecutor.getThreadFactory	(	): Returns the thread factory used to create new threads.
java.util.concurrent.ThreadPoolExecutor.interruptIdleWorkers	(	): Common form of interruptIdleWorkers, to avoid having to remember what the boolean argument means.
java.util.concurrent.ThreadPoolExecutor.interruptIdleWorkers	(	boolean	): Interrupts threads that might be waiting for tasks (as indicated by not being locked) so they can check for termination or configuration changes. Ignores SecurityExceptions (in which case some threads may remain uninterrupted).
java.util.concurrent.ThreadPoolExecutor.interruptWorkers	(	): Interrupts all threads, even if active. Ignores SecurityExceptions (in which case some threads may remain uninterrupted).
java.util.concurrent.ThreadPoolExecutor.isRunningOrShutdown	(	boolean	): State check needed by ScheduledThreadPoolExecutor to enable running tasks during shutdown.
java.util.concurrent.ThreadPoolExecutor.isTerminating	(	): Returns true if this executor is in the process of terminating after shutdown or shutdownNow but has not completely terminated. This method may be useful for debugging. A return of true reported a sufficient period after shutdown may indicate that submitted tasks have ignored or suppressed interruption, causing this executor not to properly terminate.
java.util.concurrent.ThreadPoolExecutor.onShutdown	(	): Performs any further cleanup following run state transition on invocation of shutdown. A no-op here, but used by ScheduledThreadPoolExecutor to cancel delayed tasks.
java.util.concurrent.ThreadPoolExecutor.prestartAllCoreThreads	(	): Starts all core threads, causing them to idly wait for work. This overrides the default policy of starting core threads only when new tasks are executed.
java.util.concurrent.ThreadPoolExecutor.prestartCoreThread	(	): Starts a core thread, causing it to idly wait for work. This overrides the default policy of starting core threads only when new tasks are executed. This method will return false if all core threads have already been started.
java.util.concurrent.ThreadPoolExecutor.processWorkerExit	(	Worker	boolean	): Performs cleanup and bookkeeping for a dying worker. Called only from worker threads. Unless completedAbruptly is set, assumes that workerCount has already been adjusted to account for exit. This method removes thread from worker set, and possibly terminates the pool or replaces the worker if either it exited due to user task exception or if fewer than corePoolSize workers are running or queue is non-empty but there are no workers.
java.util.concurrent.ThreadPoolExecutor.purge	(	): Tries to remove from the work queue all Future tasks that have been cancelled. This method can be useful as a storage reclamation operation, that has no other impact on functionality. Cancelled tasks are never executed, but may accumulate in work queues until worker threads can actively remove them. Invoking this method instead tries to remove them now. However, this method may fail to remove tasks in the presence of interference by other threads.
java.util.concurrent.ThreadPoolExecutor.reject	(	Runnable	): Invokes the rejected execution handler for the given command. Package-protected for use by ScheduledThreadPoolExecutor.
java.util.concurrent.ThreadPoolExecutor.remove	(	Runnable	): Removes this task from the executor's internal queue if it is present, thus causing it not to be run if it has not already started. This method may be useful as one part of a cancellation scheme. It may fail to remove tasks that have been converted into other forms before being placed on the internal queue. For example, a task entered using submit might be converted into a form that maintains Future status. However, in such cases, method purge may be used to remove those Futures that have been cancelled.
java.util.concurrent.ThreadPoolExecutor.runWorker	(	Worker	): Main worker run loop. Repeatedly gets tasks from queue and executes them, while coping with a number of issues: 1. We may start out with an initial task, in which case we don't need to get the first one. Otherwise, as long as pool is running, we get tasks from getTask. If it returns null then the worker exits due to changed pool state or configuration parameters. Other exits result from exception throws in external code, in which case completedAbruptly holds, which usually leads processWorkerExit to replace this thread. 2. Before running any task, the lock is acquired to prevent other pool interrupts while the task is executing, and then we ensure that unless pool is stopping, this thread does not have its interrupt set. 3. Each task run is preceded by a call to beforeExecute, which might throw an exception, in which case we cause thread to die (breaking loop with completedAbruptly true) without processing the task. 4. Assuming beforeExecute completes normally, we run the task, gathering any of its thrown exceptions to send to afterExecute. We separately handle RuntimeException, Error (both of which the specs guarantee that we trap) and arbitrary Throwables. Because we cannot rethrow Throwables within Runnable.run, we wrap them within Errors on the way out (to the thread's UncaughtExceptionHandler). Any thrown exception also conservatively causes thread to die. 5. After task.run completes, we call afterExecute, which may also throw an exception, which will also cause thread to die. According to JLS Sec 14.20, this exception is the one that will be in effect even if task.run throws. The net effect of the exception mechanics is that afterExecute and the thread's UncaughtExceptionHandler have as accurate information as we can provide about any problems encountered by user code.
java.util.concurrent.ThreadPoolExecutor.setCorePoolSize	(	int	): Sets the core number of threads. This overrides any value set in the constructor. If the new value is smaller than the current value, excess existing threads will be terminated when they next become idle. If larger, new threads will, if needed, be started to execute any queued tasks.
java.util.concurrent.ThreadPoolExecutor.setKeepAliveTime	(	long	TimeUnit	): Sets the time limit for which threads may remain idle before being terminated. If there are more than the core number of threads currently in the pool, after waiting this amount of time without processing a task, excess threads will be terminated. This overrides any value set in the constructor.
java.util.concurrent.ThreadPoolExecutor.setMaximumPoolSize	(	int	): Sets the maximum allowed number of threads. This overrides any value set in the constructor. If the new value is smaller than the current value, excess existing threads will be terminated when they next become idle.
java.util.concurrent.ThreadPoolExecutor.setRejectedExecutionHandler	(	RejectedExecutionHandler	): Sets a new handler for unexecutable tasks.
java.util.concurrent.ThreadPoolExecutor.setThreadFactory	(	ThreadFactory	): Sets the thread factory used to create new threads.
java.util.concurrent.ThreadPoolExecutor.shutdown	(	): Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted. Invocation has no additional effect if already shut down. This method does not wait for previously submitted tasks to complete execution. Use awaitTermination to do that.
java.util.concurrent.ThreadPoolExecutor.shutdownNow	(	): Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution. These tasks are drained (removed) from the task queue upon return from this method. This method does not wait for actively executing tasks to terminate. Use awaitTermination to do that. There are no guarantees beyond best-effort attempts to stop processing actively executing tasks. This implementation cancels tasks via interrupt, so any task that fails to respond to interrupts may never terminate.
java.util.concurrent.ThreadPoolExecutor.terminated	(	): Method invoked when the Executor has terminated. Default implementation does nothing. Note: To properly nest multiple overridings, subclasses should generally invoke super.terminated within this method.
java.util.concurrent.ThreadPoolExecutor.toString	(	): Returns a string identifying this pool, as well as its state, including indications of run state and estimated worker and task counts.
java.util.concurrent.ThreadPoolExecutor.tryTerminate	(	): Transitions to TERMINATED state if either (SHUTDOWN and pool and queue empty) or (STOP and pool empty). If otherwise eligible to terminate but workerCount is nonzero, interrupts an idle worker to ensure that shutdown signals propagate. This method must be called following any action that might make termination possible -- reducing worker count or removing tasks from the queue during shutdown. The method is non-private to allow access from ScheduledThreadPoolExecutor.
java.util.concurrent.TimeoutException: Exception thrown when a blocking operation times out. Blocking operations for which a timeout is specified need a means to indicate that the timeout has occurred. For many such operations it is possible to return a value that indicates timeout; when that is not possible or desirable then TimeoutException should be declared and thrown.
java.util.concurrent.TimeoutException.TimeoutException	(	): Constructs a TimeoutException with no specified detail message.
java.util.concurrent.TimeoutException.TimeoutException	(	String	): Constructs a TimeoutException with the specified detail message.
java.util.concurrent.TransferQueue: A BlockingQueue in which producers may wait for consumers to receive elements. A TransferQueue may be useful for example in message passing applications in which producers sometimes (using method transfer) await receipt of elements by consumers invoking take or poll, while at other times enqueue elements (via method put) without waiting for receipt. tryTransfer() Non-blocking and tryTransfer() time-out versions of tryTransfer are also available. A TransferQueue may also be queried, via hasWaitingConsumer, whether there are any threads waiting for items, which is a converse analogy to a peek operation. Like other blocking queues, a TransferQueue may be capacity bounded. If so, an attempted transfer operation may initially block waiting for available space, and/or subsequently block waiting for reception by a consumer. Note that in a queue with zero capacity, such as SynchronousQueue, put and transfer are effectively synonymous. This interface is a member of the  Java Collections Framework.
java.util.concurrent.TransferQueue.getWaitingConsumerCount	(	): Returns an estimate of the number of consumers waiting to receive elements via take or timed poll(). The return value is an approximation of a momentary state of affairs, that may be inaccurate if consumers have completed or given up waiting. The value may be useful for monitoring and heuristics, but not for synchronization control. Implementations of this method are likely to be noticeably slower than those for hasWaitingConsumer.
java.util.concurrent.TransferQueue.hasWaitingConsumer	(	): Returns true if there is at least one consumer waiting to receive an element via take or timed poll(). The return value represents a momentary state of affairs.
java.util.concurrent.TransferQueue.transfer	(	E	): Transfers the element to a consumer, waiting if necessary to do so. More precisely, transfers the specified element immediately if there exists a consumer already waiting to receive it (in take or timed poll()), else waits until the element is received by a consumer.
java.util.concurrent.TransferQueue.tryTransfer	(	E	): Transfers the element to a waiting consumer immediately, if possible. More precisely, transfers the specified element immediately if there exists a consumer already waiting to receive it (in take or timed poll()), otherwise returning false without enqueuing the element.
java.util.concurrent.TransferQueue.tryTransfer	(	E	long	TimeUnit	): Transfers the element to a consumer if it is possible to do so before the timeout elapses. More precisely, transfers the specified element immediately if there exists a consumer already waiting to receive it (in take or timed poll()), else waits until the element is received by a consumer, returning false if the specified wait time elapses before the element can be transferred.
java.util.concurrent.atomic.AtomicBoolean: A boolean value that may be updated atomically. See the java.util.concurrent.atomic package specification for description of the properties of atomic variables. An AtomicBoolean is used in applications such as atomically updated flags, and cannot be used as a replacement for a java.lang.Boolean.
java.util.concurrent.atomic.AtomicBoolean.AtomicBoolean	(	): Creates a new AtomicBoolean with initial value false.
java.util.concurrent.atomic.AtomicBoolean.AtomicBoolean	(	boolean	): Creates a new AtomicBoolean with the given initial value.
java.util.concurrent.atomic.AtomicBoolean.compareAndSet	(	boolean	boolean	): Atomically sets the value to the given updated value if the current value == the expected value.
java.util.concurrent.atomic.AtomicBoolean.get	(	): Returns the current value.
java.util.concurrent.atomic.AtomicBoolean.getAndSet	(	boolean	): Atomically sets to the given value and returns the previous value.
java.util.concurrent.atomic.AtomicBoolean.lazySet	(	boolean	): Eventually sets to the given value.
java.util.concurrent.atomic.AtomicBoolean.set	(	boolean	): Unconditionally sets to the given value.
java.util.concurrent.atomic.AtomicBoolean.toString	(	): Returns the String representation of the current value.
java.util.concurrent.atomic.AtomicBoolean.weakCompareAndSet	(	boolean	boolean	): Atomically sets the value to the given updated value if the current value == the expected value. May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to compareAndSet.
java.util.concurrent.atomic.AtomicInteger: An int value that may be updated atomically. See the java.util.concurrent.atomic package specification for description of the properties of atomic variables. An AtomicInteger is used in applications such as atomically incremented counters, and cannot be used as a replacement for an java.lang.Integer. However, this class does extend Number to allow uniform access by tools and utilities that deal with numerically-based classes.
java.util.concurrent.atomic.AtomicInteger.AtomicInteger	(	): Creates a new AtomicInteger with initial value 0.
java.util.concurrent.atomic.AtomicInteger.AtomicInteger	(	int	): Creates a new AtomicInteger with the given initial value.
java.util.concurrent.atomic.AtomicInteger.accumulateAndGet	(	int	IntBinaryOperator	): Atomically updates the current value with the results of applying the given function to the current and given values, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value as its first argument, and the given update as the second argument.
java.util.concurrent.atomic.AtomicInteger.addAndGet	(	int	): Atomically adds the given value to the current value.
java.util.concurrent.atomic.AtomicInteger.compareAndSet	(	int	int	): Atomically sets the value to the given updated value if the current value == the expected value.
java.util.concurrent.atomic.AtomicInteger.decrementAndGet	(	): Atomically decrements by one the current value.
java.util.concurrent.atomic.AtomicInteger.doubleValue	(	): Returns the value of this AtomicInteger as a double after a widening primitive conversion.
java.util.concurrent.atomic.AtomicInteger.floatValue	(	): Returns the value of this AtomicInteger as a float after a widening primitive conversion.
java.util.concurrent.atomic.AtomicInteger.get	(	): Gets the current value.
java.util.concurrent.atomic.AtomicInteger.getAndAccumulate	(	int	IntBinaryOperator	): Atomically updates the current value with the results of applying the given function to the current and given values, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value as its first argument, and the given update as the second argument.
java.util.concurrent.atomic.AtomicInteger.getAndAdd	(	int	): Atomically adds the given value to the current value.
java.util.concurrent.atomic.AtomicInteger.getAndDecrement	(	): Atomically decrements by one the current value.
java.util.concurrent.atomic.AtomicInteger.getAndIncrement	(	): Atomically increments by one the current value.
java.util.concurrent.atomic.AtomicInteger.getAndSet	(	int	): Atomically sets to the given value and returns the old value.
java.util.concurrent.atomic.AtomicInteger.getAndUpdate	(	IntUnaryOperator	): Atomically updates the current value with the results of applying the given function, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.
java.util.concurrent.atomic.AtomicInteger.incrementAndGet	(	): Atomically increments by one the current value.
java.util.concurrent.atomic.AtomicInteger.intValue	(	): Returns the value of this AtomicInteger as an int.
java.util.concurrent.atomic.AtomicInteger.lazySet	(	int	): Eventually sets to the given value.
java.util.concurrent.atomic.AtomicInteger.longValue	(	): Returns the value of this AtomicInteger as a long after a widening primitive conversion.
java.util.concurrent.atomic.AtomicInteger.set	(	int	): Sets to the given value.
java.util.concurrent.atomic.AtomicInteger.toString	(	): Returns the String representation of the current value.
java.util.concurrent.atomic.AtomicInteger.updateAndGet	(	IntUnaryOperator	): Atomically updates the current value with the results of applying the given function, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.
java.util.concurrent.atomic.AtomicInteger.weakCompareAndSet	(	int	int	): Atomically sets the value to the given updated value if the current value == the expected value. May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to compareAndSet.
java.util.concurrent.atomic.AtomicIntegerArray: An int array in which elements may be updated atomically. See the java.util.concurrent.atomic package specification for description of the properties of atomic variables.
java.util.concurrent.atomic.AtomicIntegerArray.AtomicIntegerArray	(	int	): Creates a new AtomicIntegerArray of the given length, with all elements initially zero.
java.util.concurrent.atomic.AtomicIntegerArray.AtomicIntegerArray	(	int[]	): Creates a new AtomicIntegerArray with the same length as, and all elements copied from, the given array.
java.util.concurrent.atomic.AtomicIntegerArray.accumulateAndGet	(	int	int	IntBinaryOperator	): Atomically updates the element at index i with the results of applying the given function to the current and given values, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value at index i as its first argument, and the given update as the second argument.
java.util.concurrent.atomic.AtomicIntegerArray.addAndGet	(	int	int	): Atomically adds the given value to the element at index i.
java.util.concurrent.atomic.AtomicIntegerArray.compareAndSet	(	int	int	int	): Atomically sets the element at position i to the given updated value if the current value == the expected value.
java.util.concurrent.atomic.AtomicIntegerArray.decrementAndGet	(	int	): Atomically decrements by one the element at index i.
java.util.concurrent.atomic.AtomicIntegerArray.get	(	int	): Gets the current value at position i.
java.util.concurrent.atomic.AtomicIntegerArray.getAndAccumulate	(	int	int	IntBinaryOperator	): Atomically updates the element at index i with the results of applying the given function to the current and given values, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value at index i as its first argument, and the given update as the second argument.
java.util.concurrent.atomic.AtomicIntegerArray.getAndAdd	(	int	int	): Atomically adds the given value to the element at index i.
java.util.concurrent.atomic.AtomicIntegerArray.getAndDecrement	(	int	): Atomically decrements by one the element at index i.
java.util.concurrent.atomic.AtomicIntegerArray.getAndIncrement	(	int	): Atomically increments by one the element at index i.
java.util.concurrent.atomic.AtomicIntegerArray.getAndSet	(	int	int	): Atomically sets the element at position i to the given value and returns the old value.
java.util.concurrent.atomic.AtomicIntegerArray.getAndUpdate	(	int	IntUnaryOperator	): Atomically updates the element at index i with the results of applying the given function, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.
java.util.concurrent.atomic.AtomicIntegerArray.incrementAndGet	(	int	): Atomically increments by one the element at index i.
java.util.concurrent.atomic.AtomicIntegerArray.lazySet	(	int	int	): Eventually sets the element at position i to the given value.
java.util.concurrent.atomic.AtomicIntegerArray.length	(	): Returns the length of the array.
java.util.concurrent.atomic.AtomicIntegerArray.set	(	int	int	): Sets the element at position i to the given value.
java.util.concurrent.atomic.AtomicIntegerArray.toString	(	): Returns the String representation of the current values of array.
java.util.concurrent.atomic.AtomicIntegerArray.updateAndGet	(	int	IntUnaryOperator	): Atomically updates the element at index i with the results of applying the given function, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.
java.util.concurrent.atomic.AtomicIntegerArray.weakCompareAndSet	(	int	int	int	): Atomically sets the element at position i to the given updated value if the current value == the expected value. May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to compareAndSet.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater: A reflection-based utility that enables atomic updates to designated volatile int fields of designated classes. This class is designed for use in atomic data structures in which several fields of the same node are independently subject to atomic updates. Note that the guarantees of the compareAndSet method in this class are weaker than in other atomic classes. Because this class cannot ensure that all uses of the field are appropriate for purposes of atomic access, it can guarantee atomicity only with respect to other invocations of compareAndSet and set on the same updater.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.AtomicIntegerFieldUpdater	(	): Protected do-nothing constructor for use by subclasses.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.AtomicIntegerFieldUpdaterImpl: Standard hotspot implementation using intrinsics
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.AtomicIntegerFieldUpdaterImpl.isAncestor	(	ClassLoader	ClassLoader	): Returns true if the second classloader can be found in the first classloader's delegation chain. Equivalent to the inaccessible: first.isAncestor(second).
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.accumulateAndGet	(	T	int	IntBinaryOperator	): Atomically updates the field of the given object managed by this updater with the results of applying the given function to the current and given values, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value as its first argument, and the given update as the second argument.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.addAndGet	(	T	int	): Atomically adds the given value to the current value of the field of the given object managed by this updater.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.compareAndSet	(	T	int	int	): Atomically sets the field of the given object managed by this updater to the given updated value if the current value == the expected value. This method is guaranteed to be atomic with respect to other calls to compareAndSet and set, but not necessarily with respect to other changes in the field.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.decrementAndGet	(	T	): Atomically decrements by one the current value of the field of the given object managed by this updater.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.get	(	T	): Gets the current value held in the field of the given object managed by this updater.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.getAndAccumulate	(	T	int	IntBinaryOperator	): Atomically updates the field of the given object managed by this updater with the results of applying the given function to the current and given values, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value as its first argument, and the given update as the second argument.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.getAndAdd	(	T	int	): Atomically adds the given value to the current value of the field of the given object managed by this updater.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.getAndDecrement	(	T	): Atomically decrements by one the current value of the field of the given object managed by this updater.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.getAndIncrement	(	T	): Atomically increments by one the current value of the field of the given object managed by this updater.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.getAndSet	(	T	int	): Atomically sets the field of the given object managed by this updater to the given value and returns the old value.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.getAndUpdate	(	T	IntUnaryOperator	): Atomically updates the field of the given object managed by this updater with the results of applying the given function, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.incrementAndGet	(	T	): Atomically increments by one the current value of the field of the given object managed by this updater.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.lazySet	(	T	int	): Eventually sets the field of the given object managed by this updater to the given updated value.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater	(	Class	String	): Creates and returns an updater for objects with the given field. The Class argument is needed to check that reflective types and generic types match.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.set	(	T	int	): Sets the field of the given object managed by this updater to the given updated value. This operation is guaranteed to act as a volatile store with respect to subsequent invocations of compareAndSet.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.updateAndGet	(	T	IntUnaryOperator	): Atomically updates the field of the given object managed by this updater with the results of applying the given function, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.
java.util.concurrent.atomic.AtomicIntegerFieldUpdater.weakCompareAndSet	(	T	int	int	): Atomically sets the field of the given object managed by this updater to the given updated value if the current value == the expected value. This method is guaranteed to be atomic with respect to other calls to compareAndSet and set, but not necessarily with respect to other changes in the field. May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to compareAndSet.
java.util.concurrent.atomic.AtomicLong: A long value that may be updated atomically. See the java.util.concurrent.atomic package specification for description of the properties of atomic variables. An AtomicLong is used in applications such as atomically incremented sequence numbers, and cannot be used as a replacement for a java.lang.Long. However, this class does extend Number to allow uniform access by tools and utilities that deal with numerically-based classes.
java.util.concurrent.atomic.AtomicLong.AtomicLong	(	): Creates a new AtomicLong with initial value 0.
java.util.concurrent.atomic.AtomicLong.AtomicLong	(	long	): Creates a new AtomicLong with the given initial value.
java.util.concurrent.atomic.AtomicLong.VMSupportsCS8	(	): Returns whether underlying JVM supports lockless CompareAndSet for longs. Called only once and cached in VM_SUPPORTS_LONG_CAS.
java.util.concurrent.atomic.AtomicLong.accumulateAndGet	(	long	LongBinaryOperator	): Atomically updates the current value with the results of applying the given function to the current and given values, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value as its first argument, and the given update as the second argument.
java.util.concurrent.atomic.AtomicLong.addAndGet	(	long	): Atomically adds the given value to the current value.
java.util.concurrent.atomic.AtomicLong.compareAndSet	(	long	long	): Atomically sets the value to the given updated value if the current value == the expected value.
java.util.concurrent.atomic.AtomicLong.decrementAndGet	(	): Atomically decrements by one the current value.
java.util.concurrent.atomic.AtomicLong.doubleValue	(	): Returns the value of this AtomicLong as a double after a widening primitive conversion.
java.util.concurrent.atomic.AtomicLong.floatValue	(	): Returns the value of this AtomicLong as a float after a widening primitive conversion.
java.util.concurrent.atomic.AtomicLong.get	(	): Gets the current value.
java.util.concurrent.atomic.AtomicLong.getAndAccumulate	(	long	LongBinaryOperator	): Atomically updates the current value with the results of applying the given function to the current and given values, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value as its first argument, and the given update as the second argument.
java.util.concurrent.atomic.AtomicLong.getAndAdd	(	long	): Atomically adds the given value to the current value.
java.util.concurrent.atomic.AtomicLong.getAndDecrement	(	): Atomically decrements by one the current value.
java.util.concurrent.atomic.AtomicLong.getAndIncrement	(	): Atomically increments by one the current value.
java.util.concurrent.atomic.AtomicLong.getAndSet	(	long	): Atomically sets to the given value and returns the old value.
java.util.concurrent.atomic.AtomicLong.getAndUpdate	(	LongUnaryOperator	): Atomically updates the current value with the results of applying the given function, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.
java.util.concurrent.atomic.AtomicLong.incrementAndGet	(	): Atomically increments by one the current value.
java.util.concurrent.atomic.AtomicLong.intValue	(	): Returns the value of this AtomicLong as an int after a narrowing primitive conversion.
java.util.concurrent.atomic.AtomicLong.lazySet	(	long	): Eventually sets to the given value.
java.util.concurrent.atomic.AtomicLong.longValue	(	): Returns the value of this AtomicLong as a long.
java.util.concurrent.atomic.AtomicLong.set	(	long	): Sets to the given value.
java.util.concurrent.atomic.AtomicLong.toString	(	): Returns the String representation of the current value.
java.util.concurrent.atomic.AtomicLong.updateAndGet	(	LongUnaryOperator	): Atomically updates the current value with the results of applying the given function, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.
java.util.concurrent.atomic.AtomicLong.weakCompareAndSet	(	long	long	): Atomically sets the value to the given updated value if the current value == the expected value. May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to compareAndSet.
java.util.concurrent.atomic.AtomicLongArray: A long array in which elements may be updated atomically. See the java.util.concurrent.atomic package specification for description of the properties of atomic variables.
java.util.concurrent.atomic.AtomicLongArray.AtomicLongArray	(	int	): Creates a new AtomicLongArray of the given length, with all elements initially zero.
java.util.concurrent.atomic.AtomicLongArray.AtomicLongArray	(	long[]	): Creates a new AtomicLongArray with the same length as, and all elements copied from, the given array.
java.util.concurrent.atomic.AtomicLongArray.accumulateAndGet	(	int	long	LongBinaryOperator	): Atomically updates the element at index i with the results of applying the given function to the current and given values, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value at index i as its first argument, and the given update as the second argument.
java.util.concurrent.atomic.AtomicLongArray.addAndGet	(	int	long	): Atomically adds the given value to the element at index i.
java.util.concurrent.atomic.AtomicLongArray.compareAndSet	(	int	long	long	): Atomically sets the element at position i to the given updated value if the current value == the expected value.
java.util.concurrent.atomic.AtomicLongArray.decrementAndGet	(	int	): Atomically decrements by one the element at index i.
java.util.concurrent.atomic.AtomicLongArray.get	(	int	): Gets the current value at position i.
java.util.concurrent.atomic.AtomicLongArray.getAndAccumulate	(	int	long	LongBinaryOperator	): Atomically updates the element at index i with the results of applying the given function to the current and given values, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value at index i as its first argument, and the given update as the second argument.
java.util.concurrent.atomic.AtomicLongArray.getAndAdd	(	int	long	): Atomically adds the given value to the element at index i.
java.util.concurrent.atomic.AtomicLongArray.getAndDecrement	(	int	): Atomically decrements by one the element at index i.
java.util.concurrent.atomic.AtomicLongArray.getAndIncrement	(	int	): Atomically increments by one the element at index i.
java.util.concurrent.atomic.AtomicLongArray.getAndSet	(	int	long	): Atomically sets the element at position i to the given value and returns the old value.
java.util.concurrent.atomic.AtomicLongArray.getAndUpdate	(	int	LongUnaryOperator	): Atomically updates the element at index i with the results of applying the given function, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.
java.util.concurrent.atomic.AtomicLongArray.incrementAndGet	(	int	): Atomically increments by one the element at index i.
java.util.concurrent.atomic.AtomicLongArray.lazySet	(	int	long	): Eventually sets the element at position i to the given value.
java.util.concurrent.atomic.AtomicLongArray.length	(	): Returns the length of the array.
java.util.concurrent.atomic.AtomicLongArray.set	(	int	long	): Sets the element at position i to the given value.
java.util.concurrent.atomic.AtomicLongArray.toString	(	): Returns the String representation of the current values of array.
java.util.concurrent.atomic.AtomicLongArray.updateAndGet	(	int	LongUnaryOperator	): Atomically updates the element at index i with the results of applying the given function, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.
java.util.concurrent.atomic.AtomicLongArray.weakCompareAndSet	(	int	long	long	): Atomically sets the element at position i to the given updated value if the current value == the expected value. May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to compareAndSet.
java.util.concurrent.atomic.AtomicLongFieldUpdater: A reflection-based utility that enables atomic updates to designated volatile long fields of designated classes. This class is designed for use in atomic data structures in which several fields of the same node are independently subject to atomic updates. Note that the guarantees of the compareAndSet method in this class are weaker than in other atomic classes. Because this class cannot ensure that all uses of the field are appropriate for purposes of atomic access, it can guarantee atomicity only with respect to other invocations of compareAndSet and set on the same updater.
java.util.concurrent.atomic.AtomicLongFieldUpdater.AtomicLongFieldUpdater	(	): Protected do-nothing constructor for use by subclasses.
java.util.concurrent.atomic.AtomicLongFieldUpdater.accumulateAndGet	(	T	long	LongBinaryOperator	): Atomically updates the field of the given object managed by this updater with the results of applying the given function to the current and given values, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value as its first argument, and the given update as the second argument.
java.util.concurrent.atomic.AtomicLongFieldUpdater.addAndGet	(	T	long	): Atomically adds the given value to the current value of the field of the given object managed by this updater.
java.util.concurrent.atomic.AtomicLongFieldUpdater.compareAndSet	(	T	long	long	): Atomically sets the field of the given object managed by this updater to the given updated value if the current value == the expected value. This method is guaranteed to be atomic with respect to other calls to compareAndSet and set, but not necessarily with respect to other changes in the field.
java.util.concurrent.atomic.AtomicLongFieldUpdater.decrementAndGet	(	T	): Atomically decrements by one the current value of the field of the given object managed by this updater.
java.util.concurrent.atomic.AtomicLongFieldUpdater.get	(	T	): Gets the current value held in the field of the given object managed by this updater.
java.util.concurrent.atomic.AtomicLongFieldUpdater.getAndAccumulate	(	T	long	LongBinaryOperator	): Atomically updates the field of the given object managed by this updater with the results of applying the given function to the current and given values, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value as its first argument, and the given update as the second argument.
java.util.concurrent.atomic.AtomicLongFieldUpdater.getAndAdd	(	T	long	): Atomically adds the given value to the current value of the field of the given object managed by this updater.
java.util.concurrent.atomic.AtomicLongFieldUpdater.getAndDecrement	(	T	): Atomically decrements by one the current value of the field of the given object managed by this updater.
java.util.concurrent.atomic.AtomicLongFieldUpdater.getAndIncrement	(	T	): Atomically increments by one the current value of the field of the given object managed by this updater.
java.util.concurrent.atomic.AtomicLongFieldUpdater.getAndSet	(	T	long	): Atomically sets the field of the given object managed by this updater to the given value and returns the old value.
java.util.concurrent.atomic.AtomicLongFieldUpdater.getAndUpdate	(	T	LongUnaryOperator	): Atomically updates the field of the given object managed by this updater with the results of applying the given function, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.
java.util.concurrent.atomic.AtomicLongFieldUpdater.incrementAndGet	(	T	): Atomically increments by one the current value of the field of the given object managed by this updater.
java.util.concurrent.atomic.AtomicLongFieldUpdater.isAncestor	(	ClassLoader	ClassLoader	): Returns true if the second classloader can be found in the first classloader's delegation chain. Equivalent to the inaccessible: first.isAncestor(second).
java.util.concurrent.atomic.AtomicLongFieldUpdater.lazySet	(	T	long	): Eventually sets the field of the given object managed by this updater to the given updated value.
java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater	(	Class	String	): Creates and returns an updater for objects with the given field. The Class argument is needed to check that reflective types and generic types match.
java.util.concurrent.atomic.AtomicLongFieldUpdater.set	(	T	long	): Sets the field of the given object managed by this updater to the given updated value. This operation is guaranteed to act as a volatile store with respect to subsequent invocations of compareAndSet.
java.util.concurrent.atomic.AtomicLongFieldUpdater.updateAndGet	(	T	LongUnaryOperator	): Atomically updates the field of the given object managed by this updater with the results of applying the given function, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.
java.util.concurrent.atomic.AtomicLongFieldUpdater.weakCompareAndSet	(	T	long	long	): Atomically sets the field of the given object managed by this updater to the given updated value if the current value == the expected value. This method is guaranteed to be atomic with respect to other calls to compareAndSet and set, but not necessarily with respect to other changes in the field. May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to compareAndSet.
java.util.concurrent.atomic.AtomicMarkableReference: An AtomicMarkableReference maintains an object reference along with a mark bit, that can be updated atomically. Implementation note: This implementation maintains markable references by creating internal objects representing "boxed" [reference, boolean] pairs.
java.util.concurrent.atomic.AtomicMarkableReference.AtomicMarkableReference	(	V	boolean	): Creates a new AtomicMarkableReference with the given initial values.
java.util.concurrent.atomic.AtomicMarkableReference.attemptMark	(	V	boolean	): Atomically sets the value of the mark to the given update value if the current reference is == to the expected reference. Any given invocation of this operation may fail (return false) spuriously, but repeated invocation when the current value holds the expected value and no other thread is also attempting to set the value will eventually succeed.
java.util.concurrent.atomic.AtomicMarkableReference.compareAndSet	(	V	V	boolean	boolean	): Atomically sets the value of both the reference and mark to the given update values if the current reference is == to the expected reference and the current mark is equal to the expected mark.
java.util.concurrent.atomic.AtomicMarkableReference.get	(	boolean[]	): Returns the current values of both the reference and the mark. Typical usage is boolean[1] holder; ref = v.get(holder); .
java.util.concurrent.atomic.AtomicMarkableReference.getReference	(	): Returns the current value of the reference.
java.util.concurrent.atomic.AtomicMarkableReference.isMarked	(	): Returns the current value of the mark.
java.util.concurrent.atomic.AtomicMarkableReference.set	(	V	boolean	): Unconditionally sets the value of both the reference and mark.
java.util.concurrent.atomic.AtomicMarkableReference.weakCompareAndSet	(	V	V	boolean	boolean	): Atomically sets the value of both the reference and mark to the given update values if the current reference is == to the expected reference and the current mark is equal to the expected mark. May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to compareAndSet.
java.util.concurrent.atomic.AtomicReference: An object reference that may be updated atomically. See the java.util.concurrent.atomic package specification for description of the properties of atomic variables.
java.util.concurrent.atomic.AtomicReference.AtomicReference	(	): Creates a new AtomicReference with null initial value.
java.util.concurrent.atomic.AtomicReference.AtomicReference	(	V	): Creates a new AtomicReference with the given initial value.
java.util.concurrent.atomic.AtomicReference.accumulateAndGet	(	V	BinaryOperator	): Atomically updates the current value with the results of applying the given function to the current and given values, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value as its first argument, and the given update as the second argument.
java.util.concurrent.atomic.AtomicReference.compareAndSet	(	V	V	): Atomically sets the value to the given updated value if the current value == the expected value.
java.util.concurrent.atomic.AtomicReference.get	(	): Gets the current value.
java.util.concurrent.atomic.AtomicReference.getAndAccumulate	(	V	BinaryOperator	): Atomically updates the current value with the results of applying the given function to the current and given values, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value as its first argument, and the given update as the second argument.
java.util.concurrent.atomic.AtomicReference.getAndSet	(	V	): Atomically sets to the given value and returns the old value.
java.util.concurrent.atomic.AtomicReference.getAndUpdate	(	UnaryOperator	): Atomically updates the current value with the results of applying the given function, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.
java.util.concurrent.atomic.AtomicReference.lazySet	(	V	): Eventually sets to the given value.
java.util.concurrent.atomic.AtomicReference.set	(	V	): Sets to the given value.
java.util.concurrent.atomic.AtomicReference.toString	(	): Returns the String representation of the current value.
java.util.concurrent.atomic.AtomicReference.updateAndGet	(	UnaryOperator	): Atomically updates the current value with the results of applying the given function, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.
java.util.concurrent.atomic.AtomicReference.weakCompareAndSet	(	V	V	): Atomically sets the value to the given updated value if the current value == the expected value. May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to compareAndSet.
java.util.concurrent.atomic.AtomicReferenceArray: An array of object references in which elements may be updated atomically. See the java.util.concurrent.atomic package specification for description of the properties of atomic variables.
java.util.concurrent.atomic.AtomicReferenceArray.AtomicReferenceArray	(	E[]	): Creates a new AtomicReferenceArray with the same length as, and all elements copied from, the given array.
java.util.concurrent.atomic.AtomicReferenceArray.AtomicReferenceArray	(	int	): Creates a new AtomicReferenceArray of the given length, with all elements initially null.
java.util.concurrent.atomic.AtomicReferenceArray.accumulateAndGet	(	int	E	BinaryOperator	): Atomically updates the element at index i with the results of applying the given function to the current and given values, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value at index i as its first argument, and the given update as the second argument.
java.util.concurrent.atomic.AtomicReferenceArray.compareAndSet	(	int	E	E	): Atomically sets the element at position i to the given updated value if the current value == the expected value.
java.util.concurrent.atomic.AtomicReferenceArray.get	(	int	): Gets the current value at position i.
java.util.concurrent.atomic.AtomicReferenceArray.getAndAccumulate	(	int	E	BinaryOperator	): Atomically updates the element at index i with the results of applying the given function to the current and given values, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value at index i as its first argument, and the given update as the second argument.
java.util.concurrent.atomic.AtomicReferenceArray.getAndSet	(	int	E	): Atomically sets the element at position i to the given value and returns the old value.
java.util.concurrent.atomic.AtomicReferenceArray.getAndUpdate	(	int	UnaryOperator	): Atomically updates the element at index i with the results of applying the given function, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.
java.util.concurrent.atomic.AtomicReferenceArray.lazySet	(	int	E	): Eventually sets the element at position i to the given value.
java.util.concurrent.atomic.AtomicReferenceArray.length	(	): Returns the length of the array.
java.util.concurrent.atomic.AtomicReferenceArray.readObject	(	java.io.ObjectInputStream	): Reconstitutes the instance from a stream (that is, deserializes it).
java.util.concurrent.atomic.AtomicReferenceArray.set	(	int	E	): Sets the element at position i to the given value.
java.util.concurrent.atomic.AtomicReferenceArray.toString	(	): Returns the String representation of the current values of array.
java.util.concurrent.atomic.AtomicReferenceArray.updateAndGet	(	int	UnaryOperator	): Atomically updates the element at index i with the results of applying the given function, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.
java.util.concurrent.atomic.AtomicReferenceArray.weakCompareAndSet	(	int	E	E	): Atomically sets the element at position i to the given updated value if the current value == the expected value. May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to compareAndSet.
java.util.concurrent.atomic.AtomicReferenceFieldUpdater: A reflection-based utility that enables atomic updates to designated volatile reference fields of designated classes. This class is designed for use in atomic data structures in which several reference fields of the same node are independently subject to atomic updates. For example, a tree node might be declared as  class Node private volatile Node left, right; private static final AtomicReferenceFieldUpdater leftUpdater = AtomicReferenceFieldUpdater.newUpdater(Node.class, Node.class, "left"); private static AtomicReferenceFieldUpdater rightUpdater = AtomicReferenceFieldUpdater.newUpdater(Node.class, Node.class, "right"); Node getLeft() { return left; } boolean compareAndSetLeft(Node expect, Node update) { return leftUpdater.compareAndSet(this, expect, update); } // ... and so on }} Note that the guarantees of the compareAndSet method in this class are weaker than in other atomic classes. Because this class cannot ensure that all uses of the field are appropriate for purposes of atomic access, it can guarantee atomicity only with respect to other invocations of compareAndSet and set on the same updater.
java.util.concurrent.atomic.AtomicReferenceFieldUpdater.AtomicReferenceFieldUpdater	(	): Protected do-nothing constructor for use by subclasses.
java.util.concurrent.atomic.AtomicReferenceFieldUpdater.AtomicReferenceFieldUpdaterImpl.isAncestor	(	ClassLoader	ClassLoader	): Returns true if the second classloader can be found in the first classloader's delegation chain. Equivalent to the inaccessible: first.isAncestor(second).
java.util.concurrent.atomic.AtomicReferenceFieldUpdater.accumulateAndGet	(	T	V	BinaryOperator	): Atomically updates the field of the given object managed by this updater with the results of applying the given function to the current and given values, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value as its first argument, and the given update as the second argument.
java.util.concurrent.atomic.AtomicReferenceFieldUpdater.compareAndSet	(	T	V	V	): Atomically sets the field of the given object managed by this updater to the given updated value if the current value == the expected value. This method is guaranteed to be atomic with respect to other calls to compareAndSet and set, but not necessarily with respect to other changes in the field.
java.util.concurrent.atomic.AtomicReferenceFieldUpdater.get	(	T	): Gets the current value held in the field of the given object managed by this updater.
java.util.concurrent.atomic.AtomicReferenceFieldUpdater.getAndAccumulate	(	T	V	BinaryOperator	): Atomically updates the field of the given object managed by this updater with the results of applying the given function to the current and given values, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value as its first argument, and the given update as the second argument.
java.util.concurrent.atomic.AtomicReferenceFieldUpdater.getAndSet	(	T	V	): Atomically sets the field of the given object managed by this updater to the given value and returns the old value.
java.util.concurrent.atomic.AtomicReferenceFieldUpdater.getAndUpdate	(	T	UnaryOperator	): Atomically updates the field of the given object managed by this updater with the results of applying the given function, returning the previous value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.
java.util.concurrent.atomic.AtomicReferenceFieldUpdater.lazySet	(	T	V	): Eventually sets the field of the given object managed by this updater to the given updated value.
java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater	(	Class	Class	String	): Creates and returns an updater for objects with the given field. The Class arguments are needed to check that reflective types and generic types match.
java.util.concurrent.atomic.AtomicReferenceFieldUpdater.set	(	T	V	): Sets the field of the given object managed by this updater to the given updated value. This operation is guaranteed to act as a volatile store with respect to subsequent invocations of compareAndSet.
java.util.concurrent.atomic.AtomicReferenceFieldUpdater.updateAndGet	(	T	UnaryOperator	): Atomically updates the field of the given object managed by this updater with the results of applying the given function, returning the updated value. The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.
java.util.concurrent.atomic.AtomicReferenceFieldUpdater.weakCompareAndSet	(	T	V	V	): Atomically sets the field of the given object managed by this updater to the given updated value if the current value == the expected value. This method is guaranteed to be atomic with respect to other calls to compareAndSet and set, but not necessarily with respect to other changes in the field. May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to compareAndSet.
java.util.concurrent.atomic.AtomicStampedReference: An AtomicStampedReference maintains an object reference along with an integer "stamp", that can be updated atomically. Implementation note: This implementation maintains stamped references by creating internal objects representing "boxed" [reference, integer] pairs.
java.util.concurrent.atomic.AtomicStampedReference.AtomicStampedReference	(	V	int	): Creates a new AtomicStampedReference with the given initial values.
java.util.concurrent.atomic.AtomicStampedReference.attemptStamp	(	V	int	): Atomically sets the value of the stamp to the given update value if the current reference is == to the expected reference. Any given invocation of this operation may fail (return false) spuriously, but repeated invocation when the current value holds the expected value and no other thread is also attempting to set the value will eventually succeed.
java.util.concurrent.atomic.AtomicStampedReference.compareAndSet	(	V	V	int	int	): Atomically sets the value of both the reference and stamp to the given update values if the current reference is == to the expected reference and the current stamp is equal to the expected stamp.
java.util.concurrent.atomic.AtomicStampedReference.get	(	int[]	): Returns the current values of both the reference and the stamp. Typical usage is int[1] holder; ref = v.get(holder); .
java.util.concurrent.atomic.AtomicStampedReference.getReference	(	): Returns the current value of the reference.
java.util.concurrent.atomic.AtomicStampedReference.getStamp	(	): Returns the current value of the stamp.
java.util.concurrent.atomic.AtomicStampedReference.set	(	V	int	): Unconditionally sets the value of both the reference and stamp.
java.util.concurrent.atomic.AtomicStampedReference.weakCompareAndSet	(	V	V	int	int	): Atomically sets the value of both the reference and stamp to the given update values if the current reference is == to the expected reference and the current stamp is equal to the expected stamp. May fail spuriously and does not provide ordering guarantees, so is only rarely an appropriate alternative to compareAndSet.
java.util.concurrent.atomic.DoubleAccumulator: One or more variables that together maintain a running double value updated using a supplied function. When updates (method accumulate) are contended across threads, the set of variables may grow dynamically to reduce contention. Method get (or, equivalently, doubleValue) returns the current value across the variables maintaining updates. This class is usually preferable to alternatives when multiple threads update a common value that is used for purposes such as summary statistics that are frequently updated but less frequently read. The supplied accumulator function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value as its first argument, and the given update as the second argument. For example, to maintain a running maximum value, you could supply Double::max along with Double.NEGATIVE_INFINITY as the identity. The order of accumulation within or across threads is not guaranteed. Thus, this class may not be applicable if numerical stability is required, especially when combining values of substantially different orders of magnitude. Class DoubleAdder provides analogs of the functionality of this class for the common special case of maintaining sums. The call new DoubleAdder() is equivalent to new DoubleAccumulator((x, y) -> x + y, 0.0). This class extends Number, but does not define methods such as equals, hashCode and compareTo because instances are expected to be mutated, and so are not useful as collection keys.
java.util.concurrent.atomic.DoubleAccumulator.DoubleAccumulator	(	DoubleBinaryOperator	double	): Creates a new instance using the given accumulator function and identity element.
java.util.concurrent.atomic.DoubleAccumulator.SerializationProxy: Serialization proxy, used to avoid reference to the non-public Striped64 superclass in serialized forms.
java.util.concurrent.atomic.DoubleAccumulator.SerializationProxy.readResolve	(	): Returns a DoubleAccumulator object with initial state held by this proxy.
java.util.concurrent.atomic.DoubleAccumulator.accumulate	(	double	): Updates with the given value.
java.util.concurrent.atomic.DoubleAccumulator.doubleValue	(	): Equivalent to get.
java.util.concurrent.atomic.DoubleAccumulator.floatValue	(	): Returns the get current value as a float after a narrowing primitive conversion.
java.util.concurrent.atomic.DoubleAccumulator.get	(	): Returns the current value. The returned value is NOT an atomic snapshot; invocation in the absence of concurrent updates returns an accurate result, but concurrent updates that occur while the value is being calculated might not be incorporated.
java.util.concurrent.atomic.DoubleAccumulator.getThenReset	(	): Equivalent in effect to get followed by reset. This method may apply for example during quiescent points between multithreaded computations. If there are updates concurrent with this method, the returned value is not guaranteed to be the final value occurring before the reset.
java.util.concurrent.atomic.DoubleAccumulator.intValue	(	): Returns the get current value as an int after a narrowing primitive conversion.
java.util.concurrent.atomic.DoubleAccumulator.longValue	(	): Returns the get current value as a long after a narrowing primitive conversion.
java.util.concurrent.atomic.DoubleAccumulator.readObject	(	java.io.ObjectInputStream	): 
java.util.concurrent.atomic.DoubleAccumulator.reset	(	): Resets variables maintaining updates to the identity value. This method may be a useful alternative to creating a new updater, but is only effective if there are no concurrent updates. Because this method is intrinsically racy, it should only be used when it is known that no threads are concurrently updating.
java.util.concurrent.atomic.DoubleAccumulator.toString	(	): Returns the String representation of the current value.
java.util.concurrent.atomic.DoubleAccumulator.writeReplace	(	): Returns a  SerializationProxy representing the state of this instance.
java.util.concurrent.atomic.DoubleAdder: One or more variables that together maintain an initially zero double sum. When updates (method add) are contended across threads, the set of variables may grow dynamically to reduce contention. Method sum (or, equivalently doubleValue) returns the current total combined across the variables maintaining the sum. The order of accumulation within or across threads is not guaranteed. Thus, this class may not be applicable if numerical stability is required, especially when combining values of substantially different orders of magnitude. This class is usually preferable to alternatives when multiple threads update a common value that is used for purposes such as summary statistics that are frequently updated but less frequently read. This class extends Number, but does not define methods such as equals, hashCode and compareTo because instances are expected to be mutated, and so are not useful as collection keys.
java.util.concurrent.atomic.DoubleAdder.DoubleAdder	(	): Creates a new adder with initial sum of zero.
java.util.concurrent.atomic.DoubleAdder.SerializationProxy: Serialization proxy, used to avoid reference to the non-public Striped64 superclass in serialized forms.
java.util.concurrent.atomic.DoubleAdder.SerializationProxy.readResolve	(	): Returns a DoubleAdder object with initial state held by this proxy.
java.util.concurrent.atomic.DoubleAdder.add	(	double	): Adds the given value.
java.util.concurrent.atomic.DoubleAdder.doubleValue	(	): Equivalent to sum.
java.util.concurrent.atomic.DoubleAdder.floatValue	(	): Returns the sum as a float after a narrowing primitive conversion.
java.util.concurrent.atomic.DoubleAdder.intValue	(	): Returns the sum as an int after a narrowing primitive conversion.
java.util.concurrent.atomic.DoubleAdder.longValue	(	): Returns the sum as a long after a narrowing primitive conversion.
java.util.concurrent.atomic.DoubleAdder.readObject	(	java.io.ObjectInputStream	): 
java.util.concurrent.atomic.DoubleAdder.reset	(	): Resets variables maintaining the sum to zero. This method may be a useful alternative to creating a new adder, but is only effective if there are no concurrent updates. Because this method is intrinsically racy, it should only be used when it is known that no threads are concurrently updating.
java.util.concurrent.atomic.DoubleAdder.sum	(	): Returns the current sum. The returned value is NOT an atomic snapshot; invocation in the absence of concurrent updates returns an accurate result, but concurrent updates that occur while the sum is being calculated might not be incorporated. Also, because floating-point arithmetic is not strictly associative, the returned result need not be identical to the value that would be obtained in a sequential series of updates to a single variable.
java.util.concurrent.atomic.DoubleAdder.sumThenReset	(	): Equivalent in effect to sum followed by reset. This method may apply for example during quiescent points between multithreaded computations. If there are updates concurrent with this method, the returned value is not guaranteed to be the final value occurring before the reset.
java.util.concurrent.atomic.DoubleAdder.toString	(	): Returns the String representation of the sum.
java.util.concurrent.atomic.DoubleAdder.writeReplace	(	): Returns a  SerializationProxy representing the state of this instance.
java.util.concurrent.atomic.LongAccumulator: One or more variables that together maintain a running long value updated using a supplied function. When updates (method accumulate) are contended across threads, the set of variables may grow dynamically to reduce contention. Method get (or, equivalently, longValue) returns the current value across the variables maintaining updates. This class is usually preferable to AtomicLong when multiple threads update a common value that is used for purposes such as collecting statistics, not for fine-grained synchronization control. Under low update contention, the two classes have similar characteristics. But under high contention, expected throughput of this class is significantly higher, at the expense of higher space consumption. The order of accumulation within or across threads is not guaranteed and cannot be depended upon, so this class is only applicable to functions for which the order of accumulation does not matter. The supplied accumulator function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads. The function is applied with the current value as its first argument, and the given update as the second argument. For example, to maintain a running maximum value, you could supply Long::max along with Long.MIN_VALUE as the identity. Class LongAdder provides analogs of the functionality of this class for the common special case of maintaining counts and sums. The call new LongAdder() is equivalent to new LongAccumulator((x, y) -> x + y, 0L. This class extends Number, but does not define methods such as equals, hashCode and compareTo because instances are expected to be mutated, and so are not useful as collection keys.
java.util.concurrent.atomic.LongAccumulator.LongAccumulator	(	LongBinaryOperator	long	): Creates a new instance using the given accumulator function and identity element.
java.util.concurrent.atomic.LongAccumulator.SerializationProxy: Serialization proxy, used to avoid reference to the non-public Striped64 superclass in serialized forms.
java.util.concurrent.atomic.LongAccumulator.SerializationProxy.readResolve	(	): Returns a LongAccumulator object with initial state held by this proxy.
java.util.concurrent.atomic.LongAccumulator.accumulate	(	long	): Updates with the given value.
java.util.concurrent.atomic.LongAccumulator.doubleValue	(	): Returns the get current value as a double after a widening primitive conversion.
java.util.concurrent.atomic.LongAccumulator.floatValue	(	): Returns the get current value as a float after a widening primitive conversion.
java.util.concurrent.atomic.LongAccumulator.get	(	): Returns the current value. The returned value is NOT an atomic snapshot; invocation in the absence of concurrent updates returns an accurate result, but concurrent updates that occur while the value is being calculated might not be incorporated.
java.util.concurrent.atomic.LongAccumulator.getThenReset	(	): Equivalent in effect to get followed by reset. This method may apply for example during quiescent points between multithreaded computations. If there are updates concurrent with this method, the returned value is not guaranteed to be the final value occurring before the reset.
java.util.concurrent.atomic.LongAccumulator.intValue	(	): Returns the get current value as an int after a narrowing primitive conversion.
java.util.concurrent.atomic.LongAccumulator.longValue	(	): Equivalent to get.
java.util.concurrent.atomic.LongAccumulator.readObject	(	java.io.ObjectInputStream	): 
java.util.concurrent.atomic.LongAccumulator.reset	(	): Resets variables maintaining updates to the identity value. This method may be a useful alternative to creating a new updater, but is only effective if there are no concurrent updates. Because this method is intrinsically racy, it should only be used when it is known that no threads are concurrently updating.
java.util.concurrent.atomic.LongAccumulator.toString	(	): Returns the String representation of the current value.
java.util.concurrent.atomic.LongAccumulator.writeReplace	(	): Returns a  SerializationProxy representing the state of this instance.
java.util.concurrent.atomic.LongAdder: One or more variables that together maintain an initially zero long sum. When updates (method add) are contended across threads, the set of variables may grow dynamically to reduce contention. Method sum (or, equivalently, longValue) returns the current total combined across the variables maintaining the sum. This class is usually preferable to AtomicLong when multiple threads update a common sum that is used for purposes such as collecting statistics, not for fine-grained synchronization control. Under low update contention, the two classes have similar characteristics. But under high contention, expected throughput of this class is significantly higher, at the expense of higher space consumption. LongAdders can be used with a java.util.concurrent.ConcurrentHashMap to maintain a scalable frequency map (a form of histogram or multiset). For example, to add a count to a ConcurrentHashMap freqs, initializing if not already present, you can use freqs.computeIfAbsent(k -> new LongAdder()).increment(); This class extends Number, but does not define methods such as equals, hashCode and compareTo because instances are expected to be mutated, and so are not useful as collection keys.
java.util.concurrent.atomic.LongAdder.LongAdder	(	): Creates a new adder with initial sum of zero.
java.util.concurrent.atomic.LongAdder.SerializationProxy: Serialization proxy, used to avoid reference to the non-public Striped64 superclass in serialized forms.
java.util.concurrent.atomic.LongAdder.SerializationProxy.readResolve	(	): Return a LongAdder object with initial state held by this proxy.
java.util.concurrent.atomic.LongAdder.add	(	long	): Adds the given value.
java.util.concurrent.atomic.LongAdder.decrement	(	): Equivalent to add(-1).
java.util.concurrent.atomic.LongAdder.doubleValue	(	): Returns the sum as a double after a widening primitive conversion.
java.util.concurrent.atomic.LongAdder.floatValue	(	): Returns the sum as a float after a widening primitive conversion.
java.util.concurrent.atomic.LongAdder.increment	(	): Equivalent to add(1).
java.util.concurrent.atomic.LongAdder.intValue	(	): Returns the sum as an int after a narrowing primitive conversion.
java.util.concurrent.atomic.LongAdder.longValue	(	): Equivalent to sum.
java.util.concurrent.atomic.LongAdder.readObject	(	java.io.ObjectInputStream	): 
java.util.concurrent.atomic.LongAdder.reset	(	): Resets variables maintaining the sum to zero. This method may be a useful alternative to creating a new adder, but is only effective if there are no concurrent updates. Because this method is intrinsically racy, it should only be used when it is known that no threads are concurrently updating.
java.util.concurrent.atomic.LongAdder.sum	(	): Returns the current sum. The returned value is NOT an atomic snapshot; invocation in the absence of concurrent updates returns an accurate result, but concurrent updates that occur while the sum is being calculated might not be incorporated.
java.util.concurrent.atomic.LongAdder.sumThenReset	(	): Equivalent in effect to sum followed by reset. This method may apply for example during quiescent points between multithreaded computations. If there are updates concurrent with this method, the returned value is not guaranteed to be the final value occurring before the reset.
java.util.concurrent.atomic.LongAdder.toString	(	): Returns the String representation of the sum.
java.util.concurrent.atomic.LongAdder.writeReplace	(	): Returns a  SerializationProxy representing the state of this instance.
java.util.concurrent.atomic.Striped64: A package-local class holding common representation and mechanics for classes supporting dynamic striping on 64bit values. The class extends Number so that concrete subclasses must publicly do so.
java.util.concurrent.atomic.Striped64.Cell: Padded variant of AtomicLong supporting only raw accesses plus CAS. JVM intrinsics note: It would be possible to use a release-only form of CAS here, if it were provided.
java.util.concurrent.atomic.Striped64.Striped64	(	): Package-private default constructor
java.util.concurrent.atomic.Striped64.advanceProbe	(	int	): Pseudo-randomly advances and records the given probe value for the given thread. Duplicated from ThreadLocalRandom because of packaging restrictions.
java.util.concurrent.atomic.Striped64.casBase	(	long	long	): CASes the base field.
java.util.concurrent.atomic.Striped64.casCellsBusy	(	): CASes the cellsBusy field from 0 to 1 to acquire lock.
java.util.concurrent.atomic.Striped64.doubleAccumulate	(	double	DoubleBinaryOperator	boolean	): Same as longAccumulate, but injecting long/double conversions in too many places to sensibly merge with long version, given the low-overhead requirements of this class. So must instead be maintained by copy/paste/adapt.
java.util.concurrent.atomic.Striped64.getProbe	(	): Returns the probe value for the current thread. Duplicated from ThreadLocalRandom because of packaging restrictions.
java.util.concurrent.atomic.Striped64.longAccumulate	(	long	LongBinaryOperator	boolean	): Handles cases of updates involving initialization, resizing, creating new Cells, and/or contention. See above for explanation. This method suffers the usual non-modularity problems of optimistic retry code, relying on rechecked sets of reads.
java.util.concurrent.locks.AbstractOwnableSynchronizer: A synchronizer that may be exclusively owned by a thread. This class provides a basis for creating locks and related synchronizers that may entail a notion of ownership. The AbstractOwnableSynchronizer class itself does not manage or use this information. However, subclasses and tools may use appropriately maintained values to help control and monitor access and provide diagnostics.
java.util.concurrent.locks.AbstractOwnableSynchronizer.AbstractOwnableSynchronizer	(	): Empty constructor for use by subclasses.
java.util.concurrent.locks.AbstractOwnableSynchronizer.getExclusiveOwnerThread	(	): Returns the thread last set by setExclusiveOwnerThread, or null if never set. This method does not otherwise impose any synchronization or volatile field accesses.
java.util.concurrent.locks.AbstractOwnableSynchronizer.setExclusiveOwnerThread	(	Thread	): Sets the thread that currently owns exclusive access. A null argument indicates that no thread owns access. This method does not otherwise impose any synchronization or volatile field accesses.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer: A version of AbstractQueuedSynchronizer in which synchronization state is maintained as a long. This class has exactly the same structure, properties, and methods as AbstractQueuedSynchronizer with the exception that all state-related parameters and results are defined as long rather than int. This class may be useful when creating synchronizers such as multilevel locks and barriers that require 64 bits of state. See AbstractQueuedSynchronizer for usage notes and examples.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.AbstractQueuedLongSynchronizer	(	): Creates a new AbstractQueuedLongSynchronizer instance with initial synchronization state of zero.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject: Condition implementation for a AbstractQueuedLongSynchronizer serving as the basis of a Lock implementation. Method documentation for this class describes mechanics, not behavioral specifications from the point of view of Lock and Condition users. Exported versions of this class will in general need to be accompanied by documentation describing condition semantics that rely on those of the associated AbstractQueuedLongSynchronizer. This class is Serializable, but all fields are transient, so deserialized conditions have no waiters.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject.ConditionObject	(	): Creates a new ConditionObject instance.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject.addConditionWaiter	(	): Adds a new waiter to wait queue.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject.await	(	): Implements interruptible condition wait.   If current thread is interrupted, throw InterruptedException.  Save lock state returned by getState.  Invoke release with saved state as argument, throwing IllegalMonitorStateException if it fails.  Block until signalled or interrupted.  Reacquire by invoking specialized version of acquire with saved state as argument.  If interrupted while blocked in step 4, throw InterruptedException. 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject.await	(	long	TimeUnit	): Implements timed condition wait.   If current thread is interrupted, throw InterruptedException.  Save lock state returned by getState.  Invoke release with saved state as argument, throwing IllegalMonitorStateException if it fails.  Block until signalled, interrupted, or timed out.  Reacquire by invoking specialized version of acquire with saved state as argument.  If interrupted while blocked in step 4, throw InterruptedException.  If timed out while blocked in step 4, return false, else true. 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject.awaitNanos	(	long	): Implements timed condition wait.   If current thread is interrupted, throw InterruptedException.  Save lock state returned by getState.  Invoke release with saved state as argument, throwing IllegalMonitorStateException if it fails.  Block until signalled, interrupted, or timed out.  Reacquire by invoking specialized version of acquire with saved state as argument.  If interrupted while blocked in step 4, throw InterruptedException. 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject.awaitUninterruptibly	(	): Implements uninterruptible condition wait.   Save lock state returned by getState.  Invoke release with saved state as argument, throwing IllegalMonitorStateException if it fails.  Block until signalled.  Reacquire by invoking specialized version of acquire with saved state as argument. 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject.awaitUntil	(	Date	): Implements absolute timed condition wait.   If current thread is interrupted, throw InterruptedException.  Save lock state returned by getState.  Invoke release with saved state as argument, throwing IllegalMonitorStateException if it fails.  Block until signalled, interrupted, or timed out.  Reacquire by invoking specialized version of acquire with saved state as argument.  If interrupted while blocked in step 4, throw InterruptedException.  If timed out while blocked in step 4, return false, else true. 
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject.checkInterruptWhileWaiting	(	Node	): Checks for interrupt, returning THROW_IE if interrupted before signalled, REINTERRUPT if after signalled, or 0 if not interrupted.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject.doSignal	(	Node	): Removes and transfers nodes until hit non-cancelled one or null. Split out from signal in part to encourage compilers to inline the case of no waiters.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject.doSignalAll	(	Node	): Removes and transfers all nodes.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject.getWaitQueueLength	(	): Returns an estimate of the number of threads waiting on this condition. Implements getWaitQueueLength().
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject.getWaitingThreads	(	): Returns a collection containing those threads that may be waiting on this Condition. Implements getWaitingThreads().
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject.hasWaiters	(	): Queries whether any threads are waiting on this condition. Implements hasWaiters().
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject.isOwnedBy	(	AbstractQueuedLongSynchronizer	): Returns true if this condition was created by the given synchronization object.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject.reportInterruptAfterWait	(	int	): Throws InterruptedException, reinterrupts current thread, or does nothing, depending on mode.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject.signal	(	): Moves the longest-waiting thread, if one exists, from the wait queue for this condition to the wait queue for the owning lock.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject.signalAll	(	): Moves all threads from the wait queue for this condition to the wait queue for the owning lock.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.ConditionObject.unlinkCancelledWaiters	(	): Unlinks cancelled waiter nodes from condition queue. Called only while holding lock. This is called when cancellation occurred during condition wait, and upon insertion of a new waiter when lastWaiter is seen to have been cancelled. This method is needed to avoid garbage retention in the absence of signals. So even though it may require a full traversal, it comes into play only when timeouts or cancellations occur in the absence of signals. It traverses all nodes rather than stopping at a particular target to unlink all pointers to garbage nodes without requiring many re-traversals during cancellation storms.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.Node: Wait queue node class. The wait queue is a variant of a "CLH" (Craig, Landin, and Hagersten) lock queue. CLH locks are normally used for spinlocks. We instead use them for blocking synchronizers, but use the same basic tactic of holding some of the control information about a thread in the predecessor of its node. A "status" field in each node keeps track of whether a thread should block. A node is signalled when its predecessor releases. Each node of the queue otherwise serves as a specific-notification-style monitor holding a single waiting thread. The status field does NOT control whether threads are granted locks etc though. A thread may try to acquire if it is first in the queue. But being first does not guarantee success; it only gives the right to contend. So the currently released contender thread may need to rewait. To enqueue into a CLH lock, you atomically splice it in as new tail. To dequeue, you just set the head field.  +------+ prev +-----+ +-----+ head | | <---- | | <---- | | tail +------+ +-----+ +-----+  Insertion into a CLH queue requires only a single atomic operation on "tail", so there is a simple atomic point of demarcation from unqueued to queued. Similarly, dequeuing involves only updating the "head". However, it takes a bit more work for nodes to determine who their successors are, in part to deal with possible cancellation due to timeouts and interrupts. The "prev" links (not used in original CLH locks), are mainly needed to handle cancellation. If a node is cancelled, its successor is (normally) relinked to a non-cancelled predecessor. For explanation of similar mechanics in the case of spin locks, see the papers by Scott and Scherer at http://www.cs.rochester.edu/u/scott/synchronization/ We also use "next" links to implement blocking mechanics. The thread id for each node is kept in its own node, so a predecessor signals the next node to wake up by traversing next link to determine which thread it is. Determination of successor must avoid races with newly queued nodes to set the "next" fields of their predecessors. This is solved when necessary by checking backwards from the atomically updated "tail" when a node's successor appears to be null. (Or, said differently, the next-links are an optimization so that we don't usually need a backward scan.) Cancellation introduces some conservatism to the basic algorithms. Since we must poll for cancellation of other nodes, we can miss noticing whether a cancelled node is ahead or behind us. This is dealt with by always unparking successors upon cancellation, allowing them to stabilize on a new predecessor, unless we can identify an uncancelled predecessor who will carry this responsibility. CLH queues need a dummy header node to get started. But we don't create them on construction, because it would be wasted effort if there is never contention. Instead, the node is constructed and head and tail pointers are set upon first contention. Threads waiting on Conditions use the same nodes, but use an additional link. Conditions only need to link nodes in simple (non-concurrent) linked queues because they are only accessed when exclusively held. Upon await, a node is inserted into a condition queue. Upon signal, the node is transferred to the main queue. A special value of status field is used to mark which queue a node is on. Thanks go to Dave Dice, Mark Moir, Victor Luchangco, Bill Scherer and Michael Scott, along with members of JSR-166 expert group, for helpful ideas, discussions, and critiques on the design of this class.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.Node.isShared	(	): Returns true if node is waiting in shared mode.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.Node.predecessor	(	): Returns previous node, or throws NullPointerException if null. Use when predecessor cannot be null. The null check could be elided, but is present to help the VM.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.acquire	(	long	): Acquires in exclusive mode, ignoring interrupts. Implemented by invoking at least once tryAcquire, returning on success. Otherwise the thread is queued, possibly repeatedly blocking and unblocking, invoking tryAcquire until success. This method can be used to implement method lock.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.acquireInterruptibly	(	long	): Acquires in exclusive mode, aborting if interrupted. Implemented by first checking interrupt status, then invoking at least once tryAcquire, returning on success. Otherwise the thread is queued, possibly repeatedly blocking and unblocking, invoking tryAcquire until success or the thread is interrupted. This method can be used to implement method lockInterruptibly.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.acquireQueued	(	Node	long	): Acquires in exclusive uninterruptible mode for thread already in queue. Used by condition wait methods as well as acquire.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.acquireShared	(	long	): Acquires in shared mode, ignoring interrupts. Implemented by first invoking at least once tryAcquireShared, returning on success. Otherwise the thread is queued, possibly repeatedly blocking and unblocking, invoking tryAcquireShared until success.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.acquireSharedInterruptibly	(	long	): Acquires in shared mode, aborting if interrupted. Implemented by first checking interrupt status, then invoking at least once tryAcquireShared, returning on success. Otherwise the thread is queued, possibly repeatedly blocking and unblocking, invoking tryAcquireShared until success or the thread is interrupted.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.addWaiter	(	Node	): Creates and enqueues node for current thread and given mode.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.apparentlyFirstQueuedIsExclusive	(	): Returns true if the apparent first queued thread, if one exists, is waiting in exclusive mode. If this method returns true, and the current thread is attempting to acquire in shared mode (that is, this method is invoked from tryAcquireShared) then it is guaranteed that the current thread is not the first queued thread. Used only as a heuristic in ReentrantReadWriteLock.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.cancelAcquire	(	Node	): Cancels an ongoing attempt to acquire.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.compareAndSetHead	(	Node	): CAS head field. Used only by enq.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.compareAndSetNext	(	Node	Node	Node	): CAS next field of a node.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.compareAndSetState	(	long	long	): Atomically sets synchronization state to the given updated value if the current state value equals the expected value. This operation has memory semantics of a volatile read and write.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.compareAndSetTail	(	Node	Node	): CAS tail field. Used only by enq.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.compareAndSetWaitStatus	(	Node	int	int	): CAS waitStatus field of a node.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.doAcquireInterruptibly	(	long	): Acquires in exclusive interruptible mode.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.doAcquireNanos	(	long	long	): Acquires in exclusive timed mode.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.doAcquireShared	(	long	): Acquires in shared uninterruptible mode.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.doAcquireSharedInterruptibly	(	long	): Acquires in shared interruptible mode.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.doAcquireSharedNanos	(	long	long	): Acquires in shared timed mode.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.doReleaseShared	(	): Release action for shared mode -- signals successor and ensures propagation. (Note: For exclusive mode, release just amounts to calling unparkSuccessor of head if it needs signal.)
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.enq	(	Node	): Inserts node into queue, initializing if necessary. See picture above.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.findNodeFromTail	(	Node	): Returns true if node is on sync queue by searching backwards from tail. Called only when needed by isOnSyncQueue.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.fullGetFirstQueuedThread	(	): Version of getFirstQueuedThread called when fastpath fails
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.fullyRelease	(	Node	): Invokes release with current state value; returns saved state. Cancels node and throws exception on failure.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.getExclusiveQueuedThreads	(	): Returns a collection containing threads that may be waiting to acquire in exclusive mode. This has the same properties as getQueuedThreads except that it only returns those threads waiting due to an exclusive acquire.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.getFirstQueuedThread	(	): Returns the first (longest-waiting) thread in the queue, or null if no threads are currently queued. In this implementation, this operation normally returns in constant time, but may iterate upon contention if other threads are concurrently modifying the queue.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.getQueueLength	(	): Returns an estimate of the number of threads waiting to acquire. The value is only an estimate because the number of threads may change dynamically while this method traverses internal data structures. This method is designed for use in monitoring system state, not for synchronization control.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.getQueuedThreads	(	): Returns a collection containing threads that may be waiting to acquire. Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate. The elements of the returned collection are in no particular order. This method is designed to facilitate construction of subclasses that provide more extensive monitoring facilities.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.getSharedQueuedThreads	(	): Returns a collection containing threads that may be waiting to acquire in shared mode. This has the same properties as getQueuedThreads except that it only returns those threads waiting due to a shared acquire.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.getState	(	): Returns the current value of synchronization state. This operation has memory semantics of a volatile read.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.getWaitQueueLength	(	ConditionObject	): Returns an estimate of the number of threads waiting on the given condition associated with this synchronizer. Note that because timeouts and interrupts may occur at any time, the estimate serves only as an upper bound on the actual number of waiters. This method is designed for use in monitoring of the system state, not for synchronization control.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.getWaitingThreads	(	ConditionObject	): Returns a collection containing those threads that may be waiting on the given condition associated with this synchronizer. Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate. The elements of the returned collection are in no particular order.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.hasContended	(	): Queries whether any threads have ever contended to acquire this synchronizer; that is if an acquire method has ever blocked. In this implementation, this operation returns in constant time.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.hasQueuedPredecessors	(	): Queries whether any threads have been waiting to acquire longer than the current thread. An invocation of this method is equivalent to (but may be more efficient than):  getFirstQueuedThread() != Thread.currentThread() && hasQueuedThreads() Note that because cancellations due to interrupts and timeouts may occur at any time, a true return does not guarantee that some other thread will acquire before the current thread. Likewise, it is possible for another thread to win a race to enqueue after this method has returned false, due to the queue being empty. This method is designed to be used by a fair synchronizer to avoid barging. Such a synchronizer's tryAcquire method should return false, and its tryAcquireShared method should return a negative value, if this method returns true (unless this is a reentrant acquire). For example, the tryAcquire method for a fair, reentrant, exclusive mode synchronizer might look like this:  protected boolean tryAcquire(int arg) if (isHeldExclusively()) { // A reentrant acquire; increment hold count return true; } else if (hasQueuedPredecessors()) { return false; } else { // try to acquire normally } }}
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.hasQueuedThreads	(	): Queries whether any threads are waiting to acquire. Note that because cancellations due to interrupts and timeouts may occur at any time, a true return does not guarantee that any other thread will ever acquire. In this implementation, this operation returns in constant time.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.hasWaiters	(	ConditionObject	): Queries whether any threads are waiting on the given condition associated with this synchronizer. Note that because timeouts and interrupts may occur at any time, a true return does not guarantee that a future signal will awaken any threads. This method is designed primarily for use in monitoring of the system state.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.isHeldExclusively	(	): Returns true if synchronization is held exclusively with respect to the current (calling) thread. This method is invoked upon each call to a non-waiting ConditionObject method. (Waiting methods instead invoke release.) The default implementation throws UnsupportedOperationException. This method is invoked internally only within ConditionObject methods, so need not be defined if conditions are not used.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.isOnSyncQueue	(	Node	): Returns true if a node, always one that was initially placed on a condition queue, is now waiting to reacquire on sync queue.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.isQueued	(	Thread	): Returns true if the given thread is currently queued. This implementation traverses the queue to determine presence of the given thread.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.owns	(	ConditionObject	): Queries whether the given ConditionObject uses this synchronizer as its lock.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.parkAndCheckInterrupt	(	): Convenience method to park and then check if interrupted
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.release	(	long	): Releases in exclusive mode. Implemented by unblocking one or more threads if tryRelease returns true. This method can be used to implement method unlock.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.releaseShared	(	long	): Releases in shared mode. Implemented by unblocking one or more threads if tryReleaseShared returns true.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.selfInterrupt	(	): Convenience method to interrupt current thread.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.setHead	(	Node	): Sets head of queue to be node, thus dequeuing. Called only by acquire methods. Also nulls out unused fields for sake of GC and to suppress unnecessary signals and traversals.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.setHeadAndPropagate	(	Node	long	): Sets head of queue, and checks if successor may be waiting in shared mode, if so propagating if either propagate > 0 or PROPAGATE status was set.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.setState	(	long	): Sets the value of synchronization state. This operation has memory semantics of a volatile write.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.shouldParkAfterFailedAcquire	(	Node	Node	): Checks and updates status for a node that failed to acquire. Returns true if thread should block. This is the main signal control in all acquire loops. Requires that pred == node.prev.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.toString	(	): Returns a string identifying this synchronizer, as well as its state. The state, in brackets, includes the String "State =" followed by the current value of getState, and either "nonempty" or "empty" depending on whether the queue is empty.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.transferAfterCancelledWait	(	Node	): Transfers node, if necessary, to sync queue after a cancelled wait. Returns true if thread was cancelled before being signalled.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.transferForSignal	(	Node	): Transfers a node from a condition queue onto sync queue. Returns true if successful.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.tryAcquire	(	long	): Attempts to acquire in exclusive mode. This method should query if the state of the object permits it to be acquired in the exclusive mode, and if so to acquire it. This method is always invoked by the thread performing acquire. If this method reports failure, the acquire method may queue the thread, if it is not already queued, until it is signalled by a release from some other thread. This can be used to implement method tryLock(). The default implementation throws UnsupportedOperationException.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.tryAcquireNanos	(	long	long	): Attempts to acquire in exclusive mode, aborting if interrupted, and failing if the given timeout elapses. Implemented by first checking interrupt status, then invoking at least once tryAcquire, returning on success. Otherwise, the thread is queued, possibly repeatedly blocking and unblocking, invoking tryAcquire until success or the thread is interrupted or the timeout elapses. This method can be used to implement method tryLock().
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.tryAcquireShared	(	long	): Attempts to acquire in shared mode. This method should query if the state of the object permits it to be acquired in the shared mode, and if so to acquire it. This method is always invoked by the thread performing acquire. If this method reports failure, the acquire method may queue the thread, if it is not already queued, until it is signalled by a release from some other thread. The default implementation throws UnsupportedOperationException.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.tryAcquireSharedNanos	(	long	long	): Attempts to acquire in shared mode, aborting if interrupted, and failing if the given timeout elapses. Implemented by first checking interrupt status, then invoking at least once tryAcquireShared, returning on success. Otherwise, the thread is queued, possibly repeatedly blocking and unblocking, invoking tryAcquireShared until success or the thread is interrupted or the timeout elapses.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.tryRelease	(	long	): Attempts to set the state to reflect a release in exclusive mode. This method is always invoked by the thread performing release. The default implementation throws UnsupportedOperationException.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.tryReleaseShared	(	long	): Attempts to set the state to reflect a release in shared mode. This method is always invoked by the thread performing release. The default implementation throws UnsupportedOperationException.
java.util.concurrent.locks.AbstractQueuedLongSynchronizer.unparkSuccessor	(	Node	): Wakes up node's successor, if one exists.
java.util.concurrent.locks.AbstractQueuedSynchronizer: Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues. This class is designed to be a useful basis for most kinds of synchronizers that rely on a single atomic int value to represent state. Subclasses must define the protected methods that change this state, and which define what that state means in terms of this object being acquired or released. Given these, the other methods in this class carry out all queuing and blocking mechanics. Subclasses can maintain other state fields, but only the atomically updated int value manipulated using methods getState, setState and compareAndSetState is tracked with respect to synchronization. Subclasses should be defined as non-public internal helper classes that are used to implement the synchronization properties of their enclosing class. Class AbstractQueuedSynchronizer does not implement any synchronization interface. Instead it defines methods such as acquireInterruptibly that can be invoked as appropriate by concrete locks and related synchronizers to implement their public methods. This class supports either or both a default exclusive mode and a shared mode. When acquired in exclusive mode, attempted acquires by other threads cannot succeed. Shared mode acquires by multiple threads may (but need not) succeed. This class does not "understand" these differences except in the mechanical sense that when a shared mode acquire succeeds, the next waiting thread (if one exists) must also determine whether it can acquire as well. Threads waiting in the different modes share the same FIFO queue. Usually, implementation subclasses support only one of these modes, but both can come into play for example in a ReadWriteLock. Subclasses that support only exclusive or only shared modes need not define the methods supporting the unused mode. This class defines a nested ConditionObject class that can be used as a Condition implementation by subclasses supporting exclusive mode for which method isHeldExclusively reports whether synchronization is exclusively held with respect to the current thread, method release invoked with the current getState value fully releases this object, and acquire, given this saved state value, eventually restores this object to its previous acquired state. No AbstractQueuedSynchronizer method otherwise creates such a condition, so if this constraint cannot be met, do not use it. The behavior of ConditionObject depends of course on the semantics of its synchronizer implementation. This class provides inspection, instrumentation, and monitoring methods for the internal queue, as well as similar methods for condition objects. These can be exported as desired into classes using an AbstractQueuedSynchronizer for their synchronization mechanics. Serialization of this class stores only the underlying atomic integer maintaining state, so deserialized objects have empty thread queues. Typical subclasses requiring serializability will define a readObject method that restores this to a known initial state upon deserialization. Usage To use this class as the basis of a synchronizer, redefine the following methods, as applicable, by inspecting and/or modifying the synchronization state using getState, setState and/or compareAndSetState:   tryAcquire  tryRelease  tryAcquireShared  tryReleaseShared  isHeldExclusively  Each of these methods by default throws UnsupportedOperationException. Implementations of these methods must be internally thread-safe, and should in general be short and not block. Defining these methods is the only supported means of using this class. All other methods are declared final because they cannot be independently varied. You may also find the inherited methods from AbstractOwnableSynchronizer useful to keep track of the thread owning an exclusive synchronizer. You are encouraged to use them -- this enables monitoring and diagnostic tools to assist users in determining which threads hold locks. Even though this class is based on an internal FIFO queue, it does not automatically enforce FIFO acquisition policies. The core of exclusive synchronization takes the form:  Acquire: while (!tryAcquire(arg)) { enqueue thread if it is not already queued; possibly block current thread; } Release: if (tryRelease(arg)) unblock the first queued thread;  (Shared mode is similar but may involve cascading signals.) Because checks in acquire are invoked before enqueuing, a newly acquiring thread may barge ahead of others that are blocked and queued. However, you can, if desired, define tryAcquire and/or tryAcquireShared to disable barging by internally invoking one or more of the inspection methods, thereby providing a fair FIFO acquisition order. In particular, most fair synchronizers can define tryAcquire to return false if hasQueuedPredecessors (a method specifically designed to be used by fair synchronizers) returns true. Other variations are possible. Throughput and scalability are generally highest for the default barging (also known as greedy, renouncement, and convoy-avoidance) strategy. While this is not guaranteed to be fair or starvation-free, earlier queued threads are allowed to recontend before later queued threads, and each recontention has an unbiased chance to succeed against incoming threads. Also, while acquires do not "spin" in the usual sense, they may perform multiple invocations of tryAcquire interspersed with other computations before blocking. This gives most of the benefits of spins when exclusive synchronization is only briefly held, without most of the liabilities when it isn't. If so desired, you can augment this by preceding calls to acquire methods with "fast-path" checks, possibly prechecking hasContended and/or hasQueuedThreads to only do so if the synchronizer is likely not to be contended. This class provides an efficient and scalable basis for synchronization in part by specializing its range of use to synchronizers that can rely on int state, acquire, and release parameters, and an internal FIFO wait queue. When this does not suffice, you can build synchronizers from a lower level using java.util.concurrent.atomic atomic classes, your own custom java.util.Queue classes, and LockSupport blocking support. Usage Examples Here is a non-reentrant mutual exclusion lock class that uses the value zero to represent the unlocked state, and one to represent the locked state. While a non-reentrant lock does not strictly require recording of the current owner thread, this class does so anyway to make usage easier to monitor. It also supports conditions and exposes one of the instrumentation methods:  class Mutex implements Lock, java.io.Serializable // Our internal helper class private static class Sync extends AbstractQueuedSynchronizer { // Reports whether in locked state protected boolean isHeldExclusively() { return getState() == 1; } // Acquires the lock if state is zero public boolean tryAcquire(int acquires) { assert acquires == 1; // Otherwise unused if (compareAndSetState(0, 1)) { setExclusiveOwnerThread(Thread.currentThread()); return true; } return false; } // Releases the lock by setting state to zero protected boolean tryRelease(int releases) { assert releases == 1; // Otherwise unused if (getState() == 0) throw new IllegalMonitorStateException(); setExclusiveOwnerThread(null); setState(0); return true; } // Provides a Condition Condition newCondition() { return new ConditionObject(); } // Deserializes properly private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException { s.defaultReadObject(); setState(0); // reset to unlocked state } } // The sync object does all the hard work. We just forward to it. private final Sync sync = new Sync(); public void lock() { sync.acquire(1); } public boolean tryLock() { return sync.tryAcquire(1); } public void unlock() { sync.release(1); } public Condition newCondition() { return sync.newCondition(); } public boolean isLocked() { return sync.isHeldExclusively(); } public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); } public void lockInterruptibly() throws InterruptedException { sync.acquireInterruptibly(1); } public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException { return sync.tryAcquireNanos(1, unit.toNanos(timeout)); } }} Here is a latch class that is like a java.util.concurrent.CountDownLatch CountDownLatch except that it only requires a single signal to fire. Because a latch is non-exclusive, it uses the shared acquire and release methods.  class BooleanLatch private static class Sync extends AbstractQueuedSynchronizer { boolean isSignalled() { return getState() != 0; } protected int tryAcquireShared(int ignore) { return isSignalled() ? 1 : -1; } protected boolean tryReleaseShared(int ignore) { setState(1); return true; } } private final Sync sync = new Sync(); public boolean isSignalled() { return sync.isSignalled(); } public void signal() { sync.releaseShared(1); } public void await() throws InterruptedException { sync.acquireSharedInterruptibly(1); } }}
java.util.concurrent.locks.AbstractQueuedSynchronizer.AbstractQueuedSynchronizer	(	): Creates a new AbstractQueuedSynchronizer instance with initial synchronization state of zero.
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject: Condition implementation for a AbstractQueuedSynchronizer serving as the basis of a Lock implementation. Method documentation for this class describes mechanics, not behavioral specifications from the point of view of Lock and Condition users. Exported versions of this class will in general need to be accompanied by documentation describing condition semantics that rely on those of the associated AbstractQueuedSynchronizer. This class is Serializable, but all fields are transient, so deserialized conditions have no waiters.
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject.ConditionObject	(	): Creates a new ConditionObject instance.
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject.addConditionWaiter	(	): Adds a new waiter to wait queue.
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject.await	(	): Implements interruptible condition wait.   If current thread is interrupted, throw InterruptedException.  Save lock state returned by getState.  Invoke release with saved state as argument, throwing IllegalMonitorStateException if it fails.  Block until signalled or interrupted.  Reacquire by invoking specialized version of acquire with saved state as argument.  If interrupted while blocked in step 4, throw InterruptedException. 
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject.await	(	long	TimeUnit	): Implements timed condition wait.   If current thread is interrupted, throw InterruptedException.  Save lock state returned by getState.  Invoke release with saved state as argument, throwing IllegalMonitorStateException if it fails.  Block until signalled, interrupted, or timed out.  Reacquire by invoking specialized version of acquire with saved state as argument.  If interrupted while blocked in step 4, throw InterruptedException.  If timed out while blocked in step 4, return false, else true. 
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject.awaitNanos	(	long	): Implements timed condition wait.   If current thread is interrupted, throw InterruptedException.  Save lock state returned by getState.  Invoke release with saved state as argument, throwing IllegalMonitorStateException if it fails.  Block until signalled, interrupted, or timed out.  Reacquire by invoking specialized version of acquire with saved state as argument.  If interrupted while blocked in step 4, throw InterruptedException. 
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject.awaitUninterruptibly	(	): Implements uninterruptible condition wait.   Save lock state returned by getState.  Invoke release with saved state as argument, throwing IllegalMonitorStateException if it fails.  Block until signalled.  Reacquire by invoking specialized version of acquire with saved state as argument. 
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject.awaitUntil	(	Date	): Implements absolute timed condition wait.   If current thread is interrupted, throw InterruptedException.  Save lock state returned by getState.  Invoke release with saved state as argument, throwing IllegalMonitorStateException if it fails.  Block until signalled, interrupted, or timed out.  Reacquire by invoking specialized version of acquire with saved state as argument.  If interrupted while blocked in step 4, throw InterruptedException.  If timed out while blocked in step 4, return false, else true. 
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject.checkInterruptWhileWaiting	(	Node	): Checks for interrupt, returning THROW_IE if interrupted before signalled, REINTERRUPT if after signalled, or 0 if not interrupted.
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject.doSignal	(	Node	): Removes and transfers nodes until hit non-cancelled one or null. Split out from signal in part to encourage compilers to inline the case of no waiters.
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject.doSignalAll	(	Node	): Removes and transfers all nodes.
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject.getWaitQueueLength	(	): Returns an estimate of the number of threads waiting on this condition. Implements getWaitQueueLength().
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject.getWaitingThreads	(	): Returns a collection containing those threads that may be waiting on this Condition. Implements getWaitingThreads().
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject.hasWaiters	(	): Queries whether any threads are waiting on this condition. Implements hasWaiters().
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject.isOwnedBy	(	AbstractQueuedSynchronizer	): Returns true if this condition was created by the given synchronization object.
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject.reportInterruptAfterWait	(	int	): Throws InterruptedException, reinterrupts current thread, or does nothing, depending on mode.
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject.signal	(	): Moves the longest-waiting thread, if one exists, from the wait queue for this condition to the wait queue for the owning lock.
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject.signalAll	(	): Moves all threads from the wait queue for this condition to the wait queue for the owning lock.
java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject.unlinkCancelledWaiters	(	): Unlinks cancelled waiter nodes from condition queue. Called only while holding lock. This is called when cancellation occurred during condition wait, and upon insertion of a new waiter when lastWaiter is seen to have been cancelled. This method is needed to avoid garbage retention in the absence of signals. So even though it may require a full traversal, it comes into play only when timeouts or cancellations occur in the absence of signals. It traverses all nodes rather than stopping at a particular target to unlink all pointers to garbage nodes without requiring many re-traversals during cancellation storms.
java.util.concurrent.locks.AbstractQueuedSynchronizer.Node: Wait queue node class. The wait queue is a variant of a "CLH" (Craig, Landin, and Hagersten) lock queue. CLH locks are normally used for spinlocks. We instead use them for blocking synchronizers, but use the same basic tactic of holding some of the control information about a thread in the predecessor of its node. A "status" field in each node keeps track of whether a thread should block. A node is signalled when its predecessor releases. Each node of the queue otherwise serves as a specific-notification-style monitor holding a single waiting thread. The status field does NOT control whether threads are granted locks etc though. A thread may try to acquire if it is first in the queue. But being first does not guarantee success; it only gives the right to contend. So the currently released contender thread may need to rewait. To enqueue into a CLH lock, you atomically splice it in as new tail. To dequeue, you just set the head field.  +------+ prev +-----+ +-----+ head | | <---- | | <---- | | tail +------+ +-----+ +-----+  Insertion into a CLH queue requires only a single atomic operation on "tail", so there is a simple atomic point of demarcation from unqueued to queued. Similarly, dequeuing involves only updating the "head". However, it takes a bit more work for nodes to determine who their successors are, in part to deal with possible cancellation due to timeouts and interrupts. The "prev" links (not used in original CLH locks), are mainly needed to handle cancellation. If a node is cancelled, its successor is (normally) relinked to a non-cancelled predecessor. For explanation of similar mechanics in the case of spin locks, see the papers by Scott and Scherer at http://www.cs.rochester.edu/u/scott/synchronization/ We also use "next" links to implement blocking mechanics. The thread id for each node is kept in its own node, so a predecessor signals the next node to wake up by traversing next link to determine which thread it is. Determination of successor must avoid races with newly queued nodes to set the "next" fields of their predecessors. This is solved when necessary by checking backwards from the atomically updated "tail" when a node's successor appears to be null. (Or, said differently, the next-links are an optimization so that we don't usually need a backward scan.) Cancellation introduces some conservatism to the basic algorithms. Since we must poll for cancellation of other nodes, we can miss noticing whether a cancelled node is ahead or behind us. This is dealt with by always unparking successors upon cancellation, allowing them to stabilize on a new predecessor, unless we can identify an uncancelled predecessor who will carry this responsibility. CLH queues need a dummy header node to get started. But we don't create them on construction, because it would be wasted effort if there is never contention. Instead, the node is constructed and head and tail pointers are set upon first contention. Threads waiting on Conditions use the same nodes, but use an additional link. Conditions only need to link nodes in simple (non-concurrent) linked queues because they are only accessed when exclusively held. Upon await, a node is inserted into a condition queue. Upon signal, the node is transferred to the main queue. A special value of status field is used to mark which queue a node is on. Thanks go to Dave Dice, Mark Moir, Victor Luchangco, Bill Scherer and Michael Scott, along with members of JSR-166 expert group, for helpful ideas, discussions, and critiques on the design of this class.
java.util.concurrent.locks.AbstractQueuedSynchronizer.Node.isShared	(	): Returns true if node is waiting in shared mode.
java.util.concurrent.locks.AbstractQueuedSynchronizer.Node.predecessor	(	): Returns previous node, or throws NullPointerException if null. Use when predecessor cannot be null. The null check could be elided, but is present to help the VM.
java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire	(	int	): Acquires in exclusive mode, ignoring interrupts. Implemented by invoking at least once tryAcquire, returning on success. Otherwise the thread is queued, possibly repeatedly blocking and unblocking, invoking tryAcquire until success. This method can be used to implement method lock.
java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly	(	int	): Acquires in exclusive mode, aborting if interrupted. Implemented by first checking interrupt status, then invoking at least once tryAcquire, returning on success. Otherwise the thread is queued, possibly repeatedly blocking and unblocking, invoking tryAcquire until success or the thread is interrupted. This method can be used to implement method lockInterruptibly.
java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued	(	Node	int	): Acquires in exclusive uninterruptible mode for thread already in queue. Used by condition wait methods as well as acquire.
java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireShared	(	int	): Acquires in shared mode, ignoring interrupts. Implemented by first invoking at least once tryAcquireShared, returning on success. Otherwise the thread is queued, possibly repeatedly blocking and unblocking, invoking tryAcquireShared until success.
java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly	(	int	): Acquires in shared mode, aborting if interrupted. Implemented by first checking interrupt status, then invoking at least once tryAcquireShared, returning on success. Otherwise the thread is queued, possibly repeatedly blocking and unblocking, invoking tryAcquireShared until success or the thread is interrupted.
java.util.concurrent.locks.AbstractQueuedSynchronizer.addWaiter	(	Node	): Creates and enqueues node for current thread and given mode.
java.util.concurrent.locks.AbstractQueuedSynchronizer.apparentlyFirstQueuedIsExclusive	(	): Returns true if the apparent first queued thread, if one exists, is waiting in exclusive mode. If this method returns true, and the current thread is attempting to acquire in shared mode (that is, this method is invoked from tryAcquireShared) then it is guaranteed that the current thread is not the first queued thread. Used only as a heuristic in ReentrantReadWriteLock.
java.util.concurrent.locks.AbstractQueuedSynchronizer.cancelAcquire	(	Node	): Cancels an ongoing attempt to acquire.
java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetHead	(	Node	): CAS head field. Used only by enq.
java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetNext	(	Node	Node	Node	): CAS next field of a node.
java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetState	(	int	int	): Atomically sets synchronization state to the given updated value if the current state value equals the expected value. This operation has memory semantics of a volatile read and write.
java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetTail	(	Node	Node	): CAS tail field. Used only by enq.
java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetWaitStatus	(	Node	int	int	): CAS waitStatus field of a node.
java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly	(	int	): Acquires in exclusive interruptible mode.
java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireNanos	(	int	long	): Acquires in exclusive timed mode.
java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireShared	(	int	): Acquires in shared uninterruptible mode.
java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly	(	int	): Acquires in shared interruptible mode.
java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedNanos	(	int	long	): Acquires in shared timed mode.
java.util.concurrent.locks.AbstractQueuedSynchronizer.doReleaseShared	(	): Release action for shared mode -- signals successor and ensures propagation. (Note: For exclusive mode, release just amounts to calling unparkSuccessor of head if it needs signal.)
java.util.concurrent.locks.AbstractQueuedSynchronizer.enq	(	Node	): Inserts node into queue, initializing if necessary. See picture above.
java.util.concurrent.locks.AbstractQueuedSynchronizer.findNodeFromTail	(	Node	): Returns true if node is on sync queue by searching backwards from tail. Called only when needed by isOnSyncQueue.
java.util.concurrent.locks.AbstractQueuedSynchronizer.fullGetFirstQueuedThread	(	): Version of getFirstQueuedThread called when fastpath fails
java.util.concurrent.locks.AbstractQueuedSynchronizer.fullyRelease	(	Node	): Invokes release with current state value; returns saved state. Cancels node and throws exception on failure.
java.util.concurrent.locks.AbstractQueuedSynchronizer.getExclusiveQueuedThreads	(	): Returns a collection containing threads that may be waiting to acquire in exclusive mode. This has the same properties as getQueuedThreads except that it only returns those threads waiting due to an exclusive acquire.
java.util.concurrent.locks.AbstractQueuedSynchronizer.getFirstQueuedThread	(	): Returns the first (longest-waiting) thread in the queue, or null if no threads are currently queued. In this implementation, this operation normally returns in constant time, but may iterate upon contention if other threads are concurrently modifying the queue.
java.util.concurrent.locks.AbstractQueuedSynchronizer.getQueueLength	(	): Returns an estimate of the number of threads waiting to acquire. The value is only an estimate because the number of threads may change dynamically while this method traverses internal data structures. This method is designed for use in monitoring system state, not for synchronization control.
java.util.concurrent.locks.AbstractQueuedSynchronizer.getQueuedThreads	(	): Returns a collection containing threads that may be waiting to acquire. Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate. The elements of the returned collection are in no particular order. This method is designed to facilitate construction of subclasses that provide more extensive monitoring facilities.
java.util.concurrent.locks.AbstractQueuedSynchronizer.getSharedQueuedThreads	(	): Returns a collection containing threads that may be waiting to acquire in shared mode. This has the same properties as getQueuedThreads except that it only returns those threads waiting due to a shared acquire.
java.util.concurrent.locks.AbstractQueuedSynchronizer.getState	(	): Returns the current value of synchronization state. This operation has memory semantics of a volatile read.
java.util.concurrent.locks.AbstractQueuedSynchronizer.getWaitQueueLength	(	ConditionObject	): Returns an estimate of the number of threads waiting on the given condition associated with this synchronizer. Note that because timeouts and interrupts may occur at any time, the estimate serves only as an upper bound on the actual number of waiters. This method is designed for use in monitoring of the system state, not for synchronization control.
java.util.concurrent.locks.AbstractQueuedSynchronizer.getWaitingThreads	(	ConditionObject	): Returns a collection containing those threads that may be waiting on the given condition associated with this synchronizer. Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate. The elements of the returned collection are in no particular order.
java.util.concurrent.locks.AbstractQueuedSynchronizer.hasContended	(	): Queries whether any threads have ever contended to acquire this synchronizer; that is if an acquire method has ever blocked. In this implementation, this operation returns in constant time.
java.util.concurrent.locks.AbstractQueuedSynchronizer.hasQueuedPredecessors	(	): Queries whether any threads have been waiting to acquire longer than the current thread. An invocation of this method is equivalent to (but may be more efficient than):  getFirstQueuedThread() != Thread.currentThread() && hasQueuedThreads() Note that because cancellations due to interrupts and timeouts may occur at any time, a true return does not guarantee that some other thread will acquire before the current thread. Likewise, it is possible for another thread to win a race to enqueue after this method has returned false, due to the queue being empty. This method is designed to be used by a fair synchronizer to avoid barging. Such a synchronizer's tryAcquire method should return false, and its tryAcquireShared method should return a negative value, if this method returns true (unless this is a reentrant acquire). For example, the tryAcquire method for a fair, reentrant, exclusive mode synchronizer might look like this:  protected boolean tryAcquire(int arg) if (isHeldExclusively()) { // A reentrant acquire; increment hold count return true; } else if (hasQueuedPredecessors()) { return false; } else { // try to acquire normally } }}
java.util.concurrent.locks.AbstractQueuedSynchronizer.hasQueuedThreads	(	): Queries whether any threads are waiting to acquire. Note that because cancellations due to interrupts and timeouts may occur at any time, a true return does not guarantee that any other thread will ever acquire. In this implementation, this operation returns in constant time.
java.util.concurrent.locks.AbstractQueuedSynchronizer.hasWaiters	(	ConditionObject	): Queries whether any threads are waiting on the given condition associated with this synchronizer. Note that because timeouts and interrupts may occur at any time, a true return does not guarantee that a future signal will awaken any threads. This method is designed primarily for use in monitoring of the system state.
java.util.concurrent.locks.AbstractQueuedSynchronizer.isHeldExclusively	(	): Returns true if synchronization is held exclusively with respect to the current (calling) thread. This method is invoked upon each call to a non-waiting ConditionObject method. (Waiting methods instead invoke release.) The default implementation throws UnsupportedOperationException. This method is invoked internally only within ConditionObject methods, so need not be defined if conditions are not used.
java.util.concurrent.locks.AbstractQueuedSynchronizer.isOnSyncQueue	(	Node	): Returns true if a node, always one that was initially placed on a condition queue, is now waiting to reacquire on sync queue.
java.util.concurrent.locks.AbstractQueuedSynchronizer.isQueued	(	Thread	): Returns true if the given thread is currently queued. This implementation traverses the queue to determine presence of the given thread.
java.util.concurrent.locks.AbstractQueuedSynchronizer.owns	(	ConditionObject	): Queries whether the given ConditionObject uses this synchronizer as its lock.
java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt	(	): Convenience method to park and then check if interrupted
java.util.concurrent.locks.AbstractQueuedSynchronizer.release	(	int	): Releases in exclusive mode. Implemented by unblocking one or more threads if tryRelease returns true. This method can be used to implement method unlock.
java.util.concurrent.locks.AbstractQueuedSynchronizer.releaseShared	(	int	): Releases in shared mode. Implemented by unblocking one or more threads if tryReleaseShared returns true.
java.util.concurrent.locks.AbstractQueuedSynchronizer.selfInterrupt	(	): Convenience method to interrupt current thread.
java.util.concurrent.locks.AbstractQueuedSynchronizer.setHead	(	Node	): Sets head of queue to be node, thus dequeuing. Called only by acquire methods. Also nulls out unused fields for sake of GC and to suppress unnecessary signals and traversals.
java.util.concurrent.locks.AbstractQueuedSynchronizer.setHeadAndPropagate	(	Node	int	): Sets head of queue, and checks if successor may be waiting in shared mode, if so propagating if either propagate > 0 or PROPAGATE status was set.
java.util.concurrent.locks.AbstractQueuedSynchronizer.setState	(	int	): Sets the value of synchronization state. This operation has memory semantics of a volatile write.
java.util.concurrent.locks.AbstractQueuedSynchronizer.shouldParkAfterFailedAcquire	(	Node	Node	): Checks and updates status for a node that failed to acquire. Returns true if thread should block. This is the main signal control in all acquire loops. Requires that pred == node.prev.
java.util.concurrent.locks.AbstractQueuedSynchronizer.toString	(	): Returns a string identifying this synchronizer, as well as its state. The state, in brackets, includes the String "State =" followed by the current value of getState, and either "nonempty" or "empty" depending on whether the queue is empty.
java.util.concurrent.locks.AbstractQueuedSynchronizer.transferAfterCancelledWait	(	Node	): Transfers node, if necessary, to sync queue after a cancelled wait. Returns true if thread was cancelled before being signalled.
java.util.concurrent.locks.AbstractQueuedSynchronizer.transferForSignal	(	Node	): Transfers a node from a condition queue onto sync queue. Returns true if successful.
java.util.concurrent.locks.AbstractQueuedSynchronizer.tryAcquire	(	int	): Attempts to acquire in exclusive mode. This method should query if the state of the object permits it to be acquired in the exclusive mode, and if so to acquire it. This method is always invoked by the thread performing acquire. If this method reports failure, the acquire method may queue the thread, if it is not already queued, until it is signalled by a release from some other thread. This can be used to implement method tryLock(). The default implementation throws UnsupportedOperationException.
java.util.concurrent.locks.AbstractQueuedSynchronizer.tryAcquireNanos	(	int	long	): Attempts to acquire in exclusive mode, aborting if interrupted, and failing if the given timeout elapses. Implemented by first checking interrupt status, then invoking at least once tryAcquire, returning on success. Otherwise, the thread is queued, possibly repeatedly blocking and unblocking, invoking tryAcquire until success or the thread is interrupted or the timeout elapses. This method can be used to implement method tryLock().
java.util.concurrent.locks.AbstractQueuedSynchronizer.tryAcquireShared	(	int	): Attempts to acquire in shared mode. This method should query if the state of the object permits it to be acquired in the shared mode, and if so to acquire it. This method is always invoked by the thread performing acquire. If this method reports failure, the acquire method may queue the thread, if it is not already queued, until it is signalled by a release from some other thread. The default implementation throws UnsupportedOperationException.
java.util.concurrent.locks.AbstractQueuedSynchronizer.tryAcquireSharedNanos	(	int	long	): Attempts to acquire in shared mode, aborting if interrupted, and failing if the given timeout elapses. Implemented by first checking interrupt status, then invoking at least once tryAcquireShared, returning on success. Otherwise, the thread is queued, possibly repeatedly blocking and unblocking, invoking tryAcquireShared until success or the thread is interrupted or the timeout elapses.
java.util.concurrent.locks.AbstractQueuedSynchronizer.tryRelease	(	int	): Attempts to set the state to reflect a release in exclusive mode. This method is always invoked by the thread performing release. The default implementation throws UnsupportedOperationException.
java.util.concurrent.locks.AbstractQueuedSynchronizer.tryReleaseShared	(	int	): Attempts to set the state to reflect a release in shared mode. This method is always invoked by the thread performing release. The default implementation throws UnsupportedOperationException.
java.util.concurrent.locks.AbstractQueuedSynchronizer.unparkSuccessor	(	Node	): Wakes up node's successor, if one exists.
java.util.concurrent.locks.Condition: Condition factors out the Object monitor methods (wait(), notify and notifyAll) into distinct objects to give the effect of having multiple wait-sets per object, by combining them with the use of arbitrary Lock implementations. Where a Lock replaces the use of synchronized methods and statements, a Condition replaces the use of the Object monitor methods. Conditions (also known as condition queues or condition variables) provide a means for one thread to suspend execution (to "wait") until notified by another thread that some state condition may now be true. Because access to this shared state information occurs in different threads, it must be protected, so a lock of some form is associated with the condition. The key property that waiting for a condition provides is that it atomically releases the associated lock and suspends the current thread, just like Object.wait. A Condition instance is intrinsically bound to a lock. To obtain a Condition instance for a particular Lock instance use its newCondition newCondition() method. As an example, suppose we have a bounded buffer which supports put and take methods. If a take is attempted on an empty buffer, then the thread will block until an item becomes available; if a put is attempted on a full buffer, then the thread will block until a space becomes available. We would like to keep waiting put threads and take threads in separate wait-sets so that we can use the optimization of only notifying a single thread at a time when items or spaces become available in the buffer. This can be achieved using two Condition instances.  class BoundedBuffer { final Lock lock = new ReentrantLock(); final Condition notFull = lock.newCondition();  final Condition notEmpty = lock.newCondition();  final Object[] items = new Object[100]; int putptr, takeptr, count; public void put(Object x) throws InterruptedException { lock.lock(); try { while (count == items.length) notFull.await(); items[putptr] = x; if (++putptr == items.length) putptr = 0; ++count; notEmpty.signal(); } finally { lock.unlock(); } } public Object take() throws InterruptedException { lock.lock(); try { while (count == 0) notEmpty.await(); Object x = items[takeptr]; if (++takeptr == items.length) takeptr = 0; --count; notFull.signal(); return x; } finally { lock.unlock(); } } }  (The java.util.concurrent.ArrayBlockingQueue class provides this functionality, so there is no reason to implement this sample usage class.) A Condition implementation can provide behavior and semantics that is different from that of the Object monitor methods, such as guaranteed ordering for notifications, or not requiring a lock to be held when performing notifications. If an implementation provides such specialized semantics then the implementation must document those semantics. Note that Condition instances are just normal objects and can themselves be used as the target in a synchronized statement, and can have their own monitor wait and notify notification methods invoked. Acquiring the monitor lock of a Condition instance, or using its monitor methods, has no specified relationship with acquiring the Lock associated with that Condition or the use of its await waiting and signal signalling methods. It is recommended that to avoid confusion you never use Condition instances in this way, except perhaps within their own implementation. Except where noted, passing a null value for any parameter will result in a NullPointerException being thrown. Implementation Considerations When waiting upon a Condition, a "spurious wakeup" is permitted to occur, in general, as a concession to the underlying platform semantics. This has little practical impact on most application programs as a Condition should always be waited upon in a loop, testing the state predicate that is being waited for. An implementation is free to remove the possibility of spurious wakeups but it is recommended that applications programmers always assume that they can occur and so always wait in a loop. The three forms of condition waiting (interruptible, non-interruptible, and timed) may differ in their ease of implementation on some platforms and in their performance characteristics. In particular, it may be difficult to provide these features and maintain specific semantics such as ordering guarantees. Further, the ability to interrupt the actual suspension of the thread may not always be feasible to implement on all platforms. Consequently, an implementation is not required to define exactly the same guarantees or semantics for all three forms of waiting, nor is it required to support interruption of the actual suspension of the thread. An implementation is required to clearly document the semantics and guarantees provided by each of the waiting methods, and when an implementation does support interruption of thread suspension then it must obey the interruption semantics as defined in this interface. As interruption generally implies cancellation, and checks for interruption are often infrequent, an implementation can favor responding to an interrupt over normal method return. This is true even if it can be shown that the interrupt occurred after another action that may have unblocked the thread. An implementation should document this behavior.
java.util.concurrent.locks.Condition.await	(	): Causes the current thread to wait until it is signalled or interrupt interrupted. The lock associated with this Condition is atomically released and the current thread becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:  Some other thread invokes the signal method for this Condition and the current thread happens to be chosen as the thread to be awakened; or Some other thread invokes the signalAll method for this Condition; or Some other thread interrupt interrupts the current thread, and interruption of thread suspension is supported; or A "spurious wakeup" occurs.  In all cases, before this method can return the current thread must re-acquire the lock associated with this condition. When the thread returns it is guaranteed to hold this lock. If the current thread:  has its interrupted status set on entry to this method; or is interrupt interrupted while waiting and interruption of thread suspension is supported,  then InterruptedException is thrown and the current thread's interrupted status is cleared. It is not specified, in the first case, whether or not the test for interruption occurs before the lock is released. Implementation Considerations The current thread is assumed to hold the lock associated with this Condition when this method is called. It is up to the implementation to determine if this is the case and if not, how to respond. Typically, an exception will be thrown (such as IllegalMonitorStateException) and the implementation must document that fact. An implementation can favor responding to an interrupt over normal method return in response to a signal. In that case the implementation must ensure that the signal is redirected to another waiting thread, if there is one.
java.util.concurrent.locks.Condition.await	(	long	TimeUnit	): Causes the current thread to wait until it is signalled or interrupted, or the specified waiting time elapses. This method is behaviorally equivalent to:  awaitNanos(unit.toNanos(time)) > 0
java.util.concurrent.locks.Condition.awaitNanos	(	long	): Causes the current thread to wait until it is signalled or interrupted, or the specified waiting time elapses. The lock associated with this condition is atomically released and the current thread becomes disabled for thread scheduling purposes and lies dormant until one of five things happens:  Some other thread invokes the signal method for this Condition and the current thread happens to be chosen as the thread to be awakened; or Some other thread invokes the signalAll method for this Condition; or Some other thread interrupt interrupts the current thread, and interruption of thread suspension is supported; or The specified waiting time elapses; or A "spurious wakeup" occurs.  In all cases, before this method can return the current thread must re-acquire the lock associated with this condition. When the thread returns it is guaranteed to hold this lock. If the current thread:  has its interrupted status set on entry to this method; or is interrupt interrupted while waiting and interruption of thread suspension is supported,  then InterruptedException is thrown and the current thread's interrupted status is cleared. It is not specified, in the first case, whether or not the test for interruption occurs before the lock is released. The method returns an estimate of the number of nanoseconds remaining to wait given the supplied nanosTimeout value upon return, or a value less than or equal to zero if it timed out. This value can be used to determine whether and how long to re-wait in cases where the wait returns but an awaited condition still does not hold. Typical uses of this method take the following form:  boolean aMethod(long timeout, TimeUnit unit) long nanos = unit.toNanos(timeout); lock.lock(); try { while (!conditionBeingWaitedFor()) { if (nanos <= 0L) return false; nanos = theCondition.awaitNanos(nanos); } // ... } finally { lock.unlock(); } }} Design note: This method requires a nanosecond argument so as to avoid truncation errors in reporting remaining times. Such precision loss would make it difficult for programmers to ensure that total waiting times are not systematically shorter than specified when re-waits occur. Implementation Considerations The current thread is assumed to hold the lock associated with this Condition when this method is called. It is up to the implementation to determine if this is the case and if not, how to respond. Typically, an exception will be thrown (such as IllegalMonitorStateException) and the implementation must document that fact. An implementation can favor responding to an interrupt over normal method return in response to a signal, or over indicating the elapse of the specified waiting time. In either case the implementation must ensure that the signal is redirected to another waiting thread, if there is one.
java.util.concurrent.locks.Condition.awaitUninterruptibly	(	): Causes the current thread to wait until it is signalled. The lock associated with this condition is atomically released and the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:  Some other thread invokes the signal method for this Condition and the current thread happens to be chosen as the thread to be awakened; or Some other thread invokes the signalAll method for this Condition; or A "spurious wakeup" occurs.  In all cases, before this method can return the current thread must re-acquire the lock associated with this condition. When the thread returns it is guaranteed to hold this lock. If the current thread's interrupted status is set when it enters this method, or it is interrupt interrupted while waiting, it will continue to wait until signalled. When it finally returns from this method its interrupted status will still be set. Implementation Considerations The current thread is assumed to hold the lock associated with this Condition when this method is called. It is up to the implementation to determine if this is the case and if not, how to respond. Typically, an exception will be thrown (such as IllegalMonitorStateException) and the implementation must document that fact.
java.util.concurrent.locks.Condition.awaitUntil	(	Date	): Causes the current thread to wait until it is signalled or interrupted, or the specified deadline elapses. The lock associated with this condition is atomically released and the current thread becomes disabled for thread scheduling purposes and lies dormant until one of five things happens:  Some other thread invokes the signal method for this Condition and the current thread happens to be chosen as the thread to be awakened; or Some other thread invokes the signalAll method for this Condition; or Some other thread interrupt interrupts the current thread, and interruption of thread suspension is supported; or The specified deadline elapses; or A "spurious wakeup" occurs.  In all cases, before this method can return the current thread must re-acquire the lock associated with this condition. When the thread returns it is guaranteed to hold this lock. If the current thread:  has its interrupted status set on entry to this method; or is interrupt interrupted while waiting and interruption of thread suspension is supported,  then InterruptedException is thrown and the current thread's interrupted status is cleared. It is not specified, in the first case, whether or not the test for interruption occurs before the lock is released. The return value indicates whether the deadline has elapsed, which can be used as follows:  boolean aMethod(Date deadline) boolean stillWaiting = true; lock.lock(); try { while (!conditionBeingWaitedFor()) { if (!stillWaiting) return false; stillWaiting = theCondition.awaitUntil(deadline); } // ... } finally { lock.unlock(); } }} Implementation Considerations The current thread is assumed to hold the lock associated with this Condition when this method is called. It is up to the implementation to determine if this is the case and if not, how to respond. Typically, an exception will be thrown (such as IllegalMonitorStateException) and the implementation must document that fact. An implementation can favor responding to an interrupt over normal method return in response to a signal, or over indicating the passing of the specified deadline. In either case the implementation must ensure that the signal is redirected to another waiting thread, if there is one.
java.util.concurrent.locks.Condition.signal	(	): Wakes up one waiting thread. If any threads are waiting on this condition then one is selected for waking up. That thread must then re-acquire the lock before returning from await. Implementation Considerations An implementation may (and typically does) require that the current thread hold the lock associated with this Condition when this method is called. Implementations must document this precondition and any actions taken if the lock is not held. Typically, an exception such as IllegalMonitorStateException will be thrown.
java.util.concurrent.locks.Condition.signalAll	(	): Wakes up all waiting threads. If any threads are waiting on this condition then they are all woken up. Each thread must re-acquire the lock before it can return from await. Implementation Considerations An implementation may (and typically does) require that the current thread hold the lock associated with this Condition when this method is called. Implementations must document this precondition and any actions taken if the lock is not held. Typically, an exception such as IllegalMonitorStateException will be thrown.
java.util.concurrent.locks.Lock: Lock implementations provide more extensive locking operations than can be obtained using synchronized methods and statements. They allow more flexible structuring, may have quite different properties, and may support multiple associated Condition objects. A lock is a tool for controlling access to a shared resource by multiple threads. Commonly, a lock provides exclusive access to a shared resource: only one thread at a time can acquire the lock and all access to the shared resource requires that the lock be acquired first. However, some locks may allow concurrent access to a shared resource, such as the read lock of a ReadWriteLock. The use of synchronized methods or statements provides access to the implicit monitor lock associated with every object, but forces all lock acquisition and release to occur in a block-structured way: when multiple locks are acquired they must be released in the opposite order, and all locks must be released in the same lexical scope in which they were acquired. While the scoping mechanism for synchronized methods and statements makes it much easier to program with monitor locks, and helps avoid many common programming errors involving locks, there are occasions where you need to work with locks in a more flexible way. For example, some algorithms for traversing concurrently accessed data structures require the use of "hand-over-hand" or "chain locking": you acquire the lock of node A, then node B, then release A and acquire C, then release B and acquire D and so on. Implementations of the Lock interface enable the use of such techniques by allowing a lock to be acquired and released in different scopes, and allowing multiple locks to be acquired and released in any order. With this increased flexibility comes additional responsibility. The absence of block-structured locking removes the automatic release of locks that occurs with synchronized methods and statements. In most cases, the following idiom should be used:  Lock l = ...; l.lock(); try // access the resource protected by this lock } finally { l.unlock(); }} When locking and unlocking occur in different scopes, care must be taken to ensure that all code that is executed while the lock is held is protected by try-finally or try-catch to ensure that the lock is released when necessary. Lock implementations provide additional functionality over the use of synchronized methods and statements by providing a non-blocking attempt to acquire a lock (tryLock()), an attempt to acquire the lock that can be interrupted (lockInterruptibly, and an attempt to acquire the lock that can timeout (tryLock()). A Lock class can also provide behavior and semantics that is quite different from that of the implicit monitor lock, such as guaranteed ordering, non-reentrant usage, or deadlock detection. If an implementation provides such specialized semantics then the implementation must document those semantics. Note that Lock instances are just normal objects and can themselves be used as the target in a synchronized statement. Acquiring the monitor lock of a Lock instance has no specified relationship with invoking any of the lock methods of that instance. It is recommended that to avoid confusion you never use Lock instances in this way, except within their own implementation. Except where noted, passing a null value for any parameter will result in a NullPointerException being thrown. Memory Synchronization All Lock implementations must enforce the same memory synchronization semantics as provided by the built-in monitor lock, as described in  The Java Language Specification (17.4 Memory Model):  A successful lock operation has the same memory synchronization effects as a successful Lock action. A successful unlock operation has the same memory synchronization effects as a successful Unlock action.  Unsuccessful locking and unlocking operations, and reentrant locking/unlocking operations, do not require any memory synchronization effects. Implementation Considerations The three forms of lock acquisition (interruptible, non-interruptible, and timed) may differ in their performance characteristics, ordering guarantees, or other implementation qualities. Further, the ability to interrupt the ongoing acquisition of a lock may not be available in a given Lock class. Consequently, an implementation is not required to define exactly the same guarantees or semantics for all three forms of lock acquisition, nor is it required to support interruption of an ongoing lock acquisition. An implementation is required to clearly document the semantics and guarantees provided by each of the locking methods. It must also obey the interruption semantics as defined in this interface, to the extent that interruption of lock acquisition is supported: which is either totally, or only on method entry. As interruption generally implies cancellation, and checks for interruption are often infrequent, an implementation can favor responding to an interrupt over normal method return. This is true even if it can be shown that the interrupt occurred after another action may have unblocked the thread. An implementation should document this behavior.
java.util.concurrent.locks.Lock.lock	(	): Acquires the lock. If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired. Implementation Considerations A Lock implementation may be able to detect erroneous use of the lock, such as an invocation that would cause deadlock, and may throw an (unchecked) exception in such circumstances. The circumstances and the exception type must be documented by that Lock implementation.
java.util.concurrent.locks.Lock.lockInterruptibly	(	): Acquires the lock unless the current thread is interrupt interrupted. Acquires the lock if it is available and returns immediately. If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:  The lock is acquired by the current thread; or Some other thread interrupt interrupts the current thread, and interruption of lock acquisition is supported.  If the current thread:  has its interrupted status set on entry to this method; or is interrupt interrupted while acquiring the lock, and interruption of lock acquisition is supported,  then InterruptedException is thrown and the current thread's interrupted status is cleared. Implementation Considerations The ability to interrupt a lock acquisition in some implementations may not be possible, and if possible may be an expensive operation. The programmer should be aware that this may be the case. An implementation should document when this is the case. An implementation can favor responding to an interrupt over normal method return. A Lock implementation may be able to detect erroneous use of the lock, such as an invocation that would cause deadlock, and may throw an (unchecked) exception in such circumstances. The circumstances and the exception type must be documented by that Lock implementation.
java.util.concurrent.locks.Lock.newCondition	(	): Returns a new Condition instance that is bound to this Lock instance. Before waiting on the condition the lock must be held by the current thread. A call to await() will atomically release the lock before waiting and re-acquire the lock before the wait returns. Implementation Considerations The exact operation of the Condition instance depends on the Lock implementation and must be documented by that implementation.
java.util.concurrent.locks.Lock.tryLock	(	): Acquires the lock only if it is free at the time of invocation. Acquires the lock if it is available and returns immediately with the value true. If the lock is not available then this method will return immediately with the value false. A typical usage idiom for this method would be:  Lock lock = ...; if (lock.tryLock()) try { // manipulate protected state } finally { lock.unlock(); } } else { // perform alternative actions }} This usage ensures that the lock is unlocked if it was acquired, and doesn't try to unlock if the lock was not acquired.
java.util.concurrent.locks.Lock.tryLock	(	long	TimeUnit	): Acquires the lock if it is free within the given waiting time and the current thread has not been interrupt interrupted. If the lock is available this method returns immediately with the value true. If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:  The lock is acquired by the current thread; or Some other thread interrupt interrupts the current thread, and interruption of lock acquisition is supported; or The specified waiting time elapses  If the lock is acquired then the value true is returned. If the current thread:  has its interrupted status set on entry to this method; or is interrupt interrupted while acquiring the lock, and interruption of lock acquisition is supported,  then InterruptedException is thrown and the current thread's interrupted status is cleared. If the specified waiting time elapses then the value false is returned. If the time is less than or equal to zero, the method will not wait at all. Implementation Considerations The ability to interrupt a lock acquisition in some implementations may not be possible, and if possible may be an expensive operation. The programmer should be aware that this may be the case. An implementation should document when this is the case. An implementation can favor responding to an interrupt over normal method return, or reporting a timeout. A Lock implementation may be able to detect erroneous use of the lock, such as an invocation that would cause deadlock, and may throw an (unchecked) exception in such circumstances. The circumstances and the exception type must be documented by that Lock implementation.
java.util.concurrent.locks.Lock.unlock	(	): Releases the lock. Implementation Considerations A Lock implementation will usually impose restrictions on which thread can release a lock (typically only the holder of the lock can release it) and may throw an (unchecked) exception if the restriction is violated. Any restrictions and the exception type must be documented by that Lock implementation.
java.util.concurrent.locks.LockSupport: Basic thread blocking primitives for creating locks and other synchronization classes. This class associates, with each thread that uses it, a permit (in the sense of the java.util.concurrent.Semaphore Semaphore class). A call to park will return immediately if the permit is available, consuming it in the process; otherwise it may block. A call to unpark makes the permit available, if it was not already available. (Unlike with Semaphores though, permits do not accumulate. There is at most one.) Methods park and unpark provide efficient means of blocking and unblocking threads that do not encounter the problems that cause the deprecated methods Thread.suspend and Thread.resume to be unusable for such purposes: Races between one thread invoking park and another thread trying to unpark it will preserve liveness, due to the permit. Additionally, park will return if the caller's thread was interrupted, and timeout versions are supported. The park method may also return at any other time, for "no reason", so in general must be invoked within a loop that rechecks conditions upon return. In this sense park serves as an optimization of a "busy wait" that does not waste as much time spinning, but must be paired with an unpark to be effective. The three forms of park each also support a blocker object parameter. This object is recorded while the thread is blocked to permit monitoring and diagnostic tools to identify the reasons that threads are blocked. (Such tools may access blockers using method getBlocker().) The use of these forms rather than the original forms without this parameter is strongly encouraged. The normal argument to supply as a blocker within a lock implementation is this. These methods are designed to be used as tools for creating higher-level synchronization utilities, and are not in themselves useful for most concurrency control applications. The park method is designed for use only in constructions of the form:  while (!canProceed()) { ... LockSupport.park(this); } where neither canProceed nor any other actions prior to the call to park entail locking or blocking. Because only one permit is associated with each thread, any intermediary uses of park could interfere with its intended effects. Sample Usage. Here is a sketch of a first-in-first-out non-reentrant lock class:  class FIFOMutex private final AtomicBoolean locked = new AtomicBoolean(false); private final Queue waiters = new ConcurrentLinkedQueue(); public void lock() { boolean wasInterrupted = false; Thread current = Thread.currentThread(); waiters.add(current); // Block while not first in queue or cannot acquire lock while (waiters.peek() != current || !locked.compareAndSet(false, true)) { LockSupport.park(this); if (Thread.interrupted()) // ignore interrupts while waiting wasInterrupted = true; } waiters.remove(); if (wasInterrupted) // reassert interrupt status on exit current.interrupt(); } public void unlock() { locked.set(false); LockSupport.unpark(waiters.peek()); } }}
java.util.concurrent.locks.LockSupport.getBlocker	(	Thread	): Returns the blocker object supplied to the most recent invocation of a park method that has not yet unblocked, or null if not blocked. The value returned is just a momentary snapshot -- the thread may have since unblocked or blocked on a different blocker object.
java.util.concurrent.locks.LockSupport.nextSecondarySeed	(	): Returns the pseudo-randomly initialized or updated secondary seed. Copied from ThreadLocalRandom due to package access restrictions.
java.util.concurrent.locks.LockSupport.park	(	): Disables the current thread for thread scheduling purposes unless the permit is available. If the permit is available then it is consumed and the call returns immediately; otherwise the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:  Some other thread invokes unpark with the current thread as the target; or Some other thread interrupt interrupts the current thread; or The call spuriously (that is, for no reason) returns.  This method does not report which of these caused the method to return. Callers should re-check the conditions which caused the thread to park in the first place. Callers may also determine, for example, the interrupt status of the thread upon return.
java.util.concurrent.locks.LockSupport.park	(	Object	): Disables the current thread for thread scheduling purposes unless the permit is available. If the permit is available then it is consumed and the call returns immediately; otherwise the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:  Some other thread invokes unpark with the current thread as the target; or Some other thread interrupt interrupts the current thread; or The call spuriously (that is, for no reason) returns.  This method does not report which of these caused the method to return. Callers should re-check the conditions which caused the thread to park in the first place. Callers may also determine, for example, the interrupt status of the thread upon return.
java.util.concurrent.locks.LockSupport.parkNanos	(	Object	long	): Disables the current thread for thread scheduling purposes, for up to the specified waiting time, unless the permit is available. If the permit is available then it is consumed and the call returns immediately; otherwise the current thread becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:  Some other thread invokes unpark with the current thread as the target; or Some other thread interrupt interrupts the current thread; or The specified waiting time elapses; or The call spuriously (that is, for no reason) returns.  This method does not report which of these caused the method to return. Callers should re-check the conditions which caused the thread to park in the first place. Callers may also determine, for example, the interrupt status of the thread, or the elapsed time upon return.
java.util.concurrent.locks.LockSupport.parkNanos	(	long	): Disables the current thread for thread scheduling purposes, for up to the specified waiting time, unless the permit is available. If the permit is available then it is consumed and the call returns immediately; otherwise the current thread becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:  Some other thread invokes unpark with the current thread as the target; or Some other thread interrupt interrupts the current thread; or The specified waiting time elapses; or The call spuriously (that is, for no reason) returns.  This method does not report which of these caused the method to return. Callers should re-check the conditions which caused the thread to park in the first place. Callers may also determine, for example, the interrupt status of the thread, or the elapsed time upon return.
java.util.concurrent.locks.LockSupport.parkUntil	(	Object	long	): Disables the current thread for thread scheduling purposes, until the specified deadline, unless the permit is available. If the permit is available then it is consumed and the call returns immediately; otherwise the current thread becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:  Some other thread invokes unpark with the current thread as the target; or Some other thread interrupt interrupts the current thread; or The specified deadline passes; or The call spuriously (that is, for no reason) returns.  This method does not report which of these caused the method to return. Callers should re-check the conditions which caused the thread to park in the first place. Callers may also determine, for example, the interrupt status of the thread, or the current time upon return.
java.util.concurrent.locks.LockSupport.parkUntil	(	long	): Disables the current thread for thread scheduling purposes, until the specified deadline, unless the permit is available. If the permit is available then it is consumed and the call returns immediately; otherwise the current thread becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:  Some other thread invokes unpark with the current thread as the target; or Some other thread interrupt interrupts the current thread; or The specified deadline passes; or The call spuriously (that is, for no reason) returns.  This method does not report which of these caused the method to return. Callers should re-check the conditions which caused the thread to park in the first place. Callers may also determine, for example, the interrupt status of the thread, or the current time upon return.
java.util.concurrent.locks.LockSupport.unpark	(	Thread	): Makes available the permit for the given thread, if it was not already available. If the thread was blocked on park then it will unblock. Otherwise, its next call to park is guaranteed not to block. This operation is not guaranteed to have any effect at all if the given thread has not been started.
java.util.concurrent.locks.ReadWriteLock: A ReadWriteLock maintains a pair of associated Lock locks, one for read-only operations and one for writing. The readLock read lock may be held simultaneously by multiple reader threads, so long as there are no writers. The writeLock write lock is exclusive. All ReadWriteLock implementations must guarantee that the memory synchronization effects of writeLock operations (as specified in the Lock interface) also hold with respect to the associated readLock. That is, a thread successfully acquiring the read lock will see all updates made upon previous release of the write lock. A read-write lock allows for a greater level of concurrency in accessing shared data than that permitted by a mutual exclusion lock. It exploits the fact that while only a single thread at a time (a writer thread) can modify the shared data, in many cases any number of threads can concurrently read the data (hence reader threads). In theory, the increase in concurrency permitted by the use of a read-write lock will lead to performance improvements over the use of a mutual exclusion lock. In practice this increase in concurrency will only be fully realized on a multi-processor, and then only if the access patterns for the shared data are suitable. Whether or not a read-write lock will improve performance over the use of a mutual exclusion lock depends on the frequency that the data is read compared to being modified, the duration of the read and write operations, and the contention for the data - that is, the number of threads that will try to read or write the data at the same time. For example, a collection that is initially populated with data and thereafter infrequently modified, while being frequently searched (such as a directory of some kind) is an ideal candidate for the use of a read-write lock. However, if updates become frequent then the data spends most of its time being exclusively locked and there is little, if any increase in concurrency. Further, if the read operations are too short the overhead of the read-write lock implementation (which is inherently more complex than a mutual exclusion lock) can dominate the execution cost, particularly as many read-write lock implementations still serialize all threads through a small section of code. Ultimately, only profiling and measurement will establish whether the use of a read-write lock is suitable for your application. Although the basic operation of a read-write lock is straight-forward, there are many policy decisions that an implementation must make, which may affect the effectiveness of the read-write lock in a given application. Examples of these policies include:  Determining whether to grant the read lock or the write lock, when both readers and writers are waiting, at the time that a writer releases the write lock. Writer preference is common, as writes are expected to be short and infrequent. Reader preference is less common as it can lead to lengthy delays for a write if the readers are frequent and long-lived as expected. Fair, or "in-order" implementations are also possible. Determining whether readers that request the read lock while a reader is active and a writer is waiting, are granted the read lock. Preference to the reader can delay the writer indefinitely, while preference to the writer can reduce the potential for concurrency. Determining whether the locks are reentrant: can a thread with the write lock reacquire it? Can it acquire a read lock while holding the write lock? Is the read lock itself reentrant? Can the write lock be downgraded to a read lock without allowing an intervening writer? Can a read lock be upgraded to a write lock, in preference to other waiting readers or writers?  You should consider all of these things when evaluating the suitability of a given implementation for your application.
java.util.concurrent.locks.ReadWriteLock.readLock	(	): Returns the lock used for reading.
java.util.concurrent.locks.ReadWriteLock.writeLock	(	): Returns the lock used for writing.
java.util.concurrent.locks.ReentrantLock: A reentrant mutual exclusion Lock with the same basic behavior and semantics as the implicit monitor lock accessed using synchronized methods and statements, but with extended capabilities. A ReentrantLock is owned by the thread last successfully locking, but not yet unlocking it. A thread invoking lock will return, successfully acquiring the lock, when the lock is not owned by another thread. The method will return immediately if the current thread already owns the lock. This can be checked using methods isHeldByCurrentThread, and getHoldCount. The constructor for this class accepts an optional fairness parameter. When set true, under contention, locks favor granting access to the longest-waiting thread. Otherwise this lock does not guarantee any particular access order. Programs using fair locks accessed by many threads may display lower overall throughput (i.e., are slower; often much slower) than those using the default setting, but have smaller variances in times to obtain locks and guarantee lack of starvation. Note however, that fairness of locks does not guarantee fairness of thread scheduling. Thus, one of many threads using a fair lock may obtain it multiple times in succession while other active threads are not progressing and not currently holding the lock. Also note that the untimed tryLock() method does not honor the fairness setting. It will succeed if the lock is available even if other threads are waiting. It is recommended practice to always immediately follow a call to lock with a try block, most typically in a before/after construction such as:  class X private final ReentrantLock lock = new ReentrantLock(); // ... public void m() { lock.lock(); // block until condition holds try { // ... method body } finally { lock.unlock() } } }} In addition to implementing the Lock interface, this class defines a number of public and protected methods for inspecting the state of the lock. Some of these methods are only useful for instrumentation and monitoring. Serialization of this class behaves in the same way as built-in locks: a deserialized lock is in the unlocked state, regardless of its state when serialized. This lock supports a maximum of 2147483647 recursive locks by the same thread. Attempts to exceed this limit result in Error throws from locking methods.
java.util.concurrent.locks.ReentrantLock.FairSync: Sync object for fair locks
java.util.concurrent.locks.ReentrantLock.FairSync.tryAcquire	(	int	): Fair version of tryAcquire. Don't grant access unless recursive call or no waiters or is first.
java.util.concurrent.locks.ReentrantLock.NonfairSync: Sync object for non-fair locks
java.util.concurrent.locks.ReentrantLock.NonfairSync.lock	(	): Performs lock. Try immediate barge, backing up to normal acquire on failure.
java.util.concurrent.locks.ReentrantLock.ReentrantLock	(	): Creates an instance of ReentrantLock. This is equivalent to using ReentrantLock(false).
java.util.concurrent.locks.ReentrantLock.ReentrantLock	(	boolean	): Creates an instance of ReentrantLock with the given fairness policy.
java.util.concurrent.locks.ReentrantLock.Sync: Base of synchronization control for this lock. Subclassed into fair and nonfair versions below. Uses AQS state to represent the number of holds on the lock.
java.util.concurrent.locks.ReentrantLock.Sync.lock	(	): Performs lock. The main reason for subclassing is to allow fast path for nonfair version.
java.util.concurrent.locks.ReentrantLock.Sync.nonfairTryAcquire	(	int	): Performs non-fair tryLock. tryAcquire is implemented in subclasses, but both need nonfair try for trylock method.
java.util.concurrent.locks.ReentrantLock.Sync.readObject	(	java.io.ObjectInputStream	): Reconstitutes the instance from a stream (that is, deserializes it).
java.util.concurrent.locks.ReentrantLock.getHoldCount	(	): Queries the number of holds on this lock by the current thread. A thread has a hold on a lock for each lock action that is not matched by an unlock action. The hold count information is typically only used for testing and debugging purposes. For example, if a certain section of code should not be entered with the lock already held then we can assert that fact:  class X ReentrantLock lock = new ReentrantLock(); // ... public void m() { assert lock.getHoldCount() == 0; lock.lock(); try { // ... method body } finally { lock.unlock(); } } }}
java.util.concurrent.locks.ReentrantLock.getOwner	(	): Returns the thread that currently owns this lock, or null if not owned. When this method is called by a thread that is not the owner, the return value reflects a best-effort approximation of current lock status. For example, the owner may be momentarily null even if there are threads trying to acquire the lock but have not yet done so. This method is designed to facilitate construction of subclasses that provide more extensive lock monitoring facilities.
java.util.concurrent.locks.ReentrantLock.getQueueLength	(	): Returns an estimate of the number of threads waiting to acquire this lock. The value is only an estimate because the number of threads may change dynamically while this method traverses internal data structures. This method is designed for use in monitoring of the system state, not for synchronization control.
java.util.concurrent.locks.ReentrantLock.getQueuedThreads	(	): Returns a collection containing threads that may be waiting to acquire this lock. Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate. The elements of the returned collection are in no particular order. This method is designed to facilitate construction of subclasses that provide more extensive monitoring facilities.
java.util.concurrent.locks.ReentrantLock.getWaitQueueLength	(	Condition	): Returns an estimate of the number of threads waiting on the given condition associated with this lock. Note that because timeouts and interrupts may occur at any time, the estimate serves only as an upper bound on the actual number of waiters. This method is designed for use in monitoring of the system state, not for synchronization control.
java.util.concurrent.locks.ReentrantLock.getWaitingThreads	(	Condition	): Returns a collection containing those threads that may be waiting on the given condition associated with this lock. Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate. The elements of the returned collection are in no particular order. This method is designed to facilitate construction of subclasses that provide more extensive condition monitoring facilities.
java.util.concurrent.locks.ReentrantLock.hasQueuedThread	(	Thread	): Queries whether the given thread is waiting to acquire this lock. Note that because cancellations may occur at any time, a true return does not guarantee that this thread will ever acquire this lock. This method is designed primarily for use in monitoring of the system state.
java.util.concurrent.locks.ReentrantLock.hasQueuedThreads	(	): Queries whether any threads are waiting to acquire this lock. Note that because cancellations may occur at any time, a true return does not guarantee that any other thread will ever acquire this lock. This method is designed primarily for use in monitoring of the system state.
java.util.concurrent.locks.ReentrantLock.hasWaiters	(	Condition	): Queries whether any threads are waiting on the given condition associated with this lock. Note that because timeouts and interrupts may occur at any time, a true return does not guarantee that a future signal will awaken any threads. This method is designed primarily for use in monitoring of the system state.
java.util.concurrent.locks.ReentrantLock.isFair	(	): Returns true if this lock has fairness set true.
java.util.concurrent.locks.ReentrantLock.isHeldByCurrentThread	(	): Queries if this lock is held by the current thread. Analogous to the holdsLock() method for built-in monitor locks, this method is typically used for debugging and testing. For example, a method that should only be called while a lock is held can assert that this is the case:  class X ReentrantLock lock = new ReentrantLock(); // ... public void m() { assert lock.isHeldByCurrentThread(); // ... method body } }} It can also be used to ensure that a reentrant lock is used in a non-reentrant manner, for example:  class X ReentrantLock lock = new ReentrantLock(); // ... public void m() { assert !lock.isHeldByCurrentThread(); lock.lock(); try { // ... method body } finally { lock.unlock(); } } }}
java.util.concurrent.locks.ReentrantLock.isLocked	(	): Queries if this lock is held by any thread. This method is designed for use in monitoring of the system state, not for synchronization control.
java.util.concurrent.locks.ReentrantLock.lock	(	): Acquires the lock. Acquires the lock if it is not held by another thread and returns immediately, setting the lock hold count to one. If the current thread already holds the lock then the hold count is incremented by one and the method returns immediately. If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired, at which time the lock hold count is set to one.
java.util.concurrent.locks.ReentrantLock.lockInterruptibly	(	): Acquires the lock unless the current thread is interrupt interrupted. Acquires the lock if it is not held by another thread and returns immediately, setting the lock hold count to one. If the current thread already holds this lock then the hold count is incremented by one and the method returns immediately. If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:  The lock is acquired by the current thread; or Some other thread interrupt interrupts the current thread.  If the lock is acquired by the current thread then the lock hold count is set to one. If the current thread:  has its interrupted status set on entry to this method; or is interrupt interrupted while acquiring the lock,  then InterruptedException is thrown and the current thread's interrupted status is cleared. In this implementation, as this method is an explicit interruption point, preference is given to responding to the interrupt over normal or reentrant acquisition of the lock.
java.util.concurrent.locks.ReentrantLock.newCondition	(	): Returns a Condition instance for use with this Lock instance. The returned Condition instance supports the same usages as do the Object monitor methods (wait(), notify, and notifyAll) when used with the built-in monitor lock.  If this lock is not held when any of the Condition await() waiting or signal signalling methods are called, then an IllegalMonitorStateException is thrown. When the condition await() waiting methods are called the lock is released and, before they return, the lock is reacquired and the lock hold count restored to what it was when the method was called. If a thread is interrupt interrupted while waiting then the wait will terminate, an InterruptedException will be thrown, and the thread's interrupted status will be cleared.  Waiting threads are signalled in FIFO order. The ordering of lock reacquisition for threads returning from waiting methods is the same as for threads initially acquiring the lock, which is in the default case not specified, but for fair locks favors those threads that have been waiting the longest. 
java.util.concurrent.locks.ReentrantLock.toString	(	): Returns a string identifying this lock, as well as its lock state. The state, in brackets, includes either the String "Unlocked" or the String "Locked by" followed by the getName name of the owning thread.
java.util.concurrent.locks.ReentrantLock.tryLock	(	): Acquires the lock only if it is not held by another thread at the time of invocation. Acquires the lock if it is not held by another thread and returns immediately with the value true, setting the lock hold count to one. Even when this lock has been set to use a fair ordering policy, a call to tryLock() will immediately acquire the lock if it is available, whether or not other threads are currently waiting for the lock. This "barging" behavior can be useful in certain circumstances, even though it breaks fairness. If you want to honor the fairness setting for this lock, then use tryLock() tryLock(0, TimeUnit.SECONDS) which is almost equivalent (it also detects interruption). If the current thread already holds this lock then the hold count is incremented by one and the method returns true. If the lock is held by another thread then this method will return immediately with the value false.
java.util.concurrent.locks.ReentrantLock.tryLock	(	long	TimeUnit	): Acquires the lock if it is not held by another thread within the given waiting time and the current thread has not been interrupt interrupted. Acquires the lock if it is not held by another thread and returns immediately with the value true, setting the lock hold count to one. If this lock has been set to use a fair ordering policy then an available lock will not be acquired if any other threads are waiting for the lock. This is in contrast to the tryLock() method. If you want a timed tryLock that does permit barging on a fair lock then combine the timed and un-timed forms together:  if (lock.tryLock() || lock.tryLock(timeout, unit)) ... }} If the current thread already holds this lock then the hold count is incremented by one and the method returns true. If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:  The lock is acquired by the current thread; or Some other thread interrupt interrupts the current thread; or The specified waiting time elapses  If the lock is acquired then the value true is returned and the lock hold count is set to one. If the current thread:  has its interrupted status set on entry to this method; or is interrupt interrupted while acquiring the lock,  then InterruptedException is thrown and the current thread's interrupted status is cleared. If the specified waiting time elapses then the value false is returned. If the time is less than or equal to zero, the method will not wait at all. In this implementation, as this method is an explicit interruption point, preference is given to responding to the interrupt over normal or reentrant acquisition of the lock, and over reporting the elapse of the waiting time.
java.util.concurrent.locks.ReentrantLock.unlock	(	): Attempts to release this lock. If the current thread is the holder of this lock then the hold count is decremented. If the hold count is now zero then the lock is released. If the current thread is not the holder of this lock then IllegalMonitorStateException is thrown.
java.util.concurrent.locks.ReentrantReadWriteLock: An implementation of ReadWriteLock supporting similar semantics to ReentrantLock. This class has the following properties:  Acquisition order This class does not impose a reader or writer preference ordering for lock access. However, it does support an optional fairness policy.  Non-fair mode (default) When constructed as non-fair (the default), the order of entry to the read and write lock is unspecified, subject to reentrancy constraints. A nonfair lock that is continuously contended may indefinitely postpone one or more reader or writer threads, but will normally have higher throughput than a fair lock. Fair mode When constructed as fair, threads contend for entry using an approximately arrival-order policy. When the currently held lock is released, either the longest-waiting single writer thread will be assigned the write lock, or if there is a group of reader threads waiting longer than all waiting writer threads, that group will be assigned the read lock. A thread that tries to acquire a fair read lock (non-reentrantly) will block if either the write lock is held, or there is a waiting writer thread. The thread will not acquire the read lock until after the oldest currently waiting writer thread has acquired and released the write lock. Of course, if a waiting writer abandons its wait, leaving one or more reader threads as the longest waiters in the queue with the write lock free, then those readers will be assigned the read lock. A thread that tries to acquire a fair write lock (non-reentrantly) will block unless both the read lock and write lock are free (which implies there are no waiting threads). (Note that the non-blocking tryLock() and tryLock() methods do not honor this fair setting and will immediately acquire the lock if it is possible, regardless of waiting threads.)   Reentrancy This lock allows both readers and writers to reacquire read or write locks in the style of a ReentrantLock. Non-reentrant readers are not allowed until all write locks held by the writing thread have been released. Additionally, a writer can acquire the read lock, but not vice-versa. Among other applications, reentrancy can be useful when write locks are held during calls or callbacks to methods that perform reads under read locks. If a reader tries to acquire the write lock it will never succeed. Lock downgrading Reentrancy also allows downgrading from the write lock to a read lock, by acquiring the write lock, then the read lock and then releasing the write lock. However, upgrading from a read lock to the write lock is not possible. Interruption of lock acquisition The read lock and write lock both support interruption during lock acquisition. Condition support The write lock provides a Condition implementation that behaves in the same way, with respect to the write lock, as the Condition implementation provided by newCondition does for ReentrantLock. This Condition can, of course, only be used with the write lock. The read lock does not support a Condition and readLock().newCondition() throws UnsupportedOperationException. Instrumentation This class supports methods to determine whether locks are held or contended. These methods are designed for monitoring system state, not for synchronization control.  Serialization of this class behaves in the same way as built-in locks: a deserialized lock is in the unlocked state, regardless of its state when serialized. Sample usages. Here is a code sketch showing how to perform lock downgrading after updating a cache (exception handling is particularly tricky when handling multiple locks in a non-nested fashion):  class CachedData Object data; volatile boolean cacheValid; final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); void processCachedData() { rwl.readLock().lock(); if (!cacheValid) { // Must release read lock before acquiring write lock rwl.readLock().unlock(); rwl.writeLock().lock(); try { // Recheck state because another thread might have // acquired write lock and changed state before we did. if (!cacheValid) { data = ... cacheValid = true; } // Downgrade by acquiring read lock before releasing write lock rwl.readLock().lock(); } finally { rwl.writeLock().unlock(); // Unlock write, still hold read } } try { use(data); } finally { rwl.readLock().unlock(); } } }} ReentrantReadWriteLocks can be used to improve concurrency in some uses of some kinds of Collections. This is typically worthwhile only when the collections are expected to be large, accessed by more reader threads than writer threads, and entail operations with overhead that outweighs synchronization overhead. For example, here is a class using a TreeMap that is expected to be large and concurrently accessed.  class RWDictionary private final Map m = new TreeMap(); private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); private final Lock r = rwl.readLock(); private final Lock w = rwl.writeLock(); public Data get(String key) { r.lock(); try { return m.get(key); } finally { r.unlock(); } } public String[] allKeys() { r.lock(); try { return m.keySet().toArray(); } finally { r.unlock(); } } public Data put(String key, Data value) { w.lock(); try { return m.put(key, value); } finally { w.unlock(); } } public void clear() { w.lock(); try { m.clear(); } finally { w.unlock(); } } }} Implementation Notes This lock supports a maximum of 65535 recursive write locks and 65535 read locks. Attempts to exceed these limits result in Error throws from locking methods.
java.util.concurrent.locks.ReentrantReadWriteLock.FairSync: Fair version of Sync
java.util.concurrent.locks.ReentrantReadWriteLock.NonfairSync: Nonfair version of Sync
java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock: The lock returned by method readLock.
java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock.ReadLock	(	ReentrantReadWriteLock	): Constructor for use by subclasses
java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock.lock	(	): Acquires the read lock. Acquires the read lock if the write lock is not held by another thread and returns immediately. If the write lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until the read lock has been acquired.
java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock.lockInterruptibly	(	): Acquires the read lock unless the current thread is interrupt interrupted. Acquires the read lock if the write lock is not held by another thread and returns immediately. If the write lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:  The read lock is acquired by the current thread; or Some other thread interrupt interrupts the current thread.  If the current thread:  has its interrupted status set on entry to this method; or is interrupt interrupted while acquiring the read lock,  then InterruptedException is thrown and the current thread's interrupted status is cleared. In this implementation, as this method is an explicit interruption point, preference is given to responding to the interrupt over normal or reentrant acquisition of the lock.
java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock.newCondition	(	): Throws UnsupportedOperationException because ReadLocks do not support conditions.
java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock.toString	(	): Returns a string identifying this lock, as well as its lock state. The state, in brackets, includes the String "Read locks =" followed by the number of held read locks.
java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock.tryLock	(	): Acquires the read lock only if the write lock is not held by another thread at the time of invocation. Acquires the read lock if the write lock is not held by another thread and returns immediately with the value true. Even when this lock has been set to use a fair ordering policy, a call to tryLock() will immediately acquire the read lock if it is available, whether or not other threads are currently waiting for the read lock. This "barging" behavior can be useful in certain circumstances, even though it breaks fairness. If you want to honor the fairness setting for this lock, then use tryLock() tryLock(0, TimeUnit.SECONDS) which is almost equivalent (it also detects interruption). If the write lock is held by another thread then this method will return immediately with the value false.
java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock.tryLock	(	long	TimeUnit	): Acquires the read lock if the write lock is not held by another thread within the given waiting time and the current thread has not been interrupt interrupted. Acquires the read lock if the write lock is not held by another thread and returns immediately with the value true. If this lock has been set to use a fair ordering policy then an available lock will not be acquired if any other threads are waiting for the lock. This is in contrast to the tryLock() method. If you want a timed tryLock that does permit barging on a fair lock then combine the timed and un-timed forms together:  if (lock.tryLock() || lock.tryLock(timeout, unit)) ... }} If the write lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:  The read lock is acquired by the current thread; or Some other thread interrupt interrupts the current thread; or The specified waiting time elapses.  If the read lock is acquired then the value true is returned. If the current thread:  has its interrupted status set on entry to this method; or is interrupt interrupted while acquiring the read lock,  then InterruptedException is thrown and the current thread's interrupted status is cleared. If the specified waiting time elapses then the value false is returned. If the time is less than or equal to zero, the method will not wait at all. In this implementation, as this method is an explicit interruption point, preference is given to responding to the interrupt over normal or reentrant acquisition of the lock, and over reporting the elapse of the waiting time.
java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock.unlock	(	): Attempts to release this lock. If the number of readers is now zero then the lock is made available for write lock attempts.
java.util.concurrent.locks.ReentrantReadWriteLock.ReentrantReadWriteLock	(	): Creates a new ReentrantReadWriteLock with default (nonfair) ordering properties.
java.util.concurrent.locks.ReentrantReadWriteLock.ReentrantReadWriteLock	(	boolean	): Creates a new ReentrantReadWriteLock with the given fairness policy.
java.util.concurrent.locks.ReentrantReadWriteLock.Sync: Synchronization implementation for ReentrantReadWriteLock. Subclassed into fair and nonfair versions.
java.util.concurrent.locks.ReentrantReadWriteLock.Sync.HoldCounter: A counter for per-thread read hold counts. Maintained as a ThreadLocal; cached in cachedHoldCounter
java.util.concurrent.locks.ReentrantReadWriteLock.Sync.ThreadLocalHoldCounter: ThreadLocal subclass. Easiest to explicitly define for sake of deserialization mechanics.
java.util.concurrent.locks.ReentrantReadWriteLock.Sync.exclusiveCount	(	int	): Returns the number of exclusive holds represented in count 
java.util.concurrent.locks.ReentrantReadWriteLock.Sync.fullTryAcquireShared	(	Thread	): Full version of acquire for reads, that handles CAS misses and reentrant reads not dealt with in tryAcquireShared.
java.util.concurrent.locks.ReentrantReadWriteLock.Sync.readObject	(	java.io.ObjectInputStream	): Reconstitutes the instance from a stream (that is, deserializes it).
java.util.concurrent.locks.ReentrantReadWriteLock.Sync.readerShouldBlock	(	): Returns true if the current thread, when trying to acquire the read lock, and otherwise eligible to do so, should block because of policy for overtaking other waiting threads.
java.util.concurrent.locks.ReentrantReadWriteLock.Sync.sharedCount	(	int	): Returns the number of shared holds represented in count 
java.util.concurrent.locks.ReentrantReadWriteLock.Sync.tryReadLock	(	): Performs tryLock for read, enabling barging in both modes. This is identical in effect to tryAcquireShared except for lack of calls to readerShouldBlock.
java.util.concurrent.locks.ReentrantReadWriteLock.Sync.tryWriteLock	(	): Performs tryLock for write, enabling barging in both modes. This is identical in effect to tryAcquire except for lack of calls to writerShouldBlock.
java.util.concurrent.locks.ReentrantReadWriteLock.Sync.writerShouldBlock	(	): Returns true if the current thread, when trying to acquire the write lock, and otherwise eligible to do so, should block because of policy for overtaking other waiting threads.
java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock: The lock returned by method writeLock.
java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock.WriteLock	(	ReentrantReadWriteLock	): Constructor for use by subclasses
java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock.getHoldCount	(	): Queries the number of holds on this write lock by the current thread. A thread has a hold on a lock for each lock action that is not matched by an unlock action. Identical in effect to getWriteHoldCount.
java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock.isHeldByCurrentThread	(	): Queries if this write lock is held by the current thread. Identical in effect to isWriteLockedByCurrentThread.
java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock.lock	(	): Acquires the write lock. Acquires the write lock if neither the read nor write lock are held by another thread and returns immediately, setting the write lock hold count to one. If the current thread already holds the write lock then the hold count is incremented by one and the method returns immediately. If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until the write lock has been acquired, at which time the write lock hold count is set to one.
java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock.lockInterruptibly	(	): Acquires the write lock unless the current thread is interrupt interrupted. Acquires the write lock if neither the read nor write lock are held by another thread and returns immediately, setting the write lock hold count to one. If the current thread already holds this lock then the hold count is incremented by one and the method returns immediately. If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens:  The write lock is acquired by the current thread; or Some other thread interrupt interrupts the current thread.  If the write lock is acquired by the current thread then the lock hold count is set to one. If the current thread:  has its interrupted status set on entry to this method; or is interrupt interrupted while acquiring the write lock,  then InterruptedException is thrown and the current thread's interrupted status is cleared. In this implementation, as this method is an explicit interruption point, preference is given to responding to the interrupt over normal or reentrant acquisition of the lock.
java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock.newCondition	(	): Returns a Condition instance for use with this Lock instance. The returned Condition instance supports the same usages as do the Object monitor methods (wait(), notify, and notifyAll) when used with the built-in monitor lock.  If this write lock is not held when any Condition method is called then an IllegalMonitorStateException is thrown. (Read locks are held independently of write locks, so are not checked or affected. However it is essentially always an error to invoke a condition waiting method when the current thread has also acquired read locks, since other threads that could unblock it will not be able to acquire the write lock.) When the condition await() waiting methods are called the write lock is released and, before they return, the write lock is reacquired and the lock hold count restored to what it was when the method was called. If a thread is interrupt interrupted while waiting then the wait will terminate, an InterruptedException will be thrown, and the thread's interrupted status will be cleared.  Waiting threads are signalled in FIFO order. The ordering of lock reacquisition for threads returning from waiting methods is the same as for threads initially acquiring the lock, which is in the default case not specified, but for fair locks favors those threads that have been waiting the longest. 
java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock.toString	(	): Returns a string identifying this lock, as well as its lock state. The state, in brackets includes either the String "Unlocked" or the String "Locked by" followed by the getName name of the owning thread.
java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock.tryLock	(	): Acquires the write lock only if it is not held by another thread at the time of invocation. Acquires the write lock if neither the read nor write lock are held by another thread and returns immediately with the value true, setting the write lock hold count to one. Even when this lock has been set to use a fair ordering policy, a call to tryLock() will immediately acquire the lock if it is available, whether or not other threads are currently waiting for the write lock. This "barging" behavior can be useful in certain circumstances, even though it breaks fairness. If you want to honor the fairness setting for this lock, then use tryLock() tryLock(0, TimeUnit.SECONDS) which is almost equivalent (it also detects interruption). If the current thread already holds this lock then the hold count is incremented by one and the method returns true. If the lock is held by another thread then this method will return immediately with the value false.
java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock.tryLock	(	long	TimeUnit	): Acquires the write lock if it is not held by another thread within the given waiting time and the current thread has not been interrupt interrupted. Acquires the write lock if neither the read nor write lock are held by another thread and returns immediately with the value true, setting the write lock hold count to one. If this lock has been set to use a fair ordering policy then an available lock will not be acquired if any other threads are waiting for the write lock. This is in contrast to the tryLock() method. If you want a timed tryLock that does permit barging on a fair lock then combine the timed and un-timed forms together:  if (lock.tryLock() || lock.tryLock(timeout, unit)) ... }} If the current thread already holds this lock then the hold count is incremented by one and the method returns true. If the lock is held by another thread then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of three things happens:  The write lock is acquired by the current thread; or Some other thread interrupt interrupts the current thread; or The specified waiting time elapses  If the write lock is acquired then the value true is returned and the write lock hold count is set to one. If the current thread:  has its interrupted status set on entry to this method; or is interrupt interrupted while acquiring the write lock,  then InterruptedException is thrown and the current thread's interrupted status is cleared. If the specified waiting time elapses then the value false is returned. If the time is less than or equal to zero, the method will not wait at all. In this implementation, as this method is an explicit interruption point, preference is given to responding to the interrupt over normal or reentrant acquisition of the lock, and over reporting the elapse of the waiting time.
java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock.unlock	(	): Attempts to release this lock. If the current thread is the holder of this lock then the hold count is decremented. If the hold count is now zero then the lock is released. If the current thread is not the holder of this lock then IllegalMonitorStateException is thrown.
java.util.concurrent.locks.ReentrantReadWriteLock.getOwner	(	): Returns the thread that currently owns the write lock, or null if not owned. When this method is called by a thread that is not the owner, the return value reflects a best-effort approximation of current lock status. For example, the owner may be momentarily null even if there are threads trying to acquire the lock but have not yet done so. This method is designed to facilitate construction of subclasses that provide more extensive lock monitoring facilities.
java.util.concurrent.locks.ReentrantReadWriteLock.getQueueLength	(	): Returns an estimate of the number of threads waiting to acquire either the read or write lock. The value is only an estimate because the number of threads may change dynamically while this method traverses internal data structures. This method is designed for use in monitoring of the system state, not for synchronization control.
java.util.concurrent.locks.ReentrantReadWriteLock.getQueuedReaderThreads	(	): Returns a collection containing threads that may be waiting to acquire the read lock. Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate. The elements of the returned collection are in no particular order. This method is designed to facilitate construction of subclasses that provide more extensive lock monitoring facilities.
java.util.concurrent.locks.ReentrantReadWriteLock.getQueuedThreads	(	): Returns a collection containing threads that may be waiting to acquire either the read or write lock. Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate. The elements of the returned collection are in no particular order. This method is designed to facilitate construction of subclasses that provide more extensive monitoring facilities.
java.util.concurrent.locks.ReentrantReadWriteLock.getQueuedWriterThreads	(	): Returns a collection containing threads that may be waiting to acquire the write lock. Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate. The elements of the returned collection are in no particular order. This method is designed to facilitate construction of subclasses that provide more extensive lock monitoring facilities.
java.util.concurrent.locks.ReentrantReadWriteLock.getReadHoldCount	(	): Queries the number of reentrant read holds on this lock by the current thread. A reader thread has a hold on a lock for each lock action that is not matched by an unlock action.
java.util.concurrent.locks.ReentrantReadWriteLock.getReadLockCount	(	): Queries the number of read locks held for this lock. This method is designed for use in monitoring system state, not for synchronization control.
java.util.concurrent.locks.ReentrantReadWriteLock.getThreadId	(	Thread	): Returns the thread id for the given thread. We must access this directly rather than via method Thread.getId() because getId() is not final, and has been known to be overridden in ways that do not preserve unique mappings.
java.util.concurrent.locks.ReentrantReadWriteLock.getWaitQueueLength	(	Condition	): Returns an estimate of the number of threads waiting on the given condition associated with the write lock. Note that because timeouts and interrupts may occur at any time, the estimate serves only as an upper bound on the actual number of waiters. This method is designed for use in monitoring of the system state, not for synchronization control.
java.util.concurrent.locks.ReentrantReadWriteLock.getWaitingThreads	(	Condition	): Returns a collection containing those threads that may be waiting on the given condition associated with the write lock. Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate. The elements of the returned collection are in no particular order. This method is designed to facilitate construction of subclasses that provide more extensive condition monitoring facilities.
java.util.concurrent.locks.ReentrantReadWriteLock.getWriteHoldCount	(	): Queries the number of reentrant write holds on this lock by the current thread. A writer thread has a hold on a lock for each lock action that is not matched by an unlock action.
java.util.concurrent.locks.ReentrantReadWriteLock.hasQueuedThread	(	Thread	): Queries whether the given thread is waiting to acquire either the read or write lock. Note that because cancellations may occur at any time, a true return does not guarantee that this thread will ever acquire a lock. This method is designed primarily for use in monitoring of the system state.
java.util.concurrent.locks.ReentrantReadWriteLock.hasQueuedThreads	(	): Queries whether any threads are waiting to acquire the read or write lock. Note that because cancellations may occur at any time, a true return does not guarantee that any other thread will ever acquire a lock. This method is designed primarily for use in monitoring of the system state.
java.util.concurrent.locks.ReentrantReadWriteLock.hasWaiters	(	Condition	): Queries whether any threads are waiting on the given condition associated with the write lock. Note that because timeouts and interrupts may occur at any time, a true return does not guarantee that a future signal will awaken any threads. This method is designed primarily for use in monitoring of the system state.
java.util.concurrent.locks.ReentrantReadWriteLock.isFair	(	): Returns true if this lock has fairness set true.
java.util.concurrent.locks.ReentrantReadWriteLock.isWriteLocked	(	): Queries if the write lock is held by any thread. This method is designed for use in monitoring system state, not for synchronization control.
java.util.concurrent.locks.ReentrantReadWriteLock.isWriteLockedByCurrentThread	(	): Queries if the write lock is held by the current thread.
java.util.concurrent.locks.ReentrantReadWriteLock.toString	(	): Returns a string identifying this lock, as well as its lock state. The state, in brackets, includes the String "Write locks =" followed by the number of reentrantly held write locks, and the String "Read locks =" followed by the number of held read locks.
java.util.concurrent.locks.StampedLock: A capability-based lock with three modes for controlling read/write access. The state of a StampedLock consists of a version and mode. Lock acquisition methods return a stamp that represents and controls access with respect to a lock state; "try" versions of these methods may instead return the special value zero to represent failure to acquire access. Lock release and conversion methods require stamps as arguments, and fail if they do not match the state of the lock. The three modes are:  Writing. Method writeLock possibly blocks waiting for exclusive access, returning a stamp that can be used in method unlockWrite to release the lock. Untimed and timed versions of tryWriteLock are also provided. When the lock is held in write mode, no read locks may be obtained, and all optimistic read validations will fail.  Reading. Method readLock possibly blocks waiting for non-exclusive access, returning a stamp that can be used in method unlockRead to release the lock. Untimed and timed versions of tryReadLock are also provided.  Optimistic Reading. Method tryOptimisticRead returns a non-zero stamp only if the lock is not currently held in write mode. Method validate returns true if the lock has not been acquired in write mode since obtaining a given stamp. This mode can be thought of as an extremely weak version of a read-lock, that can be broken by a writer at any time. The use of optimistic mode for short read-only code segments often reduces contention and improves throughput. However, its use is inherently fragile. Optimistic read sections should only read fields and hold them in local variables for later use after validation. Fields read while in optimistic mode may be wildly inconsistent, so usage applies only when you are familiar enough with data representations to check consistency and/or repeatedly invoke method validate(). For example, such steps are typically required when first reading an object or array reference, and then accessing one of its fields, elements or methods.   This class also supports methods that conditionally provide conversions across the three modes. For example, method tryConvertToWriteLock attempts to "upgrade" a mode, returning a valid write stamp if (1) already in writing mode (2) in reading mode and there are no other readers or (3) in optimistic mode and the lock is available. The forms of these methods are designed to help reduce some of the code bloat that otherwise occurs in retry-based designs. StampedLocks are designed for use as internal utilities in the development of thread-safe components. Their use relies on knowledge of the internal properties of the data, objects, and methods they are protecting. They are not reentrant, so locked bodies should not call other unknown methods that may try to re-acquire locks (although you may pass a stamp to other methods that can use or convert it). The use of read lock modes relies on the associated code sections being side-effect-free. Unvalidated optimistic read sections cannot call methods that are not known to tolerate potential inconsistencies. Stamps use finite representations, and are not cryptographically secure (i.e., a valid stamp may be guessable). Stamp values may recycle after (no sooner than) one year of continuous operation. A stamp held without use or validation for longer than this period may fail to validate correctly. StampedLocks are serializable, but always deserialize into initial unlocked state, so they are not useful for remote locking. The scheduling policy of StampedLock does not consistently prefer readers over writers or vice versa. All "try" methods are best-effort and do not necessarily conform to any scheduling or fairness policy. A zero return from any "try" method for acquiring or converting locks does not carry any information about the state of the lock; a subsequent invocation may succeed. Because it supports coordinated usage across multiple lock modes, this class does not directly implement the Lock or ReadWriteLock interfaces. However, a StampedLock may be viewed asReadLock(), asWriteLock(), or asReadWriteLock() in applications requiring only the associated set of functionality. Sample Usage. The following illustrates some usage idioms in a class that maintains simple two-dimensional points. The sample code illustrates some try/catch conventions even though they are not strictly needed here because no exceptions can occur in their bodies. class Point private double x, y; private final StampedLock sl = new StampedLock(); void move(double deltaX, double deltaY) { // an exclusively locked method long stamp = sl.writeLock(); try { x += deltaX; y += deltaY; } finally { sl.unlockWrite(stamp); } } double distanceFromOrigin() { // A read-only method long stamp = sl.tryOptimisticRead(); double currentX = x, currentY = y; if (!sl.validate(stamp)) { stamp = sl.readLock(); try { currentX = x; currentY = y; } finally { sl.unlockRead(stamp); } } return Math.sqrt(currentX * currentX + currentY * currentY); } void moveIfAtOrigin(double newX, double newY) { // upgrade // Could instead start with optimistic, not read mode long stamp = sl.readLock(); try { while (x == 0.0 && y == 0.0) { long ws = sl.tryConvertToWriteLock(stamp); if (ws != 0L) { stamp = ws; x = newX; y = newY; break; } else { sl.unlockRead(stamp); stamp = sl.writeLock(); } } } finally { sl.unlock(stamp); } } }}
java.util.concurrent.locks.StampedLock.StampedLock	(	): Creates a new lock, initially in unlocked state.
java.util.concurrent.locks.StampedLock.WNode: Wait nodes 
java.util.concurrent.locks.StampedLock.acquireRead	(	boolean	long	): See above for explanation.
java.util.concurrent.locks.StampedLock.acquireWrite	(	boolean	long	): See above for explanation.
java.util.concurrent.locks.StampedLock.asReadLock	(	): Returns a plain Lock view of this StampedLock in which the lock method is mapped to readLock, and similarly for other methods. The returned Lock does not support a Condition; method newCondition() throws UnsupportedOperationException.
java.util.concurrent.locks.StampedLock.asReadWriteLock	(	): Returns a ReadWriteLock view of this StampedLock in which the readLock() method is mapped to asReadLock(), and writeLock() to asWriteLock().
java.util.concurrent.locks.StampedLock.asWriteLock	(	): Returns a plain Lock view of this StampedLock in which the lock method is mapped to writeLock, and similarly for other methods. The returned Lock does not support a Condition; method newCondition() throws UnsupportedOperationException.
java.util.concurrent.locks.StampedLock.cancelWaiter	(	WNode	WNode	boolean	): If node non-null, forces cancel status and unsplices it from queue if possible and wakes up any cowaiters (of the node, or group, as applicable), and in any case helps release current first waiter if lock is free. (Calling with null arguments serves as a conditional form of release, which is not currently needed but may be needed under possible future cancellation policies). This is a variant of cancellation methods in AbstractQueuedSynchronizer (see its detailed explanation in AQS internal documentation).
java.util.concurrent.locks.StampedLock.getReadLockCount	(	): Queries the number of read locks held for this lock. This method is designed for use in monitoring system state, not for synchronization control.
java.util.concurrent.locks.StampedLock.getReadLockCount	(	long	): Returns combined state-held and overflow read count for given state s.
java.util.concurrent.locks.StampedLock.isReadLocked	(	): Returns true if the lock is currently held non-exclusively.
java.util.concurrent.locks.StampedLock.isWriteLocked	(	): Returns true if the lock is currently held exclusively.
java.util.concurrent.locks.StampedLock.readLock	(	): Non-exclusively acquires the lock, blocking if necessary until available.
java.util.concurrent.locks.StampedLock.readLockInterruptibly	(	): Non-exclusively acquires the lock, blocking if necessary until available or the current thread is interrupted. Behavior under interruption matches that specified for method lockInterruptibly().
java.util.concurrent.locks.StampedLock.release	(	WNode	): Wakes up the successor of h (normally whead). This is normally just h.next, but may require traversal from wtail if next pointers are lagging. This may fail to wake up an acquiring thread when one or more have been cancelled, but the cancel methods themselves provide extra safeguards to ensure liveness.
java.util.concurrent.locks.StampedLock.toString	(	): Returns a string identifying this lock, as well as its lock state. The state, in brackets, includes the String "Unlocked" or the String "Write-locked" or the String "Read-locks:" followed by the current number of read-locks held.
java.util.concurrent.locks.StampedLock.tryConvertToOptimisticRead	(	long	): If the lock state matches the given stamp then, if the stamp represents holding a lock, releases it and returns an observation stamp. Or, if an optimistic read, returns it if validated. This method returns zero in all other cases, and so may be useful as a form of "tryUnlock".
java.util.concurrent.locks.StampedLock.tryConvertToReadLock	(	long	): If the lock state matches the given stamp, performs one of the following actions. If the stamp represents holding a write lock, releases it and obtains a read lock. Or, if a read lock, returns it. Or, if an optimistic read, acquires a read lock and returns a read stamp only if immediately available. This method returns zero in all other cases.
java.util.concurrent.locks.StampedLock.tryConvertToWriteLock	(	long	): If the lock state matches the given stamp, performs one of the following actions. If the stamp represents holding a write lock, returns it. Or, if a read lock, if the write lock is available, releases the read lock and returns a write stamp. Or, if an optimistic read, returns a write stamp only if immediately available. This method returns zero in all other cases.
java.util.concurrent.locks.StampedLock.tryDecReaderOverflow	(	long	): Tries to decrement readerOverflow.
java.util.concurrent.locks.StampedLock.tryIncReaderOverflow	(	long	): Tries to increment readerOverflow by first setting state access bits value to RBITS, indicating hold of spinlock, then updating, then releasing.
java.util.concurrent.locks.StampedLock.tryOptimisticRead	(	): Returns a stamp that can later be validated, or zero if exclusively locked.
java.util.concurrent.locks.StampedLock.tryReadLock	(	): Non-exclusively acquires the lock if it is immediately available.
java.util.concurrent.locks.StampedLock.tryReadLock	(	long	TimeUnit	): Non-exclusively acquires the lock if it is available within the given time and the current thread has not been interrupted. Behavior under timeout and interruption matches that specified for method tryLock().
java.util.concurrent.locks.StampedLock.tryUnlockRead	(	): Releases one hold of the read lock if it is held, without requiring a stamp value. This method may be useful for recovery after errors.
java.util.concurrent.locks.StampedLock.tryUnlockWrite	(	): Releases the write lock if it is held, without requiring a stamp value. This method may be useful for recovery after errors.
java.util.concurrent.locks.StampedLock.tryWriteLock	(	): Exclusively acquires the lock if it is immediately available.
java.util.concurrent.locks.StampedLock.tryWriteLock	(	long	TimeUnit	): Exclusively acquires the lock if it is available within the given time and the current thread has not been interrupted. Behavior under timeout and interruption matches that specified for method tryLock().
java.util.concurrent.locks.StampedLock.unlock	(	long	): If the lock state matches the given stamp, releases the corresponding mode of the lock.
java.util.concurrent.locks.StampedLock.unlockRead	(	long	): If the lock state matches the given stamp, releases the non-exclusive lock.
java.util.concurrent.locks.StampedLock.unlockWrite	(	long	): If the lock state matches the given stamp, releases the exclusive lock.
java.util.concurrent.locks.StampedLock.validate	(	long	): Returns true if the lock has not been exclusively acquired since issuance of the given stamp. Always returns false if the stamp is zero. Always returns true if the stamp represents a currently held lock. Invoking this method with a value not obtained from tryOptimisticRead or a locking method for this lock has no defined effect or result.
java.util.concurrent.locks.StampedLock.writeLock	(	): Exclusively acquires the lock, blocking if necessary until available.
java.util.concurrent.locks.StampedLock.writeLockInterruptibly	(	): Exclusively acquires the lock, blocking if necessary until available or the current thread is interrupted. Behavior under interruption matches that specified for method lockInterruptibly().
java.util.function.BiConsumer: Represents an operation that accepts two input arguments and returns no result. This is the two-arity specialization of Consumer. Unlike most other functional interfaces, BiConsumer is expected to operate via side-effects. This is a functional interface whose functional method is accept().
java.util.function.BiConsumer.accept	(	T	U	): Performs this operation on the given arguments.
java.util.function.BiConsumer.andThen	(	BiConsumer	): Returns a composed BiConsumer that performs, in sequence, this operation followed by the after operation. If performing either operation throws an exception, it is relayed to the caller of the composed operation. If performing this operation throws an exception, the after operation will not be performed.
java.util.function.BiFunction: Represents a function that accepts two arguments and produces a result. This is the two-arity specialization of Function. This is a functional interface whose functional method is apply().
java.util.function.BiFunction.andThen	(	Function	): Returns a composed function that first applies this function to its input, and then applies the after function to the result. If evaluation of either function throws an exception, it is relayed to the caller of the composed function.
java.util.function.BiFunction.apply	(	T	U	): Applies this function to the given arguments.
java.util.function.BiPredicate: Represents a predicate (boolean-valued function) of two arguments. This is the two-arity specialization of Predicate. This is a functional interface whose functional method is test().
java.util.function.BiPredicate.and	(	BiPredicate	): Returns a composed predicate that represents a short-circuiting logical AND of this predicate and another. When evaluating the composed predicate, if this predicate is false, then the other predicate is not evaluated. Any exceptions thrown during evaluation of either predicate are relayed to the caller; if evaluation of this predicate throws an exception, the other predicate will not be evaluated.
java.util.function.BiPredicate.negate	(	): Returns a predicate that represents the logical negation of this predicate.
java.util.function.BiPredicate.or	(	BiPredicate	): Returns a composed predicate that represents a short-circuiting logical OR of this predicate and another. When evaluating the composed predicate, if this predicate is true, then the other predicate is not evaluated. Any exceptions thrown during evaluation of either predicate are relayed to the caller; if evaluation of this predicate throws an exception, the other predicate will not be evaluated.
java.util.function.BiPredicate.test	(	T	U	): Evaluates this predicate on the given arguments.
java.util.function.BinaryOperator: Represents an operation upon two operands of the same type, producing a result of the same type as the operands. This is a specialization of BiFunction for the case where the operands and the result are all of the same type. This is a functional interface whose functional method is apply().
java.util.function.BinaryOperator.maxBy	(	Comparator	): Returns a BinaryOperator which returns the greater of two elements according to the specified Comparator.
java.util.function.BinaryOperator.minBy	(	Comparator	): Returns a BinaryOperator which returns the lesser of two elements according to the specified Comparator.
java.util.function.BooleanSupplier: Represents a supplier of boolean-valued results. This is the boolean-producing primitive specialization of Supplier. There is no requirement that a new or distinct result be returned each time the supplier is invoked. This is a functional interface whose functional method is getAsBoolean().
java.util.function.BooleanSupplier.getAsBoolean	(	): Gets a result.
java.util.function.Consumer: Represents an operation that accepts a single input argument and returns no result. Unlike most other functional interfaces, Consumer is expected to operate via side-effects. This is a functional interface whose functional method is accept().
java.util.function.Consumer.accept	(	T	): Performs this operation on the given argument.
java.util.function.Consumer.andThen	(	Consumer	): Returns a composed Consumer that performs, in sequence, this operation followed by the after operation. If performing either operation throws an exception, it is relayed to the caller of the composed operation. If performing this operation throws an exception, the after operation will not be performed.
java.util.function.DoubleBinaryOperator: Represents an operation upon two double-valued operands and producing a double-valued result. This is the primitive type specialization of BinaryOperator for double. This is a functional interface whose functional method is applyAsDouble().
java.util.function.DoubleBinaryOperator.applyAsDouble	(	double	double	): Applies this operator to the given operands.
java.util.function.DoubleConsumer: Represents an operation that accepts a single double-valued argument and returns no result. This is the primitive type specialization of Consumer for double. Unlike most other functional interfaces, DoubleConsumer is expected to operate via side-effects. This is a functional interface whose functional method is accept().
java.util.function.DoubleConsumer.accept	(	double	): Performs this operation on the given argument.
java.util.function.DoubleConsumer.andThen	(	DoubleConsumer	): Returns a composed DoubleConsumer that performs, in sequence, this operation followed by the after operation. If performing either operation throws an exception, it is relayed to the caller of the composed operation. If performing this operation throws an exception, the after operation will not be performed.
java.util.function.DoubleFunction: Represents a function that accepts a double-valued argument and produces a result. This is the double-consuming primitive specialization for Function. This is a functional interface whose functional method is apply().
java.util.function.DoubleFunction.apply	(	double	): Applies this function to the given argument.
java.util.function.DoublePredicate: Represents a predicate (boolean-valued function) of one double-valued argument. This is the double-consuming primitive type specialization of Predicate. This is a functional interface whose functional method is test().
java.util.function.DoublePredicate.and	(	DoublePredicate	): Returns a composed predicate that represents a short-circuiting logical AND of this predicate and another. When evaluating the composed predicate, if this predicate is false, then the other predicate is not evaluated. Any exceptions thrown during evaluation of either predicate are relayed to the caller; if evaluation of this predicate throws an exception, the other predicate will not be evaluated.
java.util.function.DoublePredicate.negate	(	): Returns a predicate that represents the logical negation of this predicate.
java.util.function.DoublePredicate.or	(	DoublePredicate	): Returns a composed predicate that represents a short-circuiting logical OR of this predicate and another. When evaluating the composed predicate, if this predicate is true, then the other predicate is not evaluated. Any exceptions thrown during evaluation of either predicate are relayed to the caller; if evaluation of this predicate throws an exception, the other predicate will not be evaluated.
java.util.function.DoublePredicate.test	(	double	): Evaluates this predicate on the given argument.
java.util.function.DoubleSupplier: Represents a supplier of double-valued results. This is the double-producing primitive specialization of Supplier. There is no requirement that a distinct result be returned each time the supplier is invoked. This is a functional interface whose functional method is getAsDouble().
java.util.function.DoubleSupplier.getAsDouble	(	): Gets a result.
java.util.function.DoubleToIntFunction: Represents a function that accepts a double-valued argument and produces an int-valued result. This is the double-to-int primitive specialization for Function. This is a functional interface whose functional method is applyAsInt().
java.util.function.DoubleToIntFunction.applyAsInt	(	double	): Applies this function to the given argument.
java.util.function.DoubleToLongFunction: Represents a function that accepts a double-valued argument and produces a long-valued result. This is the double-to-long primitive specialization for Function. This is a functional interface whose functional method is applyAsLong().
java.util.function.DoubleToLongFunction.applyAsLong	(	double	): Applies this function to the given argument.
java.util.function.DoubleUnaryOperator: Represents an operation on a single double-valued operand that produces a double-valued result. This is the primitive type specialization of UnaryOperator for double. This is a functional interface whose functional method is applyAsDouble().
java.util.function.DoubleUnaryOperator.andThen	(	DoubleUnaryOperator	): Returns a composed operator that first applies this operator to its input, and then applies the after operator to the result. If evaluation of either operator throws an exception, it is relayed to the caller of the composed operator.
java.util.function.DoubleUnaryOperator.applyAsDouble	(	double	): Applies this operator to the given operand.
java.util.function.DoubleUnaryOperator.compose	(	DoubleUnaryOperator	): Returns a composed operator that first applies the before operator to its input, and then applies this operator to the result. If evaluation of either operator throws an exception, it is relayed to the caller of the composed operator.
java.util.function.DoubleUnaryOperator.identity	(	): Returns a unary operator that always returns its input argument.
java.util.function.Function: Represents a function that accepts one argument and produces a result. This is a functional interface whose functional method is apply().
java.util.function.Function.andThen	(	Function	): Returns a composed function that first applies this function to its input, and then applies the after function to the result. If evaluation of either function throws an exception, it is relayed to the caller of the composed function.
java.util.function.Function.apply	(	T	): Applies this function to the given argument.
java.util.function.Function.compose	(	Function	): Returns a composed function that first applies the before function to its input, and then applies this function to the result. If evaluation of either function throws an exception, it is relayed to the caller of the composed function.
java.util.function.Function.identity	(	): Returns a function that always returns its input argument.
java.util.function.IntBinaryOperator: Represents an operation upon two int-valued operands and producing an int-valued result. This is the primitive type specialization of BinaryOperator for int. This is a functional interface whose functional method is applyAsInt().
java.util.function.IntBinaryOperator.applyAsInt	(	int	int	): Applies this operator to the given operands.
java.util.function.IntConsumer: Represents an operation that accepts a single int-valued argument and returns no result. This is the primitive type specialization of Consumer for int. Unlike most other functional interfaces, IntConsumer is expected to operate via side-effects. This is a functional interface whose functional method is accept().
java.util.function.IntConsumer.accept	(	int	): Performs this operation on the given argument.
java.util.function.IntConsumer.andThen	(	IntConsumer	): Returns a composed IntConsumer that performs, in sequence, this operation followed by the after operation. If performing either operation throws an exception, it is relayed to the caller of the composed operation. If performing this operation throws an exception, the after operation will not be performed.
java.util.function.IntFunction: Represents a function that accepts an int-valued argument and produces a result. This is the int-consuming primitive specialization for Function. This is a functional interface whose functional method is apply().
java.util.function.IntFunction.apply	(	int	): Applies this function to the given argument.
java.util.function.IntPredicate: Represents a predicate (boolean-valued function) of one int-valued argument. This is the int-consuming primitive type specialization of Predicate. This is a functional interface whose functional method is test().
java.util.function.IntPredicate.and	(	IntPredicate	): Returns a composed predicate that represents a short-circuiting logical AND of this predicate and another. When evaluating the composed predicate, if this predicate is false, then the other predicate is not evaluated. Any exceptions thrown during evaluation of either predicate are relayed to the caller; if evaluation of this predicate throws an exception, the other predicate will not be evaluated.
java.util.function.IntPredicate.negate	(	): Returns a predicate that represents the logical negation of this predicate.
java.util.function.IntPredicate.or	(	IntPredicate	): Returns a composed predicate that represents a short-circuiting logical OR of this predicate and another. When evaluating the composed predicate, if this predicate is true, then the other predicate is not evaluated. Any exceptions thrown during evaluation of either predicate are relayed to the caller; if evaluation of this predicate throws an exception, the other predicate will not be evaluated.
java.util.function.IntPredicate.test	(	int	): Evaluates this predicate on the given argument.
java.util.function.IntSupplier: Represents a supplier of int-valued results. This is the int-producing primitive specialization of Supplier. There is no requirement that a distinct result be returned each time the supplier is invoked. This is a functional interface whose functional method is getAsInt().
java.util.function.IntSupplier.getAsInt	(	): Gets a result.
java.util.function.IntToDoubleFunction: Represents a function that accepts an int-valued argument and produces a double-valued result. This is the int-to-double primitive specialization for Function. This is a functional interface whose functional method is applyAsDouble().
java.util.function.IntToDoubleFunction.applyAsDouble	(	int	): Applies this function to the given argument.
java.util.function.IntToLongFunction: Represents a function that accepts an int-valued argument and produces a long-valued result. This is the int-to-long primitive specialization for Function. This is a functional interface whose functional method is applyAsLong().
java.util.function.IntToLongFunction.applyAsLong	(	int	): Applies this function to the given argument.
java.util.function.IntUnaryOperator: Represents an operation on a single int-valued operand that produces an int-valued result. This is the primitive type specialization of UnaryOperator for int. This is a functional interface whose functional method is applyAsInt().
java.util.function.IntUnaryOperator.andThen	(	IntUnaryOperator	): Returns a composed operator that first applies this operator to its input, and then applies the after operator to the result. If evaluation of either operator throws an exception, it is relayed to the caller of the composed operator.
java.util.function.IntUnaryOperator.applyAsInt	(	int	): Applies this operator to the given operand.
java.util.function.IntUnaryOperator.compose	(	IntUnaryOperator	): Returns a composed operator that first applies the before operator to its input, and then applies this operator to the result. If evaluation of either operator throws an exception, it is relayed to the caller of the composed operator.
java.util.function.IntUnaryOperator.identity	(	): Returns a unary operator that always returns its input argument.
java.util.function.LongBinaryOperator: Represents an operation upon two long-valued operands and producing a long-valued result. This is the primitive type specialization of BinaryOperator for long. This is a functional interface whose functional method is applyAsLong().
java.util.function.LongBinaryOperator.applyAsLong	(	long	long	): Applies this operator to the given operands.
java.util.function.LongConsumer: Represents an operation that accepts a single long-valued argument and returns no result. This is the primitive type specialization of Consumer for long. Unlike most other functional interfaces, LongConsumer is expected to operate via side-effects. This is a functional interface whose functional method is accept().
java.util.function.LongConsumer.accept	(	long	): Performs this operation on the given argument.
java.util.function.LongConsumer.andThen	(	LongConsumer	): Returns a composed LongConsumer that performs, in sequence, this operation followed by the after operation. If performing either operation throws an exception, it is relayed to the caller of the composed operation. If performing this operation throws an exception, the after operation will not be performed.
java.util.function.LongFunction: Represents a function that accepts a long-valued argument and produces a result. This is the long-consuming primitive specialization for Function. This is a functional interface whose functional method is apply().
java.util.function.LongFunction.apply	(	long	): Applies this function to the given argument.
java.util.function.LongPredicate: Represents a predicate (boolean-valued function) of one long-valued argument. This is the long-consuming primitive type specialization of Predicate. This is a functional interface whose functional method is test().
java.util.function.LongPredicate.and	(	LongPredicate	): Returns a composed predicate that represents a short-circuiting logical AND of this predicate and another. When evaluating the composed predicate, if this predicate is false, then the other predicate is not evaluated. Any exceptions thrown during evaluation of either predicate are relayed to the caller; if evaluation of this predicate throws an exception, the other predicate will not be evaluated.
java.util.function.LongPredicate.negate	(	): Returns a predicate that represents the logical negation of this predicate.
java.util.function.LongPredicate.or	(	LongPredicate	): Returns a composed predicate that represents a short-circuiting logical OR of this predicate and another. When evaluating the composed predicate, if this predicate is true, then the other predicate is not evaluated. Any exceptions thrown during evaluation of either predicate are relayed to the caller; if evaluation of this predicate throws an exception, the other predicate will not be evaluated.
java.util.function.LongPredicate.test	(	long	): Evaluates this predicate on the given argument.
java.util.function.LongSupplier: Represents a supplier of long-valued results. This is the long-producing primitive specialization of Supplier. There is no requirement that a distinct result be returned each time the supplier is invoked. This is a functional interface whose functional method is getAsLong().
java.util.function.LongSupplier.getAsLong	(	): Gets a result.
java.util.function.LongToDoubleFunction: Represents a function that accepts a long-valued argument and produces a double-valued result. This is the long-to-double primitive specialization for Function. This is a functional interface whose functional method is applyAsDouble().
java.util.function.LongToDoubleFunction.applyAsDouble	(	long	): Applies this function to the given argument.
java.util.function.LongToIntFunction: Represents a function that accepts a long-valued argument and produces an int-valued result. This is the long-to-int primitive specialization for Function. This is a functional interface whose functional method is applyAsInt().
java.util.function.LongToIntFunction.applyAsInt	(	long	): Applies this function to the given argument.
java.util.function.LongUnaryOperator: Represents an operation on a single long-valued operand that produces a long-valued result. This is the primitive type specialization of UnaryOperator for long. This is a functional interface whose functional method is applyAsLong().
java.util.function.LongUnaryOperator.andThen	(	LongUnaryOperator	): Returns a composed operator that first applies this operator to its input, and then applies the after operator to the result. If evaluation of either operator throws an exception, it is relayed to the caller of the composed operator.
java.util.function.LongUnaryOperator.applyAsLong	(	long	): Applies this operator to the given operand.
java.util.function.LongUnaryOperator.compose	(	LongUnaryOperator	): Returns a composed operator that first applies the before operator to its input, and then applies this operator to the result. If evaluation of either operator throws an exception, it is relayed to the caller of the composed operator.
java.util.function.LongUnaryOperator.identity	(	): Returns a unary operator that always returns its input argument.
java.util.function.ObjDoubleConsumer: Represents an operation that accepts an object-valued and a double-valued argument, and returns no result. This is the (reference, double) specialization of BiConsumer. Unlike most other functional interfaces, ObjDoubleConsumer is expected to operate via side-effects. This is a functional interface whose functional method is accept().
java.util.function.ObjDoubleConsumer.accept	(	T	double	): Performs this operation on the given arguments.
java.util.function.ObjIntConsumer: Represents an operation that accepts an object-valued and a int-valued argument, and returns no result. This is the (reference, int) specialization of BiConsumer. Unlike most other functional interfaces, ObjIntConsumer is expected to operate via side-effects. This is a functional interface whose functional method is accept().
java.util.function.ObjIntConsumer.accept	(	T	int	): Performs this operation on the given arguments.
java.util.function.ObjLongConsumer: Represents an operation that accepts an object-valued and a long-valued argument, and returns no result. This is the (reference, long) specialization of BiConsumer. Unlike most other functional interfaces, ObjLongConsumer is expected to operate via side-effects. This is a functional interface whose functional method is accept().
java.util.function.ObjLongConsumer.accept	(	T	long	): Performs this operation on the given arguments.
java.util.function.Predicate: Represents a predicate (boolean-valued function) of one argument. This is a functional interface whose functional method is test().
java.util.function.Predicate.and	(	Predicate	): Returns a composed predicate that represents a short-circuiting logical AND of this predicate and another. When evaluating the composed predicate, if this predicate is false, then the other predicate is not evaluated. Any exceptions thrown during evaluation of either predicate are relayed to the caller; if evaluation of this predicate throws an exception, the other predicate will not be evaluated.
java.util.function.Predicate.isEqual	(	Object	): Returns a predicate that tests if two arguments are equal according to equals().
java.util.function.Predicate.negate	(	): Returns a predicate that represents the logical negation of this predicate.
java.util.function.Predicate.or	(	Predicate	): Returns a composed predicate that represents a short-circuiting logical OR of this predicate and another. When evaluating the composed predicate, if this predicate is true, then the other predicate is not evaluated. Any exceptions thrown during evaluation of either predicate are relayed to the caller; if evaluation of this predicate throws an exception, the other predicate will not be evaluated.
java.util.function.Predicate.test	(	T	): Evaluates this predicate on the given argument.
java.util.function.Supplier: Represents a supplier of results. There is no requirement that a new or distinct result be returned each time the supplier is invoked. This is a functional interface whose functional method is get().
java.util.function.Supplier.get	(	): Gets a result.
java.util.function.ToDoubleBiFunction: Represents a function that accepts two arguments and produces a double-valued result. This is the double-producing primitive specialization for BiFunction. This is a functional interface whose functional method is applyAsDouble().
java.util.function.ToDoubleBiFunction.applyAsDouble	(	T	U	): Applies this function to the given arguments.
java.util.function.ToDoubleFunction: Represents a function that produces a double-valued result. This is the double-producing primitive specialization for Function. This is a functional interface whose functional method is applyAsDouble().
java.util.function.ToDoubleFunction.applyAsDouble	(	T	): Applies this function to the given argument.
java.util.function.ToIntBiFunction: Represents a function that accepts two arguments and produces an int-valued result. This is the int-producing primitive specialization for BiFunction. This is a functional interface whose functional method is applyAsInt().
java.util.function.ToIntBiFunction.applyAsInt	(	T	U	): Applies this function to the given arguments.
java.util.function.ToIntFunction: Represents a function that produces an int-valued result. This is the int-producing primitive specialization for Function. This is a functional interface whose functional method is applyAsInt().
java.util.function.ToIntFunction.applyAsInt	(	T	): Applies this function to the given argument.
java.util.function.ToLongBiFunction: Represents a function that accepts two arguments and produces a long-valued result. This is the long-producing primitive specialization for BiFunction. This is a functional interface whose functional method is applyAsLong().
java.util.function.ToLongBiFunction.applyAsLong	(	T	U	): Applies this function to the given arguments.
java.util.function.ToLongFunction: Represents a function that produces a long-valued result. This is the long-producing primitive specialization for Function. This is a functional interface whose functional method is applyAsLong().
java.util.function.ToLongFunction.applyAsLong	(	T	): Applies this function to the given argument.
java.util.function.UnaryOperator: Represents an operation on a single operand that produces a result of the same type as its operand. This is a specialization of Function for the case where the operand and result are of the same type. This is a functional interface whose functional method is apply().
java.util.function.UnaryOperator.identity	(	): Returns a unary operator that always returns its input argument.
java.util.jar.Attributes: The Attributes class maps Manifest attribute names to associated string values. Valid attribute names are case-insensitive, are restricted to the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed 70 characters in length. Attribute values can contain any characters and will be UTF8-encoded when written to the output stream. See the JAR File Specification for more information about valid attribute names and values.
java.util.jar.Attributes.Attributes	(	): Constructs a new, empty Attributes object with default size.
java.util.jar.Attributes.Attributes	(	Attributes	): Constructs a new Attributes object with the same attribute name-value mappings as in the specified Attributes.
java.util.jar.Attributes.Attributes	(	int	): Constructs a new, empty Attributes object with the specified initial size.
java.util.jar.Attributes.Name: The Attributes.Name class represents an attribute name stored in this Map. Valid attribute names are case-insensitive, are restricted to the ASCII characters in the set [0-9a-zA-Z_-], and cannot exceed 70 characters in length. Attribute values can contain any characters and will be UTF8-encoded when written to the output stream. See the JAR File Specification for more information about valid attribute names and values.
java.util.jar.Attributes.Name.Name	(	String	): Constructs a new attribute name using the given string name.
java.util.jar.Attributes.Name.equals	(	Object	): Compares this attribute name to another for equality.
java.util.jar.Attributes.Name.hashCode	(	): Computes the hash value for this attribute name.
java.util.jar.Attributes.Name.toString	(	): Returns the attribute name as a String.
java.util.jar.Attributes.clear	(	): Removes all attributes from this Map.
java.util.jar.Attributes.clone	(	): Returns a copy of the Attributes, implemented as follows:  public Object clone() { return new Attributes(this); }  Since the attribute names and values are themselves immutable, the Attributes returned can be safely modified without affecting the original.
java.util.jar.Attributes.containsKey	(	Object	): Returns true if this Map contains the specified attribute name (key).
java.util.jar.Attributes.containsValue	(	Object	): Returns true if this Map maps one or more attribute names (keys) to the specified value.
java.util.jar.Attributes.entrySet	(	): Returns a Collection view of the attribute name-value mappings contained in this Map.
java.util.jar.Attributes.equals	(	Object	): Compares the specified Attributes object with this Map for equality. Returns true if the given object is also an instance of Attributes and the two Attributes objects represent the same mappings.
java.util.jar.Attributes.get	(	Object	): Returns the value of the specified attribute name, or null if the attribute name was not found.
java.util.jar.Attributes.getValue	(	Name	): Returns the value of the specified Attributes.Name, or null if the attribute was not found.  This method is defined as:  return (String)get(name); 
java.util.jar.Attributes.getValue	(	String	): Returns the value of the specified attribute name, specified as a string, or null if the attribute was not found. The attribute name is case-insensitive.  This method is defined as:  return (String)get(new Attributes.Name((String)name)); 
java.util.jar.Attributes.hashCode	(	): Returns the hash code value for this Map.
java.util.jar.Attributes.isEmpty	(	): Returns true if this Map contains no attributes.
java.util.jar.Attributes.keySet	(	): Returns a Set view of the attribute names (keys) contained in this Map.
java.util.jar.Attributes.put	(	Object	Object	): Associates the specified value with the specified attribute name (key) in this Map. If the Map previously contained a mapping for the attribute name, the old value is replaced.
java.util.jar.Attributes.putAll	(	Map	): Copies all of the attribute name-value mappings from the specified Attributes to this Map. Duplicate mappings will be replaced.
java.util.jar.Attributes.putValue	(	String	String	): Associates the specified value with the specified attribute name, specified as a String. The attributes name is case-insensitive. If the Map previously contained a mapping for the attribute name, the old value is replaced.  This method is defined as:  return (String)put(new Attributes.Name(name), value); 
java.util.jar.Attributes.remove	(	Object	): Removes the attribute with the specified name (key) from this Map. Returns the previous attribute value, or null if none.
java.util.jar.Attributes.size	(	): Returns the number of attributes in this Map.
java.util.jar.Attributes.values	(	): Returns a Collection view of the attribute values contained in this Map.
java.util.jar.JarEntry: This class is used to represent a JAR file entry.
java.util.jar.JarEntry.JarEntry	(	JarEntry	): Creates a new JarEntry with fields taken from the specified JarEntry object.
java.util.jar.JarEntry.JarEntry	(	String	): Creates a new JarEntry for the specified JAR file entry name.
java.util.jar.JarEntry.JarEntry	(	ZipEntry	): Creates a new JarEntry with fields taken from the specified ZipEntry object.
java.util.jar.JarEntry.getAttributes	(	): Returns the Manifest Attributes for this entry, or null if none.
java.util.jar.JarEntry.getCertificates	(	): Returns the Certificate objects for this entry, or null if none. This method can only be called once the JarEntry has been completely verified by reading from the entry input stream until the end of the stream has been reached. Otherwise, this method will return null. The returned certificate array comprises all the signer certificates that were used to verify this entry. Each signer certificate is followed by its supporting certificate chain (which may be empty). Each signer certificate and its supporting certificate chain are ordered bottom-to-top (i.e., with the signer certificate first and the (root) certificate authority last).
java.util.jar.JarEntry.getCodeSigners	(	): Returns the CodeSigner objects for this entry, or null if none. This method can only be called once the JarEntry has been completely verified by reading from the entry input stream until the end of the stream has been reached. Otherwise, this method will return null. The returned array comprises all the code signers that have signed this entry.
java.util.jar.JarException: Signals that an error of some sort has occurred while reading from or writing to a JAR file.
java.util.jar.JarException.JarException	(	): Constructs a JarException with no detail message.
java.util.jar.JarException.JarException	(	String	): Constructs a JarException with the specified detail message.
java.util.jar.JarFile: The JarFile class is used to read the contents of a jar file from any file that can be opened with java.io.RandomAccessFile. It extends the class java.util.zip.ZipFile with support for reading an optional Manifest entry. The Manifest can be used to specify meta-information about the jar file and its entries.  Unless otherwise noted, passing a null argument to a constructor or method in this class will cause a NullPointerException to be thrown. If the verify flag is on when opening a signed jar file, the content of the file is verified against its signature embedded inside the file. Please note that the verification process does not include validating the signer's certificate. A caller should inspect the return value of getCodeSigners() to further determine if the signature can be trusted.
java.util.jar.JarFile.JarFile	(	File	): Creates a new JarFile to read from the specified File object. The JarFile will be verified if it is signed.
java.util.jar.JarFile.JarFile	(	File	boolean	): Creates a new JarFile to read from the specified File object.
java.util.jar.JarFile.JarFile	(	File	boolean	int	): Creates a new JarFile to read from the specified File object in the specified mode. The mode argument must be either OPEN_READ or OPEN_READ | OPEN_DELETE.
java.util.jar.JarFile.JarFile	(	String	): Creates a new JarFile to read from the specified file name. The JarFile will be verified if it is signed.
java.util.jar.JarFile.JarFile	(	String	boolean	): Creates a new JarFile to read from the specified file name.
java.util.jar.JarFile.checkForSpecialAttributes	(	): On first invocation, check if the JAR file has the Class-Path attribute. A no-op on subsequent calls.
java.util.jar.JarFile.entries	(	): Returns an enumeration of the zip file entries.
java.util.jar.JarFile.entries2	(	): Returns an enumeration of the zip file entries excluding internal JAR mechanism entries and including signed entries missing from the ZIP directory.
java.util.jar.JarFile.getEntry	(	String	): Returns the ZipEntry for the given entry name or null if not found.
java.util.jar.JarFile.getInputStream	(	ZipEntry	): Returns an input stream for reading the contents of the specified zip file entry.
java.util.jar.JarFile.getJarEntry	(	String	): Returns the JarEntry for the given entry name or null if not found.
java.util.jar.JarFile.getManifest	(	): Returns the jar file manifest, or null if none.
java.util.jar.JarFile.hasClassPathAttribute	(	): Returns true iff this JAR file has a manifest with the Class-Path attribute
java.util.jar.JarFile.match	(	char[]	byte[]	int[]	int[]	): Returns true if the pattern src is found in b. The lastOcc and optoSft arrays are the precomputed bad character and good suffix shifts.
java.util.jar.JarInputStream: The JarInputStream class is used to read the contents of a JAR file from any input stream. It extends the class java.util.zip.ZipInputStream with support for reading an optional Manifest entry. The Manifest can be used to store meta-information about the JAR file and its entries.
java.util.jar.JarInputStream.JarInputStream	(	InputStream	): Creates a new JarInputStream and reads the optional manifest. If a manifest is present, also attempts to verify the signatures if the JarInputStream is signed.
java.util.jar.JarInputStream.JarInputStream	(	InputStream	boolean	): Creates a new JarInputStream and reads the optional manifest. If a manifest is present and verify is true, also attempts to verify the signatures if the JarInputStream is signed.
java.util.jar.JarInputStream.createZipEntry	(	String	): Creates a new JarEntry (ZipEntry) for the specified JAR file entry name. The manifest attributes of the specified JAR file entry name will be copied to the new JarEntry.
java.util.jar.JarInputStream.getManifest	(	): Returns the Manifest for this JAR file, or null if none.
java.util.jar.JarInputStream.getNextEntry	(	): Reads the next ZIP file entry and positions the stream at the beginning of the entry data. If verification has been enabled, any invalid signature detected while positioning the stream for the next entry will result in an exception.
java.util.jar.JarInputStream.getNextJarEntry	(	): Reads the next JAR file entry and positions the stream at the beginning of the entry data. If verification has been enabled, any invalid signature detected while positioning the stream for the next entry will result in an exception.
java.util.jar.JarInputStream.read	(	byte[]	int	int	): Reads from the current JAR file entry into an array of bytes. If len is not zero, the method blocks until some input is available; otherwise, no bytes are read and 0 is returned. If verification has been enabled, any invalid signature on the current entry will be reported at some point before the end of the entry is reached.
java.util.jar.JarOutputStream: The JarOutputStream class is used to write the contents of a JAR file to any output stream. It extends the class java.util.zip.ZipOutputStream with support for writing an optional Manifest entry. The Manifest can be used to specify meta-information about the JAR file and its entries.
java.util.jar.JarOutputStream.JarOutputStream	(	OutputStream	): Creates a new JarOutputStream with no manifest.
java.util.jar.JarOutputStream.JarOutputStream	(	OutputStream	Manifest	): Creates a new JarOutputStream with the specified Manifest. The manifest is written as the first entry to the output stream.
java.util.jar.JarOutputStream.putNextEntry	(	ZipEntry	): Begins writing a new JAR file entry and positions the stream to the start of the entry data. This method will also close any previous entry. The default compression method will be used if no compression method was specified for the entry. The current time will be used if the entry has no set modification time.
java.util.jar.JarVerifier.beginEntry	(	JarEntry	ManifestEntryVerifier	): This method scans to see which entry we're parsing and keeps various state information depending on what type of file is being parsed.
java.util.jar.JarVerifier.doneWithMeta	(	): called to let us know we have processed all the META-INF entries, and if we re-read one of them, don't re-process it. Also gets rid of any data structures we needed when parsing META-INF entries.
java.util.jar.JarVerifier.getCerts	(	String	): Return an array of java.security.cert.Certificate objects for the given file in the jar.
java.util.jar.JarVerifier.getCodeSigners	(	String	): return an array of CodeSigner objects for the given file in the jar. this array is not cloned.
java.util.jar.JarVerifier.nothingToVerify	(	): returns true if there no files to verify. should only be called after all the META-INF entries have been processed.
java.util.jar.JarVerifier.processEntry	(	ManifestEntryVerifier	): called when we reach the end of entry in one of the read() methods.
java.util.jar.JarVerifier.update	(	int	ManifestEntryVerifier	): update a single byte.
java.util.jar.JarVerifier.update	(	int	byte[]	int	int	ManifestEntryVerifier	): update an array of bytes.
java.util.jar.Manifest: The Manifest class is used to maintain Manifest entry names and their associated Attributes. There are main Manifest Attributes as well as per-entry Attributes. For information on the Manifest format, please see the  Manifest format specification.
java.util.jar.Manifest.Manifest	(	): Constructs a new, empty Manifest.
java.util.jar.Manifest.Manifest	(	InputStream	): Constructs a new Manifest from the specified input stream.
java.util.jar.Manifest.Manifest	(	Manifest	): Constructs a new Manifest that is a copy of the specified Manifest.
java.util.jar.Manifest.clear	(	): Clears the main Attributes as well as the entries in this Manifest.
java.util.jar.Manifest.clone	(	): Returns a shallow copy of this Manifest. The shallow copy is implemented as follows:  public Object clone() { return new Manifest(this); } 
java.util.jar.Manifest.equals	(	Object	): Returns true if the specified Object is also a Manifest and has the same main Attributes and entries.
java.util.jar.Manifest.getAttributes	(	String	): Returns the Attributes for the specified entry name. This method is defined as:  return (Attributes)getEntries().get(name)  Though null is a valid name, when getAttributes(null) is invoked on a Manifest obtained from a jar file, null will be returned. While jar files themselves do not allow null-named attributes, it is possible to invoke getEntries on a Manifest, and on that result, invoke put with a null key and an arbitrary value. Subsequent invocations of getAttributes(null) will return the just-put value.  Note that this method does not return the manifest's main attributes; see getMainAttributes.
java.util.jar.Manifest.getEntries	(	): Returns a Map of the entries contained in this Manifest. Each entry is represented by a String name (key) and associated Attributes (value). The Map permits the null key, but no entry with a null key is created by read, nor is such an entry written by using write.
java.util.jar.Manifest.getMainAttributes	(	): Returns the main Attributes for the Manifest.
java.util.jar.Manifest.hashCode	(	): Returns the hash code for this Manifest.
java.util.jar.Manifest.make72Safe	(	StringBuffer	): Adds line breaks to enforce a maximum 72 bytes per line.
java.util.jar.Manifest.read	(	InputStream	): Reads the Manifest from the specified InputStream. The entry names and attributes read will be merged in with the current manifest entries.
java.util.jar.Manifest.write	(	OutputStream	): Writes the Manifest to the specified OutputStream. Attributes.Name.MANIFEST_VERSION must be set in MainAttributes prior to invoking this method.
java.util.jar.Pack200: Transforms a JAR file to or from a packed stream in Pack200 format. Please refer to Network Transfer Format JSR 200 Specification at http://jcp.org/aboutJava/communityprocess/review/jsr200/index.html  Typically the packer engine is used by application developers to deploy or host JAR files on a website. The unpacker engine is used by deployment applications to transform the byte-stream back to JAR format.  Here is an example using packer and unpacker: import java.util.jar.Pack200; import java.util.jar.Pack200.*; ... // Create the Packer object Packer packer = Pack200.newPacker(); // Initialize the state by setting the desired properties Map p = packer.properties(); // take more time choosing codings for better compression p.put(Packer.EFFORT, "7"); // default is "5" // use largest-possible archive segments (>10% better compression). p.put(Packer.SEGMENT_LIMIT, "-1"); // reorder files for better compression. p.put(Packer.KEEP_FILE_ORDER, Packer.FALSE); // smear modification times to a single value. p.put(Packer.MODIFICATION_TIME, Packer.LATEST); // ignore all JAR deflation requests, // transmitting a single request to use "store" mode. p.put(Packer.DEFLATE_HINT, Packer.FALSE); // discard debug attributes p.put(Packer.CODE_ATTRIBUTE_PFX+"LineNumberTable", Packer.STRIP); // throw an error if an attribute is unrecognized p.put(Packer.UNKNOWN_ATTRIBUTE, Packer.ERROR); // pass one class file uncompressed: p.put(Packer.PASS_FILE_PFX+0, "mutants/Rogue.class"); try JarFile jarFile = new JarFile("/tmp/testref.jar"); FileOutputStream fos = new FileOutputStream("/tmp/test.pack"); // Call the packer packer.pack(jarFile, fos); jarFile.close(); fos.close(); File f = new File("/tmp/test.pack"); FileOutputStream fostream = new FileOutputStream("/tmp/test.jar"); JarOutputStream jostream = new JarOutputStream(fostream); Unpacker unpacker = Pack200.newUnpacker(); // Call the unpacker unpacker.unpack(f, jostream); // Must explicitly close the output. jostream.close(); } catch (IOException ioe) { ioe.printStackTrace(); } }  A Pack200 file compressed with gzip can be hosted on HTTP/1.1 web servers. The deployment applications can use "Accept-Encoding=pack200-gzip". This indicates to the server that the client application desires a version of the file encoded with Pack200 and further compressed with gzip. Please refer to Java Deployment Guide for more details and techniques.  Unless otherwise noted, passing a null argument to a constructor or method in this class will cause a NullPointerException to be thrown.
java.util.jar.Pack200.Packer: The packer engine applies various transformations to the input JAR file, making the pack stream highly compressible by a compressor such as gzip or zip. An instance of the engine can be obtained using newPacker. The high degree of compression is achieved by using a number of techniques described in the JSR 200 specification. Some of the techniques are sorting, re-ordering and co-location of the constant pool.  The pack engine is initialized to an initial state as described by their properties below. The initial state can be manipulated by getting the engine properties (using properties) and storing the modified properties on the map. The resource files will be passed through with no changes at all. The class files will not contain identical bytes, since the unpacker is free to change minor class file features such as constant pool order. However, the class files will be semantically identical, as specified in The Java Virtual Machine Specification.  By default, the packer does not change the order of JAR elements. Also, the modification time and deflation hint of each JAR element is passed unchanged. (Any other ZIP-archive information, such as extra attributes giving Unix file permissions, are lost.)  Note that packing and unpacking a JAR will in general alter the bytewise contents of classfiles in the JAR. This means that packing and unpacking will in general invalidate any digital signatures which rely on bytewise images of JAR elements. In order both to sign and to pack a JAR, you must first pack and unpack the JAR to "normalize" it, then compute signatures on the unpacked JAR elements, and finally repack the signed JAR. Both packing steps should use precisely the same options, and the segment limit may also need to be set to "-1", to prevent accidental variation of segment boundaries as class file sizes change slightly.  (Here's why this works: Any reordering the packer does of any classfile structures is idempotent, so the second packing does not change the orderings produced by the first packing. Also, the unpacker is guaranteed by the JSR 200 specification to produce a specific bytewise image for any given transmission ordering of archive elements.)  In order to maintain backward compatibility, the pack file's version is set to accommodate the class files present in the input JAR file. In other words, the pack file version will be the latest, if the class files are the latest and conversely the pack file version will be the oldest if the class file versions are also the oldest. For intermediate class file versions the corresponding pack file version will be used. For example: If the input JAR-files are solely comprised of 1.5 (or lesser) class files, a 1.5 compatible pack file is produced. This will also be the case for archives that have no class files. If the input JAR-files contains a 1.6 class file, then the pack file version will be set to 1.6.  Note: Unless otherwise noted, passing a null argument to a constructor or method in this class will cause a NullPointerException to be thrown. 
java.util.jar.Pack200.Packer.addPropertyChangeListener	(	PropertyChangeListener	): Registers a listener for PropertyChange events on the properties map. This is typically used by applications to update a progress bar.  The default implementation of this method does nothing and has no side-effects. WARNING: This method is omitted from the interface declaration in all subset Profiles of Java SE that do not include the java.beans package. 
java.util.jar.Pack200.Packer.pack	(	JarFile	OutputStream	): Takes a JarFile and converts it into a Pack200 archive.  Closes its input but not its output. (Pack200 archives are appendable.)
java.util.jar.Pack200.Packer.pack	(	JarInputStream	OutputStream	): Takes a JarInputStream and converts it into a Pack200 archive.  Closes its input but not its output. (Pack200 archives are appendable.)  The modification time and deflation hint attributes are not available, for the JAR manifest file and its containing directory.
java.util.jar.Pack200.Packer.properties	(	): Get the set of this engine's properties. This set is a "live view", so that changing its contents immediately affects the Packer engine, and changes from the engine (such as progress indications) are immediately visible in the map. The property map may contain pre-defined implementation specific and default properties. Users are encouraged to read the information and fully understand the implications, before modifying pre-existing properties.  Implementation specific properties are prefixed with a package name associated with the implementor, beginning with com. or a similar prefix. All property names beginning with pack. and unpack. are reserved for use by this API.  Unknown properties may be ignored or rejected with an unspecified error, and invalid entries may cause an unspecified error to be thrown.  The returned map implements all optional SortedMap operations
java.util.jar.Pack200.Packer.removePropertyChangeListener	(	PropertyChangeListener	): Remove a listener for PropertyChange events, added by the addPropertyChangeListener.  The default implementation of this method does nothing and has no side-effects. WARNING: This method is omitted from the interface declaration in all subset Profiles of Java SE that do not include the java.beans package. 
java.util.jar.Pack200.Unpacker: The unpacker engine converts the packed stream to a JAR file. An instance of the engine can be obtained using newUnpacker.  Every JAR file produced by this engine will include the string "PACK200" as a zip file comment. This allows a deployer to detect if a JAR archive was packed and unpacked.  Note: Unless otherwise noted, passing a null argument to a constructor or method in this class will cause a NullPointerException to be thrown.  This version of the unpacker is compatible with all previous versions.
java.util.jar.Pack200.Unpacker.addPropertyChangeListener	(	PropertyChangeListener	): Registers a listener for PropertyChange events on the properties map. This is typically used by applications to update a progress bar.  The default implementation of this method does nothing and has no side-effects. WARNING: This method is omitted from the interface declaration in all subset Profiles of Java SE that do not include the java.beans package. 
java.util.jar.Pack200.Unpacker.properties	(	): Get the set of this engine's properties. This set is a "live view", so that changing its contents immediately affects the Packer engine, and changes from the engine (such as progress indications) are immediately visible in the map. The property map may contain pre-defined implementation specific and default properties. Users are encouraged to read the information and fully understand the implications, before modifying pre-existing properties.  Implementation specific properties are prefixed with a package name associated with the implementor, beginning with com. or a similar prefix. All property names beginning with pack. and unpack. are reserved for use by this API.  Unknown properties may be ignored or rejected with an unspecified error, and invalid entries may cause an unspecified error to be thrown.
java.util.jar.Pack200.Unpacker.removePropertyChangeListener	(	PropertyChangeListener	): Remove a listener for PropertyChange events, added by the addPropertyChangeListener.  The default implementation of this method does nothing and has no side-effects. WARNING: This method is omitted from the interface declaration in all subset Profiles of Java SE that do not include the java.beans package. 
java.util.jar.Pack200.Unpacker.unpack	(	File	JarOutputStream	): Read a Pack200 archive, and write the encoded JAR to a JarOutputStream.  Does not close its output. (The output can accumulate more elements.)
java.util.jar.Pack200.Unpacker.unpack	(	InputStream	JarOutputStream	): Read a Pack200 archive, and write the encoded JAR to a JarOutputStream. The entire contents of the input stream will be read. It may be more efficient to read the Pack200 archive to a file and pass the File object, using the alternate method described below.  Closes its input but not its output. (The output can accumulate more elements.)
java.util.jar.Pack200.newPacker	(	): Obtain new instance of a class that implements Packer.  If the system property java.util.jar.Pack200.Packer is defined, then the value is taken to be the fully-qualified name of a concrete implementation class, which must implement Packer. This class is loaded and instantiated. If this process fails then an unspecified error is thrown. If an implementation has not been specified with the system property, then the system-default implementation class is instantiated, and the result is returned.  Note: The returned object is not guaranteed to operate correctly if multiple threads use it at the same time. A multi-threaded application should either allocate multiple packer engines, or else serialize use of one engine with a lock.
java.util.jar.Pack200.newUnpacker	(	): Obtain new instance of a class that implements Unpacker.  If the system property java.util.jar.Pack200.Unpacker is defined, then the value is taken to be the fully-qualified name of a concrete implementation class, which must implement Unpacker. The class is loaded and instantiated. If this process fails then an unspecified error is thrown. If an implementation has not been specified with the system property, then the system-default implementation class is instantiated, and the result is returned.  Note: The returned object is not guaranteed to operate correctly if multiple threads use it at the same time. A multi-threaded application should either allocate multiple unpacker engines, or else serialize use of one engine with a lock.
java.util.logging.ConsoleHandler: This Handler publishes log records to System.err. By default the SimpleFormatter is used to generate brief summaries.  Configuration: By default each ConsoleHandler is initialized using the following LogManager configuration properties where  refers to the fully-qualified class name of the handler. If properties are not defined (or have invalid values) then the specified default values are used.   <handler-name>.level specifies the default level for the Handler (defaults to Level.INFO).   <handler-name>.filter specifies the name of a Filter class to use (defaults to no Filter).   <handler-name>.formatter specifies the name of a Formatter class to use (defaults to java.util.logging.SimpleFormatter).   <handler-name>.encoding the name of the character set encoding to use (defaults to the default platform encoding).    For example, the properties for ConsoleHandler would be:   java.util.logging.ConsoleHandler.level=INFO   java.util.logging.ConsoleHandler.formatter=java.util.logging.SimpleFormatter    For a custom handler, e.g. com.foo.MyHandler, the properties would be:   com.foo.MyHandler.level=INFO   com.foo.MyHandler.formatter=java.util.logging.SimpleFormatter   
java.util.logging.ConsoleHandler.ConsoleHandler	(	): Create a ConsoleHandler for System.err.  The ConsoleHandler is configured based on LogManager properties (or their default values).
java.util.logging.ConsoleHandler.close	(	): Override StreamHandler.close to do a flush but not to close the output stream. That is, we do not close System.err.
java.util.logging.ConsoleHandler.publish	(	LogRecord	): Publish a LogRecord.  The logging request was made initially to a Logger object, which initialized the LogRecord and forwarded it here. 
java.util.logging.ErrorManager: ErrorManager objects can be attached to Handlers to process any error that occurs on a Handler during Logging.  When processing logging output, if a Handler encounters problems then rather than throwing an Exception back to the issuer of the logging call (who is unlikely to be interested) the Handler should call its associated ErrorManager.
java.util.logging.ErrorManager.error	(	String	Exception	int	): The error method is called when a Handler failure occurs.  This method may be overridden in subclasses. The default behavior in this base class is that the first call is reported to System.err, and subsequent calls are ignored.
java.util.logging.FileHandler: Simple file logging Handler.  The FileHandler can either write to a specified file, or it can write to a rotating set of files.  For a rotating set of files, as each file reaches a given size limit, it is closed, rotated out, and a new file opened. Successively older files are named by adding "0", "1", "2", etc. into the base filename.  By default buffering is enabled in the IO libraries but each log record is flushed out when it is complete.  By default the XMLFormatter class is used for formatting.  Configuration: By default each FileHandler is initialized using the following LogManager configuration properties where <handler-name> refers to the fully-qualified class name of the handler. If properties are not defined (or have invalid values) then the specified default values are used.   <handler-name>.level specifies the default level for the Handler (defaults to Level.ALL).   <handler-name>.filter specifies the name of a Filter class to use (defaults to no Filter).   <handler-name>.formatter specifies the name of a Formatter class to use (defaults to java.util.logging.XMLFormatter)   <handler-name>.encoding the name of the character set encoding to use (defaults to the default platform encoding).   <handler-name>.limit specifies an approximate maximum amount to write (in bytes) to any one file. If this is zero, then there is no limit. (Defaults to no limit).   <handler-name>.count specifies how many output files to cycle through (defaults to 1).   <handler-name>.pattern specifies a pattern for generating the output file name. See below for details. (Defaults to "%h/java%u.log").   <handler-name>.append specifies whether the FileHandler should append onto any existing files (defaults to false).    For example, the properties for FileHandler would be:   java.util.logging.FileHandler.level=INFO   java.util.logging.FileHandler.formatter=java.util.logging.SimpleFormatter    For a custom handler, e.g. com.foo.MyHandler, the properties would be:   com.foo.MyHandler.level=INFO   com.foo.MyHandler.formatter=java.util.logging.SimpleFormatter    A pattern consists of a string that includes the following special components that will be replaced at runtime:   "/" the local pathname separator   "%t" the system temporary directory   "%h" the value of the "user.home" system property   "%g" the generation number to distinguish rotated logs   "%u" a unique number to resolve conflicts   "%%" translates to a single percent sign "%"   If no "%g" field has been specified and the file count is greater than one, then the generation number will be added to the end of the generated filename, after a dot.  Thus for example a pattern of "%t/java%g.log" with a count of 2 would typically cause log files to be written on Solaris to /var/tmp/java0.log and /var/tmp/java1.log whereas on Windows 95 they would be typically written to C:\TEMP\java0.log and C:\TEMP\java1.log  Generation numbers follow the sequence 0, 1, 2, etc.  Normally the "%u" unique field is set to 0. However, if the FileHandler tries to open the filename and finds the file is currently in use by another process it will increment the unique number field and try again. This will be repeated until FileHandler finds a file name that is not currently in use. If there is a conflict and no "%u" field has been specified, it will be added at the end of the filename after a dot. (This will be after any automatically added generation number.)  Thus if three processes were all trying to log to fred%u.%g.txt then they might end up using fred0.0.txt, fred1.0.txt, fred2.0.txt as the first file in their rotating sequences.  Note that the use of unique ids to avoid conflicts is only guaranteed to work reliably when using a local disk file system.
java.util.logging.FileHandler.FileHandler	(	): Construct a default FileHandler. This will be configured entirely from LogManager properties (or their default values). 
java.util.logging.FileHandler.FileHandler	(	String	): Initialize a FileHandler to write to the given filename.  The FileHandler is configured based on LogManager properties (or their default values) except that the given pattern argument is used as the filename pattern, the file limit is set to no limit, and the file count is set to one.  There is no limit on the amount of data that may be written, so use this with care.
java.util.logging.FileHandler.FileHandler	(	String	boolean	): Initialize a FileHandler to write to the given filename, with optional append.  The FileHandler is configured based on LogManager properties (or their default values) except that the given pattern argument is used as the filename pattern, the file limit is set to no limit, the file count is set to one, and the append mode is set to the given append argument.  There is no limit on the amount of data that may be written, so use this with care.
java.util.logging.FileHandler.FileHandler	(	String	int	int	): Initialize a FileHandler to write to a set of files. When (approximately) the given limit has been written to one file, another file will be opened. The output will cycle through a set of count files.  The FileHandler is configured based on LogManager properties (or their default values) except that the given pattern argument is used as the filename pattern, the file limit is set to the limit argument, and the file count is set to the given count argument.  The count must be at least 1.
java.util.logging.FileHandler.FileHandler	(	String	int	int	boolean	): Initialize a FileHandler to write to a set of files with optional append. When (approximately) the given limit has been written to one file, another file will be opened. The output will cycle through a set of count files.  The FileHandler is configured based on LogManager properties (or their default values) except that the given pattern argument is used as the filename pattern, the file limit is set to the limit argument, and the file count is set to the given count argument, and the append mode is set to the given append argument.  The count must be at least 1.
java.util.logging.FileHandler.MeteredStream: A metered stream is a subclass of OutputStream that (a) forwards all its output to a target stream (b) keeps track of how many bytes have been written
java.util.logging.FileHandler.close	(	): Close all the files.
java.util.logging.FileHandler.configure	(	): Configure a FileHandler from LogManager properties and/or default values as specified in the class javadoc.
java.util.logging.FileHandler.generate	(	String	int	int	): Generate a file based on a user-supplied pattern, generation number, and an integer uniqueness suffix
java.util.logging.FileHandler.isSetUID	(	): check if we are in a set UID program.
java.util.logging.FileHandler.openFiles	(	): Open the set of output files, based on the configured instance variables.
java.util.logging.FileHandler.publish	(	LogRecord	): Format and publish a LogRecord.
java.util.logging.FileHandler.rotate	(	): Rotate the set of output files
java.util.logging.Filter: A Filter can be used to provide fine grain control over what is logged, beyond the control provided by log levels.  Each Logger and each Handler can have a filter associated with it. The Logger or Handler will call the isLoggable method to check if a given LogRecord should be published. If isLoggable returns false, the LogRecord will be discarded.
java.util.logging.Filter.isLoggable	(	LogRecord	): Check if a given log record should be published.
java.util.logging.Formatter: A Formatter provides support for formatting LogRecords.  Typically each logging Handler will have a Formatter associated with it. The Formatter takes a LogRecord and converts it to a string.  Some formatters (such as the XMLFormatter) need to wrap head and tail strings around a set of formatted records. The getHeader and getTail methods can be used to obtain these strings.
java.util.logging.Formatter.Formatter	(	): Construct a new formatter.
java.util.logging.Formatter.format	(	LogRecord	): Format the given log record and return the formatted string.  The resulting formatted String will normally include a localized and formatted version of the LogRecord's message field. It is recommended to use the formatMessage convenience method to localize and format the message field.
java.util.logging.Formatter.formatMessage	(	LogRecord	): Localize and format the message string from a log record. This method is provided as a convenience for Formatter subclasses to use when they are performing formatting.  The message string is first localized to a format string using the record's ResourceBundle. (If there is no ResourceBundle, or if the message key is not found, then the key is used as the format string.) The format String uses java.text style formatting.  If there are no parameters, no formatter is used. Otherwise, if the string contains "{0" then java.text.MessageFormat is used to format the string. Otherwise no formatting is performed.  
java.util.logging.Formatter.getHead	(	Handler	): Return the header string for a set of formatted records.  This base class returns an empty string, but this may be overridden by subclasses.
java.util.logging.Formatter.getTail	(	Handler	): Return the tail string for a set of formatted records.  This base class returns an empty string, but this may be overridden by subclasses.
java.util.logging.Handler: A Handler object takes log messages from a Logger and exports them. It might for example, write them to a console or write them to a file, or send them to a network logging service, or forward them to an OS log, or whatever.  A Handler can be disabled by doing a setLevel(Level.OFF) and can be re-enabled by doing a setLevel with an appropriate level.  Handler classes typically use LogManager properties to set default values for the Handler's Filter, Formatter, and Level. See the specific documentation for each concrete Handler class.
java.util.logging.Handler.Handler	(	): Default constructor. The resulting Handler has a log level of Level.ALL, no Formatter, and no Filter. A default ErrorManager instance is installed as the ErrorManager.
java.util.logging.Handler.close	(	): Close the Handler and free all associated resources.  The close method will perform a flush and then close the Handler. After close has been called this Handler should no longer be used. Method calls may either be silently ignored or may throw runtime exceptions.
java.util.logging.Handler.flush	(	): Flush any buffered output.
java.util.logging.Handler.getEncoding	(	): Return the character encoding for this Handler.
java.util.logging.Handler.getErrorManager	(	): Retrieves the ErrorManager for this Handler.
java.util.logging.Handler.getFilter	(	): Get the current Filter for this Handler.
java.util.logging.Handler.getFormatter	(	): Return the Formatter for this Handler.
java.util.logging.Handler.getLevel	(	): Get the log level specifying which messages will be logged by this Handler. Message levels lower than this level will be discarded.
java.util.logging.Handler.isLoggable	(	LogRecord	): Check if this Handler would actually log a given LogRecord.  This method checks if the LogRecord has an appropriate Level and whether it satisfies any Filter. It also may make other Handler specific checks that might prevent a handler from logging the LogRecord. It will return false if the LogRecord is null. 
java.util.logging.Handler.publish	(	LogRecord	): Publish a LogRecord.  The logging request was made initially to a Logger object, which initialized the LogRecord and forwarded it here.  The Handler is responsible for formatting the message, when and if necessary. The formatting should include localization.
java.util.logging.Handler.reportError	(	String	Exception	int	): Protected convenience method to report an error to this Handler's ErrorManager. Note that this method retrieves and uses the ErrorManager without doing a security check. It can therefore be used in environments where the caller may be non-privileged.
java.util.logging.Handler.setEncoding	(	String	): Set the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.
java.util.logging.Handler.setErrorManager	(	ErrorManager	): Define an ErrorManager for this Handler.  The ErrorManager's "error" method will be invoked if any errors occur while using this Handler.
java.util.logging.Handler.setFilter	(	Filter	): Set a Filter to control output on this Handler.  For each call of publish the Handler will call this Filter (if it is non-null) to check if the LogRecord should be published or discarded.
java.util.logging.Handler.setFormatter	(	Formatter	): Set a Formatter. This Formatter will be used to format LogRecords for this Handler.  Some Handlers may not use Formatters, in which case the Formatter will be remembered, but not used. 
java.util.logging.Handler.setLevel	(	Level	): Set the log level specifying which message levels will be logged by this Handler. Message levels lower than this value will be discarded.  The intention is to allow developers to turn on voluminous logging, but to limit the messages that are sent to certain Handlers.
java.util.logging.Level: The Level class defines a set of standard logging levels that can be used to control logging output. The logging Level objects are ordered and are specified by ordered integers. Enabling logging at a given level also enables logging at all higher levels.  Clients should normally use the predefined Level constants such as Level.SEVERE.  The levels in descending order are:  SEVERE (highest value) WARNING INFO CONFIG FINE FINER FINEST (lowest value)  In addition there is a level OFF that can be used to turn off logging, and a level ALL that can be used to enable logging of all messages.  It is possible for third parties to define additional logging levels by subclassing Level. In such cases subclasses should take care to chose unique integer level values and to ensure that they maintain the Object uniqueness property across serialization by defining a suitable readResolve method.
java.util.logging.Level.Level	(	String	int	): Create a named Level with a given integer value.  Note that this constructor is "protected" to allow subclassing. In general clients of logging should use one of the constant Level objects such as SEVERE or FINEST. However, if clients need to add new logging levels, they may subclass Level and define new constants.
java.util.logging.Level.Level	(	String	int	String	): Create a named Level with a given integer value and a given localization resource name. 
java.util.logging.Level.equals	(	Object	): Compare two objects for value equality.
java.util.logging.Level.getLocalizedName	(	): Return the localized string name of the Level, for the current default locale.  If no localization information is available, the non-localized name is returned.
java.util.logging.Level.getName	(	): Return the non-localized string name of the Level.
java.util.logging.Level.getResourceBundleName	(	): Return the level's localization resource bundle name, or null if no localization bundle is defined.
java.util.logging.Level.hashCode	(	): Generate a hashcode.
java.util.logging.Level.intValue	(	): Get the integer value for this level. This integer value can be used for efficient ordering comparisons between Level objects.
java.util.logging.Level.parse	(	String	): Parse a level name string into a Level.  The argument string may consist of either a level name or an integer value.  For example:   "SEVERE"  "1000" 
java.util.logging.Level.toString	(	): Returns a string representation of this Level.
java.util.logging.LogManager: There is a single global LogManager object that is used to maintain a set of shared state about Loggers and log services.  This LogManager object:   Manages a hierarchical namespace of Logger objects. All named Loggers are stored in this namespace.  Manages a set of logging control properties. These are simple key-value pairs that can be used by Handlers and other logging objects to configure themselves.   The global LogManager object can be retrieved using LogManager.getLogManager(). The LogManager object is created during class initialization and cannot subsequently be changed.  At startup the LogManager class is located using the java.util.logging.manager system property.  The LogManager defines two optional system properties that allow control over the initial configuration:  "java.util.logging.config.class" "java.util.logging.config.file"  These two properties may be specified on the command line to the "java" command, or as system property definitions passed to JNI_CreateJavaVM.  If the "java.util.logging.config.class" property is set, then the property value is treated as a class name. The given class will be loaded, an object will be instantiated, and that object's constructor is responsible for reading in the initial configuration. (That object may use other system properties to control its configuration.) The alternate configuration class can use readConfiguration(InputStream) to define properties in the LogManager.  If "java.util.logging.config.class" property is not set, then the "java.util.logging.config.file" system property can be used to specify a properties file (in java.util.Properties format). The initial logging configuration will be read from this file.  If neither of these properties is defined then the LogManager uses its default configuration. The default configuration is typically loaded from the properties file "lib/logging.properties" in the Java installation directory.  The properties for loggers and Handlers will have names starting with the dot-separated name for the handler or logger.  The global logging properties may include:  A property "handlers". This defines a whitespace or comma separated list of class names for handler classes to load and register as handlers on the root Logger (the Logger named ""). Each class name must be for a Handler class which has a default constructor. Note that these Handlers may be created lazily, when they are first used. A property "<logger>.handlers". This defines a whitespace or comma separated list of class names for handlers classes to load and register as handlers to the specified logger. Each class name must be for a Handler class which has a default constructor. Note that these Handlers may be created lazily, when they are first used. A property "<logger>.useParentHandlers". This defines a boolean value. By default every logger calls its parent in addition to handling the logging message itself, this often result in messages being handled by the root logger as well. When setting this property to false a Handler needs to be configured for this logger otherwise no logging messages are delivered. A property "config". This property is intended to allow arbitrary configuration code to be run. The property defines a whitespace or comma separated list of class names. A new instance will be created for each named class. The default constructor of each class may execute arbitrary code to update the logging configuration, such as setting logger levels, adding handlers, adding filters, etc.   Note that all classes loaded during LogManager configuration are first searched on the system class path before any user class path. That includes the LogManager class, any config classes, and any handler classes.  Loggers are organized into a naming hierarchy based on their dot separated names. Thus "a.b.c" is a child of "a.b", but "a.b1" and a.b2" are peers.  All properties whose names end with ".level" are assumed to define log levels for Loggers. Thus "foo.level" defines a log level for the logger called "foo" and (recursively) for any of its children in the naming hierarchy. Log Levels are applied in the order they are defined in the properties file. Thus level settings for child nodes in the tree should come after settings for their parents. The property name ".level" can be used to set the level for the root of the tree.  All methods on the LogManager object are multi-thread safe.
java.util.logging.LogManager.Beans: A class that provides access to the java.beans.PropertyChangeListener and java.beans.PropertyChangeEvent without creating a static dependency on java.beans. This class can be removed once the addPropertyChangeListener and removePropertyChangeListener methods are removed.
java.util.logging.LogManager.Beans.invokePropertyChange	(	Object	Object	): Invokes the given PropertyChangeListener's propertyChange method with the given event.
java.util.logging.LogManager.Beans.isBeansPresent	(	): Returns true if java.beans is present.
java.util.logging.LogManager.Beans.newPropertyChangeEvent	(	Object	String	Object	Object	): Returns a new PropertyChangeEvent with the given source, property name, old and new values.
java.util.logging.LogManager.LogManager	(	): Protected constructor. This is protected so that container applications (such as J2EE containers) can subclass the object. It is non-public as it is intended that there only be one LogManager object, whose value is retrieved by calling LogManager.getLogManager.
java.util.logging.LogManager.addLogger	(	Logger	): Add a named logger. This does nothing and returns false if a logger with the same name is already registered.  The Logger factory methods call this method to register each newly created Logger.  The application should retain its own reference to the Logger object to avoid it being garbage collected. The LogManager may only retain a weak reference.
java.util.logging.LogManager.addPropertyChangeListener	(	PropertyChangeListener	): Adds an event listener to be invoked when the logging properties are re-read. Adding multiple instances of the same event Listener results in multiple entries in the property event listener table. WARNING: This method is omitted from this class in all subset Profiles of Java SE that do not include the java.beans package. 
java.util.logging.LogManager.checkAccess	(	): Check that the current context is trusted to modify the logging configuration. This requires LoggingPermission("control").  If the check fails we throw a SecurityException, otherwise we return normally.
java.util.logging.LogManager.getLogManager	(	): Returns the global LogManager object.
java.util.logging.LogManager.getLogger	(	String	): Method to find a named logger.  Note that since untrusted code may create loggers with arbitrary names this method should not be relied on to find Loggers for security sensitive logging. It is also important to note that the Logger associated with the String name may be garbage collected at any time if there is no strong reference to the Logger. The caller of this method must check the return value for null in order to properly handle the case where the Logger has been garbage collected. 
java.util.logging.LogManager.getLoggerNames	(	): Get an enumeration of known logger names.  Note: Loggers may be added dynamically as new classes are loaded. This method only reports on the loggers that are currently registered. It is also important to note that this method only returns the name of a Logger, not a strong reference to the Logger itself. The returned String does nothing to prevent the Logger from being garbage collected. In particular, if the returned name is passed to LogManager.getLogger(), then the caller must check the return value from LogManager.getLogger() for null to properly handle the case where the Logger has been garbage collected in the time since its name was returned by this method. 
java.util.logging.LogManager.getLoggingMXBean	(	): Returns LoggingMXBean for managing loggers. An alternative way to manage loggers is through the java.lang.management.PlatformLoggingMXBean interface that can be obtained by calling:  PlatformLoggingMXBean logging = getPlatformMXBean() ManagementFactory.getPlatformMXBean(PlatformLoggingMXBean.class); 
java.util.logging.LogManager.getProperty	(	String	): Get the value of a logging property. The method returns null if the property is not found.
java.util.logging.LogManager.readConfiguration	(	): Reinitialize the logging properties and reread the logging configuration.  The same rules are used for locating the configuration properties as are used at startup. So normally the logging properties will be re-read from the same file that was used at startup.  Any log level definitions in the new configuration file will be applied using Logger.setLevel(), if the target Logger exists.  A PropertyChangeEvent will be fired after the properties are read.
java.util.logging.LogManager.readConfiguration	(	InputStream	): Reinitialize the logging properties and reread the logging configuration from the given stream, which should be in java.util.Properties format. A PropertyChangeEvent will be fired after the properties are read.  Any log level definitions in the new configuration file will be applied using Logger.setLevel(), if the target Logger exists.
java.util.logging.LogManager.removePropertyChangeListener	(	PropertyChangeListener	): Removes an event listener for property change events. If the same listener instance has been added to the listener table through multiple invocations of addPropertyChangeListener, then an equivalent number of removePropertyChangeListener invocations are required to remove all instances of that listener from the listener table.  Returns silently if the given listener is not found. WARNING: This method is omitted from this class in all subset Profiles of Java SE that do not include the java.beans package. 
java.util.logging.LogManager.reset	(	): Reset the logging configuration.  For all named loggers, the reset operation removes and closes all Handlers and (except for the root logger) sets the level to null. The root logger's level is set to Level.INFO.
java.util.logging.LogRecord: LogRecord objects are used to pass logging requests between the logging framework and individual log Handlers.  When a LogRecord is passed into the logging framework it logically belongs to the framework and should no longer be used or updated by the client application.  Note that if the client application has not specified an explicit source method name and source class name, then the LogRecord class will infer them automatically when they are first accessed (due to a call on getSourceMethodName or getSourceClassName) by analyzing the call stack. Therefore, if a logging Handler wants to pass off a LogRecord to another thread, or to transmit it over RMI, and if it wishes to subsequently obtain method name or class name information it should call one of getSourceClassName or getSourceMethodName to force the values to be filled in.   Serialization notes:  The LogRecord class is serializable.  Because objects in the parameters array may not be serializable, during serialization all objects in the parameters array are written as the corresponding Strings (using Object.toString).  The ResourceBundle is not transmitted as part of the serialized form, but the resource bundle name is, and the recipient object's readObject method will attempt to locate a suitable resource bundle. 
java.util.logging.LogRecord.LogRecord	(	Level	String	): Construct a LogRecord with the given level and message values.  The sequence property will be initialized with a new unique value. These sequence values are allocated in increasing order within a VM.  The millis property will be initialized to the current time.  The thread ID property will be initialized with a unique ID for the current thread.  All other properties will be initialized to "null".
java.util.logging.LogRecord.defaultThreadID	(	): Returns the default value for a new LogRecord's threadID.
java.util.logging.LogRecord.getLevel	(	): Get the logging message level, for example Level.SEVERE.
java.util.logging.LogRecord.getLoggerName	(	): Get the source Logger's name.
java.util.logging.LogRecord.getMessage	(	): Get the "raw" log message, before localization or formatting.  May be null, which is equivalent to the empty string "".  This message may be either the final text or a localization key.  During formatting, if the source logger has a localization ResourceBundle and if that ResourceBundle has an entry for this message string, then the message string is replaced with the localized value.
java.util.logging.LogRecord.getMillis	(	): Get event time in milliseconds since 1970.
java.util.logging.LogRecord.getParameters	(	): Get the parameters to the log message.
java.util.logging.LogRecord.getResourceBundle	(	): Get the localization resource bundle  This is the ResourceBundle that should be used to localize the message string before formatting it. The result may be null if the message is not localizable, or if no suitable ResourceBundle is available.
java.util.logging.LogRecord.getResourceBundleName	(	): Get the localization resource bundle name  This is the name for the ResourceBundle that should be used to localize the message string before formatting it. The result may be null if the message is not localizable.
java.util.logging.LogRecord.getSequenceNumber	(	): Get the sequence number.  Sequence numbers are normally assigned in the LogRecord constructor, which assigns unique sequence numbers to each new LogRecord in increasing order.
java.util.logging.LogRecord.getSourceClassName	(	): Get the name of the class that (allegedly) issued the logging request.  Note that this sourceClassName is not verified and may be spoofed. This information may either have been provided as part of the logging call, or it may have been inferred automatically by the logging framework. In the latter case, the information may only be approximate and may in fact describe an earlier call on the stack frame.  May be null if no information could be obtained.
java.util.logging.LogRecord.getSourceMethodName	(	): Get the name of the method that (allegedly) issued the logging request.  Note that this sourceMethodName is not verified and may be spoofed. This information may either have been provided as part of the logging call, or it may have been inferred automatically by the logging framework. In the latter case, the information may only be approximate and may in fact describe an earlier call on the stack frame.  May be null if no information could be obtained.
java.util.logging.LogRecord.getThreadID	(	): Get an identifier for the thread where the message originated.  This is a thread identifier within the Java VM and may or may not map to any operating system ID.
java.util.logging.LogRecord.getThrown	(	): Get any throwable associated with the log record.  If the event involved an exception, this will be the exception object. Otherwise null.
java.util.logging.LogRecord.setLevel	(	Level	): Set the logging message level, for example Level.SEVERE.
java.util.logging.LogRecord.setLoggerName	(	String	): Set the source Logger's name.
java.util.logging.LogRecord.setMessage	(	String	): Set the "raw" log message, before localization or formatting.
java.util.logging.LogRecord.setMillis	(	long	): Set event time.
java.util.logging.LogRecord.setParameters	(	Object	): Set the parameters to the log message.
java.util.logging.LogRecord.setResourceBundle	(	ResourceBundle	): Set the localization resource bundle.
java.util.logging.LogRecord.setResourceBundleName	(	String	): Set the localization resource bundle name.
java.util.logging.LogRecord.setSequenceNumber	(	long	): Set the sequence number.  Sequence numbers are normally assigned in the LogRecord constructor, so it should not normally be necessary to use this method.
java.util.logging.LogRecord.setSourceClassName	(	String	): Set the name of the class that (allegedly) issued the logging request.
java.util.logging.LogRecord.setSourceMethodName	(	String	): Set the name of the method that (allegedly) issued the logging request.
java.util.logging.LogRecord.setThreadID	(	int	): Set an identifier for the thread where the message originated.
java.util.logging.LogRecord.setThrown	(	Throwable	): Set a throwable associated with the log event.
java.util.logging.LogRecord.writeObject	(	ObjectOutputStream	): 
java.util.logging.Logger: A Logger object is used to log messages for a specific system or application component. Loggers are normally named, using a hierarchical dot-separated namespace. Logger names can be arbitrary strings, but they should normally be based on the package name or class name of the logged component, such as java.net or javax.swing. In addition it is possible to create "anonymous" Loggers that are not stored in the Logger namespace.  Logger objects may be obtained by calls on one of the getLogger factory methods. These will either create a new Logger or return a suitable existing Logger. It is important to note that the Logger returned by one of the getLogger factory methods may be garbage collected at any time if a strong reference to the Logger is not kept.  Logging messages will be forwarded to registered Handler objects, which can forward the messages to a variety of destinations, including consoles, files, OS logs, etc.  Each Logger keeps track of a "parent" Logger, which is its nearest existing ancestor in the Logger namespace.  Each Logger has a "Level" associated with it. This reflects a minimum Level that this logger cares about. If a Logger's level is set to null, then its effective level is inherited from its parent, which may in turn obtain it recursively from its parent, and so on up the tree.  The log level can be configured based on the properties from the logging configuration file, as described in the description of the LogManager class. However it may also be dynamically changed by calls on the Logger.setLevel method. If a logger's level is changed the change may also affect child loggers, since any child logger that has null as its level will inherit its effective level from its parent.  On each logging call the Logger initially performs a cheap check of the request level (e.g., SEVERE or FINE) against the effective log level of the logger. If the request level is lower than the log level, the logging call returns immediately.  After passing this initial (cheap) test, the Logger will allocate a LogRecord to describe the logging message. It will then call a Filter (if present) to do a more detailed check on whether the record should be published. If that passes it will then publish the LogRecord to its output Handlers. By default, loggers also publish to their parent's Handlers, recursively up the tree.  Each Logger may have a ResourceBundle associated with it. The ResourceBundle may be specified by name, using the getLogger() factory method, or by value - using the setResourceBundle() method. This bundle will be used for localizing logging messages. If a Logger does not have its own ResourceBundle or resource bundle name, then it will inherit the ResourceBundle or resource bundle name from its parent, recursively up the tree.  Most of the logger output methods take a "msg" argument. This msg argument may be either a raw value or a localization key. During formatting, if the logger has (or inherits) a localization ResourceBundle and if the ResourceBundle has a mapping for the msg string, then the msg string is replaced by the localized value. Otherwise the original msg string is used. Typically, formatters use java.text.MessageFormat style formatting to format parameters, so for example a format string "{0} {1}" would format two parameters as strings.  A set of methods alternatively take a "msgSupplier" instead of a "msg" argument. These methods take a Supplier  function which is invoked to construct the desired log message only when the message actually is to be logged based on the effective log level thus eliminating unnecessary message construction. For example, if the developer wants to log system health status for diagnosis, with the String-accepting version, the code would look like:  class DiagnosisMessages { static String systemHealthStatus() { // collect system health information ... } } ... logger.log(Level.FINER, DiagnosisMessages.systemHealthStatus());  With the above code, the health status is collected unnecessarily even when the log level FINER is disabled. With the Supplier-accepting version as below, the status will only be collected when the log level FINER is enabled.  logger.log(Level.FINER, DiagnosisMessages::systemHealthStatus);   When looking for a ResourceBundle, the logger will first look at whether a bundle was specified using setResourceBundle(), and then only whether a resource bundle name was specified through the getLogger() factory method. If no ResourceBundle or no resource bundle name is found, then it will use the nearest ResourceBundle or resource bundle name inherited from its parent tree. When a ResourceBundle was inherited or specified through the setResourceBundle() method, then that ResourceBundle will be used. Otherwise if the logger only has or inherited a resource bundle name, then that resource bundle name will be mapped to a ResourceBundle object, using the default Locale at the time of logging. When mapping resource bundle names to ResourceBundle objects, the logger will first try to use the Thread's getContextClassLoader() context class loader to map the given resource bundle name to a ResourceBundle. If the thread context class loader is null, it will try the getSystemClassLoader() system class loader instead. If the ResourceBundle is still not found, it will use the class loader of the first caller of the getLogger() factory method.  Formatting (including localization) is the responsibility of the output Handler, which will typically call a Formatter.  Note that formatting need not occur synchronously. It may be delayed until a LogRecord is actually written to an external sink.  The logging methods are grouped in five main categories:   There are a set of "log" methods that take a log level, a message string, and optionally some parameters to the message string.  There are a set of "logp" methods (for "log precise") that are like the "log" methods, but also take an explicit source class name and method name.  There are a set of "logrb" method (for "log with resource bundle") that are like the "logp" method, but also take an explicit resource bundle object for use in localizing the log message.  There are convenience methods for tracing method entries (the "entering" methods), method returns (the "exiting" methods) and throwing exceptions (the "throwing" methods).  Finally, there are a set of convenience methods for use in the very simplest cases, when a developer simply wants to log a simple string at a given log level. These methods are named after the standard Level names ("severe", "warning", "info", etc.) and take a single argument, a message string.   For the methods that do not take an explicit source name and method name, the Logging framework will make a "best effort" to determine which class and method called into the logging method. However, it is important to realize that this automatically inferred information may only be approximate (or may even be quite wrong!). Virtual machines are allowed to do extensive optimizations when JITing and may entirely remove stack frames, making it impossible to reliably locate the calling class and method.  All methods on Logger are multi-thread safe.  Subclassing Information: Note that a LogManager class may provide its own implementation of named Loggers for any point in the namespace. Therefore, any subclasses of Logger (unless they are implemented in conjunction with a new LogManager class) should take care to obtain a Logger instance from the LogManager class and should delegate operations such as "isLoggable" and "log(LogRecord)" to that instance. Note that in order to intercept all logging output, subclasses need only override the log(LogRecord) method. All the other logging methods are implemented as calls on this log(LogRecord) method.
java.util.logging.Logger.Logger	(	String	String	): Protected method to construct a logger for a named subsystem.  The logger will be initially configured with a null Level and with useParentHandlers set to true.
java.util.logging.Logger.addHandler	(	Handler	): Add a log Handler to receive logging messages.  By default, Loggers also send their output to their parent logger. Typically the root Logger is configured with a set of Handlers that essentially act as default handlers for all loggers.
java.util.logging.Logger.config	(	String	): Log a CONFIG message.  If the logger is currently enabled for the CONFIG message level then the given message is forwarded to all the registered output Handler objects. 
java.util.logging.Logger.config	(	Supplier	): Log a CONFIG message, which is only to be constructed if the logging level is such that the message will actually be logged.  If the logger is currently enabled for the CONFIG message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects. 
java.util.logging.Logger.entering	(	String	String	): Log a method entry.  This is a convenience method that can be used to log entry to a method. A LogRecord with message "ENTRY", log level FINER, and the given sourceMethod and sourceClass is logged. 
java.util.logging.Logger.entering	(	String	String	Object	): Log a method entry, with an array of parameters.  This is a convenience method that can be used to log entry to a method. A LogRecord with message "ENTRY" (followed by a format {N} indicator for each entry in the parameter array), log level FINER, and the given sourceMethod, sourceClass, and parameters is logged. 
java.util.logging.Logger.exiting	(	String	String	): Log a method return.  This is a convenience method that can be used to log returning from a method. A LogRecord with message "RETURN", log level FINER, and the given sourceMethod and sourceClass is logged. 
java.util.logging.Logger.exiting	(	String	String	Object	): Log a method return, with result object.  This is a convenience method that can be used to log returning from a method. A LogRecord with message "RETURN {0}", log level FINER, and the gives sourceMethod, sourceClass, and result object is logged. 
java.util.logging.Logger.findResourceBundle	(	String	boolean	): Private utility method to map a resource bundle name to an actual resource bundle, using a simple one-entry cache. Returns null for a null name. May also return null if we can't find the resource bundle and there is no suitable previous cached value.
java.util.logging.Logger.fine	(	String	): Log a FINE message.  If the logger is currently enabled for the FINE message level then the given message is forwarded to all the registered output Handler objects. 
java.util.logging.Logger.fine	(	Supplier	): Log a FINE message, which is only to be constructed if the logging level is such that the message will actually be logged.  If the logger is currently enabled for the FINE message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects. 
java.util.logging.Logger.finer	(	String	): Log a FINER message.  If the logger is currently enabled for the FINER message level then the given message is forwarded to all the registered output Handler objects. 
java.util.logging.Logger.finer	(	Supplier	): Log a FINER message, which is only to be constructed if the logging level is such that the message will actually be logged.  If the logger is currently enabled for the FINER message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects. 
java.util.logging.Logger.finest	(	String	): Log a FINEST message.  If the logger is currently enabled for the FINEST message level then the given message is forwarded to all the registered output Handler objects. 
java.util.logging.Logger.finest	(	Supplier	): Log a FINEST message, which is only to be constructed if the logging level is such that the message will actually be logged.  If the logger is currently enabled for the FINEST message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects. 
java.util.logging.Logger.getAnonymousLogger	(	): Create an anonymous Logger. The newly created Logger is not registered in the LogManager namespace. There will be no access checks on updates to the logger.  This factory method is primarily intended for use from applets. Because the resulting Logger is anonymous it can be kept private by the creating class. This removes the need for normal security checks, which in turn allows untrusted applet code to update the control state of the Logger. For example an applet can do a setLevel or an addHandler on an anonymous Logger.  Even although the new logger is anonymous, it is configured to have the root logger ("") as its parent. This means that by default it inherits its effective level and handlers from the root logger. Changing its parent via the setParent() method will still require the security permission specified by that method. 
java.util.logging.Logger.getAnonymousLogger	(	String	): Create an anonymous Logger. The newly created Logger is not registered in the LogManager namespace. There will be no access checks on updates to the logger.  This factory method is primarily intended for use from applets. Because the resulting Logger is anonymous it can be kept private by the creating class. This removes the need for normal security checks, which in turn allows untrusted applet code to update the control state of the Logger. For example an applet can do a setLevel or an addHandler on an anonymous Logger.  Even although the new logger is anonymous, it is configured to have the root logger ("") as its parent. This means that by default it inherits its effective level and handlers from the root logger. Changing its parent via the setParent() method will still require the security permission specified by that method. 
java.util.logging.Logger.getFilter	(	): Get the current filter for this Logger.
java.util.logging.Logger.getGlobal	(	): Return global logger object with the name Logger.GLOBAL_LOGGER_NAME.
java.util.logging.Logger.getHandlers	(	): Get the Handlers associated with this logger. 
java.util.logging.Logger.getLevel	(	): Get the log Level that has been specified for this Logger. The result may be null, which means that this logger's effective level will be inherited from its parent.
java.util.logging.Logger.getLogger	(	String	): Find or create a logger for a named subsystem. If a logger has already been created with the given name it is returned. Otherwise a new logger is created.  If a new logger is created its log level will be configured based on the LogManager configuration and it will configured to also send logging output to its parent's Handlers. It will be registered in the LogManager global namespace.  Note: The LogManager may only retain a weak reference to the newly created Logger. It is important to understand that a previously created Logger with the given name may be garbage collected at any time if there is no strong reference to the Logger. In particular, this means that two back-to-back calls like getLogger("MyLogger").log(...) may use different Logger objects named "MyLogger" if there is no strong reference to the Logger named "MyLogger" elsewhere in the program.
java.util.logging.Logger.getLogger	(	String	String	): Find or create a logger for a named subsystem. If a logger has already been created with the given name it is returned. Otherwise a new logger is created.  If a new logger is created its log level will be configured based on the LogManager and it will configured to also send logging output to its parent's Handlers. It will be registered in the LogManager global namespace.  Note: The LogManager may only retain a weak reference to the newly created Logger. It is important to understand that a previously created Logger with the given name may be garbage collected at any time if there is no strong reference to the Logger. In particular, this means that two back-to-back calls like getLogger("MyLogger", ...).log(...) may use different Logger objects named "MyLogger" if there is no strong reference to the Logger named "MyLogger" elsewhere in the program.  If the named Logger already exists and does not yet have a localization resource bundle then the given resource bundle name is used. If the named Logger already exists and has a different resource bundle name then an IllegalArgumentException is thrown. 
java.util.logging.Logger.getName	(	): Get the name for this logger.
java.util.logging.Logger.getParent	(	): Return the parent for this Logger.  This method returns the nearest extant parent in the namespace. Thus if a Logger is called "a.b.c.d", and a Logger called "a.b" has been created but no logger "a.b.c" exists, then a call of getParent on the Logger "a.b.c.d" will return the Logger "a.b".  The result will be null if it is called on the root Logger in the namespace.
java.util.logging.Logger.getResourceBundle	(	): Retrieve the localization resource bundle for this logger. This method will return a ResourceBundle that was either set by the setResourceBundle() method or mapped from the the resource bundle name set via the getLogger() factory method for the current default locale. Note that if the result is null, then the Logger will use a resource bundle or resource bundle name inherited from its parent.
java.util.logging.Logger.getResourceBundleName	(	): Retrieve the localization resource bundle name for this logger. This is either the name specified through the getLogger() factory method, or the getBaseBundleName() base name of the ResourceBundle set through setResourceBundle() method. Note that if the result is null, then the Logger will use a resource bundle or resource bundle name inherited from its parent.
java.util.logging.Logger.getUseParentHandlers	(	): Discover whether or not this logger is sending its output to its parent logger.
java.util.logging.Logger.info	(	String	): Log an INFO message.  If the logger is currently enabled for the INFO message level then the given message is forwarded to all the registered output Handler objects. 
java.util.logging.Logger.info	(	Supplier	): Log a INFO message, which is only to be constructed if the logging level is such that the message will actually be logged.  If the logger is currently enabled for the INFO message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects. 
java.util.logging.Logger.isLoggable	(	Level	): Check if a message of the given level would actually be logged by this logger. This check is based on the Loggers effective level, which may be inherited from its parent.
java.util.logging.Logger.log	(	Level	String	): Log a message, with no arguments.  If the logger is currently enabled for the given message level then the given message is forwarded to all the registered output Handler objects. 
java.util.logging.Logger.log	(	Level	String	Object	): Log a message, with an array of object arguments.  If the logger is currently enabled for the given message level then a corresponding LogRecord is created and forwarded to all the registered output Handler objects. 
java.util.logging.Logger.log	(	Level	String	Throwable	): Log a message, with associated Throwable information.  If the logger is currently enabled for the given message level then the given arguments are stored in a LogRecord which is forwarded to all registered output handlers.  Note that the thrown argument is stored in the LogRecord thrown property, rather than the LogRecord parameters property. Thus it is processed specially by output Formatters and is not treated as a formatting parameter to the LogRecord message property. 
java.util.logging.Logger.log	(	Level	Supplier	): Log a message, which is only to be constructed if the logging level is such that the message will actually be logged.  If the logger is currently enabled for the given message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects. 
java.util.logging.Logger.log	(	Level	Throwable	Supplier	): Log a lazily constructed message, with associated Throwable information.  If the logger is currently enabled for the given message level then the message is constructed by invoking the provided supplier function. The message and the given Throwable are then stored in a LogRecord which is forwarded to all registered output handlers.  Note that the thrown argument is stored in the LogRecord thrown property, rather than the LogRecord parameters property. Thus it is processed specially by output Formatters and is not treated as a formatting parameter to the LogRecord message property. 
java.util.logging.Logger.log	(	LogRecord	): Log a LogRecord.  All the other logging methods in this class call through this method to actually perform any logging. Subclasses can override this single method to capture all log activity.
java.util.logging.Logger.logp	(	Level	String	String	String	): Log a message, specifying source class and method, with no arguments.  If the logger is currently enabled for the given message level then the given message is forwarded to all the registered output Handler objects. 
java.util.logging.Logger.logp	(	Level	String	String	String	Object	): Log a message, specifying source class and method, with an array of object arguments.  If the logger is currently enabled for the given message level then a corresponding LogRecord is created and forwarded to all the registered output Handler objects. 
java.util.logging.Logger.logp	(	Level	String	String	String	Throwable	): Log a message, specifying source class and method, with associated Throwable information.  If the logger is currently enabled for the given message level then the given arguments are stored in a LogRecord which is forwarded to all registered output handlers.  Note that the thrown argument is stored in the LogRecord thrown property, rather than the LogRecord parameters property. Thus it is processed specially by output Formatters and is not treated as a formatting parameter to the LogRecord message property. 
java.util.logging.Logger.logp	(	Level	String	String	Supplier	): Log a lazily constructed message, specifying source class and method, with no arguments.  If the logger is currently enabled for the given message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects. 
java.util.logging.Logger.logp	(	Level	String	String	Throwable	Supplier	): Log a lazily constructed message, specifying source class and method, with associated Throwable information.  If the logger is currently enabled for the given message level then the message is constructed by invoking the provided supplier function. The message and the given Throwable are then stored in a LogRecord which is forwarded to all registered output handlers.  Note that the thrown argument is stored in the LogRecord thrown property, rather than the LogRecord parameters property. Thus it is processed specially by output Formatters and is not treated as a formatting parameter to the LogRecord message property. 
java.util.logging.Logger.logrb	(	Level	String	String	ResourceBundle	String	Object	): Log a message, specifying source class, method, and resource bundle, with an optional list of message parameters.  If the logger is currently enabled for the given message level then a corresponding LogRecord is created and forwarded to all the registered output Handler objects.  The msg string is localized using the given resource bundle. If the resource bundle is null, then the msg string is not localized. 
java.util.logging.Logger.logrb	(	Level	String	String	ResourceBundle	String	Throwable	): Log a message, specifying source class, method, and resource bundle, with associated Throwable information.  If the logger is currently enabled for the given message level then the given arguments are stored in a LogRecord which is forwarded to all registered output handlers.  The msg string is localized using the given resource bundle. If the resource bundle is null, then the msg string is not localized.  Note that the thrown argument is stored in the LogRecord thrown property, rather than the LogRecord parameters property. Thus it is processed specially by output Formatters and is not treated as a formatting parameter to the LogRecord message property. 
java.util.logging.Logger.logrb	(	Level	String	String	String	String	): Log a message, specifying source class, method, and resource bundle name with no arguments.  If the logger is currently enabled for the given message level then the given message is forwarded to all the registered output Handler objects.  The msg string is localized using the named resource bundle. If the resource bundle name is null, or an empty String or invalid then the msg string is not localized. 
java.util.logging.Logger.logrb	(	Level	String	String	String	String	Object	): Log a message, specifying source class, method, and resource bundle name, with an array of object arguments.  If the logger is currently enabled for the given message level then a corresponding LogRecord is created and forwarded to all the registered output Handler objects.  The msg string is localized using the named resource bundle. If the resource bundle name is null, or an empty String or invalid then the msg string is not localized. 
java.util.logging.Logger.logrb	(	Level	String	String	String	String	Throwable	): Log a message, specifying source class, method, and resource bundle name, with associated Throwable information.  If the logger is currently enabled for the given message level then the given arguments are stored in a LogRecord which is forwarded to all registered output handlers.  The msg string is localized using the named resource bundle. If the resource bundle name is null, or an empty String or invalid then the msg string is not localized.  Note that the thrown argument is stored in the LogRecord thrown property, rather than the LogRecord parameters property. Thus it is processed specially by output Formatters and is not treated as a formatting parameter to the LogRecord message property. 
java.util.logging.Logger.removeHandler	(	Handler	): Remove a log Handler.  Returns silently if the given Handler is not found or is null
java.util.logging.Logger.setFilter	(	Filter	): Set a filter to control output on this Logger.  After passing the initial "level" check, the Logger will call this Filter to check if a log record should really be published.
java.util.logging.Logger.setLevel	(	Level	): Set the log level specifying which message levels will be logged by this logger. Message levels lower than this value will be discarded. The level value Level.OFF can be used to turn off logging.  If the new level is null, it means that this node should inherit its level from its nearest ancestor with a specific (non-null) level value.
java.util.logging.Logger.setParent	(	Logger	): Set the parent for this Logger. This method is used by the LogManager to update a Logger when the namespace changes.  It should not be called from application code. 
java.util.logging.Logger.setResourceBundle	(	ResourceBundle	): Sets a resource bundle on this logger. All messages will be logged using the given resource bundle for its specific getLocale locale.
java.util.logging.Logger.setUseParentHandlers	(	boolean	): Specify whether or not this logger should send its output to its parent Logger. This means that any LogRecords will also be written to the parent's Handlers, and potentially to its parent, recursively up the namespace.
java.util.logging.Logger.severe	(	String	): Log a SEVERE message.  If the logger is currently enabled for the SEVERE message level then the given message is forwarded to all the registered output Handler objects. 
java.util.logging.Logger.severe	(	Supplier	): Log a SEVERE message, which is only to be constructed if the logging level is such that the message will actually be logged.  If the logger is currently enabled for the SEVERE message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects. 
java.util.logging.Logger.throwing	(	String	String	Throwable	): Log throwing an exception.  This is a convenience method to log that a method is terminating by throwing an exception. The logging is done using the FINER level.  If the logger is currently enabled for the given message level then the given arguments are stored in a LogRecord which is forwarded to all registered output handlers. The LogRecord's message is set to "THROW".  Note that the thrown argument is stored in the LogRecord thrown property, rather than the LogRecord parameters property. Thus it is processed specially by output Formatters and is not treated as a formatting parameter to the LogRecord message property. 
java.util.logging.Logger.warning	(	String	): Log a WARNING message.  If the logger is currently enabled for the WARNING message level then the given message is forwarded to all the registered output Handler objects. 
java.util.logging.Logger.warning	(	Supplier	): Log a WARNING message, which is only to be constructed if the logging level is such that the message will actually be logged.  If the logger is currently enabled for the WARNING message level then the message is constructed by invoking the provided supplier function and forwarded to all the registered output Handler objects. 
java.util.logging.Logging: Logging is the implementation class of LoggingMXBean. The LoggingMXBean interface provides a standard method for management access to the individual Logger objects available at runtime.
java.util.logging.Logging.Logging	(	): Constructor of Logging which is the implementation class of LoggingMXBean.
java.util.logging.LoggingMXBean: The management interface for the logging facility. It is recommended to use the java.lang.management.PlatformLoggingMXBean management interface that implements all attributes defined in this LoggingMXBean. The getPlatformMXBean() ManagementFactory.getPlatformMXBean method can be used to obtain the PlatformLoggingMXBean object representing the management interface for logging. There is a single global instance of the LoggingMXBean. This instance is an javax.management.MXBean MXBean that can be obtained by calling the getLoggingMXBean method or from the getPlatformMBeanServer platform MBeanServer.  The javax.management.ObjectName ObjectName that uniquely identifies the management interface for logging within the MBeanServer is:  LOGGING_MXBEAN_NAME java.util.logging:type=Logging   The instance registered in the platform MBeanServer is also a java.lang.management.PlatformLoggingMXBean.
java.util.logging.LoggingMXBean.getLoggerLevel	(	String	): Gets the name of the log level associated with the specified logger. If the specified logger does not exist, null is returned. This method first finds the logger of the given name and then returns the name of the log level by calling:  getLevel Logger.getLevel().getName getName();   If the Level of the specified logger is null, which means that this logger's effective level is inherited from its parent, an empty string will be returned.
java.util.logging.LoggingMXBean.getLoggerNames	(	): Returns the list of currently registered logger names. This method calls getLoggerNames and returns a list of the logger names.
java.util.logging.LoggingMXBean.getParentLoggerName	(	String	): Returns the name of the parent for the specified logger. If the specified logger does not exist, null is returned. If the specified logger is the root Logger in the namespace, the result will be an empty string.
java.util.logging.LoggingMXBean.setLoggerLevel	(	String	String	): Sets the specified logger to the specified new level. If the levelName is not null, the level of the specified logger is set to the parsed Level matching the levelName. If the levelName is null, the level of the specified logger is set to null and the effective level of the logger is inherited from its nearest ancestor with a specific (non-null) level value.
java.util.logging.LoggingPermission: The permission which the SecurityManager will check when code that is running with a SecurityManager calls one of the logging control methods (such as Logger.setLevel).  Currently there is only one named LoggingPermission. This is "control" and it grants the ability to control the logging configuration, for example by adding or removing Handlers, by adding or removing Filters, or by changing logging levels.  Programmers do not normally create LoggingPermission objects directly. Instead they are created by the security policy code based on reading the security policy file.
java.util.logging.LoggingPermission.LoggingPermission	(	String	String	): Creates a new LoggingPermission object.
java.util.logging.LoggingProxyImpl: Implementation of LoggingProxy when java.util.logging classes exist.
java.util.logging.MemoryHandler: Handler that buffers requests in a circular buffer in memory.  Normally this Handler simply stores incoming LogRecords into its memory buffer and discards earlier records. This buffering is very cheap and avoids formatting costs. On certain trigger conditions, the MemoryHandler will push out its current buffer contents to a target Handler, which will typically publish them to the outside world.  There are three main models for triggering a push of the buffer:   An incoming LogRecord has a type that is greater than a pre-defined level, the pushLevel.   An external class calls the push method explicitly.   A subclass overrides the log method and scans each incoming LogRecord and calls push if a record matches some desired criteria.    Configuration: By default each MemoryHandler is initialized using the following LogManager configuration properties where <handler-name> refers to the fully-qualified class name of the handler. If properties are not defined (or have invalid values) then the specified default values are used. If no default value is defined then a RuntimeException is thrown.   <handler-name>.level specifies the level for the Handler (defaults to Level.ALL).   <handler-name>.filter specifies the name of a Filter class to use (defaults to no Filter).   <handler-name>.size defines the buffer size (defaults to 1000).   <handler-name>.push defines the pushLevel (defaults to level.SEVERE).   <handler-name>.target specifies the name of the target Handler  class. (no default).    For example, the properties for MemoryHandler would be:   java.util.logging.MemoryHandler.level=INFO   java.util.logging.MemoryHandler.formatter=java.util.logging.SimpleFormatter    For a custom handler, e.g. com.foo.MyHandler, the properties would be:   com.foo.MyHandler.level=INFO   com.foo.MyHandler.formatter=java.util.logging.SimpleFormatter   
java.util.logging.MemoryHandler.MemoryHandler	(	): Create a MemoryHandler and configure it based on LogManager configuration properties.
java.util.logging.MemoryHandler.MemoryHandler	(	Handler	int	Level	): Create a MemoryHandler.  The MemoryHandler is configured based on LogManager properties (or their default values) except that the given pushLevel argument and buffer size argument are used.
java.util.logging.MemoryHandler.close	(	): Close the Handler and free all associated resources. This will also close the target Handler.
java.util.logging.MemoryHandler.flush	(	): Causes a flush on the target Handler.  Note that the current contents of the MemoryHandler buffer are not written out. That requires a "push".
java.util.logging.MemoryHandler.getPushLevel	(	): Get the pushLevel.
java.util.logging.MemoryHandler.isLoggable	(	LogRecord	): Check if this Handler would actually log a given LogRecord into its internal buffer.  This method checks if the LogRecord has an appropriate level and whether it satisfies any Filter. However it does not check whether the LogRecord would result in a "push" of the buffer contents. It will return false if the LogRecord is null. 
java.util.logging.MemoryHandler.publish	(	LogRecord	): Store a LogRecord in an internal buffer.  If there is a Filter, its isLoggable method is called to check if the given log record is loggable. If not we return. Otherwise the given record is copied into an internal circular buffer. Then the record's level property is compared with the pushLevel. If the given level is greater than or equal to the pushLevel then push is called to write all buffered records to the target output Handler.
java.util.logging.MemoryHandler.push	(	): Push any buffered output to the target Handler.  The buffer is then cleared.
java.util.logging.MemoryHandler.setPushLevel	(	Level	): Set the pushLevel. After a LogRecord is copied into our internal buffer, if its level is greater than or equal to the pushLevel, then push will be called.
java.util.logging.SimpleFormatter: Print a brief summary of the LogRecord in a human readable format. The summary will typically be 1 or 2 lines.   Configuration: The SimpleFormatter is initialized with the format string specified in the java.util.logging.SimpleFormatter.format property to format the log messages. This property can be defined in the getProperty logging properties configuration file or as a system property. If this property is set in both the logging properties and system properties, the format string specified in the system property will be used. If this property is not defined or the given format string is java.util.IllegalFormatException illegal, the default format is implementation-specific.
java.util.logging.SimpleFormatter.format	(	LogRecord	): Format the given LogRecord.  The formatting can be customized by specifying the format string in the  java.util.logging.SimpleFormatter.format property. The given LogRecord will be formatted as if by calling:  format String.format(format, date, source, logger, level, message, thrown);  where the arguments are:  format - the java.util.Formatter java.util.Formatter format string specified in the java.util.logging.SimpleFormatter.format property or the default format. date - a Date object representing getMillis event time of the log record. source - a string representing the caller, if available; otherwise, the logger's name. logger - the logger's name. level - the getLocalizedName log level. message - the formatted log message returned from the formatMessage() method. It uses java.text.MessageFormat java.text formatting and does not use the java.util.Formatter format argument. thrown - a string representing the getThrown throwable associated with the log record and its backtrace beginning with a newline character, if any; otherwise, an empty string.  Some example formats:   java.util.logging.SimpleFormatter.format="%4$s: %5$s [%1$tc]%n" This prints 1 line with the log level (4$), the log message (5$) and the timestamp (1$) in a square bracket.  WARNING: warning message [Tue Mar 22 13:11:31 PDT 2011]   java.util.logging.SimpleFormatter.format="%1$tc %2$s%n%4$s: %5$s%6$s%n" This prints 2 lines where the first line includes the timestamp (1$) and the source (2$); the second line includes the log level (4$) and the log message (5$) followed with the throwable and its backtrace (6$), if any:  Tue Mar 22 13:11:31 PDT 2011 MyClass fatal SEVERE: several message with an exception java.lang.IllegalArgumentException: invalid argument at MyClass.mash(MyClass.java:9) at MyClass.crunch(MyClass.java:6) at MyClass.main(MyClass.java:3)   java.util.logging.SimpleFormatter.format="%1$tb %1$td, %1$tY %1$tl:%1$tM:%1$tS %1$Tp %2$s%n%4$s: %5$s%n" This prints 2 lines similar to the example above with a different date/time formatting and does not print the throwable and its backtrace:  Mar 22, 2011 1:11:31 PM MyClass fatal SEVERE: several message with an exception   This method can also be overridden in a subclass. It is recommended to use the formatMessage convenience method to localize and format the message field.
java.util.logging.SocketHandler: Simple network logging Handler.  LogRecords are published to a network stream connection. By default the XMLFormatter class is used for formatting.  Configuration: By default each SocketHandler is initialized using the following LogManager configuration properties where <handler-name> refers to the fully-qualified class name of the handler. If properties are not defined (or have invalid values) then the specified default values are used.   <handler-name>.level specifies the default level for the Handler (defaults to Level.ALL).   <handler-name>.filter specifies the name of a Filter class to use (defaults to no Filter).   <handler-name>.formatter specifies the name of a Formatter class to use (defaults to java.util.logging.XMLFormatter).   <handler-name>.encoding the name of the character set encoding to use (defaults to the default platform encoding).   <handler-name>.host specifies the target host name to connect to (no default).   <handler-name>.port specifies the target TCP port to use (no default).    For example, the properties for SocketHandler would be:   java.util.logging.SocketHandler.level=INFO   java.util.logging.SocketHandler.formatter=java.util.logging.SimpleFormatter    For a custom handler, e.g. com.foo.MyHandler, the properties would be:   com.foo.MyHandler.level=INFO   com.foo.MyHandler.formatter=java.util.logging.SimpleFormatter    The output IO stream is buffered, but is flushed after each LogRecord is written.
java.util.logging.SocketHandler.SocketHandler	(	): Create a SocketHandler, using only LogManager properties (or their defaults).
java.util.logging.SocketHandler.SocketHandler	(	String	int	): Construct a SocketHandler using a specified host and port. The SocketHandler is configured based on LogManager properties (or their default values) except that the given target host and port arguments are used. If the host argument is empty, but not null String then the localhost is used.
java.util.logging.SocketHandler.close	(	): Close this output stream.
java.util.logging.SocketHandler.publish	(	LogRecord	): Format and publish a LogRecord.
java.util.logging.StreamHandler: Stream based logging Handler.  This is primarily intended as a base class or support class to be used in implementing other logging Handlers.  LogRecords are published to a given java.io.OutputStream.  Configuration: By default each StreamHandler is initialized using the following LogManager configuration properties where <handler-name> refers to the fully-qualified class name of the handler. If properties are not defined (or have invalid values) then the specified default values are used.   <handler-name>.level specifies the default level for the Handler (defaults to Level.INFO).   <handler-name>.filter specifies the name of a Filter class to use (defaults to no Filter).   <handler-name>.formatter specifies the name of a Formatter class to use (defaults to java.util.logging.SimpleFormatter).   <handler-name>.encoding the name of the character set encoding to use (defaults to the default platform encoding).    For example, the properties for StreamHandler would be:   java.util.logging.StreamHandler.level=INFO   java.util.logging.StreamHandler.formatter=java.util.logging.SimpleFormatter    For a custom handler, e.g. com.foo.MyHandler, the properties would be:   com.foo.MyHandler.level=INFO   com.foo.MyHandler.formatter=java.util.logging.SimpleFormatter   
java.util.logging.StreamHandler.StreamHandler	(	): Create a StreamHandler, with no current output stream.
java.util.logging.StreamHandler.StreamHandler	(	OutputStream	Formatter	): Create a StreamHandler with a given Formatter and output stream. 
java.util.logging.StreamHandler.close	(	): Close the current output stream.  The Formatter's "tail" string is written to the stream before it is closed. In addition, if the Formatter's "head" string has not yet been written to the stream, it will be written before the "tail" string.
java.util.logging.StreamHandler.flush	(	): Flush any buffered messages.
java.util.logging.StreamHandler.isLoggable	(	LogRecord	): Check if this Handler would actually log a given LogRecord.  This method checks if the LogRecord has an appropriate level and whether it satisfies any Filter. It will also return false if no output stream has been assigned yet or the LogRecord is null. 
java.util.logging.StreamHandler.publish	(	LogRecord	): Format and publish a LogRecord.  The StreamHandler first checks if there is an OutputStream and if the given LogRecord has at least the required log level. If not it silently returns. If so, it calls any associated Filter to check if the record should be published. If so, it calls its Formatter to format the record and then writes the result to the current output stream.  If this is the first LogRecord to be written to a given OutputStream, the Formatter's "head" string is written to the stream before the LogRecord is written.
java.util.logging.StreamHandler.setEncoding	(	String	): Set (or change) the character encoding used by this Handler.  The encoding should be set before any LogRecords are written to the Handler.
java.util.logging.StreamHandler.setOutputStream	(	OutputStream	): Change the output stream.  If there is a current output stream then the Formatter's tail string is written and the stream is flushed and closed. Then the output stream is replaced with the new output stream.
java.util.logging.XMLFormatter: Format a LogRecord into a standard XML format.  The DTD specification is provided as Appendix A to the Java Logging APIs specification.  The XMLFormatter can be used with arbitrary character encodings, but it is recommended that it normally be used with UTF-8. The character encoding can be set on the output Handler.
java.util.logging.XMLFormatter.format	(	LogRecord	): Format the given message to XML.  This method can be overridden in a subclass. It is recommended to use the formatMessage convenience method to localize and format the message field.
java.util.logging.XMLFormatter.getHead	(	Handler	): Return the header string for a set of XML formatted records.
java.util.logging.XMLFormatter.getTail	(	Handler	): Return the tail string for a set of XML formatted records.
java.util.prefs.AbstractPreferences: This class provides a skeletal implementation of the Preferences class, greatly easing the task of implementing it. This class is for Preferences implementers only. Normal users of the Preferences facility should have no need to consult this documentation. The Preferences documentation should suffice. Implementors must override the nine abstract service-provider interface (SPI) methods: getSpi(), putSpi(), removeSpi(), childSpi(), removeNodeSpi(), keysSpi(), childrenNamesSpi(), syncSpi() and flushSpi(). All of the concrete methods specify precisely how they are implemented atop these SPI methods. The implementor may, at his discretion, override one or more of the concrete methods if the default implementation is unsatisfactory for any reason, such as performance. The SPI methods fall into three groups concerning exception behavior. The getSpi method should never throw exceptions, but it doesn't really matter, as any exception thrown by this method will be intercepted by get(), which will return the specified default value to the caller. The removeNodeSpi, keysSpi, childrenNamesSpi, syncSpi and flushSpi methods are specified to throw BackingStoreException, and the implementation is required to throw this checked exception if it is unable to perform the operation. The exception propagates outward, causing the corresponding API method to fail. The remaining SPI methods putSpi(), removeSpi() and childSpi() have more complicated exception behavior. They are not specified to throw BackingStoreException, as they can generally obey their contracts even if the backing store is unavailable. This is true because they return no information and their effects are not required to become permanent until a subsequent call to flush() or sync(). Generally speaking, these SPI methods should not throw exceptions. In some implementations, there may be circumstances under which these calls cannot even enqueue the requested operation for later processing. Even under these circumstances it is generally better to simply ignore the invocation and return, rather than throwing an exception. Under these circumstances, however, all subsequent invocations of flush() and sync should return false, as returning true would imply that all previous operations had successfully been made permanent. There is one circumstance under which putSpi, removeSpi and childSpi should throw an exception: if the caller lacks sufficient privileges on the underlying operating system to perform the requested operation. This will, for instance, occur on most systems if a non-privileged user attempts to modify system preferences. (The required privileges will vary from implementation to implementation. On some implementations, they are the right to modify the contents of some directory in the file system; on others they are the right to modify contents of some key in a registry.) Under any of these circumstances, it would generally be undesirable to let the program continue executing as if these operations would become permanent at a later time. While implementations are not required to throw an exception under these circumstances, they are encouraged to do so. A SecurityException would be appropriate. Most of the SPI methods require the implementation to read or write information at a preferences node. The implementor should beware of the fact that another VM may have concurrently deleted this node from the backing store. It is the implementation's responsibility to recreate the node if it has been deleted. Implementation note: In Sun's default Preferences implementations, the user's identity is inherited from the underlying operating system and does not change for the lifetime of the virtual machine. It is recognized that server-side Preferences implementations may have the user identity change from request to request, implicitly passed to Preferences methods via the use of a static ThreadLocal instance. Authors of such implementations are strongly encouraged to determine the user at the time preferences are accessed (for example by the get() or put() method) rather than permanently associating a user with each Preferences instance. The latter behavior conflicts with normal Preferences usage and would lead to great confusion.
java.util.prefs.AbstractPreferences.AbstractPreferences	(	AbstractPreferences	String	): Creates a preference node with the specified parent and the specified name relative to its parent.
java.util.prefs.AbstractPreferences.EventDispatchThread: A single background thread ("the event notification thread") monitors the event queue and delivers events that are placed on the queue.
java.util.prefs.AbstractPreferences.NodeAddedEvent: These two classes are used to distinguish NodeChangeEvents on eventQueue so the event dispatch thread knows whether to call childAdded or childRemoved.
java.util.prefs.AbstractPreferences.absolutePath	(	): Implements the absolutePath method as per the specification in absolutePath(). This implementation merely returns the absolute path name that was computed at the time that this node was constructed (based on the name that was passed to this node's constructor, and the names that were passed to this node's ancestors' constructors).
java.util.prefs.AbstractPreferences.cachedChildren	(	): Returns all known unremoved children of this node.
java.util.prefs.AbstractPreferences.childSpi	(	String	): Returns the named child of this preference node, creating it if it does not already exist. It is guaranteed that name is non-null, non-empty, does not contain the slash character ('/'), and is no longer than MAX_NAME_LENGTH characters. Also, it is guaranteed that this node has not been removed. (The implementor needn't check for any of these things.) Finally, it is guaranteed that the named node has not been returned by a previous invocation of this method or getChild() after the last time that it was removed. In other words, a cached value will always be used in preference to invoking this method. Subclasses need not maintain their own cache of previously returned children. The implementer must ensure that the returned node has not been removed. If a like-named child of this node was previously removed, the implementer must return a newly constructed AbstractPreferences node; once removed, an AbstractPreferences node cannot be "resuscitated." If this method causes a node to be created, this node is not guaranteed to be persistent until the flush method is invoked on this node or one of its ancestors (or descendants). This method is invoked with the lock on this node held.
java.util.prefs.AbstractPreferences.childrenNames	(	): Implements the children method as per the specification in childrenNames(). This implementation obtains this preference node's lock, checks that the node has not been removed, constructs a TreeSet initialized to the names of children already cached (the children in this node's "child-cache"), invokes childrenNamesSpi(), and adds all of the returned child-names into the set. The elements of the tree set are dumped into a String array using the toArray method, and this array is returned.
java.util.prefs.AbstractPreferences.childrenNamesSpi	(	): Returns the names of the children of this preference node. (The returned array will be of size zero if this node has no children.) This method need not return the names of any nodes already cached, but may do so without harm. This method is invoked with the lock on this node held. If this node throws a BackingStoreException, the exception will propagate out beyond the enclosing childrenNames() invocation.
java.util.prefs.AbstractPreferences.clear	(	): Implements the clear method as per the specification in clear(). This implementation obtains this preference node's lock, invokes keys() to obtain an array of keys, and iterates over the array invoking remove() on each key.
java.util.prefs.AbstractPreferences.enqueueNodeAddedEvent	(	Preferences	): Enqueue a "node added" event for delivery to registered node change listeners unless there are no registered listeners. Invoked with this.lock held.
java.util.prefs.AbstractPreferences.enqueueNodeRemovedEvent	(	Preferences	): Enqueue a "node removed" event for delivery to registered node change listeners unless there are no registered listeners. Invoked with this.lock held.
java.util.prefs.AbstractPreferences.enqueuePreferenceChangeEvent	(	String	String	): Enqueue a preference change event for delivery to registered preference change listeners unless there are no registered listeners. Invoked with this.lock held.
java.util.prefs.AbstractPreferences.exportNode	(	OutputStream	): Implements the exportNode method as per the specification in exportNode().
java.util.prefs.AbstractPreferences.exportSubtree	(	OutputStream	): Implements the exportSubtree method as per the specification in exportSubtree().
java.util.prefs.AbstractPreferences.flush	(	): Implements the flush method as per the specification in flush(). This implementation calls a recursive helper method that locks this node, invokes flushSpi() on it, unlocks this node, and recursively invokes this method on each "cached child." A cached child is a child of this node that has been created in this VM and not subsequently removed. In effect, this method does a depth first traversal of the "cached subtree" rooted at this node, calling flushSpi() on each node in the subTree while only that node is locked. Note that flushSpi() is invoked top-down.  If this method is invoked on a node that has been removed with the removeNode() method, flushSpi() is invoked on this node, but not on others.
java.util.prefs.AbstractPreferences.flushSpi	(	): This method is invoked with this node locked. The contract of this method is to force any cached changes in the contents of this preference node to the backing store, guaranteeing their persistence. (It is perfectly possible that this node does not exist on the backing store, either because it has been deleted by another VM, or because it has not yet been created.) Note that this method should not flush the preferences in any subnodes of this node. If the backing store naturally flushes an entire subtree at once, the implementer is encouraged to override flush(), rather than merely overriding this method. If this node throws a BackingStoreException, the exception will propagate out beyond the enclosing flush() invocation.
java.util.prefs.AbstractPreferences.get	(	String	String	): Implements the get method as per the specification in get(). This implementation first checks to see if key is null throwing a NullPointerException if this is the case. Then it obtains this preference node's lock, checks that the node has not been removed, invokes getSpi(), and returns the result, unless the getSpi invocation returns null or throws an exception, in which case this invocation returns def.
java.util.prefs.AbstractPreferences.getBoolean	(	String	boolean	): Implements the getBoolean method as per the specification in getBoolean(). This implementation invokes get() get(key, null). If the return value is non-null, it is compared with "true" using equalsIgnoreCase(). If the comparison returns true, this invocation returns true. Otherwise, the original return value is compared with "false", again using equalsIgnoreCase(). If the comparison returns true, this invocation returns false. Otherwise, this invocation returns def.
java.util.prefs.AbstractPreferences.getByteArray	(	String	byte[]	): Implements the getByteArray method as per the specification in getByteArray().
java.util.prefs.AbstractPreferences.getChild	(	String	): Returns the named child if it exists, or null if it does not. It is guaranteed that nodeName is non-null, non-empty, does not contain the slash character ('/'), and is no longer than MAX_NAME_LENGTH characters. Also, it is guaranteed that this node has not been removed. (The implementor needn't check for any of these things if he chooses to override this method.) Finally, it is guaranteed that the named node has not been returned by a previous invocation of this method or childSpi after the last time that it was removed. In other words, a cached value will always be used in preference to invoking this method. (The implementor needn't maintain his own cache of previously returned children if he chooses to override this method.) This implementation obtains this preference node's lock, invokes childrenNames() to get an array of the names of this node's children, and iterates over the array comparing the name of each child with the specified node name. If a child node has the correct name, the childSpi() method is invoked and the resulting node is returned. If the iteration completes without finding the specified name, null is returned.
java.util.prefs.AbstractPreferences.getDouble	(	String	double	): Implements the getDouble method as per the specification in getDouble(). This implementation invokes get() get(key, null). If the return value is non-null, the implementation attempts to translate it to an double with parseDouble(). If the attempt succeeds, the return value is returned by this method. Otherwise, def is returned.
java.util.prefs.AbstractPreferences.getFloat	(	String	float	): Implements the getFloat method as per the specification in getFloat(). This implementation invokes get() get(key, null). If the return value is non-null, the implementation attempts to translate it to an float with parseFloat(). If the attempt succeeds, the return value is returned by this method. Otherwise, def is returned.
java.util.prefs.AbstractPreferences.getInt	(	String	int	): Implements the getInt method as per the specification in getInt(). This implementation invokes get() get(key, null). If the return value is non-null, the implementation attempts to translate it to an int with parseInt(). If the attempt succeeds, the return value is returned by this method. Otherwise, def is returned.
java.util.prefs.AbstractPreferences.getLong	(	String	long	): Implements the getLong method as per the specification in getLong(). This implementation invokes get() get(key, null). If the return value is non-null, the implementation attempts to translate it to a long with parseLong(). If the attempt succeeds, the return value is returned by this method. Otherwise, def is returned.
java.util.prefs.AbstractPreferences.getSpi	(	String	): Return the value associated with the specified key at this preference node, or null if there is no association for this key, or the association cannot be determined at this time. It is guaranteed that key is non-null. Also, it is guaranteed that this node has not been removed. (The implementor needn't check for either of these things.)  Generally speaking, this method should not throw an exception under any circumstances. If, however, if it does throw an exception, the exception will be intercepted and treated as a null return value. This method is invoked with the lock on this node held.
java.util.prefs.AbstractPreferences.isRemoved	(	): Returns true iff this node (or an ancestor) has been removed with the removeNode() method. This method locks this node prior to returning the contents of the private field used to track this state.
java.util.prefs.AbstractPreferences.isUserNode	(	): Implements the isUserNode method as per the specification in isUserNode(). This implementation compares this node's root node (which is stored in a private field) with the value returned by userRoot(). If the two object references are identical, this method returns true.
java.util.prefs.AbstractPreferences.keys	(	): Implements the keys method as per the specification in keys(). This implementation obtains this preference node's lock, checks that the node has not been removed and invokes keysSpi().
java.util.prefs.AbstractPreferences.keysSpi	(	): Returns all of the keys that have an associated value in this preference node. (The returned array will be of size zero if this node has no preferences.) It is guaranteed that this node has not been removed. This method is invoked with the lock on this node held. If this node throws a BackingStoreException, the exception will propagate out beyond the enclosing keys() invocation.
java.util.prefs.AbstractPreferences.name	(	): Implements the name method as per the specification in name(). This implementation merely returns the name that was passed to this node's constructor.
java.util.prefs.AbstractPreferences.node	(	String	): Implements the node method as per the specification in node(). This implementation obtains this preference node's lock and checks that the node has not been removed. If path is "", this node is returned; if path is "/", this node's root is returned. If the first character in path is not '/', the implementation breaks path into tokens and recursively traverses the path from this node to the named node, "consuming" a name and a slash from path at each step of the traversal. At each step, the current node is locked and the node's child-cache is checked for the named node. If it is not found, the name is checked to make sure its length does not exceed MAX_NAME_LENGTH. Then the childSpi() method is invoked, and the result stored in this node's child-cache. If the newly created Preferences object's newNode field is true and there are any node change listeners, a notification event is enqueued for processing by the event dispatch thread. When there are no more tokens, the last value found in the child-cache or returned by childSpi is returned by this method. If during the traversal, two "/" tokens occur consecutively, or the final token is "/" (rather than a name), an appropriate IllegalArgumentException is thrown.  If the first character of path is '/' (indicating an absolute path name) this preference node's lock is dropped prior to breaking path into tokens, and this method recursively traverses the path starting from the root (rather than starting from this node). The traversal is otherwise identical to the one described for relative path names. Dropping the lock on this node prior to commencing the traversal at the root node is essential to avoid the possibility of deadlock, as per the lock locking invariant.
java.util.prefs.AbstractPreferences.node	(	StringTokenizer	): tokenizer contains  {'/' }
java.util.prefs.AbstractPreferences.nodeExists	(	String	): Implements the nodeExists method as per the specification in nodeExists(). This implementation is very similar to node(), except that getChild() is used instead of childSpi().
java.util.prefs.AbstractPreferences.nodeExists	(	StringTokenizer	): tokenizer contains  {'/' }
java.util.prefs.AbstractPreferences.parent	(	): Implements the parent method as per the specification in parent(). This implementation obtains this preference node's lock, checks that the node has not been removed and returns the parent value that was passed to this node's constructor.
java.util.prefs.AbstractPreferences.prefListeners	(	): Return this node's preference/node change listeners. Even though we're using a copy-on-write lists, we use synchronized accessors to ensure information transmission from the writing thread to the reading thread.
java.util.prefs.AbstractPreferences.put	(	String	String	): Implements the put method as per the specification in put(). This implementation checks that the key and value are legal, obtains this preference node's lock, checks that the node has not been removed, invokes putSpi(), and if there are any preference change listeners, enqueues a notification event for processing by the event dispatch thread.
java.util.prefs.AbstractPreferences.putBoolean	(	String	boolean	): Implements the putBoolean method as per the specification in putBoolean(). This implementation translates value to a string with valueOf() and invokes put() on the result.
java.util.prefs.AbstractPreferences.putByteArray	(	String	byte[]	): Implements the putByteArray method as per the specification in putByteArray().
java.util.prefs.AbstractPreferences.putDouble	(	String	double	): Implements the putDouble method as per the specification in putDouble(). This implementation translates value to a string with toString() and invokes put() on the result.
java.util.prefs.AbstractPreferences.putFloat	(	String	float	): Implements the putFloat method as per the specification in putFloat(). This implementation translates value to a string with toString() and invokes put() on the result.
java.util.prefs.AbstractPreferences.putInt	(	String	int	): Implements the putInt method as per the specification in putInt(). This implementation translates value to a string with toString() and invokes put() on the result.
java.util.prefs.AbstractPreferences.putLong	(	String	long	): Implements the putLong method as per the specification in putLong(). This implementation translates value to a string with toString() and invokes put() on the result.
java.util.prefs.AbstractPreferences.putSpi	(	String	String	): Put the given key-value association into this preference node. It is guaranteed that key and value are non-null and of legal length. Also, it is guaranteed that this node has not been removed. (The implementor needn't check for any of these things.) This method is invoked with the lock on this node held.
java.util.prefs.AbstractPreferences.remove	(	String	): Implements the remove(String) method as per the specification in remove(). This implementation obtains this preference node's lock, checks that the node has not been removed, invokes removeSpi() and if there are any preference change listeners, enqueues a notification event for processing by the event dispatch thread.
java.util.prefs.AbstractPreferences.removeNode	(	): Implements the removeNode() method as per the specification in removeNode(). This implementation checks to see that this node is the root; if so, it throws an appropriate exception. Then, it locks this node's parent, and calls a recursive helper method that traverses the subtree rooted at this node. The recursive method locks the node on which it was called, checks that it has not already been removed, and then ensures that all of its children are cached: The childrenNamesSpi() method is invoked and each returned child name is checked for containment in the child-cache. If a child is not already cached, the childSpi() method is invoked to create a Preferences instance for it, and this instance is put into the child-cache. Then the helper method calls itself recursively on each node contained in its child-cache. Next, it invokes removeNodeSpi(), marks itself as removed, and removes itself from its parent's child-cache. Finally, if there are any node change listeners, it enqueues a notification event for processing by the event dispatch thread. Note that the helper method is always invoked with all ancestors up to the "closest non-removed ancestor" locked.
java.util.prefs.AbstractPreferences.removeNodeSpi	(	): Removes this preference node, invalidating it and any preferences that it contains. The named child will have no descendants at the time this invocation is made (i.e., the removeNode() method invokes this method repeatedly in a bottom-up fashion, removing each of a node's descendants before removing the node itself). This method is invoked with the lock held on this node and its parent (and all ancestors that are being removed as a result of a single invocation to removeNode()). The removal of a node needn't become persistent until the flush method is invoked on this node (or an ancestor). If this node throws a BackingStoreException, the exception will propagate out beyond the enclosing removeNode() invocation.
java.util.prefs.AbstractPreferences.removeSpi	(	String	): Remove the association (if any) for the specified key at this preference node. It is guaranteed that key is non-null. Also, it is guaranteed that this node has not been removed. (The implementor needn't check for either of these things.) This method is invoked with the lock on this node held.
java.util.prefs.AbstractPreferences.startEventDispatchThreadIfNecessary	(	): This method starts the event dispatch thread the first time it is called. The event dispatch thread will be started only if someone registers a listener.
java.util.prefs.AbstractPreferences.sync	(	): Implements the sync method as per the specification in sync(). This implementation calls a recursive helper method that locks this node, invokes syncSpi() on it, unlocks this node, and recursively invokes this method on each "cached child." A cached child is a child of this node that has been created in this VM and not subsequently removed. In effect, this method does a depth first traversal of the "cached subtree" rooted at this node, calling syncSpi() on each node in the subTree while only that node is locked. Note that syncSpi() is invoked top-down.
java.util.prefs.AbstractPreferences.syncSpi	(	): This method is invoked with this node locked. The contract of this method is to synchronize any cached preferences stored at this node with any stored in the backing store. (It is perfectly possible that this node does not exist on the backing store, either because it has been deleted by another VM, or because it has not yet been created.) Note that this method should not synchronize the preferences in any subnodes of this node. If the backing store naturally syncs an entire subtree at once, the implementer is encouraged to override sync(), rather than merely overriding this method. If this node throws a BackingStoreException, the exception will propagate out beyond the enclosing sync() invocation.
java.util.prefs.AbstractPreferences.toString	(	): Returns the absolute path name of this preferences node.
java.util.prefs.BackingStoreException: Thrown to indicate that a preferences operation could not complete because of a failure in the backing store, or a failure to contact the backing store.
java.util.prefs.BackingStoreException.BackingStoreException	(	String	): Constructs a BackingStoreException with the specified detail message.
java.util.prefs.BackingStoreException.BackingStoreException	(	Throwable	): Constructs a BackingStoreException with the specified cause.
java.util.prefs.Base64: Static methods for translating Base64 encoded strings to byte arrays and vice-versa.
java.util.prefs.Base64.altBase64ToByteArray	(	String	): Translates the specified "alternate representation" Base64 string into a byte array.
java.util.prefs.Base64.base64ToByteArray	(	String	): Translates the specified Base64 string (as per Preferences.get(byte[])) into a byte array.
java.util.prefs.Base64.base64toInt	(	char	byte[]	): Translates the specified character, which is assumed to be in the "Base 64 Alphabet" into its equivalent 6-bit positive integer.
java.util.prefs.Base64.byteArrayToAltBase64	(	byte[]	): Translates the specified byte array into an "alternate representation" Base64 string. This non-standard variant uses an alphabet that does not contain the uppercase alphabetic characters, which makes it suitable for use in situations where case-folding occurs.
java.util.prefs.Base64.byteArrayToBase64	(	byte[]	): Translates the specified byte array into a Base64 string as per Preferences.put(byte[]).
java.util.prefs.InvalidPreferencesFormatException: Thrown to indicate that an operation could not complete because the input did not conform to the appropriate XML document type for a collection of preferences, as per the Preferences specification.
java.util.prefs.InvalidPreferencesFormatException.InvalidPreferencesFormatException	(	String	): Constructs an InvalidPreferencesFormatException with the specified detail message.
java.util.prefs.InvalidPreferencesFormatException.InvalidPreferencesFormatException	(	String	Throwable	): Constructs an InvalidPreferencesFormatException with the specified detail message and cause.
java.util.prefs.InvalidPreferencesFormatException.InvalidPreferencesFormatException	(	Throwable	): Constructs an InvalidPreferencesFormatException with the specified cause.
java.util.prefs.NodeChangeEvent: An event emitted by a Preferences node to indicate that a child of that node has been added or removed. Note, that although NodeChangeEvent inherits Serializable interface from java.util.EventObject, it is not intended to be Serializable. Appropriate serialization methods are implemented to throw NotSerializableException.
java.util.prefs.NodeChangeEvent.NodeChangeEvent	(	Preferences	Preferences	): Constructs a new NodeChangeEvent instance.
java.util.prefs.NodeChangeEvent.getChild	(	): Returns the node that was added or removed.
java.util.prefs.NodeChangeEvent.getParent	(	): Returns the parent of the node that was added or removed.
java.util.prefs.NodeChangeEvent.readObject	(	java.io.ObjectInputStream	): Throws NotSerializableException, since NodeChangeEvent objects are not intended to be serializable.
java.util.prefs.NodeChangeEvent.writeObject	(	java.io.ObjectOutputStream	): Throws NotSerializableException, since NodeChangeEvent objects are not intended to be serializable.
java.util.prefs.NodeChangeListener: A listener for receiving preference node change events.
java.util.prefs.NodeChangeListener.childAdded	(	NodeChangeEvent	): This method gets called when a child node is added.
java.util.prefs.NodeChangeListener.childRemoved	(	NodeChangeEvent	): This method gets called when a child node is removed.
java.util.prefs.PreferenceChangeEvent: An event emitted by a Preferences node to indicate that a preference has been added, removed or has had its value changed. Note, that although PreferenceChangeEvent inherits Serializable interface from EventObject, it is not intended to be Serializable. Appropriate serialization methods are implemented to throw NotSerializableException.
java.util.prefs.PreferenceChangeEvent.PreferenceChangeEvent	(	Preferences	String	String	): Constructs a new PreferenceChangeEvent instance.
java.util.prefs.PreferenceChangeEvent.getKey	(	): Returns the key of the preference that was changed.
java.util.prefs.PreferenceChangeEvent.getNewValue	(	): Returns the new value for the preference.
java.util.prefs.PreferenceChangeEvent.getNode	(	): Returns the preference node that emitted the event.
java.util.prefs.PreferenceChangeEvent.readObject	(	java.io.ObjectInputStream	): Throws NotSerializableException, since PreferenceChangeEvent objects are not intended to be serializable.
java.util.prefs.PreferenceChangeEvent.writeObject	(	java.io.ObjectOutputStream	): Throws NotSerializableException, since NodeChangeEvent objects are not intended to be serializable.
java.util.prefs.PreferenceChangeListener: A listener for receiving preference change events.
java.util.prefs.PreferenceChangeListener.preferenceChange	(	PreferenceChangeEvent	): This method gets called when a preference is added, removed or when its value is changed. 
java.util.prefs.Preferences: A node in a hierarchical collection of preference data. This class allows applications to store and retrieve user and system preference and configuration data. This data is stored persistently in an implementation-dependent backing store. Typical implementations include flat files, OS-specific registries, directory servers and SQL databases. The user of this class needn't be concerned with details of the backing store. There are two separate trees of preference nodes, one for user preferences and one for system preferences. Each user has a separate user preference tree, and all users in a given system share the same system preference tree. The precise description of "user" and "system" will vary from implementation to implementation. Typical information stored in the user preference tree might include font choice, color choice, or preferred window location and size for a particular application. Typical information stored in the system preference tree might include installation configuration data for an application. Nodes in a preference tree are named in a similar fashion to directories in a hierarchical file system. Every node in a preference tree has a node name (which is not necessarily unique), a unique absolute path name, and a path name relative to each ancestor including itself. The root node has a node name of the empty string (""). Every other node has an arbitrary node name, specified at the time it is created. The only restrictions on this name are that it cannot be the empty string, and it cannot contain the slash character ('/'). The root node has an absolute path name of "/". Children of the root node have absolute path names of "/" + <node name>. All other nodes have absolute path names of <parent's absolute path name> + "/" + <node name>. Note that all absolute path names begin with the slash character. A node n's path name relative to its ancestor a is simply the string that must be appended to a's absolute path name in order to form n's absolute path name, with the initial slash character (if present) removed. Note that:  No relative path names begin with the slash character. Every node's path name relative to itself is the empty string. Every node's path name relative to its parent is its node name (except for the root node, which does not have a parent). Every node's path name relative to the root is its absolute path name with the initial slash character removed.  Note finally that:  No path name contains multiple consecutive slash characters. No path name with the exception of the root's absolute path name ends in the slash character. Any string that conforms to these two rules is a valid path name.  All of the methods that modify preferences data are permitted to operate asynchronously; they may return immediately, and changes will eventually propagate to the persistent backing store with an implementation-dependent delay. The flush method may be used to synchronously force updates to the backing store. Normal termination of the Java Virtual Machine will not result in the loss of pending updates -- an explicit flush invocation is not required upon termination to ensure that pending updates are made persistent. All of the methods that read preferences from a Preferences object require the invoker to provide a default value. The default value is returned if no value has been previously set or if the backing store is unavailable. The intent is to allow applications to operate, albeit with slightly degraded functionality, even if the backing store becomes unavailable. Several methods, like flush, have semantics that prevent them from operating if the backing store is unavailable. Ordinary applications should have no need to invoke any of these methods, which can be identified by the fact that they are declared to throw BackingStoreException. The methods in this class may be invoked concurrently by multiple threads in a single JVM without the need for external synchronization, and the results will be equivalent to some serial execution. If this class is used concurrently by multiple JVMs that store their preference data in the same backing store, the data store will not be corrupted, but no other guarantees are made concerning the consistency of the preference data. This class contains an export/import facility, allowing preferences to be "exported" to an XML document, and XML documents representing preferences to be "imported" back into the system. This facility may be used to back up all or part of a preference tree, and subsequently restore from the backup. The XML document has the following DOCTYPE declaration:  Note that the system URI (http://java.sun.com/dtd/preferences.dtd) is not accessed when exporting or importing preferences; it merely serves as a string to uniquely identify the DTD, which is:                    Every Preferences implementation must have an associated PreferencesFactory implementation. Every Java(TM) SE implementation must provide some means of specifying which PreferencesFactory implementation is used to generate the root preferences nodes. This allows the administrator to replace the default preferences implementation with an alternative implementation. Implementation note: In Sun's JRE, the PreferencesFactory implementation is located as follows:  If the system property java.util.prefs.PreferencesFactory is defined, then it is taken to be the fully-qualified name of a class implementing the PreferencesFactory interface. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.  If a PreferencesFactory implementation class file has been installed in a jar file that is visible to the getSystemClassLoader system class loader, and that jar file contains a provider-configuration file named java.util.prefs.PreferencesFactory in the resource directory META-INF/services, then the first class name specified in that file is taken. If more than one such jar file is provided, the first one found will be used. The class is loaded and instantiated; if this process fails then an unspecified error is thrown.  Finally, if neither the above-mentioned system property nor an extension jar file is provided, then the system-wide default PreferencesFactory implementation for the underlying platform is loaded and instantiated. 
java.util.prefs.Preferences.Preferences	(	): Sole constructor. (For invocation by subclass constructors, typically implicit.)
java.util.prefs.Preferences.absolutePath	(	): Returns this preference node's absolute path name.
java.util.prefs.Preferences.addNodeChangeListener	(	NodeChangeListener	): Registers the specified listener to receive node change events for this node. A node change event is generated when a child node is added to or removed from this node. (A single removeNode() invocation results in multiple node change events, one for every node in the subtree rooted at the removed node.) Events are only guaranteed for changes made within the same JVM as the registered listener, though some implementations may generate events for changes made outside this JVM. Events may be generated before the changes have become permanent. Events are not generated when indirect descendants of this node are added or removed; a caller desiring such events must register with each descendant. Few guarantees can be made regarding node creation. Because nodes are created implicitly upon access, it may not be feasible for an implementation to determine whether a child node existed in the backing store prior to access (for example, because the backing store is unreachable or cached information is out of date). Under these circumstances, implementations are neither required to generate node change events nor prohibited from doing so.
java.util.prefs.Preferences.addPreferenceChangeListener	(	PreferenceChangeListener	): Registers the specified listener to receive preference change events for this preference node. A preference change event is generated when a preference is added to this node, removed from this node, or when the value associated with a preference is changed. (Preference change events are not generated by the removeNode() method, which generates a node change event. Preference change events are generated by the clear method.) Events are only guaranteed for changes made within the same JVM as the registered listener, though some implementations may generate events for changes made outside this JVM. Events may be generated before the changes have been made persistent. Events are not generated when preferences are modified in descendants of this node; a caller desiring such events must register with each descendant.
java.util.prefs.Preferences.childrenNames	(	): Returns the names of the children of this preference node, relative to this node. (The returned array will be of size zero if this node has no children.)
java.util.prefs.Preferences.clear	(	): Removes all of the preferences (key-value associations) in this preference node. This call has no effect on any descendants of this node. If this implementation supports stored defaults, and this node in the preferences hierarchy contains any such defaults, the stored defaults will be "exposed" by this call, in the sense that they will be returned by succeeding calls to get.
java.util.prefs.Preferences.exportNode	(	OutputStream	): Emits on the specified output stream an XML document representing all of the preferences contained in this node (but not its descendants). This XML document is, in effect, an offline backup of the node. The XML document will have the following DOCTYPE declaration:  The UTF-8 character encoding will be used. This method is an exception to the general rule that the results of concurrently executing multiple methods in this class yields results equivalent to some serial execution. If the preferences at this node are modified concurrently with an invocation of this method, the exported preferences comprise a "fuzzy snapshot" of the preferences contained in the node; some of the concurrent modifications may be reflected in the exported data while others may not.
java.util.prefs.Preferences.exportSubtree	(	OutputStream	): Emits an XML document representing all of the preferences contained in this node and all of its descendants. This XML document is, in effect, an offline backup of the subtree rooted at the node. The XML document will have the following DOCTYPE declaration:  The UTF-8 character encoding will be used. This method is an exception to the general rule that the results of concurrently executing multiple methods in this class yields results equivalent to some serial execution. If the preferences or nodes in the subtree rooted at this node are modified concurrently with an invocation of this method, the exported preferences comprise a "fuzzy snapshot" of the subtree; some of the concurrent modifications may be reflected in the exported data while others may not.
java.util.prefs.Preferences.flush	(	): Forces any changes in the contents of this preference node and its descendants to the persistent store. Once this method returns successfully, it is safe to assume that all changes made in the subtree rooted at this node prior to the method invocation have become permanent. Implementations are free to flush changes into the persistent store at any time. They do not need to wait for this method to be called. When a flush occurs on a newly created node, it is made persistent, as are any ancestors (and descendants) that have yet to be made persistent. Note however that any preference value changes in ancestors are not guaranteed to be made persistent.  If this method is invoked on a node that has been removed with the removeNode() method, flushSpi() is invoked on this node, but not on others.
java.util.prefs.Preferences.get	(	String	String	): Returns the value associated with the specified key in this preference node. Returns the specified default if there is no value associated with the key, or the backing store is inaccessible. Some implementations may store default values in their backing stores. If there is no value associated with the specified key but there is such a stored default, it is returned in preference to the specified default.
java.util.prefs.Preferences.getBoolean	(	String	boolean	): Returns the boolean value represented by the string associated with the specified key in this preference node. Valid strings are "true", which represents true, and "false", which represents false. Case is ignored, so, for example, "TRUE" and "False" are also valid. This method is intended for use in conjunction with putBoolean. Returns the specified default if there is no value associated with the key, the backing store is inaccessible, or if the associated value is something other than "true" or "false", ignoring case. If the implementation supports stored defaults and such a default exists and is accessible, it is used in preference to the specified default, unless the stored default is something other than "true" or "false", ignoring case, in which case the specified default is used.
java.util.prefs.Preferences.getByteArray	(	String	byte[]	): Returns the byte array value represented by the string associated with the specified key in this preference node. Valid strings are Base64 encoded binary data, as defined in RFC 2045, Section 6.8, with one minor change: the string must consist solely of characters from the Base64 Alphabet; no newline characters or extraneous characters are permitted. This method is intended for use in conjunction with putByteArray. Returns the specified default if there is no value associated with the key, the backing store is inaccessible, or if the associated value is not a valid Base64 encoded byte array (as defined above). If the implementation supports stored defaults and such a default exists and is accessible, it is used in preference to the specified default, unless the stored default is not a valid Base64 encoded byte array (as defined above), in which case the specified default is used.
java.util.prefs.Preferences.getDouble	(	String	double	): Returns the double value represented by the string associated with the specified key in this preference node. The string is converted to an integer as by parseDouble(). Returns the specified default if there is no value associated with the key, the backing store is inaccessible, or if Double.parseDouble(String) would throw a NumberFormatException if the associated value were passed. This method is intended for use in conjunction with putDouble. If the implementation supports stored defaults and such a default exists, is accessible, and could be converted to a double with Double.parseDouble, this double is returned in preference to the specified default.
java.util.prefs.Preferences.getFloat	(	String	float	): Returns the float value represented by the string associated with the specified key in this preference node. The string is converted to an integer as by parseFloat(). Returns the specified default if there is no value associated with the key, the backing store is inaccessible, or if Float.parseFloat(String) would throw a NumberFormatException if the associated value were passed. This method is intended for use in conjunction with putFloat. If the implementation supports stored defaults and such a default exists, is accessible, and could be converted to a float with Float.parseFloat, this float is returned in preference to the specified default.
java.util.prefs.Preferences.getInt	(	String	int	): Returns the int value represented by the string associated with the specified key in this preference node. The string is converted to an integer as by parseInt(). Returns the specified default if there is no value associated with the key, the backing store is inaccessible, or if Integer.parseInt(String) would throw a NumberFormatException if the associated value were passed. This method is intended for use in conjunction with putInt. If the implementation supports stored defaults and such a default exists, is accessible, and could be converted to an int with Integer.parseInt, this int is returned in preference to the specified default.
java.util.prefs.Preferences.getLong	(	String	long	): Returns the long value represented by the string associated with the specified key in this preference node. The string is converted to a long as by parseLong(). Returns the specified default if there is no value associated with the key, the backing store is inaccessible, or if Long.parseLong(String) would throw a NumberFormatException if the associated value were passed. This method is intended for use in conjunction with putLong. If the implementation supports stored defaults and such a default exists, is accessible, and could be converted to a long with Long.parseLong, this long is returned in preference to the specified default.
java.util.prefs.Preferences.importPreferences	(	InputStream	): Imports all of the preferences represented by the XML document on the specified input stream. The document may represent user preferences or system preferences. If it represents user preferences, the preferences will be imported into the calling user's preference tree (even if they originally came from a different user's preference tree). If any of the preferences described by the document inhabit preference nodes that do not exist, the nodes will be created. The XML document must have the following DOCTYPE declaration:  (This method is designed for use in conjunction with exportNode() and exportSubtree(). This method is an exception to the general rule that the results of concurrently executing multiple methods in this class yields results equivalent to some serial execution. The method behaves as if implemented on top of the other public methods in this class, notably node() and put().
java.util.prefs.Preferences.isUserNode	(	): Returns true if this preference node is in the user preference tree, false if it's in the system preference tree.
java.util.prefs.Preferences.keys	(	): Returns all of the keys that have an associated value in this preference node. (The returned array will be of size zero if this node has no preferences.) If the implementation supports stored defaults and there are any such defaults at this node that have not been overridden, by explicit preferences, the defaults are returned in the array in addition to any explicit preferences.
java.util.prefs.Preferences.name	(	): Returns this preference node's name, relative to its parent.
java.util.prefs.Preferences.node	(	String	): Returns the named preference node in the same tree as this node, creating it and any of its ancestors if they do not already exist. Accepts a relative or absolute path name. Relative path names (which do not begin with the slash character ('/')) are interpreted relative to this preference node. If the returned node did not exist prior to this call, this node and any ancestors that were created by this call are not guaranteed to become permanent until the flush method is called on the returned node (or one of its ancestors or descendants).
java.util.prefs.Preferences.nodeExists	(	String	): Returns true if the named preference node exists in the same tree as this node. Relative path names (which do not begin with the slash character ('/')) are interpreted relative to this preference node. If this node (or an ancestor) has already been removed with the removeNode() method, it is legal to invoke this method, but only with the path name ""; the invocation will return false. Thus, the idiom p.nodeExists("") may be used to test whether p has been removed.
java.util.prefs.Preferences.nodeName	(	Class	): Returns the absolute path name of the node corresponding to the package of the specified object.
java.util.prefs.Preferences.parent	(	): Returns the parent of this preference node, or null if this is the root.
java.util.prefs.Preferences.put	(	String	String	): Associates the specified value with the specified key in this preference node.
java.util.prefs.Preferences.putBoolean	(	String	boolean	): Associates a string representing the specified boolean value with the specified key in this preference node. The associated string is "true" if the value is true, and "false" if it is false. This method is intended for use in conjunction with getBoolean.
java.util.prefs.Preferences.putByteArray	(	String	byte[]	): Associates a string representing the specified byte array with the specified key in this preference node. The associated string is the Base64 encoding of the byte array, as defined in RFC 2045, Section 6.8, with one minor change: the string will consist solely of characters from the Base64 Alphabet; it will not contain any newline characters. Note that the maximum length of the byte array is limited to three quarters of MAX_VALUE_LENGTH so that the length of the Base64 encoded String does not exceed MAX_VALUE_LENGTH. This method is intended for use in conjunction with getByteArray.
java.util.prefs.Preferences.putDouble	(	String	double	): Associates a string representing the specified double value with the specified key in this preference node. The associated string is the one that would be returned if the double value were passed to toString(). This method is intended for use in conjunction with getDouble.
java.util.prefs.Preferences.putFloat	(	String	float	): Associates a string representing the specified float value with the specified key in this preference node. The associated string is the one that would be returned if the float value were passed to toString(). This method is intended for use in conjunction with getFloat.
java.util.prefs.Preferences.putInt	(	String	int	): Associates a string representing the specified int value with the specified key in this preference node. The associated string is the one that would be returned if the int value were passed to toString(). This method is intended for use in conjunction with getInt.
java.util.prefs.Preferences.putLong	(	String	long	): Associates a string representing the specified long value with the specified key in this preference node. The associated string is the one that would be returned if the long value were passed to toString(). This method is intended for use in conjunction with getLong.
java.util.prefs.Preferences.remove	(	String	): Removes the value associated with the specified key in this preference node, if any. If this implementation supports stored defaults, and there is such a default for the specified preference, the stored default will be "exposed" by this call, in the sense that it will be returned by a succeeding call to get.
java.util.prefs.Preferences.removeNode	(	): Removes this preference node and all of its descendants, invalidating any preferences contained in the removed nodes. Once a node has been removed, attempting any method other than name(), absolutePath(), isUserNode(), flush() or node() nodeExists("") on the corresponding Preferences instance will fail with an IllegalStateException. (The methods defined on Object can still be invoked on a node after it has been removed; they will not throw IllegalStateException.) The removal is not guaranteed to be persistent until the flush method is called on this node (or an ancestor). If this implementation supports stored defaults, removing a node exposes any stored defaults at or below this node. Thus, a subsequent call to nodeExists on this node's path name may return true, and a subsequent call to node on this path name may return a (different) Preferences instance representing a non-empty collection of preferences and/or children.
java.util.prefs.Preferences.removeNodeChangeListener	(	NodeChangeListener	): Removes the specified NodeChangeListener, so it no longer receives change events.
java.util.prefs.Preferences.removePreferenceChangeListener	(	PreferenceChangeListener	): Removes the specified preference change listener, so it no longer receives preference change events.
java.util.prefs.Preferences.sync	(	): Ensures that future reads from this preference node and its descendants reflect any changes that were committed to the persistent store (from any VM) prior to the sync invocation. As a side-effect, forces any changes in the contents of this preference node and its descendants to the persistent store, as if the flush method had been invoked on this node.
java.util.prefs.Preferences.systemNodeForPackage	(	Class	): Returns the preference node from the system preference tree that is associated (by convention) with the specified class's package. The convention is as follows: the absolute path name of the node is the fully qualified package name, preceded by a slash ('/'), and with each period ('.') replaced by a slash. For example the absolute path name of the node associated with the class com.acme.widget.Foo is /com/acme/widget. This convention does not apply to the unnamed package, whose associated preference node is <unnamed>. This node is not intended for long term use, but for convenience in the early development of programs that do not yet belong to a package, and for "throwaway" programs. Valuable data should not be stored at this node as it is shared by all programs that use it. A class Foo wishing to access preferences pertaining to its package can obtain a preference node as follows:  static Preferences prefs = Preferences.systemNodeForPackage(Foo.class);  This idiom obviates the need for using a string to describe the preferences node and decreases the likelihood of a run-time failure. (If the class name is misspelled, it will typically result in a compile-time error.) Invoking this method will result in the creation of the returned node and its ancestors if they do not already exist. If the returned node did not exist prior to this call, this node and any ancestors that were created by this call are not guaranteed to become permanent until the flush method is called on the returned node (or one of its ancestors or descendants).
java.util.prefs.Preferences.systemRoot	(	): Returns the root preference node for the system.
java.util.prefs.Preferences.toString	(	): Returns a string representation of this preferences node, as if computed by the expression:(this.isUserNode() ? "User" : "System") + " Preference Node: " + this.absolutePath().
java.util.prefs.Preferences.userNodeForPackage	(	Class	): Returns the preference node from the calling user's preference tree that is associated (by convention) with the specified class's package. The convention is as follows: the absolute path name of the node is the fully qualified package name, preceded by a slash ('/'), and with each period ('.') replaced by a slash. For example the absolute path name of the node associated with the class com.acme.widget.Foo is /com/acme/widget. This convention does not apply to the unnamed package, whose associated preference node is <unnamed>. This node is not intended for long term use, but for convenience in the early development of programs that do not yet belong to a package, and for "throwaway" programs. Valuable data should not be stored at this node as it is shared by all programs that use it. A class Foo wishing to access preferences pertaining to its package can obtain a preference node as follows:  static Preferences prefs = Preferences.userNodeForPackage(Foo.class);  This idiom obviates the need for using a string to describe the preferences node and decreases the likelihood of a run-time failure. (If the class name is misspelled, it will typically result in a compile-time error.) Invoking this method will result in the creation of the returned node and its ancestors if they do not already exist. If the returned node did not exist prior to this call, this node and any ancestors that were created by this call are not guaranteed to become permanent until the flush method is called on the returned node (or one of its ancestors or descendants).
java.util.prefs.Preferences.userRoot	(	): Returns the root preference node for the calling user.
java.util.prefs.PreferencesFactory: A factory object that generates Preferences objects. Providers of new Preferences implementations should provide corresponding PreferencesFactory implementations so that the new Preferences implementation can be installed in place of the platform-specific default implementation. This class is for Preferences implementers only. Normal users of the Preferences facility should have no need to consult this documentation.
java.util.prefs.PreferencesFactory.systemRoot	(	): Returns the system root preference node. (Multiple calls on this method will return the same object reference.)
java.util.prefs.PreferencesFactory.userRoot	(	): Returns the user root preference node corresponding to the calling user. In a server, the returned value will typically depend on some implicit client-context.
java.util.prefs.WindowsPreferences: Windows registry based implementation of Preferences. Preferences' systemRoot and userRoot are stored in HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft\Prefs and HKEY_CURRENT_USER\Software\JavaSoft\Prefs correspondingly.
java.util.prefs.WindowsPreferences.WindowsPreferences	(	WindowsPreferences	String	): Constructs a WindowsPreferences node, creating underlying Windows registry node and all its Windows parents, if they are not yet created. Logs a warning message, if Windows Registry is unavailable.
java.util.prefs.WindowsPreferences.WindowsPreferences	(	int	byte[]	): Constructs a root node creating the underlying Windows registry node and all of its parents, if they have not yet been created. Logs a warning message, if Windows Registry is unavailable.
java.util.prefs.WindowsPreferences.WindowsRegCloseKey	(	int	): Java wrapper for Windows registry API RegCloseKey()
java.util.prefs.WindowsPreferences.WindowsRegCreateKeyEx	(	int	byte[]	): Java wrapper for Windows registry API RegCreateKeyEx()
java.util.prefs.WindowsPreferences.WindowsRegCreateKeyEx1	(	int	byte[]	): Retries RegCreateKeyEx() MAX_ATTEMPTS times before giving up.
java.util.prefs.WindowsPreferences.WindowsRegDeleteKey	(	int	byte[]	): Java wrapper for Windows registry API RegDeleteKey()
java.util.prefs.WindowsPreferences.WindowsRegDeleteValue	(	int	byte[]	): Java wrapper for Windows registry API RegDeleteValue()
java.util.prefs.WindowsPreferences.WindowsRegEnumKeyEx	(	int	int	int	): Java wrapper for Windows registry API RegEnumKeyEx()
java.util.prefs.WindowsPreferences.WindowsRegEnumKeyEx1	(	int	int	int	): Retries RegEnumKeyEx() MAX_ATTEMPTS times before giving up.
java.util.prefs.WindowsPreferences.WindowsRegEnumValue	(	int	int	int	): Java wrapper for Windows registry API RegEnumValue()
java.util.prefs.WindowsPreferences.WindowsRegEnumValue1	(	int	int	int	): Retries RegEnumValueEx() MAX_ATTEMPTS times before giving up.
java.util.prefs.WindowsPreferences.WindowsRegFlushKey	(	int	): Java wrapper for Windows registry API RegFlushKey()
java.util.prefs.WindowsPreferences.WindowsRegFlushKey1	(	int	): Retries RegFlushKey() MAX_ATTEMPTS times before giving up.
java.util.prefs.WindowsPreferences.WindowsRegOpenKey	(	int	byte[]	int	): Java wrapper for Windows registry API RegOpenKey()
java.util.prefs.WindowsPreferences.WindowsRegOpenKey1	(	int	byte[]	int	): Retries RegOpenKey() MAX_ATTEMPTS times before giving up.
java.util.prefs.WindowsPreferences.WindowsRegQueryInfoKey	(	int	): Java wrapper for Windows registry API RegQueryInfoKey()
java.util.prefs.WindowsPreferences.WindowsRegQueryInfoKey1	(	int	): Retries RegQueryInfoKey() MAX_ATTEMPTS times before giving up.
java.util.prefs.WindowsPreferences.WindowsRegQueryValueEx	(	int	byte[]	): Java wrapper for Windows registry API RegQueryValueEx()
java.util.prefs.WindowsPreferences.WindowsRegSetValueEx	(	int	byte[]	byte[]	): Java wrapper for Windows registry API RegSetValueEx()
java.util.prefs.WindowsPreferences.WindowsRegSetValueEx1	(	int	byte[]	byte[]	): Retries RegSetValueEx() MAX_ATTEMPTS times before giving up.
java.util.prefs.WindowsPreferences.byteArrayToString	(	byte[]	): Converts a null-terminated byte array to java string
java.util.prefs.WindowsPreferences.childSpi	(	String	): Implements AbstractPreferences childSpi() method. Constructs a child node with a given name and creates its underlying Windows registry node, if it does not exist. Logs a warning message, if Windows Registry is unavailable.
java.util.prefs.WindowsPreferences.childrenNamesSpi	(	): Implements AbstractPreferences childrenNamesSpi() method. Calls Windows registry to retrive children of this node. Throws a BackingStoreException and logs a warning message, if Windows registry is not available.
java.util.prefs.WindowsPreferences.closeKey	(	int	): Closes Windows registry key. Logs a warning if Windows registry is unavailable.
java.util.prefs.WindowsPreferences.flush	(	): Implements Preferences flush() method. Flushes Windows registry changes to disk. Throws a BackingStoreException and logs a warning message if Windows registry is not available.
java.util.prefs.WindowsPreferences.flushSpi	(	): Empty, never used implementation of AbstractPreferences.flushSpi().
java.util.prefs.WindowsPreferences.getSpi	(	String	): Implements AbstractPreferences getSpi() method. Gets a string value from the underlying Windows registry node. Logs a warning, if Windows registry is unavailable.
java.util.prefs.WindowsPreferences.keysSpi	(	): Implements AbstractPreferences keysSpi() method. Gets value names from the underlying Windows registry node. Throws a BackingStoreException and logs a warning, if Windows registry is unavailable.
java.util.prefs.WindowsPreferences.openKey	(	byte[]	int	int	): Opens Windows registry key at a given absolute path using a given security mask.
java.util.prefs.WindowsPreferences.openKey	(	int	): Opens current node's underlying Windows registry key using a given security mask.
java.util.prefs.WindowsPreferences.openKey	(	int	byte[]	int	int	): Opens Windows registry key at a given relative path with respect to a given Windows registry key.
java.util.prefs.WindowsPreferences.openKey	(	int	int	): Opens current node's underlying Windows registry key using a given security mask.
java.util.prefs.WindowsPreferences.putSpi	(	String	String	): Implements AbstractPreferences putSpi() method. Puts name-value pair into the underlying Windows registry node. Logs a warning, if Windows registry is unavailable.
java.util.prefs.WindowsPreferences.removeNodeSpi	(	): Implements AbstractPreferences removeNodeSpi() method. Deletes underlying Windows registry node. Throws a BackingStoreException and logs a warning, if Windows registry is not available.
java.util.prefs.WindowsPreferences.removeSpi	(	String	): Implements AbstractPreferences removeSpi() method. Deletes a string name-value pair from the underlying Windows registry node, if this value still exists. Logs a warning, if Windows registry is unavailable or key has already been deleted.
java.util.prefs.WindowsPreferences.rootNativeHandle	(	): Returns native handle for the top Windows node for this node.
java.util.prefs.WindowsPreferences.stringToByteArray	(	String	): Returns this java string as a null-terminated byte array
java.util.prefs.WindowsPreferences.sync	(	): Implements Preferences sync() method. Flushes Windows registry changes to disk. Equivalent to flush().
java.util.prefs.WindowsPreferences.syncSpi	(	): Empty, never used implementation of AbstractPreferences.flushSpi().
java.util.prefs.WindowsPreferences.toJavaAlt64Name	(	String	): Converts value's or node's name from its Windows representation to java string, using altBase64 encoding. See toWindowsName() toWindowsName() for a detailed description of encoding conventions.
java.util.prefs.WindowsPreferences.toJavaName	(	byte[]	): Converts value's or node's name from its byte array representation to java string. Two encodings, simple and altBase64 are used. See toWindowsName() toWindowsName() for a detailed description of encoding conventions.
java.util.prefs.WindowsPreferences.toJavaValueString	(	byte[]	): Converts value string from its Windows representation to java string. See toWindowsValueString() toWindowsValueString() for the description of the encoding algorithm.
java.util.prefs.WindowsPreferences.toWindowsAlt64Name	(	String	): Converts value's or node's name to its Windows representation as a byte-encoded string, using altBase64 encoding. See toWindowsName() toWindowsName() for a detailed description of encoding conventions.
java.util.prefs.WindowsPreferences.toWindowsName	(	String	): Converts value's or node's name to its Windows representation as a byte-encoded string. Two encodings, simple and altBase64 are used.  Simple encoding is used, if java string does not contain any characters less, than 0x0020, or greater, than 0x007f. Simple encoding adds "/" character to capital letters, i.e. "A" is encoded as "/A". Character '\' is encoded as '//', '/' is encoded as '\'. The constructed string is converted to byte array by truncating the highest byte and adding the terminating null character.  altBase64 encoding is used, if java string does contain at least one character less, than 0x0020, or greater, than 0x007f. This encoding is marked by setting first two bytes of the Windows string to '/!'. The java name is then encoded using byteArrayToAltBase64() method from Base64 class.
java.util.prefs.WindowsPreferences.toWindowsValueString	(	String	): Converts value string to it Windows representation. as a byte-encoded string. Encoding algorithm adds "/" character to capital letters, i.e. "A" is encoded as "/A". Character '\' is encoded as '//', '/' is encoded as '\'. Then encoding scheme similar to jdk's native2ascii converter is used to convert java string to a byte array of ASCII characters.
java.util.prefs.WindowsPreferences.windowsAbsolutePath	(	): Returns Windows absolute path of the current node as a byte array. Java "/" separator is transformed into Windows "\".
java.util.prefs.WindowsPreferencesFactory: Implementation of PreferencesFactory to return WindowsPreferences objects.
java.util.prefs.WindowsPreferencesFactory.systemRoot	(	): Returns WindowsPreferences.systemRoot
java.util.prefs.WindowsPreferencesFactory.userRoot	(	): Returns WindowsPreferences.userRoot
java.util.prefs.XmlSupport: XML Support for java.util.prefs. Methods to import and export preference nodes and subtrees.
java.util.prefs.XmlSupport.ImportPrefs	(	Preferences	Element	): Import the preferences described by the specified XML element (a map from a preferences document) into the specified preferences node.
java.util.prefs.XmlSupport.ImportSubtree	(	Preferences	Element	): Recursively traverse the specified preferences node and store the described preferences into the system or current user preferences tree, as appropriate.
java.util.prefs.XmlSupport.createPrefsDoc	(	String	): Create a new prefs XML document.
java.util.prefs.XmlSupport.export	(	OutputStream	Preferences	boolean	): Export the specified preferences node and, if subTree is true, all subnodes, to the specified output stream. Preferences are exported as an XML document conforming to the definition in the Preferences spec.
java.util.prefs.XmlSupport.exportMap	(	OutputStream	Map	): Export the specified Map to a map document on the specified OutputStream as per the prefs DTD. This is used as the internal (undocumented) format for FileSystemPrefs.
java.util.prefs.XmlSupport.importMap	(	InputStream	Map	): Import Map from the specified input stream, which is assumed to contain a map document as per the prefs DTD. This is used as the internal (undocumented) format for FileSystemPrefs. The key-value pairs specified in the XML document will be put into the specified Map. (If this Map is empty, it will contain exactly the key-value pairs int the XML-document when this method returns.)
java.util.prefs.XmlSupport.importPreferences	(	InputStream	): Import preferences from the specified input stream, which is assumed to contain an XML document in the format described in the Preferences spec.
java.util.prefs.XmlSupport.loadPrefsDoc	(	InputStream	): Load an XML document from specified input stream, which must have the requisite DTD URI.
java.util.prefs.XmlSupport.putPreferencesInXml	(	Element	Document	Preferences	boolean	): Put the preferences in the specified Preferences node into the specified XML element which is assumed to represent a node in the specified XML document which is assumed to conform to PREFS_DTD. If subTree is true, create children of the specified XML node conforming to all of the children of the specified Preferences node and recurse.
java.util.prefs.XmlSupport.writeDoc	(	Document	OutputStream	): Write XML document to the specified output stream.
java.util.regex.ASCII: Utility class that implements the standard C ctype functionality.
java.util.regex.MatchResult: The result of a match operation. This interface contains query methods used to determine the results of a match against a regular expression. The match boundaries, groups and group boundaries can be seen but not modified through a MatchResult.
java.util.regex.MatchResult.end	(	): Returns the offset after the last character matched.
java.util.regex.MatchResult.end	(	int	): Returns the offset after the last character of the subsequence captured by the given group during this match.  Capturing groups are indexed from left to right, starting at one. Group zero denotes the entire pattern, so the expression m.end(0) is equivalent to m.end(). 
java.util.regex.MatchResult.group	(	): Returns the input subsequence matched by the previous match.  For a matcher m with input sequence s, the expressions m.group() and s.substring(m.start(), m.end()) are equivalent.   Note that some patterns, for example a*, match the empty string. This method will return the empty string when the pattern successfully matches the empty string in the input. 
java.util.regex.MatchResult.group	(	int	): Returns the input subsequence captured by the given group during the previous match operation.  For a matcher m, input sequence s, and group index g, the expressions m.group(g) and s.substring(m.start(g), m.end(g)) are equivalent.   Capturing groups are indexed from left to right, starting at one. Group zero denotes the entire pattern, so the expression m.group(0) is equivalent to m.group().   If the match was successful but the group specified failed to match any part of the input sequence, then null is returned. Note that some groups, for example (a*), match the empty string. This method will return the empty string when such a group successfully matches the empty string in the input. 
java.util.regex.MatchResult.groupCount	(	): Returns the number of capturing groups in this match result's pattern.  Group zero denotes the entire pattern by convention. It is not included in this count.  Any non-negative integer smaller than or equal to the value returned by this method is guaranteed to be a valid group index for this matcher. 
java.util.regex.MatchResult.start	(	): Returns the start index of the match.
java.util.regex.MatchResult.start	(	int	): Returns the start index of the subsequence captured by the given group during this match.  Capturing groups are indexed from left to right, starting at one. Group zero denotes the entire pattern, so the expression m.start(0) is equivalent to m.start(). 
java.util.regex.Matcher: An engine that performs match operations on a java.lang.CharSequence character sequence by interpreting a Pattern.  A matcher is created from a pattern by invoking the pattern's matcher method. Once created, a matcher can be used to perform three different kinds of match operations:   The matches method attempts to match the entire input sequence against the pattern.   The lookingAt method attempts to match the input sequence, starting at the beginning, against the pattern.   The find method scans the input sequence looking for the next subsequence that matches the pattern.    Each of these methods returns a boolean indicating success or failure. More information about a successful match can be obtained by querying the state of the matcher.  A matcher finds matches in a subset of its input called the region. By default, the region contains all of the matcher's input. The region can be modified via the region method and queried via the regionStart and regionEnd methods. The way that the region boundaries interact with some pattern constructs can be changed. See useAnchoringBounds and useTransparentBounds for more details.  This class also defines methods for replacing matched subsequences with new strings whose contents can, if desired, be computed from the match result. The appendReplacement and appendTail methods can be used in tandem in order to collect the result into an existing string buffer, or the more convenient replaceAll method can be used to create a string in which every matching subsequence in the input sequence is replaced.  The explicit state of a matcher includes the start and end indices of the most recent successful match. It also includes the start and end indices of the input subsequence captured by each capturing group in the pattern as well as a total count of such subsequences. As a convenience, methods are also provided for returning these captured subsequences in string form.  The explicit state of a matcher is initially undefined; attempting to query any part of it before a successful match will cause an IllegalStateException to be thrown. The explicit state of a matcher is recomputed by every match operation.  The implicit state of a matcher includes the input character sequence as well as the append position, which is initially zero and is updated by the appendReplacement method.  A matcher may be reset explicitly by invoking its reset() method or, if a new input sequence is desired, its reset() reset(CharSequence) method. Resetting a matcher discards its explicit state information and sets the append position to zero.  Instances of this class are not safe for use by multiple concurrent threads. 
java.util.regex.Matcher.Matcher	(	): No default constructor.
java.util.regex.Matcher.Matcher	(	Pattern	CharSequence	): All matchers have the state used by Pattern during a match.
java.util.regex.Matcher.appendReplacement	(	StringBuffer	String	): Implements a non-terminal append-and-replace step.  This method performs the following actions:    It reads characters from the input sequence, starting at the append position, and appends them to the given string buffer. It stops after reading the last character preceding the previous match, that is, the character at index start() - 1.   It appends the given replacement string to the string buffer.   It sets the append position of this matcher to the index of the last character matched, plus one, that is, to end().    The replacement string may contain references to subsequences captured during the previous match: Each occurrence of ${name} or $g will be replaced by the result of evaluating the corresponding group() group(name) or group() group(g) respectively. For $g, the first number after the $ is always treated as part of the group reference. Subsequent numbers are incorporated into g if they would form a legal group reference. Only the numerals '0' through '9' are considered as potential components of the group reference. If the second group matched the string "foo", for example, then passing the replacement string "$2bar" would cause "foobar" to be appended to the string buffer. A dollar sign ($) may be included as a literal in the replacement string by preceding it with a backslash (\$).  Note that backslashes (\) and dollar signs ($) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string. Dollar signs may be treated as references to captured subsequences as described above, and backslashes are used to escape literal characters in the replacement string.  This method is intended to be used in a loop together with the appendTail and find methods. The following code, for example, writes one dog two dogs in the yard to the standard-output stream:   Pattern p = Pattern.compile("cat"); Matcher m = p.matcher("one cat two cats in the yard"); StringBuffer sb = new StringBuffer(); while (m.find()) { m.appendReplacement(sb, "dog"); } m.appendTail(sb); System.out.println(sb.toString());
java.util.regex.Matcher.appendTail	(	StringBuffer	): Implements a terminal append-and-replace step.  This method reads characters from the input sequence, starting at the append position, and appends them to the given string buffer. It is intended to be invoked after one or more invocations of the appendReplacement method in order to copy the remainder of the input sequence. 
java.util.regex.Matcher.charAt	(	int	): Returns this Matcher's input character at index i.
java.util.regex.Matcher.end	(	): Returns the offset after the last character matched.
java.util.regex.Matcher.end	(	String	): Returns the offset after the last character of the subsequence captured by the given named-capturing group during the previous match operation.
java.util.regex.Matcher.end	(	int	): Returns the offset after the last character of the subsequence captured by the given group during the previous match operation.  Capturing groups are indexed from left to right, starting at one. Group zero denotes the entire pattern, so the expression m.end(0) is equivalent to m.end(). 
java.util.regex.Matcher.find	(	): Attempts to find the next subsequence of the input sequence that matches the pattern.  This method starts at the beginning of this matcher's region, or, if a previous invocation of the method was successful and the matcher has not since been reset, at the first character not matched by the previous match.  If the match succeeds then more information can be obtained via the start, end, and group methods. 
java.util.regex.Matcher.find	(	int	): Resets this matcher and then attempts to find the next subsequence of the input sequence that matches the pattern, starting at the specified index.  If the match succeeds then more information can be obtained via the start, end, and group methods, and subsequent invocations of the find() method will start at the first character not matched by this match. 
java.util.regex.Matcher.getMatchedGroupIndex	(	String	): Returns the group index of the matched capturing group.
java.util.regex.Matcher.getSubSequence	(	int	int	): Generates a String from this Matcher's input in the specified range.
java.util.regex.Matcher.getTextLength	(	): Returns the end index of the text.
java.util.regex.Matcher.group	(	): Returns the input subsequence matched by the previous match.  For a matcher m with input sequence s, the expressions m.group() and s.substring(m.start(), m.end()) are equivalent.   Note that some patterns, for example a*, match the empty string. This method will return the empty string when the pattern successfully matches the empty string in the input. 
java.util.regex.Matcher.group	(	String	): Returns the input subsequence captured by the given named-capturing group during the previous match operation.  If the match was successful but the group specified failed to match any part of the input sequence, then null is returned. Note that some groups, for example (a*), match the empty string. This method will return the empty string when such a group successfully matches the empty string in the input. 
java.util.regex.Matcher.group	(	int	): Returns the input subsequence captured by the given group during the previous match operation.  For a matcher m, input sequence s, and group index g, the expressions m.group(g) and s.substring(m.start(g), m.end(g)) are equivalent.   Capturing groups are indexed from left to right, starting at one. Group zero denotes the entire pattern, so the expression m.group(0) is equivalent to m.group().   If the match was successful but the group specified failed to match any part of the input sequence, then null is returned. Note that some groups, for example (a*), match the empty string. This method will return the empty string when such a group successfully matches the empty string in the input. 
java.util.regex.Matcher.groupCount	(	): Returns the number of capturing groups in this matcher's pattern.  Group zero denotes the entire pattern by convention. It is not included in this count.  Any non-negative integer smaller than or equal to the value returned by this method is guaranteed to be a valid group index for this matcher. 
java.util.regex.Matcher.hasAnchoringBounds	(	): Queries the anchoring of region bounds for this matcher.  This method returns true if this matcher uses anchoring bounds, false otherwise.  See useAnchoringBounds for a description of anchoring bounds.  By default, a matcher uses anchoring region boundaries.
java.util.regex.Matcher.hasTransparentBounds	(	): Queries the transparency of region bounds for this matcher.  This method returns true if this matcher uses transparent bounds, false if it uses opaque bounds.  See useTransparentBounds for a description of transparent and opaque bounds.  By default, a matcher uses opaque region boundaries.
java.util.regex.Matcher.hitEnd	(	): Returns true if the end of input was hit by the search engine in the last match operation performed by this matcher. When this method returns true, then it is possible that more input would have changed the result of the last search.
java.util.regex.Matcher.lookingAt	(	): Attempts to match the input sequence, starting at the beginning of the region, against the pattern.  Like the matches method, this method always starts at the beginning of the region; unlike that method, it does not require that the entire region be matched.  If the match succeeds then more information can be obtained via the start, end, and group methods. 
java.util.regex.Matcher.match	(	int	int	): Initiates a search for an anchored match to a Pattern within the given bounds. The groups are filled with default values and the match of the root of the state machine is called. The state machine will hold the state of the match as it proceeds in this matcher.
java.util.regex.Matcher.matches	(	): Attempts to match the entire region against the pattern.  If the match succeeds then more information can be obtained via the start, end, and group methods. 
java.util.regex.Matcher.pattern	(	): Returns the pattern that is interpreted by this matcher.
java.util.regex.Matcher.quoteReplacement	(	String	): Returns a literal replacement String for the specified String. This method produces a String that will work as a literal replacement s in the appendReplacement method of the Matcher class. The String produced will match the sequence of characters in s treated as a literal sequence. Slashes ('\') and dollar signs ('$') will be given no special meaning.
java.util.regex.Matcher.region	(	int	int	): Sets the limits of this matcher's region. The region is the part of the input sequence that will be searched to find a match. Invoking this method resets the matcher, and then sets the region to start at the index specified by the start parameter and end at the index specified by the end parameter. Depending on the transparency and anchoring being used (see useTransparentBounds and useAnchoringBounds), certain constructs such as anchors may behave differently at or around the boundaries of the region.
java.util.regex.Matcher.regionEnd	(	): Reports the end index (exclusive) of this matcher's region. The searches this matcher conducts are limited to finding matches within regionStart (inclusive) and regionEnd (exclusive).
java.util.regex.Matcher.regionStart	(	): Reports the start index of this matcher's region. The searches this matcher conducts are limited to finding matches within regionStart (inclusive) and regionEnd (exclusive).
java.util.regex.Matcher.replaceAll	(	String	): Replaces every subsequence of the input sequence that matches the pattern with the given replacement string.  This method first resets this matcher. It then scans the input sequence looking for matches of the pattern. Characters that are not part of any match are appended directly to the result string; each match is replaced in the result by the replacement string. The replacement string may contain references to captured subsequences as in the appendReplacement method.  Note that backslashes (\) and dollar signs ($) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string. Dollar signs may be treated as references to captured subsequences as described above, and backslashes are used to escape literal characters in the replacement string.  Given the regular expression a*b, the input "aabfooaabfooabfoob", and the replacement string "-", an invocation of this method on a matcher for that expression would yield the string "-foo-foo-foo-".  Invoking this method changes this matcher's state. If the matcher is to be used in further matching operations then it should first be reset. 
java.util.regex.Matcher.replaceFirst	(	String	): Replaces the first subsequence of the input sequence that matches the pattern with the given replacement string.  This method first resets this matcher. It then scans the input sequence looking for a match of the pattern. Characters that are not part of the match are appended directly to the result string; the match is replaced in the result by the replacement string. The replacement string may contain references to captured subsequences as in the appendReplacement method. Note that backslashes (\) and dollar signs ($) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string. Dollar signs may be treated as references to captured subsequences as described above, and backslashes are used to escape literal characters in the replacement string.  Given the regular expression dog, the input "zzzdogzzzdogzzz", and the replacement string "cat", an invocation of this method on a matcher for that expression would yield the string "zzzcatzzzdogzzz".   Invoking this method changes this matcher's state. If the matcher is to be used in further matching operations then it should first be reset. 
java.util.regex.Matcher.requireEnd	(	): Returns true if more input could change a positive match into a negative one. If this method returns true, and a match was found, then more input could cause the match to be lost. If this method returns false and a match was found, then more input might change the match but the match won't be lost. If a match was not found, then requireEnd has no meaning.
java.util.regex.Matcher.reset	(	): Resets this matcher.  Resetting a matcher discards all of its explicit state information and sets its append position to zero. The matcher's region is set to the default region, which is its entire character sequence. The anchoring and transparency of this matcher's region boundaries are unaffected.
java.util.regex.Matcher.reset	(	CharSequence	): Resets this matcher with a new input sequence.  Resetting a matcher discards all of its explicit state information and sets its append position to zero. The matcher's region is set to the default region, which is its entire character sequence. The anchoring and transparency of this matcher's region boundaries are unaffected.
java.util.regex.Matcher.search	(	int	): Initiates a search to find a Pattern within the given bounds. The groups are filled with default values and the match of the root of the state machine is called. The state machine will hold the state of the match as it proceeds in this matcher. Matcher.from is not set here, because it is the "hard" boundary of the start of the search which anchors will set to. The from param is the "soft" boundary of the start of the search, meaning that the regex tries to match at that index but ^ won't match there. Subsequent calls to the search methods start at a new "soft" boundary which is the end of the previous match.
java.util.regex.Matcher.start	(	): Returns the start index of the previous match.
java.util.regex.Matcher.start	(	String	): Returns the start index of the subsequence captured by the given named-capturing group during the previous match operation.
java.util.regex.Matcher.start	(	int	): Returns the start index of the subsequence captured by the given group during the previous match operation.  Capturing groups are indexed from left to right, starting at one. Group zero denotes the entire pattern, so the expression m.start(0) is equivalent to m.start(). 
java.util.regex.Matcher.toMatchResult	(	): Returns the match state of this matcher as a MatchResult. The result is unaffected by subsequent operations performed upon this matcher.
java.util.regex.Matcher.toString	(	): Returns the string representation of this matcher. The string representation of a Matcher contains information that may be useful for debugging. The exact format is unspecified.
java.util.regex.Matcher.useAnchoringBounds	(	boolean	): Sets the anchoring of region bounds for this matcher.  Invoking this method with an argument of true will set this matcher to use anchoring bounds. If the boolean argument is false, then non-anchoring bounds will be used.  Using anchoring bounds, the boundaries of this matcher's region match anchors such as ^ and $.  Without anchoring bounds, the boundaries of this matcher's region will not match anchors such as ^ and $.  By default, a matcher uses anchoring region boundaries.
java.util.regex.Matcher.usePattern	(	Pattern	): Changes the Pattern that this Matcher uses to find matches with.  This method causes this matcher to lose information about the groups of the last match that occurred. The matcher's position in the input is maintained and its last append position is unaffected.
java.util.regex.Matcher.useTransparentBounds	(	boolean	): Sets the transparency of region bounds for this matcher.  Invoking this method with an argument of true will set this matcher to use transparent bounds. If the boolean argument is false, then opaque bounds will be used.  Using transparent bounds, the boundaries of this matcher's region are transparent to lookahead, lookbehind, and boundary matching constructs. Those constructs can see beyond the boundaries of the region to see if a match is appropriate.  Using opaque bounds, the boundaries of this matcher's region are opaque to lookahead, lookbehind, and boundary matching constructs that may try to see beyond them. Those constructs cannot look past the boundaries so they will fail to match anything outside of the region.  By default, a matcher uses opaque bounds.
java.util.regex.Pattern: A compiled representation of a regular expression.  A regular expression, specified as a string, must first be compiled into an instance of this class. The resulting pattern can then be used to create a Matcher object that can match arbitrary java.lang.CharSequence character sequences against the regular expression. All of the state involved in performing a match resides in the matcher, so many matchers can share the same pattern.  A typical invocation sequence is thus  Pattern p = Pattern.compile("a*b"); Matcher m = p.matcher("aaaaab"); boolean b = m.matches();  A matches method is defined by this class as a convenience for when a regular expression is used just once. This method compiles an expression and matches an input sequence against it in a single invocation. The statement  boolean b = Pattern.matches("a*b", "aaaaab"); is equivalent to the three statements above, though for repeated matches it is less efficient since it does not allow the compiled pattern to be reused.  Instances of this class are immutable and are safe for use by multiple concurrent threads. Instances of the Matcher class are not safe for such use. Summary of regular-expression constructs   Construct Matches    Characters x The character x \\ The backslash character \0n The character with octal value 0n (0 <= n <= 7) \0nn The character with octal value 0nn (0 <= n <= 7) \0mnn The character with octal value 0mnn (0 <= m <= 3, 0 <= n <= 7) \xhh The character with hexadecimal value 0xhh \uhhhh The character with hexadecimal value 0xhhhh \x{h...h} The character with hexadecimal value 0xh...h (MIN_CODE_POINT Character.MIN_CODE_POINT  <= 0xh...h <=  MAX_CODE_POINT Character.MAX_CODE_POINT) \t The tab character ('\u0009') \n The newline (line feed) character ('\u000A') \r The carriage-return character ('\u000D') \f The form-feed character ('\u000C') \a The alert (bell) character ('\u0007') \e The escape character ('\u001B') \cx The control character corresponding to x   Character classes [abc] a, b, or c (simple class) [^abc] Any character except a, b, or c (negation) [a-zA-Z] a through z or A through Z, inclusive (range) [a-d[m-p]] a through d, or m through p: [a-dm-p] (union) [a-z&&[def]] d, e, or f (intersection) [a-z&&[^bc]] a through z, except for b and c: [ad-z] (subtraction) [a-z&&[^m-p]] a through z, and not m through p: [a-lq-z](subtraction)   Predefined character classes . Any character (may or may not match line terminators) \d A digit: [0-9] \D A non-digit: [^0-9] \h A horizontal whitespace character: [ \t\xA0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000] \H A non-horizontal whitespace character: [^\h] \s A whitespace character: [ \t\n\x0B\f\r] \S A non-whitespace character: [^\s] \v A vertical whitespace character: [\n\x0B\f\r\x85\u2028\u2029]  \V A non-vertical whitespace character: [^\v] \w A word character: [a-zA-Z_0-9] \W A non-word character: [^\w]   POSIX character classes (US-ASCII only) \p{Lower} A lower-case alphabetic character: [a-z] \p{Upper} An upper-case alphabetic character:[A-Z] \p{ASCII} All ASCII:[\x00-\x7F] \p{Alpha} An alphabetic character:[\p{Lower}\p{Upper}] \p{Digit} A decimal digit: [0-9] \p{Alnum} An alphanumeric character:[\p{Alpha}\p{Digit}] \p{Punct} Punctuation: One of !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~  \p{Graph} A visible character: [\p{Alnum}\p{Punct}] \p{Print} A printable character: [\p{Graph}\x20] \p{Blank} A space or a tab: [ \t] \p{Cntrl} A control character: [\x00-\x1F\x7F] \p{XDigit} A hexadecimal digit: [0-9a-fA-F] \p{Space} A whitespace character: [ \t\n\x0B\f\r]   java.lang.Character classes (simple java character type) \p{javaLowerCase} Equivalent to java.lang.Character.isLowerCase() \p{javaUpperCase} Equivalent to java.lang.Character.isUpperCase() \p{javaWhitespace} Equivalent to java.lang.Character.isWhitespace() \p{javaMirrored} Equivalent to java.lang.Character.isMirrored()   Classes for Unicode scripts, blocks, categories and binary properties \p{IsLatin} A Latin script character (script) \p{InGreek} A character in the Greek block (block) \p{Lu} An uppercase letter (category) \p{IsAlphabetic} An alphabetic character (binary property) \p{Sc} A currency symbol \P{InGreek} Any character except one in the Greek block (negation) [\p{L}&&[^\p{Lu}]] Any letter except an uppercase letter (subtraction)   Boundary matchers ^ The beginning of a line $ The end of a line \b A word boundary \B A non-word boundary \A The beginning of the input \G The end of the previous match \Z The end of the input but for the final terminator, if any \z The end of the input   Linebreak matcher \R Any Unicode linebreak sequence, is equivalent to \u000D\u000A|[\u000A\u000B\u000C\u000D\u0085\u2028\u2029]    Greedy quantifiers X? X, once or not at all X* X, zero or more times X+ X, one or more times X{n} X, exactly n times X{n,} X, at least n times X{n,m} X, at least n but not more than m times   Reluctant quantifiers X?? X, once or not at all X*? X, zero or more times X+? X, one or more times X{n}? X, exactly n times X{n,}? X, at least n times X{n,m}? X, at least n but not more than m times   Possessive quantifiers X?+ X, once or not at all X*+ X, zero or more times X++ X, one or more times X{n}+ X, exactly n times X{n,}+ X, at least n times X{n,m}+ X, at least n but not more than m times   Logical operators XY X followed by Y X|Y Either X or Y (X) X, as a capturing group   Back references \n Whatever the nth capturing group matched \k<name> Whatever the named-capturing group "name" matched   Quotation \ Nothing, but quotes the following character \Q Nothing, but quotes all characters until \E \E Nothing, but ends quoting started by \Q    Special constructs (named-capturing and non-capturing) (?<name>X) X, as a named-capturing group (?:X) X, as a non-capturing group (?idmsuxU-idmsuxU)  Nothing, but turns match flags i d m s u x U on - off (?idmsux-idmsux:X)   X, as a non-capturing group with the given flags i d m s u x on - off (?=X) X, via zero-width positive lookahead (?!X) X, via zero-width negative lookahead (?<=X) X, via zero-width positive lookbehind (?<!X) X, via zero-width negative lookbehind (?>X) X, as an independent, non-capturing group   Backslashes, escapes, and quoting  The backslash character ('\') serves to introduce escaped constructs, as defined in the table above, as well as to quote characters that otherwise would be interpreted as unescaped constructs. Thus the expression \\ matches a single backslash and \{ matches a left brace.  It is an error to use a backslash prior to any alphabetic character that does not denote an escaped construct; these are reserved for future extensions to the regular-expression language. A backslash may be used prior to a non-alphabetic character regardless of whether that character is part of an unescaped construct.  Backslashes within string literals in Java source code are interpreted as required by The Java Language Specification as either Unicode escapes (section 3.3) or other character escapes (section 3.10.6) It is therefore necessary to double backslashes in string literals that represent regular expressions to protect them from interpretation by the Java bytecode compiler. The string literal "\b", for example, matches a single backspace character when interpreted as a regular expression, while "\\b" matches a word boundary. The string literal "\(hello\)" is illegal and leads to a compile-time error; in order to match the string (hello) the string literal "\\(hello\\)" must be used. Character Classes  Character classes may appear within other character classes, and may be composed by the union operator (implicit) and the intersection operator (&&). The union operator denotes a class that contains every character that is in at least one of its operand classes. The intersection operator denotes a class that contains every character that is in both of its operand classes.  The precedence of character-class operators is as follows, from highest to lowest:  1     Literal escape     \x 2     Grouping [...] 3     Range a-z 4     Union [a-e][i-u] 5     Intersection [a-z&&[aeiou]]   Note that a different set of metacharacters are in effect inside a character class than outside a character class. For instance, the regular expression . loses its special meaning inside a character class, while the expression - becomes a range forming metacharacter. Line terminators  A line terminator is a one- or two-character sequence that marks the end of a line of the input character sequence. The following are recognized as line terminators:   A newline (line feed) character ('\n'),  A carriage-return character followed immediately by a newline character ("\r\n"),  A standalone carriage-return character ('\r'),  A next-line character ('\u0085'),  A line-separator character ('\u2028'), or  A paragraph-separator character ('\u2029).  If UNIX_LINES mode is activated, then the only line terminators recognized are newline characters.  The regular expression . matches any character except a line terminator unless the DOTALL flag is specified.  By default, the regular expressions ^ and $ ignore line terminators and only match at the beginning and the end, respectively, of the entire input sequence. If MULTILINE mode is activated then ^ matches at the beginning of input and after any line terminator except at the end of input. When in MULTILINE mode $ matches just before a line terminator or the end of the input sequence. Groups and capturing Group number  Capturing groups are numbered by counting their opening parentheses from left to right. In the expression ((A)(B(C))), for example, there are four such groups:   1     ((A)(B(C))) 2     (A) 3     (B(C)) 4     (C)   Group zero always stands for the entire expression.  Capturing groups are so named because, during a match, each subsequence of the input sequence that matches such a group is saved. The captured subsequence may be used later in the expression, via a back reference, and may also be retrieved from the matcher once the match operation is complete. Group name A capturing group can also be assigned a "name", a named-capturing group, and then be back-referenced later by the "name". Group names are composed of the following characters. The first character must be a letter.   The uppercase letters 'A' through 'Z' ('\u0041' through '\u005a'),  The lowercase letters 'a' through 'z' ('\u0061' through '\u007a'),  The digits '0' through '9' ('\u0030' through '\u0039'),   A named-capturing group is still numbered as described in Group number.  The captured input associated with a group is always the subsequence that the group most recently matched. If a group is evaluated a second time because of quantification then its previously-captured value, if any, will be retained if the second evaluation fails. Matching the string "aba" against the expression (a(b)?)+, for example, leaves group two set to "b". All captured input is discarded at the beginning of each match.  Groups beginning with (? are either pure, non-capturing groups that do not capture text and do not count towards the group total, or named-capturing group.  Unicode support   This class is in conformance with Level 1 of Unicode Technical Standard #18: Unicode Regular Expression, plus RL2.1 Canonical Equivalents.  Unicode escape sequences such as \u2014 in Java source code are processed as described in section 3.3 of The Java Language Specification. Such escape sequences are also implemented directly by the regular-expression parser so that Unicode escapes can be used in expressions that are read from files or from the keyboard. Thus the strings "\u2014" and "\\u2014", while not equal, compile into the same pattern, which matches the character with hexadecimal value 0x2014.  A Unicode character can also be represented in a regular-expression by using its Hex notation(hexadecimal code point value) directly as described in construct \x{...}, for example a supplementary character U+2011F can be specified as \x{2011F}, instead of two consecutive Unicode escape sequences of the surrogate pair \uD840\uDD1F.  Unicode scripts, blocks, categories and binary properties are written with the \p and \P constructs as in Perl. \p{prop} matches if the input has the property prop, while \P{prop} does not match if the input has that property.  Scripts, blocks, categories and binary properties can be used both inside and outside of a character class.  Scripts are specified either with the prefix Is, as in IsHiragana, or by using the script keyword (or its short form sc)as in script=Hiragana or sc=Hiragana.  The script names supported by Pattern are the valid script names accepted and defined by forName() UnicodeScript.forName.  Blocks are specified with the prefix In, as in InMongolian, or by using the keyword block (or its short form blk) as in block=Mongolian or blk=Mongolian.  The block names supported by Pattern are the valid block names accepted and defined by forName() UnicodeBlock.forName.  Categories may be specified with the optional prefix Is: Both \p{L} and \p{IsL} denote the category of Unicode letters. Same as scripts and blocks, categories can also be specified by using the keyword general_category (or its short form gc) as in general_category=Lu or gc=Lu.  The supported categories are those of  The Unicode Standard in the version specified by the java.lang.Character Character class. The category names are those defined in the Standard, both normative and informative.  Binary properties are specified with the prefix Is, as in IsAlphabetic. The supported binary properties by Pattern are   Alphabetic  Ideographic  Letter  Lowercase  Uppercase  Titlecase  Punctuation  Control  White_Space  Digit  Hex_Digit  Join_Control  Noncharacter_Code_Point  Assigned   The following Predefined Character classes and POSIX character classes are in conformance with the recommendation of Annex C: Compatibility Properties of Unicode Regular Expression , when UNICODE_CHARACTER_CLASS flag is specified.   Classes Matches  \p{Lower} A lowercase character:\p{IsLowercase} \p{Upper} An uppercase character:\p{IsUppercase} \p{ASCII} All ASCII:[\x00-\x7F] \p{Alpha} An alphabetic character:\p{IsAlphabetic} \p{Digit} A decimal digit character:p{IsDigit} \p{Alnum} An alphanumeric character:[\p{IsAlphabetic}\p{IsDigit}] \p{Punct} A punctuation character:p{IsPunctuation} \p{Graph} A visible character: [^\p{IsWhite_Space}\p{gc=Cc}\p{gc=Cs}\p{gc=Cn}] \p{Print} A printable character: [\p{Graph}\p{Blank}&&[^\p{Cntrl}]] \p{Blank} A space or a tab: [\p{IsWhite_Space}&&[^\p{gc=Zl}\p{gc=Zp}\x0a\x0b\x0c\x0d\x85]] \p{Cntrl} A control character: \p{gc=Cc} \p{XDigit} A hexadecimal digit: [\p{gc=Nd}\p{IsHex_Digit}] \p{Space} A whitespace character:\p{IsWhite_Space} \d A digit: \p{IsDigit} \D A non-digit: [^\d] \s A whitespace character: \p{IsWhite_Space} \S A non-whitespace character: [^\s] \w A word character: [\p{Alpha}\p{gc=Mn}\p{gc=Me}\p{gc=Mc}\p{Digit}\p{gc=Pc}\p{IsJoin_Control}] \W A non-word character: [^\w]    Categories that behave like the java.lang.Character boolean ismethodname methods (except for the deprecated ones) are available through the same \p{prop} syntax where the specified property has the name javamethodname.  Comparison to Perl 5  The Pattern engine performs traditional NFA-based matching with ordered alternation as occurs in Perl 5.  Perl constructs not supported by this class:    Predefined character classes (Unicode character) \X    Match Unicode  extended grapheme cluster   The backreference constructs, \g{n} for the nthcapturing group and \g{name} for named-capturing group.   The named character construct, \N{name} for a Unicode character by its name.   The conditional constructs (?(condition)X) and (?(condition)X|Y),   The embedded code constructs (?{code}) and (??{code}),  The embedded comment syntax (?#comment), and   The preprocessing operations \l \u, \L, and \U.    Constructs supported by this class but not by Perl:    Character-class union and intersection as described above.   Notable differences from Perl:    In Perl, \1 through \9 are always interpreted as back references; a backslash-escaped number greater than 9 is treated as a back reference if at least that many subexpressions exist, otherwise it is interpreted, if possible, as an octal escape. In this class octal escapes must always begin with a zero. In this class, \1 through \9 are always interpreted as back references, and a larger number is accepted as a back reference if at least that many subexpressions exist at that point in the regular expression, otherwise the parser will drop digits until the number is smaller or equal to the existing number of groups or it is one digit.   Perl uses the g flag to request a match that resumes where the last match left off. This functionality is provided implicitly by the Matcher class: Repeated invocations of the find method will resume where the last match left off, unless the matcher is reset.   In Perl, embedded flags at the top level of an expression affect the whole expression. In this class, embedded flags always take effect at the point at which they appear, whether they are at the top level or within a group; in the latter case, flags are restored at the end of the group just as in Perl.    For a more precise description of the behavior of regular expression constructs, please see  Mastering Regular Expressions, 3nd Edition, Jeffrey E. F. Friedl, O'Reilly and Associates, 2006. 
java.util.regex.Pattern.All: Implements the Unicode category ALL and the dot metacharacter when in dotall mode.
java.util.regex.Pattern.BackRef: Refers to a group in the regular expression. Attempts to match whatever the group referred to last matched.
java.util.regex.Pattern.Begin: Node to anchor at the beginning of input. This object implements the match for a \A sequence, and the caret anchor will use this if not in multiline mode.
java.util.regex.Pattern.Behind: Zero width positive lookbehind.
java.util.regex.Pattern.BehindS: Zero width positive lookbehind, including supplementary characters or unpaired surrogates.
java.util.regex.Pattern.BitClass: Creates a bit vector for matching Latin-1 values. A normal BitClass never matches values above Latin-1, and a complemented BitClass always matches values above Latin-1.
java.util.regex.Pattern.Block: Node class that matches a Unicode block.
java.util.regex.Pattern.BmpCharProperty: Optimized version of CharProperty that works only for properties never satisfied by Supplementary characters.
java.util.regex.Pattern.BnM: Attempts to match a slice in the input using the Boyer-Moore string matching algorithm. The algorithm is based on the idea that the pattern can be shifted farther ahead in the search text if it is matched right to left.  The pattern is compared to the input one character at a time, from the rightmost character in the pattern to the left. If the characters all match the pattern has been found. If a character does not match, the pattern is shifted right a distance that is the maximum of two functions, the bad character shift and the good suffix shift. This shift moves the attempted match position through the input more quickly than a naive one position at a time check.  The bad character shift is based on the character from the text that did not match. If the character does not appear in the pattern, the pattern can be shifted completely beyond the bad character. If the character does occur in the pattern, the pattern can be shifted to line the pattern up with the next occurrence of that character.  The good suffix shift is based on the idea that some subset on the right side of the pattern has matched. When a bad character is found, the pattern can be shifted right by the pattern length if the subset does not occur again in pattern, or by the amount of distance to the next occurrence of the subset in the pattern. Boyer-Moore search methods adapted from code by Amy Yu.
java.util.regex.Pattern.BnM.optimize	(	Node	): Pre calculates arrays needed to generate the bad character shift and the good suffix shift. Only the last seven bits are used to see if chars match; This keeps the tables small and covers the heavily used ASCII range, but occasionally results in an aliased match for the bad character shift.
java.util.regex.Pattern.BnMS: Supplementary support version of BnM(). Unpaired surrogates are also handled by this class.
java.util.regex.Pattern.Bound: Handles word boundaries. Includes a field to allow this one class to deal with the different types of word boundaries we can match. The word characters include underscores, letters, and digits. Non spacing marks can are also part of a word if they have a base character, otherwise they are ignored for purposes of finding word boundaries.
java.util.regex.Pattern.Branch: Handles the branching of alternations. Note this is also used for the ? quantifier to branch between the case where it matches once and where it does not occur.
java.util.regex.Pattern.BranchConn: A Guard node at the end of each atom node in a Branch. It serves the purpose of chaining the "match" operation to "next" but not the "study", so we can collect the TreeInfo of each atom node without including the TreeInfo of the "next".
java.util.regex.Pattern.Caret: Node to anchor at the beginning of a line. This is essentially the object to match for the multiline ^.
java.util.regex.Pattern.Category: Node class that matches a Unicode category.
java.util.regex.Pattern.CharProperty: Abstract node class to match one character satisfying some boolean property.
java.util.regex.Pattern.Ctype: Node class that matches a POSIX type.
java.util.regex.Pattern.Curly: Handles the curly-brace style repetition with a specified minimum and maximum occurrences. The * quantifier is handled as a special case. This class handles the three types.
java.util.regex.Pattern.Dollar: Node to anchor at the end of a line or the end of input based on the multiline mode. When not in multiline mode, the $ can only match at the very end of the input, unless the input ends in a line terminator in which it matches right before the last line terminator. Note that \r\n is considered an atomic line terminator. Like ^ the $ operator matches at a position, it does not match the line terminators themselves.
java.util.regex.Pattern.Dot: Node class for the dot metacharacter when dotall is not enabled.
java.util.regex.Pattern.End: Node to anchor at the end of input. This is the absolute end, so this should not match at the last newline before the end as $ will.
java.util.regex.Pattern.First: Searches until the next instance of its atom. This is useful for finding the atom efficiently without passing an instance of it (greedy problem) and without a lot of wasted search time (reluctant problem).
java.util.regex.Pattern.GroupCurly: Handles the curly-brace style repetition with a specified minimum and maximum occurrences in deterministic cases. This is an iterative optimization over the Prolog and Loop system which would handle this in a recursive way. The * quantifier is handled as a special case. If capture is true then this class saves group settings and ensures that groups are unset when backing off of a group match.
java.util.regex.Pattern.GroupHead: The GroupHead saves the location where the group begins in the locals and restores them when the match is done. The matchRef is used when a reference to this group is accessed later in the expression. The locals will have a negative value in them to indicate that we do not want to unset the group if the reference doesn't match.
java.util.regex.Pattern.GroupRef: Recursive reference to a group in the regular expression. It calls matchRef because if the reference fails to match we would not unset the group.
java.util.regex.Pattern.GroupTail: The GroupTail handles the setting of group beginning and ending locations when groups are successfully matched. It must also be able to unset groups that have to be backed off of. The GroupTail node is also used when a previous group is referenced, and in that case no group information needs to be set.
java.util.regex.Pattern.HorizWS: Node class that matches a Perl horizontal whitespace
java.util.regex.Pattern.LastMatch: Node to match the location where the last match ended. This is used for the \G construct.
java.util.regex.Pattern.LastNode.match	(	Matcher	int	CharSequence	): This method implements the classic accept node with the addition of a check to see if the match occurred using all of the input.
java.util.regex.Pattern.LazyLoop: Handles the repetition count for a reluctant Curly. The matchInit is called from the Prolog to save the index of where the group beginning is stored. A zero length group check occurs in the normal match but is skipped in the matchInit.
java.util.regex.Pattern.LineEnding: Node class that matches a Unicode line ending '\R'
java.util.regex.Pattern.Loop: Handles the repetition count for a greedy Curly. The matchInit is called from the Prolog to save the index of where the group beginning is stored. A zero length group check occurs in the normal match but is skipped in the matchInit.
java.util.regex.Pattern.Neg: Zero width negative lookahead.
java.util.regex.Pattern.Node: Base class for all node classes. Subclasses should override the match() method as appropriate. This class is an accepting node, so its match() always returns true.
java.util.regex.Pattern.Node.match	(	Matcher	int	CharSequence	): This method implements the classic accept node.
java.util.regex.Pattern.Node.study	(	TreeInfo	): This method is good for all zero length assertions.
java.util.regex.Pattern.NotBehind: Zero width negative lookbehind.
java.util.regex.Pattern.NotBehindS: Zero width negative lookbehind, including supplementary characters or unpaired surrogates.
java.util.regex.Pattern.Pattern	(	String	int	): This private constructor is used to create all Patterns. The pattern string and match flags are all that is needed to completely describe a Pattern. An empty pattern string results in an object tree with only a Start node and a LastNode node.
java.util.regex.Pattern.Pos: Zero width positive lookahead.
java.util.regex.Pattern.Prolog: This sets up a loop to handle a recursive quantifier structure.
java.util.regex.Pattern.Ques: The 0 or 1 quantifier. This one class implements all three types.
java.util.regex.Pattern.RemoveQEQuoting	(	): Preprocess any \Q...\E sequences in `temp', meta-quoting them. See the description of `quotemeta' in perlfunc(1).
java.util.regex.Pattern.Script: Node class that matches a Unicode script
java.util.regex.Pattern.Single: Optimization -- matches a given BMP character
java.util.regex.Pattern.SingleI: Case insensitive matches a given BMP character
java.util.regex.Pattern.SingleS: Node class that matches a Supplementary Unicode character
java.util.regex.Pattern.SingleU: Unicode case insensitive matches a given Unicode character
java.util.regex.Pattern.Slice: Node class for a case sensitive/BMP-only sequence of literal characters.
java.util.regex.Pattern.SliceI: Node class for a case_insensitive/BMP-only sequence of literal characters.
java.util.regex.Pattern.SliceIS: Node class for a case insensitive sequence of literal characters including supplementary characters.
java.util.regex.Pattern.SliceNode: Base class for all Slice nodes
java.util.regex.Pattern.SliceS: Node class for a case sensitive sequence of literal characters including supplementary characters.
java.util.regex.Pattern.SliceU: Node class for a unicode_case_insensitive/BMP-only sequence of literal characters. Uses unicode case folding.
java.util.regex.Pattern.SliceUS: Node class for a case insensitive sequence of literal characters. Uses unicode case folding.
java.util.regex.Pattern.Start: Used for REs that can start anywhere within the input string. This basically tries to match repeatedly at each spot in the input string, moving forward after each try. An anchored search or a BnM will bypass this node completely.
java.util.regex.Pattern.TreeInfo: Used to accumulate information about a subtree of the object graph so that optimizations can be applied to the subtree.
java.util.regex.Pattern.UnixCaret: Node to anchor at the beginning of a line when in unixdot mode.
java.util.regex.Pattern.UnixDollar: Node to anchor at the end of a line or the end of input based on the multiline mode when in unix lines mode.
java.util.regex.Pattern.UnixDot: Node class for the dot metacharacter when dotall is not enabled but UNIX_LINES is enabled.
java.util.regex.Pattern.Utype: Node class that matches a Unicode "type"
java.util.regex.Pattern.VertWS: Node class that matches a Perl vertical whitespace
java.util.regex.Pattern.accept	(	int	String	): Match next character, signal error if failed.
java.util.regex.Pattern.asPredicate	(	): Creates a predicate which can be used to match a string.
java.util.regex.Pattern.c	(	): Utility method for parsing control escape sequences.
java.util.regex.Pattern.caseInsensitiveRangeFor	(	int	int	): Returns node for matching characters within an explicit value range in a case insensitive manner.
java.util.regex.Pattern.charPropertyNodeFor	(	String	): Returns a CharProperty matching all characters in a named property.
java.util.regex.Pattern.clazz	(	boolean	): Parse a character class, and return the node that matches it. Consumes a ] on the way out if consume is true. Usually consume is true except for the case of [abc&&def] where def is a separate right hand node with "understood" brackets.
java.util.regex.Pattern.closure	(	Node	): Processes repetition. If the next character peeked is a quantifier then new nodes must be appended to handle the repetition. Prev could be a single or a group, so it could be a chain of nodes.
java.util.regex.Pattern.compile	(	): Copies regular expression to an int array and invokes the parsing of the expression which will create the object tree.
java.util.regex.Pattern.compile	(	String	): Compiles the given regular expression into a pattern.
java.util.regex.Pattern.compile	(	String	int	): Compiles the given regular expression into a pattern with the given flags.
java.util.regex.Pattern.composeOneStep	(	String	): Attempts to compose input by combining the first character with the first combining mark following it. Returns a String that is the composition of the leading character with its first combining mark followed by the remaining combining marks. Returns null if the first two characters cannot be further composed.
java.util.regex.Pattern.createGroup	(	boolean	): Create group head and tail nodes using double return. If the group is created with anonymous true then it is a pure group and should not affect group counting.
java.util.regex.Pattern.cursor	(	): Utility method for parsing unicode escape sequences.
java.util.regex.Pattern.error	(	String	): Internal method used for handling all syntax errors. The pattern is displayed with a pointer to aid in locating the syntax error.
java.util.regex.Pattern.escape	(	boolean	boolean	boolean	): Parses an escape sequence to determine the actual value that needs to be matched. If -1 is returned and create was true a new object was added to the tree to handle the escape sequence. If the returned value is greater than zero, it is the value that matches the escape sequence.
java.util.regex.Pattern.expr	(	Node	): The expression is parsed with branch nodes added for alternations. This may be called recursively to parse sub expressions that may contain alternations.
java.util.regex.Pattern.family	(	boolean	boolean	): Parses a Unicode character family and returns its representative node.
java.util.regex.Pattern.findSupplementary	(	int	int	): Determines if there is any supplementary character or unpaired surrogate in the specified range.
java.util.regex.Pattern.flags	(	): Returns this pattern's match flags.
java.util.regex.Pattern.group0	(	): Parses a group and returns the head node of a set of nodes that process the group. Sometimes a double return system is used where the tail is returned in root.
java.util.regex.Pattern.groupname	(	int	): Parses and returns the name of a "named capturing group", the trailing ">" is consumed after parsing.
java.util.regex.Pattern.has	(	int	): Indicates whether a particular flag is set or not.
java.util.regex.Pattern.hasBaseCharacter	(	Matcher	int	CharSequence	): Non spacing marks only count as word characters in bounds calculations if they have a base character.
java.util.regex.Pattern.intersection	(	CharProperty	CharProperty	): Returns the set intersection of two CharProperty nodes.
java.util.regex.Pattern.isLineSeparator	(	int	): Determines if character is a line separator in the current mode
java.util.regex.Pattern.isSupplementary	(	int	): Determines if the specified code point is a supplementary character or unpaired surrogate.
java.util.regex.Pattern.mark	(	int	): Mark the end of pattern with a specific character.
java.util.regex.Pattern.matcher	(	CharSequence	): Creates a matcher that will match the given input against this pattern.
java.util.regex.Pattern.matches	(	String	CharSequence	): Compiles the given regular expression and attempts to match the given input against it.  An invocation of this convenience method of the form  Pattern.matches(regex, input); behaves in exactly the same way as the expression  Pattern.compile(regex).matcher(input).matches()  If a pattern is to be used multiple times, compiling it once and reusing it will be more efficient than invoking this method each time. 
java.util.regex.Pattern.newSingle	(	int	): Returns a suitably optimized, single character matcher.
java.util.regex.Pattern.newSlice	(	int[]	int	boolean	): Utility method for creating a string slice matcher.
java.util.regex.Pattern.next	(	): Advance the cursor by one, and peek the next character.
java.util.regex.Pattern.nextEscaped	(	): Advance the cursor by one, and peek the next character, ignoring the COMMENTS setting
java.util.regex.Pattern.normalize	(	): The pattern is converted to normalizedD form and then a pure group is constructed to match canonical equivalences of the characters.
java.util.regex.Pattern.normalizeCharClass	(	StringBuilder	int	): Complete the character class being parsed and add a set of alternations to it that will match the canonical equivalences of the characters within the class.
java.util.regex.Pattern.o	(	): Utility method for parsing octal escape sequences.
java.util.regex.Pattern.parsePastLine	(	): xmode parse past comment to end of line.
java.util.regex.Pattern.parsePastWhitespace	(	int	): If in xmode parse past whitespace and comments.
java.util.regex.Pattern.pattern	(	): Returns the regular expression from which this pattern was compiled.
java.util.regex.Pattern.peek	(	): Peek the next character, and do not advance the cursor.
java.util.regex.Pattern.peekPastLine	(	): xmode peek past comment to end of line.
java.util.regex.Pattern.peekPastWhitespace	(	int	): If in xmode peek past whitespace and comments.
java.util.regex.Pattern.printObjectTree	(	Node	): Used to print out a subtree of the Pattern to help with debugging.
java.util.regex.Pattern.produceEquivalentAlternation	(	String	): Given a specific sequence composed of a regular character and combining marks that follow it, produce the alternation that will match all canonical equivalences of that sequence.
java.util.regex.Pattern.producePermutations	(	String	): Returns an array of strings that have all the possible permutations of the characters in the input string. This is used to get a list of all possible orderings of a set of combining marks. Note that some of the permutations are invalid because of combining class collisions, and these possibilities must be removed because they are not canonically equivalent.
java.util.regex.Pattern.quote	(	String	): Returns a literal pattern String for the specified String. This method produces a String that can be used to create a Pattern that would match the string s as if it were a literal pattern. Metacharacters or escape sequences in the input sequence will be given no special meaning.
java.util.regex.Pattern.range	(	BitClass	): Parse a single character or a character range in a character class and return its representative node.
java.util.regex.Pattern.rangeFor	(	int	int	): Returns node for matching characters within an explicit value range.
java.util.regex.Pattern.read	(	): Read the next character, and advance the cursor by one.
java.util.regex.Pattern.readEscaped	(	): Read the next character, and advance the cursor by one, ignoring the COMMENTS setting
java.util.regex.Pattern.readObject	(	java.io.ObjectInputStream	): Recompile the Pattern instance from a stream. The original pattern string is read in and the object tree is recompiled from it.
java.util.regex.Pattern.ref	(	int	): Parses a backref greedily, taking as many numbers as it can. The first digit is always treated as a backref, but multi digit numbers are only treated as a backref if at least that many backrefs exist at this point in the regex.
java.util.regex.Pattern.setDifference	(	CharProperty	CharProperty	): Returns the set difference of two CharProperty nodes.
java.util.regex.Pattern.skip	(	): Read the character after the next one, and advance the cursor by two.
java.util.regex.Pattern.split	(	CharSequence	): Splits the given input sequence around matches of this pattern.  This method works as if by invoking the two-argument split() method with the given input sequence and a limit argument of zero. Trailing empty strings are therefore not included in the resulting array.   The input "boo:and:foo", for example, yields the following results with these expressions:  Regex     Result : { "boo", "and", "foo" } o { "b", "", ":and:f" } 
java.util.regex.Pattern.split	(	CharSequence	int	): Splits the given input sequence around matches of this pattern.  The array returned by this method contains each substring of the input sequence that is terminated by another subsequence that matches this pattern or is terminated by the end of the input sequence. The substrings in the array are in the order in which they occur in the input. If this pattern does not match any subsequence of the input then the resulting array has just one element, namely the input sequence in string form.  When there is a positive-width match at the beginning of the input sequence then an empty leading substring is included at the beginning of the resulting array. A zero-width match at the beginning however never produces such empty leading substring.  The limit parameter controls the number of times the pattern is applied and therefore affects the length of the resulting array. If the limit n is greater than zero then the pattern will be applied at most n - 1 times, the array's length will be no greater than n, and the array's last entry will contain all input beyond the last matched delimiter. If n is non-positive then the pattern will be applied as many times as possible and the array can have any length. If n is zero then the pattern will be applied as many times as possible, the array can have any length, and trailing empty strings will be discarded.  The input "boo:and:foo", for example, yields the following results with these parameters:  Regex     Limit     Result     : 2 { "boo", "and:foo" } : 5 { "boo", "and", "foo" } : -2 { "boo", "and", "foo" } o 5 { "b", "", ":and:f", "", "" } o -2 { "b", "", ":and:f", "", "" } o 0 { "b", "", ":and:f" } 
java.util.regex.Pattern.splitAsStream	(	CharSequence	): Creates a stream from the given input sequence around matches of this pattern.  The stream returned by this method contains each substring of the input sequence that is terminated by another subsequence that matches this pattern or is terminated by the end of the input sequence. The substrings in the stream are in the order in which they occur in the input. Trailing empty strings will be discarded and not encountered in the stream.  If this pattern does not match any subsequence of the input then the resulting stream has just one element, namely the input sequence in string form.  When there is a positive-width match at the beginning of the input sequence then an empty leading substring is included at the beginning of the stream. A zero-width match at the beginning however never produces such empty leading substring.  If the input sequence is mutable, it must remain constant during the execution of the terminal stream operation. Otherwise, the result of the terminal stream operation is undefined.
java.util.regex.Pattern.toString	(	): Returns the string representation of this pattern. This is the regular expression from which this pattern was compiled.
java.util.regex.Pattern.unicodeBlockPropertyFor	(	String	): Returns a CharProperty matching all characters in a UnicodeBlock.
java.util.regex.Pattern.unicodeScriptPropertyFor	(	String	): Returns a CharProperty matching all characters belong to a UnicodeScript.
java.util.regex.Pattern.union	(	CharProperty	CharProperty	): Returns the set union of two CharProperty nodes.
java.util.regex.Pattern.unread	(	): Unread one next character, and retreat cursor by one.
java.util.regex.Pattern.x	(	): Utility method for parsing hexadecimal escape sequences.
java.util.regex.PatternSyntaxException: Unchecked exception thrown to indicate a syntax error in a regular-expression pattern.
java.util.regex.PatternSyntaxException.PatternSyntaxException	(	String	String	int	): Constructs a new instance of this class.
java.util.regex.PatternSyntaxException.getDescription	(	): Retrieves the description of the error.
java.util.regex.PatternSyntaxException.getIndex	(	): Retrieves the error index.
java.util.regex.PatternSyntaxException.getMessage	(	): Returns a multi-line string containing the description of the syntax error and its index, the erroneous regular-expression pattern, and a visual indication of the error index within the pattern.
java.util.regex.PatternSyntaxException.getPattern	(	): Retrieves the erroneous regular-expression pattern.
java.util.spi.CalendarDataProvider: An abstract class for service providers that provide locale-dependent Calendar parameters.
java.util.spi.CalendarDataProvider.CalendarDataProvider	(	): Sole constructor. (For invocation by subclass constructors, typically implicit.)
java.util.spi.CalendarDataProvider.getFirstDayOfWeek	(	Locale	): Returns the first day of a week in the given locale. This information is required by Calendar to support operations on the week-related calendar fields.
java.util.spi.CalendarDataProvider.getMinimalDaysInFirstWeek	(	Locale	): Returns the minimal number of days required in the first week of a year. This information is required by Calendar to determine the first week of a year. Refer to the description of  how Calendar determines the first week.
java.util.spi.CalendarNameProvider: An abstract class for service providers that provide localized string representations (display names) of Calendar field values. Calendar Types Calendar types are used to specify calendar systems for which the getDisplayName() and getDisplayNames() methods provide calendar field value names. See getCalendarType() for details. Calendar Fields Calendar fields are specified with the constants defined in Calendar. The following are calendar-common fields and their values to be supported for each calendar system.   Field Value Description   MONTH JANUARY to UNDECIMBER Month numbering is 0-based (e.g., 0 - January, ..., 11 - December). Some calendar systems have 13 months. Month names need to be supported in both the formatting and stand-alone forms if required by the supported locales. If there's no distinction in the two forms, the same names should be returned in both of the forms.   DAY_OF_WEEK SUNDAY to SATURDAY Day-of-week numbering is 1-based starting from Sunday (i.e., 1 - Sunday, ..., 7 - Saturday).   AM_PM AM to PM 0 - AM, 1 - PM   The following are calendar-specific fields and their values to be supported.   Calendar Type Field Value Description   "gregory" ERA 0 BC (BCE)   1 AD (CE)   "buddhist" ERA 0 BC (BCE)   1 B.E. (Buddhist Era)   "japanese" ERA 0 Seireki (Before Meiji)   1 Meiji   2 Taisho   3 Showa   4 Heisei   YEAR 1 the first year in each era. It should be returned when a long style (LONG_FORMAT or LONG_STANDALONE) is specified. See also the  Year representation in SimpleDateFormat.   "roc" ERA 0 Before R.O.C.   1 R.O.C.   "islamic" ERA 0 Before AH   1 Anno Hijrah (AH)   Calendar field value names for "gregory" must be consistent with the date-time symbols provided by java.text.spi.DateFormatSymbolsProvider. Time zone names are supported by TimeZoneNameProvider.
java.util.spi.CalendarNameProvider.CalendarNameProvider	(	): Sole constructor. (For invocation by subclass constructors, typically implicit.)
java.util.spi.CalendarNameProvider.getDisplayName	(	String	int	int	int	Locale	): Returns the string representation (display name) of the calendar field value in the given style and locale. If no string representation is applicable, null is returned. field is a Calendar field index, such as MONTH. The time zone fields, ZONE_OFFSET and DST_OFFSET, are not supported by this method. null must be returned if any time zone fields are specified. value is the numeric representation of the field value. For example, if field is DAY_OF_WEEK, the valid values are SUNDAY to SATURDAY (inclusive). style gives the style of the string representation. It is one of SHORT_FORMAT (SHORT), SHORT_STANDALONE, LONG_FORMAT (LONG), LONG_STANDALONE, NARROW_FORMAT, or NARROW_STANDALONE. For example, the following call will return "Sunday".  getDisplayName("gregory", Calendar.DAY_OF_WEEK, Calendar.SUNDAY, Calendar.LONG_STANDALONE, Locale.ENGLISH); 
java.util.spi.CalendarNameProvider.getDisplayNames	(	String	int	int	Locale	): Returns a Map containing all string representations (display names) of the Calendar field in the given style and locale and their corresponding field values. field is a Calendar field index, such as MONTH. The time zone fields, ZONE_OFFSET and DST_OFFSET, are not supported by this method. null must be returned if any time zone fields are specified. style gives the style of the string representation. It must be one of ALL_STYLES, SHORT_FORMAT (SHORT), SHORT_STANDALONE, LONG_FORMAT (LONG), LONG_STANDALONE, NARROW_FORMAT, or NARROW_STANDALONE. Note that narrow names may not be unique due to use of single characters, such as "S" for Sunday and Saturday, and that no narrow names are included in that case. For example, the following call will return a Map containing "January" to JANUARY, "Jan" to JANUARY, "February" to FEBRUARY, "Feb" to FEBRUARY, and so on.  getDisplayNames("gregory", Calendar.MONTH, Calendar.ALL_STYLES, Locale.ENGLISH); 
java.util.spi.CurrencyNameProvider: An abstract class for service providers that provide localized currency symbols and display names for the java.util.Currency Currency class. Note that currency symbols are considered names when determining behaviors described in the java.util.spi.LocaleServiceProvider LocaleServiceProvider specification.
java.util.spi.CurrencyNameProvider.CurrencyNameProvider	(	): Sole constructor. (For invocation by subclass constructors, typically implicit.)
java.util.spi.CurrencyNameProvider.getDisplayName	(	String	Locale	): Returns a name for the currency that is appropriate for display to the user. The default implementation returns null.
java.util.spi.CurrencyNameProvider.getSymbol	(	String	Locale	): Gets the symbol of the given currency code for the specified locale. For example, for "USD" (US Dollar), the symbol is "$" if the specified locale is the US, while for other locales it may be "US$". If no symbol can be determined, null should be returned.
java.util.spi.LocaleNameProvider: An abstract class for service providers that provide localized names for the java.util.Locale Locale class.
java.util.spi.LocaleNameProvider.LocaleNameProvider	(	): Sole constructor. (For invocation by subclass constructors, typically implicit.)
java.util.spi.LocaleNameProvider.getDisplayCountry	(	String	Locale	): Returns a localized name for the given  IETF BCP47 region code (either ISO 3166 country code or UN M.49 area codes) and the given locale that is appropriate for display to the user. For example, if countryCode is "FR" and locale is en_US, getDisplayCountry() will return "France"; if countryCode is "US" and locale is fr_FR, getDisplayCountry() will return "Etats-Unis". If the name returned cannot be localized according to locale, (say, the provider does not have a Japanese name for Croatia), this method returns null.
java.util.spi.LocaleNameProvider.getDisplayLanguage	(	String	Locale	): Returns a localized name for the given  IETF BCP47 language code and the given locale that is appropriate for display to the user. For example, if languageCode is "fr" and locale is en_US, getDisplayLanguage() will return "French"; if languageCode is "en" and locale is fr_FR, getDisplayLanguage() will return "anglais". If the name returned cannot be localized according to locale, (say, the provider does not have a Japanese name for Croatian), this method returns null.
java.util.spi.LocaleNameProvider.getDisplayScript	(	String	Locale	): Returns a localized name for the given  IETF BCP47 script code and the given locale that is appropriate for display to the user. For example, if scriptCode is "Latn" and locale is en_US, getDisplayScript() will return "Latin"; if scriptCode is "Cyrl" and locale is fr_FR, getDisplayScript() will return "cyrillique". If the name returned cannot be localized according to locale, (say, the provider does not have a Japanese name for Cyrillic), this method returns null. The default implementation returns null.
java.util.spi.LocaleNameProvider.getDisplayVariant	(	String	Locale	): Returns a localized name for the given variant code and the given locale that is appropriate for display to the user. If the name returned cannot be localized according to locale, this method returns null.
java.util.spi.LocaleServiceProvider:  This is the super class of all the locale sensitive service provider interfaces (SPIs).  Locale sensitive service provider interfaces are interfaces that correspond to locale sensitive classes in the java.text and java.util packages. The interfaces enable the construction of locale sensitive objects and the retrieval of localized names for these packages. Locale sensitive factory methods and methods for name retrieval in the java.text and java.util packages use implementations of the provider interfaces to offer support for locales beyond the set of locales supported by the Java runtime environment itself. Packaging of Locale Sensitive Service Provider Implementations Implementations of these locale sensitive services are packaged using the Java Extension Mechanism as installed extensions. A provider identifies itself with a provider-configuration file in the resource directory META-INF/services, using the fully qualified provider interface class name as the file name. The file should contain a list of fully-qualified concrete provider class names, one per line. A line is terminated by any one of a line feed ('\n'), a carriage return ('\r'), or a carriage return followed immediately by a line feed. Space and tab characters surrounding each name, as well as blank lines, are ignored. The comment character is '#' ('\u0023'); on each line all characters following the first comment character are ignored. The file must be encoded in UTF-8.  If a particular concrete provider class is named in more than one configuration file, or is named in the same configuration file more than once, then the duplicates will be ignored. The configuration file naming a particular provider need not be in the same jar file or other distribution unit as the provider itself. The provider must be accessible from the same class loader that was initially queried to locate the configuration file; this is not necessarily the class loader that loaded the file.  For example, an implementation of the java.text.spi.DateFormatProvider DateFormatProvider class should take the form of a jar file which contains the file:  META-INF/services/java.text.spi.DateFormatProvider  And the file java.text.spi.DateFormatProvider should have a line such as:  com.foo.DateFormatProviderImpl  which is the fully qualified class name of the class implementing DateFormatProvider. Invocation of Locale Sensitive Services  Locale sensitive factory methods and methods for name retrieval in the java.text and java.util packages invoke service provider methods when needed to support the requested locale. The methods first check whether the Java runtime environment itself supports the requested locale, and use its support if available. Otherwise, they call the isSupportedLocale() methods of installed providers for the appropriate interface to find one that supports the requested locale. If such a provider is found, its other methods are called to obtain the requested object or name. When checking whether a locale is supported, the  locale's extensions are ignored by default. (If locale's extensions should also be checked, the isSupportedLocale method must be overridden.) If neither the Java runtime environment itself nor an installed provider supports the requested locale, the methods go through a list of candidate locales and repeat the availability check for each until a match is found. The algorithm used for creating a list of candidate locales is same as the one used by ResourceBundle by default (see getCandidateLocales for the details). Even if a locale is resolved from the candidate list, methods that return requested objects or names are invoked with the original requested locale including Locale extensions. The Java runtime environment must support the root locale for all locale sensitive services in order to guarantee that this process terminates.  Providers of names (but not providers of other objects) are allowed to return null for some name requests even for locales that they claim to support by including them in their return value for getAvailableLocales. Similarly, the Java runtime environment itself may not have all names for all locales that it supports. This is because the sets of objects for which names are requested can be large and vary over time, so that it's not always feasible to cover them completely. If the Java runtime environment or a provider returns null instead of a name, the lookup will proceed as described above as if the locale was not supported.  Starting from JDK8, the search order of locale sensitive services can be configured by using the "java.locale.providers" system property. This system property declares the user's preferred order for looking up the locale sensitive services separated by a comma. It is only read at the Java runtime startup, so the later call to System.setProperty() won't affect the order.  For example, if the following is specified in the property:  java.locale.providers=SPI,JRE  where "SPI" represents the locale sensitive services implemented in the installed SPI providers, and "JRE" represents the locale sensitive services in the Java Runtime Environment, the locale sensitive services in the SPI providers are looked up first.  There are two other possible locale sensitive service providers, i.e., "CLDR" which is a provider based on Unicode Consortium's CLDR Project, and "HOST" which is a provider that reflects the user's custom settings in the underlying operating system. These two providers may not be available, depending on the Java Runtime Environment implementation. Specifying "JRE,SPI" is identical to the default behavior, which is compatibile with the prior releases.
java.util.spi.LocaleServiceProvider.LocaleServiceProvider	(	): Sole constructor. (For invocation by subclass constructors, typically implicit.)
java.util.spi.LocaleServiceProvider.getAvailableLocales	(	): Returns an array of all locales for which this locale service provider can provide localized objects or names. This information is used to compose getAvailableLocales() values of the locale-dependent services, such as DateFormat.getAvailableLocales(). The array returned by this method should not include two or more Locale objects only differing in their extensions.
java.util.spi.LocaleServiceProvider.isSupportedLocale	(	Locale	): Returns true if the given locale is supported by this locale service provider. The given locale may contain extensions that should be taken into account for the support determination. The default implementation returns true if the given locale is equal to any of the available Locales returned by getAvailableLocales() with ignoring any extensions in both the given locale and the available locales. Concrete locale service provider implementations should override this method if those implementations are Locale extensions-aware. For example, DecimalFormatSymbolsProvider implementations will need to check extensions in the given locale to see if any numbering system is specified and can be supported. However, CollatorProvider implementations may not be affected by any particular numbering systems, and in that case, extensions for numbering systems should be ignored.
java.util.spi.ResourceBundleControlProvider: An interface for service providers that provide implementations of java.util.ResourceBundle.Control. The default resource bundle loading behavior of the ResourceBundle.getBundle factory methods that take no java.util.ResourceBundle.Control instance can be modified with ResourceBundleControlProvider implementations. Provider implementations must be packaged using the Java Extension Mechanism as installed extensions. Refer to java.util.ServiceLoader for the extension packaging. Any installed ResourceBundleControlProvider implementations are loaded using java.util.ServiceLoader at the ResourceBundle class loading time.
java.util.spi.ResourceBundleControlProvider.getControl	(	String	): Returns a ResourceBundle.Control instance that is used to handle resource bundle loading for the given baseName. This method must return null if the given baseName isn't handled by this provider.
java.util.spi.TimeZoneNameProvider: An abstract class for service providers that provide localized time zone names for the java.util.TimeZone TimeZone class. The localized time zone names available from the implementations of this class are also the source for the getZoneStrings() DateFormatSymbols.getZoneStrings() method.
java.util.spi.TimeZoneNameProvider.TimeZoneNameProvider	(	): Sole constructor. (For invocation by subclass constructors, typically implicit.)
java.util.spi.TimeZoneNameProvider.getDisplayName	(	String	boolean	int	Locale	): Returns a name for the given time zone ID that's suitable for presentation to the user in the specified locale. The given time zone ID is "GMT" or one of the names defined using "Zone" entries in the "tz database", a public domain time zone database at ftp://elsie.nci.nih.gov/pub/. The data of this database is contained in a file whose name starts with "tzdata", and the specification of the data format is part of the zic.8 man page, which is contained in a file whose name starts with "tzcode".  If daylight is true, the method should return a name appropriate for daylight saving time even if the specified time zone has not observed daylight saving time in the past.
java.util.spi.TimeZoneNameProvider.getGenericDisplayName	(	String	int	Locale	): Returns a generic name for the given time zone ID that's suitable for presentation to the user in the specified locale. Generic time zone names are neutral from standard time and daylight saving time. For example, "PT" is the short generic name of time zone ID America/Los_Angeles, while its short standard time and daylight saving time names are "PST" and "PDT", respectively. Refer to getDisplayName() for valid time zone IDs. The default implementation of this method returns null.
java.util.stream.AbstractPipeline: Abstract base class for "pipeline" classes, which are the core implementations of the Stream interface and its primitive specializations. Manages construction and evaluation of stream pipelines. An AbstractPipeline represents an initial portion of a stream pipeline, encapsulating a stream source and zero or more intermediate operations. The individual AbstractPipeline objects are often referred to as stages, where each stage describes either the stream source or an intermediate operation. A concrete intermediate stage is generally built from an AbstractPipeline, a shape-specific pipeline class which extends it (e.g., IntPipeline) which is also abstract, and an operation-specific concrete class which extends that. AbstractPipeline contains most of the mechanics of evaluating the pipeline, and implements methods that will be used by the operation; the shape-specific classes add helper methods for dealing with collection of results into the appropriate shape-specific containers. After chaining a new intermediate operation, or executing a terminal operation, the stream is considered to be consumed, and no more intermediate or terminal operations are permitted on this stream instance.
java.util.stream.AbstractPipeline.AbstractPipeline	(	AbstractPipeline	int	): Constructor for appending an intermediate operation stage onto an existing pipeline.
java.util.stream.AbstractPipeline.AbstractPipeline	(	Spliterator	int	boolean	): Constructor for the head of a stream pipeline.
java.util.stream.AbstractPipeline.AbstractPipeline	(	Supplier	int	boolean	): Constructor for the head of a stream pipeline.
java.util.stream.AbstractPipeline.evaluate	(	TerminalOp	): Evaluate the pipeline with a terminal operation to produce a result.
java.util.stream.AbstractPipeline.evaluateToArrayNode	(	IntFunction	): Collect the elements output from the pipeline stage.
java.util.stream.AbstractPipeline.evaluateToNode	(	PipelineHelper	Spliterator	boolean	IntFunction	): Collect elements output from a pipeline into a Node that holds elements of this shape.
java.util.stream.AbstractPipeline.forEachWithCancel	(	Spliterator	Sink	): Traverse the elements of a spliterator compatible with this stream shape, pushing those elements into a sink. If the sink requests cancellation, no further elements will be pulled or pushed.
java.util.stream.AbstractPipeline.getOutputShape	(	): Get the output shape of the pipeline. If the pipeline is the head, then it's output shape corresponds to the shape of the source. Otherwise, it's output shape corresponds to the output shape of the associated operation.
java.util.stream.AbstractPipeline.getStreamFlags	(	): Returns the composition of stream flags of the stream source and all intermediate operations.
java.util.stream.AbstractPipeline.lazySpliterator	(	Supplier	): Create a lazy spliterator that wraps and obtains the supplied the spliterator when a method is invoked on the lazy spliterator.
java.util.stream.AbstractPipeline.makeNodeBuilder	(	long	IntFunction	): Make a node builder compatible with this stream shape.
java.util.stream.AbstractPipeline.opEvaluateParallel	(	PipelineHelper	Spliterator	IntFunction	): Performs a parallel evaluation of the operation using the specified PipelineHelper which describes the upstream intermediate operations. Only called on stateful operations. If opIsStateful() returns true then implementations must override the default implementation.
java.util.stream.AbstractPipeline.opEvaluateParallelLazy	(	PipelineHelper	Spliterator	): Returns a Spliterator describing a parallel evaluation of the operation, using the specified PipelineHelper which describes the upstream intermediate operations. Only called on stateful operations. It is not necessary (though acceptable) to do a full computation of the result here; it is preferable, if possible, to describe the result via a lazily evaluated spliterator.
java.util.stream.AbstractPipeline.opIsStateful	(	): Returns whether this operation is stateful or not. If it is stateful, then the method opEvaluateParallel() must be overridden.
java.util.stream.AbstractPipeline.opWrapSink	(	int	Sink	): Accepts a Sink which will receive the results of this operation, and return a Sink which accepts elements of the input type of this operation and which performs the operation, passing the results to the provided Sink.
java.util.stream.AbstractPipeline.sourceSpliterator	(	int	): Get the source spliterator for this pipeline stage. For a sequential or stateless parallel pipeline, this is the source spliterator. For a stateful parallel pipeline, this is a spliterator describing the results of all computations up to and including the most recent stateful operation.
java.util.stream.AbstractPipeline.sourceStageSpliterator	(	): Gets the source stage spliterator if this pipeline stage is the source stage. The pipeline is consumed after this method is called and returns successfully.
java.util.stream.AbstractPipeline.wrap	(	PipelineHelper	Supplier	boolean	): Create a spliterator that wraps a source spliterator, compatible with this stream shape, and operations associated with a PipelineHelper.
java.util.stream.AbstractShortCircuitTask: Abstract class for fork-join tasks used to implement short-circuiting stream ops, which can produce a result without processing all elements of the stream.
java.util.stream.AbstractShortCircuitTask.AbstractShortCircuitTask	(	K	Spliterator	): Constructor for non-root nodes.
java.util.stream.AbstractShortCircuitTask.AbstractShortCircuitTask	(	PipelineHelper	Spliterator	): Constructor for root tasks.
java.util.stream.AbstractShortCircuitTask.cancel	(	): Mark this task as canceled
java.util.stream.AbstractShortCircuitTask.cancelLaterNodes	(	): Cancels all tasks which succeed this one in the encounter order. This includes canceling all the current task's right sibling, as well as the later right siblings of all its parents.
java.util.stream.AbstractShortCircuitTask.compute	(	): Overrides AbstractTask version to include checks for early exits while splitting or computing.
java.util.stream.AbstractShortCircuitTask.getEmptyResult	(	): Returns the value indicating the computation completed with no task finding a short-circuitable result. For example, for a "find" operation, this might be null or an empty Optional.
java.util.stream.AbstractShortCircuitTask.getLocalResult	(	): Retrieves the local result for this task. If this task is the root, retrieves the shared result instead.
java.util.stream.AbstractShortCircuitTask.getRawResult	(	): Retrieves the local result for this task
java.util.stream.AbstractShortCircuitTask.setLocalResult	(	R	): Sets a local result for this task. If this task is the root, set the shared result instead (if not already set).
java.util.stream.AbstractShortCircuitTask.shortCircuit	(	R	): Declares that a globally valid result has been found. If another task has not already found the answer, the result is installed in sharedResult. The compute() method will check sharedResult before proceeding with computation, so this causes the computation to terminate early.
java.util.stream.AbstractShortCircuitTask.taskCanceled	(	): Queries whether this task is canceled. A task is considered canceled if it or any of its parents have been canceled.
java.util.stream.AbstractSpinedBuffer: Base class for a data structure for gathering elements into a buffer and then iterating them. Maintains an array of increasingly sized arrays, so there is no copying cost associated with growing the data structure.
java.util.stream.AbstractSpinedBuffer.AbstractSpinedBuffer	(	): Construct with an initial capacity of 16.
java.util.stream.AbstractSpinedBuffer.AbstractSpinedBuffer	(	int	): Construct with a specified initial capacity.
java.util.stream.AbstractSpinedBuffer.chunkSize	(	int	): How big should the nth chunk be?
java.util.stream.AbstractSpinedBuffer.clear	(	): Remove all data from the buffer
java.util.stream.AbstractSpinedBuffer.count	(	): How many elements are currently in the buffer?
java.util.stream.AbstractSpinedBuffer.isEmpty	(	): Is the buffer currently empty?
java.util.stream.AbstractTask: Abstract base class for most fork-join tasks used to implement stream ops. Manages splitting logic, tracking of child tasks, and intermediate results. Each task is associated with a Spliterator that describes the portion of the input associated with the subtree rooted at this task. Tasks may be leaf nodes (which will traverse the elements of the Spliterator) or internal nodes (which split the Spliterator into multiple child tasks).
java.util.stream.AbstractTask.AbstractTask	(	K	Spliterator	): Constructor for non-root nodes.
java.util.stream.AbstractTask.AbstractTask	(	PipelineHelper	Spliterator	): Constructor for root nodes.
java.util.stream.AbstractTask.compute	(	): Decides whether or not to split a task further or compute it directly. If computing directly, calls doLeaf and pass the result to setRawResult. Otherwise splits off subtasks, forking one and continuing as the other.  The method is structured to conserve resources across a range of uses. The loop continues with one of the child tasks when split, to avoid deep recursion. To cope with spliterators that may be systematically biased toward left-heavy or right-heavy splits, we alternate which child is forked versus continued in the loop.
java.util.stream.AbstractTask.doLeaf	(	): Computes the result associated with a leaf node. Will be called by compute() and the result passed to @{code setLocalResult()}
java.util.stream.AbstractTask.getLocalResult	(	): Retrieves a result previously stored with setLocalResult
java.util.stream.AbstractTask.getParent	(	): Returns the parent of this task, or null if this task is the root
java.util.stream.AbstractTask.getRawResult	(	): Returns the local result, if any. Subclasses should use setLocalResult() and getLocalResult() to manage results. This returns the local result so that calls from within the fork-join framework will return the correct result.
java.util.stream.AbstractTask.getTargetSize	(	long	): Returns the targetSize, initializing it via the supplied size estimate if not already initialized.
java.util.stream.AbstractTask.isLeaf	(	): Indicates whether this task is a leaf node. (Only valid after compute has been called on this node). If the node is not a leaf node, then children will be non-null and numChildren will be positive.
java.util.stream.AbstractTask.isLeftmostNode	(	): Returns whether this node is a "leftmost" node -- whether the path from the root to this node involves only traversing leftmost child links. For a leaf node, this means it is the first leaf node in the encounter order.
java.util.stream.AbstractTask.isRoot	(	): Indicates whether this task is the root node
java.util.stream.AbstractTask.makeChild	(	Spliterator	): Constructs a new node of type T whose parent is the receiver; must call the AbstractTask(T, Spliterator) constructor with the receiver and the provided Spliterator.
java.util.stream.AbstractTask.onCompletion	(	CountedCompleter	): Performs an action when method tryComplete is invoked and the pending count is zero, or when the unconditional method complete is invoked. By default, this method does nothing. You can distinguish cases by checking the identity of the given caller argument. If not equal to this, then it is typically a subtask that may contain results (and/or links to other results) to combine.
java.util.stream.AbstractTask.setLocalResult	(	R	): Associates the result with the task, can be retrieved with getLocalResult
java.util.stream.AbstractTask.setRawResult	(	R	): Does nothing; instead, subclasses should use setLocalResult()} to manage results.
java.util.stream.AbstractTask.suggestTargetSize	(	long	): Returns a suggested target leaf size based on the initial size estimate.
java.util.stream.BaseStream: Base interface for streams, which are sequences of elements supporting sequential and parallel aggregate operations. The following example illustrates an aggregate operation using the stream types Stream and IntStream, computing the sum of the weights of the red widgets: int sum = widgets.stream() .filter(w -> w.getColor() == RED) .mapToInt(w -> w.getWeight()) .sum(); See the class documentation for Stream and the package documentation for java.util.stream for additional specification of streams, stream operations, stream pipelines, and parallelism, which governs the behavior of all stream types.
java.util.stream.BaseStream.close	(	): Closes this stream, causing all close handlers for this stream pipeline to be called.
java.util.stream.BaseStream.isParallel	(	): Returns whether this stream, if a terminal operation were to be executed, would execute in parallel. Calling this method after invoking an terminal stream operation method may yield unpredictable results.
java.util.stream.BaseStream.iterator	(	): Returns an iterator for the elements of this stream. This is a terminal operation.
java.util.stream.BaseStream.onClose	(	Runnable	): Returns an equivalent stream with an additional close handler. Close handlers are run when the close() method is called on the stream, and are executed in the order they were added. All close handlers are run, even if earlier close handlers throw exceptions. If any close handler throws an exception, the first exception thrown will be relayed to the caller of close(), with any remaining exceptions added to that exception as suppressed exceptions (unless one of the remaining exceptions is the same exception as the first exception, since an exception cannot suppress itself.) May return itself. This is an intermediate operation.
java.util.stream.BaseStream.parallel	(	): Returns an equivalent stream that is parallel. May return itself, either because the stream was already parallel, or because the underlying stream state was modified to be parallel. This is an intermediate operation.
java.util.stream.BaseStream.sequential	(	): Returns an equivalent stream that is sequential. May return itself, either because the stream was already sequential, or because the underlying stream state was modified to be sequential. This is an intermediate operation.
java.util.stream.BaseStream.spliterator	(	): Returns a spliterator for the elements of this stream. This is a terminal operation.
java.util.stream.BaseStream.unordered	(	): Returns an equivalent stream that is unordered. May return itself, either because the stream was already unordered, or because the underlying stream state was modified to be unordered. This is an intermediate operation.
java.util.stream.Collector: A mutable reduction operation that accumulates input elements into a mutable result container, optionally transforming the accumulated result into a final representation after all input elements have been processed. Reduction operations can be performed either sequentially or in parallel. Examples of mutable reduction operations include: accumulating elements into a Collection; concatenating strings using a StringBuilder; computing summary information about elements such as sum, min, max, or average; computing "pivot table" summaries such as "maximum valued transaction by seller", etc. The class Collectors provides implementations of many common mutable reductions. A Collector is specified by four functions that work together to accumulate entries into a mutable result container, and optionally perform a final transform on the result. They are:  creation of a new result container (supplier()) incorporating a new data element into a result container (accumulator()) combining two result containers into one (combiner()) performing an optional final transform on the container (finisher())  Collectors also have a set of characteristics, such as CONCURRENT, that provide hints that can be used by a reduction implementation to provide better performance. A sequential implementation of a reduction using a collector would create a single result container using the supplier function, and invoke the accumulator function once for each input element. A parallel implementation would partition the input, create a result container for each partition, accumulate the contents of each partition into a subresult for that partition, and then use the combiner function to merge the subresults into a combined result. To ensure that sequential and parallel executions produce equivalent results, the collector functions must satisfy an identity and an associativity constraints. The identity constraint says that for any partially accumulated result, combining it with an empty result container must produce an equivalent result. That is, for a partially accumulated result a that is the result of any series of accumulator and combiner invocations, a must be equivalent to combiner.apply(a, supplier.get()). The associativity constraint says that splitting the computation must produce an equivalent result. That is, for any input elements t1 and t2, the results r1 and r2 in the computation below must be equivalent: A a1 = supplier.get(); accumulator.accept(a1, t1); accumulator.accept(a1, t2); R r1 = finisher.apply(a1); // result without splitting A a2 = supplier.get(); accumulator.accept(a2, t1); A a3 = supplier.get(); accumulator.accept(a3, t2); R r2 = finisher.apply(combiner.apply(a2, a3)); // result with splitting  For collectors that do not have the UNORDERED characteristic, two accumulated results a1 and a2 are equivalent if finisher.apply(a1).equals(finisher.apply(a2)). For unordered collectors, equivalence is relaxed to allow for non-equality related to differences in order. (For example, an unordered collector that accumulated elements to a List would consider two lists equivalent if they contained the same elements, ignoring order.) Libraries that implement reduction based on Collector, such as collect(), must adhere to the following constraints:  The first argument passed to the accumulator function, both arguments passed to the combiner function, and the argument passed to the finisher function must be the result of a previous invocation of the result supplier, accumulator, or combiner functions. The implementation should not do anything with the result of any of the result supplier, accumulator, or combiner functions other than to pass them again to the accumulator, combiner, or finisher functions, or return them to the caller of the reduction operation. If a result is passed to the combiner or finisher function, and the same object is not returned from that function, it is never used again. Once a result is passed to the combiner or finisher function, it is never passed to the accumulator function again. For non-concurrent collectors, any result returned from the result supplier, accumulator, or combiner functions must be serially thread-confined. This enables collection to occur in parallel without the Collector needing to implement any additional synchronization. The reduction implementation must manage that the input is properly partitioned, that partitions are processed in isolation, and combining happens only after accumulation is complete. For concurrent collectors, an implementation is free to (but not required to) implement reduction concurrently. A concurrent reduction is one where the accumulator function is called concurrently from multiple threads, using the same concurrently-modifiable result container, rather than keeping the result isolated during accumulation. A concurrent reduction should only be applied if the collector has the UNORDERED characteristics or if the originating data is unordered.  In addition to the predefined implementations in Collectors, the static factory methods of() can be used to construct collectors. For example, you could create a collector that accumulates widgets into a TreeSet with: Collector> intoSet = Collector.of(TreeSet::new, TreeSet::add, (left, right) -> left.addAll(right); return left; }); } (This behavior is also implemented by the predefined collector toCollection()).
java.util.stream.Collector.accumulator	(	): A function that folds a value into a mutable result container.
java.util.stream.Collector.characteristics	(	): Returns a Set of Collector.Characteristics indicating the characteristics of this Collector. This set should be immutable.
java.util.stream.Collector.combiner	(	): A function that accepts two partial results and merges them. The combiner function may fold state from one argument into the other and return that, or may return a new result container.
java.util.stream.Collector.finisher	(	): Perform the final transformation from the intermediate accumulation type A to the final result type R. If the characteristic IDENTITY_TRANSFORM is set, this function may be presumed to be an identity transform with an unchecked cast from A to R.
java.util.stream.Collector.of	(	Supplier	BiConsumer	BinaryOperator	Characteristics	): Returns a new Collector described by the given supplier, accumulator, and combiner functions. The resulting Collector has the Collector.Characteristics.IDENTITY_FINISH characteristic.
java.util.stream.Collector.of	(	Supplier	BiConsumer	BinaryOperator	Function	Characteristics	): Returns a new Collector described by the given supplier, accumulator, combiner, and finisher functions.
java.util.stream.Collector.supplier	(	): A function that creates and returns a new mutable result container.
java.util.stream.Collectors: Implementations of Collector that implement various useful reduction operations, such as accumulating elements into collections, summarizing elements according to various criteria, etc. The following are examples of using the predefined collectors to perform common mutable reduction tasks: // Accumulate names into a List List list = people.stream().map(Person::getName).collect(Collectors.toList()); // Accumulate names into a TreeSet Set set = people.stream().map(Person::getName).collect(Collectors.toCollection(TreeSet::new)); // Convert elements to strings and concatenate them, separated by commas String joined = things.stream() .map(Object::toString) .collect(Collectors.joining(", ")); // Compute sum of salaries of employee int total = employees.stream() .collect(Collectors.summingInt(Employee::getSalary))); // Group employees by department Map> byDept = employees.stream() .collect(Collectors.groupingBy(Employee::getDepartment)); // Compute sum of salaries by department Map totalByDept = employees.stream() .collect(Collectors.groupingBy(Employee::getDepartment, Collectors.summingInt(Employee::getSalary))); // Partition students into passing and failing Map> passingFailing = students.stream() .collect(Collectors.partitioningBy(s -> s.getGrade() >= PASS_THRESHOLD));
java.util.stream.Collectors.CollectorImpl: Simple implementation class for Collector.
java.util.stream.Collectors.Partition: Implementation class used by partitioningBy.
java.util.stream.Collectors.averagingDouble	(	ToDoubleFunction	): Returns a Collector that produces the arithmetic mean of a double-valued function applied to the input elements. If no elements are present, the result is 0. The average returned can vary depending upon the order in which values are recorded, due to accumulated rounding error in addition of values of differing magnitudes. Values sorted by increasing absolute magnitude tend to yield more accurate results. If any recorded value is a NaN or the sum is at any point a NaN then the average will be NaN.
java.util.stream.Collectors.averagingInt	(	ToIntFunction	): Returns a Collector that produces the arithmetic mean of an integer-valued function applied to the input elements. If no elements are present, the result is 0.
java.util.stream.Collectors.averagingLong	(	ToLongFunction	): Returns a Collector that produces the arithmetic mean of a long-valued function applied to the input elements. If no elements are present, the result is 0.
java.util.stream.Collectors.collectingAndThen	(	Collector	Function	): Adapts a Collector to perform an additional finishing transformation. For example, one could adapt the toList() collector to always produce an immutable list with: List people = people.stream().collect(collectingAndThen(toList(), Collections::unmodifiableList));
java.util.stream.Collectors.computeFinalSum	(	double[]	): If the compensated sum is spuriously NaN from accumulating one or more same-signed infinite values, return the correctly-signed infinity stored in the simple sum.
java.util.stream.Collectors.counting	(	): Returns a Collector accepting elements of type T that counts the number of input elements. If no elements are present, the result is 0.
java.util.stream.Collectors.groupingBy	(	Function	): Returns a Collector implementing a "group by" operation on input elements of type T, grouping elements according to a classification function, and returning the results in a Map. The classification function maps elements to some key type K. The collector produces a Map> whose keys are the values resulting from applying the classification function to the input elements, and whose corresponding values are Lists containing the input elements which map to the associated key under the classification function. There are no guarantees on the type, mutability, serializability, or thread-safety of the Map or List objects returned.
java.util.stream.Collectors.groupingBy	(	Function	Collector	): Returns a Collector implementing a cascaded "group by" operation on input elements of type T, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream Collector. The classification function maps elements to some key type K. The downstream collector operates on elements of type T and produces a result of type D. The resulting collector produces a Map. There are no guarantees on the type, mutability, serializability, or thread-safety of the Map returned. For example, to compute the set of last names of people in each city: Map> namesByCity = people.stream().collect(groupingBy(Person::getCity, mapping(Person::getLastName, toSet())));
java.util.stream.Collectors.groupingBy	(	Function	Supplier	Collector	): Returns a Collector implementing a cascaded "group by" operation on input elements of type T, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream Collector. The Map produced by the Collector is created with the supplied factory function. The classification function maps elements to some key type K. The downstream collector operates on elements of type T and produces a result of type D. The resulting collector produces a Map. For example, to compute the set of last names of people in each city, where the city names are sorted: Map> namesByCity = people.stream().collect(groupingBy(Person::getCity, TreeMap::new, mapping(Person::getLastName, toSet())));
java.util.stream.Collectors.groupingByConcurrent	(	Function	): Returns a concurrent Collector implementing a "group by" operation on input elements of type T, grouping elements according to a classification function. This is a CONCURRENT concurrent and UNORDERED unordered Collector. The classification function maps elements to some key type K. The collector produces a ConcurrentMap> whose keys are the values resulting from applying the classification function to the input elements, and whose corresponding values are Lists containing the input elements which map to the associated key under the classification function. There are no guarantees on the type, mutability, or serializability of the Map or List objects returned, or of the thread-safety of the List objects returned.
java.util.stream.Collectors.groupingByConcurrent	(	Function	Collector	): Returns a concurrent Collector implementing a cascaded "group by" operation on input elements of type T, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream Collector. This is a CONCURRENT concurrent and UNORDERED unordered Collector. The classification function maps elements to some key type K. The downstream collector operates on elements of type T and produces a result of type D. The resulting collector produces a Map. For example, to compute the set of last names of people in each city, where the city names are sorted: ConcurrentMap> namesByCity = people.stream().collect(groupingByConcurrent(Person::getCity, mapping(Person::getLastName, toSet())));
java.util.stream.Collectors.groupingByConcurrent	(	Function	Supplier	Collector	): Returns a concurrent Collector implementing a cascaded "group by" operation on input elements of type T, grouping elements according to a classification function, and then performing a reduction operation on the values associated with a given key using the specified downstream Collector. The ConcurrentMap produced by the Collector is created with the supplied factory function. This is a CONCURRENT concurrent and UNORDERED unordered Collector. The classification function maps elements to some key type K. The downstream collector operates on elements of type T and produces a result of type D. The resulting collector produces a Map. For example, to compute the set of last names of people in each city, where the city names are sorted: ConcurrentMap> namesByCity = people.stream().collect(groupingBy(Person::getCity, ConcurrentSkipListMap::new, mapping(Person::getLastName, toSet())));
java.util.stream.Collectors.joining	(	): Returns a Collector that concatenates the input elements into a String, in encounter order.
java.util.stream.Collectors.joining	(	CharSequence	): Returns a Collector that concatenates the input elements, separated by the specified delimiter, in encounter order.
java.util.stream.Collectors.joining	(	CharSequence	CharSequence	CharSequence	): Returns a Collector that concatenates the input elements, separated by the specified delimiter, with the specified prefix and suffix, in encounter order.
java.util.stream.Collectors.mapMerger	(	BinaryOperator	): BinaryOperator that merges the contents of its right argument into its left argument, using the provided merge function to handle duplicate keys.
java.util.stream.Collectors.mapping	(	Function	Collector	): Adapts a Collector accepting elements of type U to one accepting elements of type T by applying a mapping function to each input element before accumulation.
java.util.stream.Collectors.maxBy	(	Comparator	): Returns a Collector that produces the maximal element according to a given Comparator, described as an Optional.
java.util.stream.Collectors.minBy	(	Comparator	): Returns a Collector that produces the minimal element according to a given Comparator, described as an Optional.
java.util.stream.Collectors.partitioningBy	(	Predicate	): Returns a Collector which partitions the input elements according to a Predicate, and organizes them into a Map>. There are no guarantees on the type, mutability, serializability, or thread-safety of the Map returned.
java.util.stream.Collectors.partitioningBy	(	Predicate	Collector	): Returns a Collector which partitions the input elements according to a Predicate, reduces the values in each partition according to another Collector, and organizes them into a Map whose values are the result of the downstream reduction. There are no guarantees on the type, mutability, serializability, or thread-safety of the Map returned.
java.util.stream.Collectors.reducing	(	BinaryOperator	): Returns a Collector which performs a reduction of its input elements under a specified BinaryOperator. The result is described as an Optional.
java.util.stream.Collectors.reducing	(	T	BinaryOperator	): Returns a Collector which performs a reduction of its input elements under a specified BinaryOperator using the provided identity.
java.util.stream.Collectors.reducing	(	U	Function	BinaryOperator	): Returns a Collector which performs a reduction of its input elements under a specified mapping function and BinaryOperator. This is a generalization of reducing() which allows a transformation of the elements before reduction.
java.util.stream.Collectors.sumWithCompensation	(	double[]	double	): Incorporate a new double value using Kahan summation / compensation summation. High-order bits of the sum are in intermediateSum[0], low-order bits of the sum are in intermediateSum[1], any additional elements are application-specific.
java.util.stream.Collectors.summarizingDouble	(	ToDoubleFunction	): Returns a Collector which applies an double-producing mapping function to each input element, and returns summary statistics for the resulting values.
java.util.stream.Collectors.summarizingInt	(	ToIntFunction	): Returns a Collector which applies an int-producing mapping function to each input element, and returns summary statistics for the resulting values.
java.util.stream.Collectors.summarizingLong	(	ToLongFunction	): Returns a Collector which applies an long-producing mapping function to each input element, and returns summary statistics for the resulting values.
java.util.stream.Collectors.summingDouble	(	ToDoubleFunction	): Returns a Collector that produces the sum of a double-valued function applied to the input elements. If no elements are present, the result is 0. The sum returned can vary depending upon the order in which values are recorded, due to accumulated rounding error in addition of values of differing magnitudes. Values sorted by increasing absolute magnitude tend to yield more accurate results. If any recorded value is a NaN or the sum is at any point a NaN then the sum will be NaN.
java.util.stream.Collectors.summingInt	(	ToIntFunction	): Returns a Collector that produces the sum of a integer-valued function applied to the input elements. If no elements are present, the result is 0.
java.util.stream.Collectors.summingLong	(	ToLongFunction	): Returns a Collector that produces the sum of a long-valued function applied to the input elements. If no elements are present, the result is 0.
java.util.stream.Collectors.throwingMerger	(	): Returns a merge function, suitable for use in merge() Map.merge() or toMap() toMap(), which always throws IllegalStateException. This can be used to enforce the assumption that the elements being collected are distinct.
java.util.stream.Collectors.toCollection	(	Supplier	): Returns a Collector that accumulates the input elements into a new Collection, in encounter order. The Collection is created by the provided factory.
java.util.stream.Collectors.toConcurrentMap	(	Function	Function	): Returns a concurrent Collector that accumulates elements into a ConcurrentMap whose keys and values are the result of applying the provided mapping functions to the input elements. If the mapped keys contains duplicates (according to equals()), an IllegalStateException is thrown when the collection operation is performed. If the mapped keys may have duplicates, use toConcurrentMap() instead.
java.util.stream.Collectors.toConcurrentMap	(	Function	Function	BinaryOperator	): Returns a concurrent Collector that accumulates elements into a ConcurrentMap whose keys and values are the result of applying the provided mapping functions to the input elements. If the mapped keys contains duplicates (according to equals()), the value mapping function is applied to each equal element, and the results are merged using the provided merging function.
java.util.stream.Collectors.toConcurrentMap	(	Function	Function	BinaryOperator	Supplier	): Returns a concurrent Collector that accumulates elements into a ConcurrentMap whose keys and values are the result of applying the provided mapping functions to the input elements. If the mapped keys contains duplicates (according to equals()), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. The ConcurrentMap is created by a provided supplier function. This is a CONCURRENT concurrent and UNORDERED unordered Collector.
java.util.stream.Collectors.toList	(	): Returns a Collector that accumulates the input elements into a new List. There are no guarantees on the type, mutability, serializability, or thread-safety of the List returned; if more control over the returned List is required, use toCollection().
java.util.stream.Collectors.toMap	(	Function	Function	): Returns a Collector that accumulates elements into a Map whose keys and values are the result of applying the provided mapping functions to the input elements. If the mapped keys contains duplicates (according to equals()), an IllegalStateException is thrown when the collection operation is performed. If the mapped keys may have duplicates, use toMap() instead.
java.util.stream.Collectors.toMap	(	Function	Function	BinaryOperator	): Returns a Collector that accumulates elements into a Map whose keys and values are the result of applying the provided mapping functions to the input elements. If the mapped keys contains duplicates (according to equals()), the value mapping function is applied to each equal element, and the results are merged using the provided merging function.
java.util.stream.Collectors.toMap	(	Function	Function	BinaryOperator	Supplier	): Returns a Collector that accumulates elements into a Map whose keys and values are the result of applying the provided mapping functions to the input elements. If the mapped keys contains duplicates (according to equals()), the value mapping function is applied to each equal element, and the results are merged using the provided merging function. The Map is created by a provided supplier function.
java.util.stream.Collectors.toSet	(	): Returns a Collector that accumulates the input elements into a new Set. There are no guarantees on the type, mutability, serializability, or thread-safety of the Set returned; if more control over the returned Set is required, use toCollection(). This is an UNORDERED unordered Collector.
java.util.stream.DistinctOps: Factory methods for transforming streams into duplicate-free streams, using equals() to determine equality.
java.util.stream.DistinctOps.makeRef	(	AbstractPipeline	): Appends a "distinct" operation to the provided stream, and returns the new stream.
java.util.stream.DoublePipeline: Abstract base class for an intermediate pipeline stage or pipeline source stage implementing whose elements are of type double.
java.util.stream.DoublePipeline.DoublePipeline	(	AbstractPipeline	int	): Constructor for appending an intermediate operation onto an existing pipeline.
java.util.stream.DoublePipeline.DoublePipeline	(	Spliterator	int	boolean	): Constructor for the head of a stream pipeline.
java.util.stream.DoublePipeline.DoublePipeline	(	Supplier	int	boolean	): Constructor for the head of a stream pipeline.
java.util.stream.DoublePipeline.Head: Source stage of a DoubleStream
java.util.stream.DoublePipeline.Head.Head	(	Spliterator	int	boolean	): Constructor for the source stage of a DoubleStream.
java.util.stream.DoublePipeline.Head.Head	(	Supplier	int	boolean	): Constructor for the source stage of a DoubleStream.
java.util.stream.DoublePipeline.StatefulOp: Base class for a stateful intermediate stage of a DoubleStream.
java.util.stream.DoublePipeline.StatefulOp.StatefulOp	(	AbstractPipeline	StreamShape	int	): Construct a new DoubleStream by appending a stateful intermediate operation to an existing stream.
java.util.stream.DoublePipeline.StatelessOp: Base class for a stateless intermediate stage of a DoubleStream.
java.util.stream.DoublePipeline.StatelessOp.StatelessOp	(	AbstractPipeline	StreamShape	int	): Construct a new DoubleStream by appending a stateless intermediate operation to an existing stream.
java.util.stream.DoublePipeline.adapt	(	Sink	): Adapt a Sink to a DoubleConsumer, ideally simply by casting.
java.util.stream.DoublePipeline.adapt	(	Spliterator	): Adapt a Spliterator to a Spliterator.OfDouble.
java.util.stream.DoublePipeline.average	(	): Returns an OptionalDouble describing the arithmetic mean of elements of this stream, or an empty optional if this stream is empty. If any recorded value is a NaN or the sum is at any point a NaN then the average will be NaN. The average returned can vary depending upon the order in which values are recorded. This method may be implemented using compensated summation or other technique to reduce the error bound in the sum numerical sum used to compute the average. The average is a special case of a reduction. This is a terminal operation.
java.util.stream.DoubleStream: A sequence of primitive double-valued elements supporting sequential and parallel aggregate operations. This is the double primitive specialization of Stream. The following example illustrates an aggregate operation using Stream and DoubleStream, computing the sum of the weights of the red widgets: double sum = widgets.stream() .filter(w -> w.getColor() == RED) .mapToDouble(w -> w.getWeight()) .sum(); See the class documentation for Stream and the package documentation for java.util.stream for additional specification of streams, stream operations, stream pipelines, and parallelism.
java.util.stream.DoubleStream.Builder: A mutable builder for a DoubleStream. A stream builder has a lifecycle, which starts in a building phase, during which elements can be added, and then transitions to a built phase, after which elements may not be added. The built phase begins when the build() method is called, which creates an ordered stream whose elements are the elements that were added to the stream builder, in the order they were added.
java.util.stream.DoubleStream.Builder.accept	(	double	): Adds an element to the stream being built.
java.util.stream.DoubleStream.Builder.add	(	double	): Adds an element to the stream being built.
java.util.stream.DoubleStream.Builder.build	(	): Builds the stream, transitioning this builder to the built state. An IllegalStateException is thrown if there are further attempts to operate on the builder after it has entered the built state.
java.util.stream.DoubleStream.allMatch	(	DoublePredicate	): Returns whether all elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then true is returned and the predicate is not evaluated. This is a short-circuiting terminal operation.
java.util.stream.DoubleStream.anyMatch	(	DoublePredicate	): Returns whether any elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then false is returned and the predicate is not evaluated. This is a short-circuiting terminal operation.
java.util.stream.DoubleStream.average	(	): Returns an OptionalDouble describing the arithmetic mean of elements of this stream, or an empty optional if this stream is empty. If any recorded value is a NaN or the sum is at any point a NaN then the average will be NaN. The average returned can vary depending upon the order in which values are recorded. This method may be implemented using compensated summation or other technique to reduce the error bound in the sum numerical sum used to compute the average. The average is a special case of a reduction. This is a terminal operation.
java.util.stream.DoubleStream.boxed	(	): Returns a Stream consisting of the elements of this stream, boxed to Double. This is an intermediate operation.
java.util.stream.DoubleStream.builder	(	): Returns a builder for a DoubleStream.
java.util.stream.DoubleStream.collect	(	Supplier	ObjDoubleConsumer	BiConsumer	): Performs a mutable reduction operation on the elements of this stream. A mutable reduction is one in which the reduced value is a mutable result container, such as an ArrayList, and elements are incorporated by updating the state of the result rather than by replacing the result. This produces a result equivalent to: R result = supplier.get(); for (double element : this stream) accumulator.accept(result, element); return result; Like reduce(), collect operations can be parallelized without requiring additional synchronization. This is a terminal operation.
java.util.stream.DoubleStream.concat	(	DoubleStream	DoubleStream	): Creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream. The resulting stream is ordered if both of the input streams are ordered, and parallel if either of the input streams is parallel. When the resulting stream is closed, the close handlers for both input streams are invoked.
java.util.stream.DoubleStream.count	(	): Returns the count of elements in this stream. This is a special case of a reduction and is equivalent to: return mapToLong(e -> 1L).sum(); This is a terminal operation.
java.util.stream.DoubleStream.distinct	(	): Returns a stream consisting of the distinct elements of this stream. The elements are compared for equality according to compare(). This is a stateful intermediate operation.
java.util.stream.DoubleStream.empty	(	): Returns an empty sequential DoubleStream.
java.util.stream.DoubleStream.filter	(	DoublePredicate	): Returns a stream consisting of the elements of this stream that match the given predicate. This is an intermediate operation.
java.util.stream.DoubleStream.findAny	(	): Returns an OptionalDouble describing some element of the stream, or an empty OptionalDouble if the stream is empty. This is a short-circuiting terminal operation. The behavior of this operation is explicitly nondeterministic; it is free to select any element in the stream. This is to allow for maximal performance in parallel operations; the cost is that multiple invocations on the same source may not return the same result. (If a stable result is desired, use findFirst() instead.)
java.util.stream.DoubleStream.findFirst	(	): Returns an OptionalDouble describing the first element of this stream, or an empty OptionalDouble if the stream is empty. If the stream has no encounter order, then any element may be returned. This is a short-circuiting terminal operation.
java.util.stream.DoubleStream.flatMap	(	DoubleFunction	): Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element. Each mapped stream is close() closed after its contents have been placed into this stream. (If a mapped stream is null an empty stream is used, instead.) This is an intermediate operation.
java.util.stream.DoubleStream.forEach	(	DoubleConsumer	): Performs an action for each element of this stream. This is a terminal operation. For parallel stream pipelines, this operation does not guarantee to respect the encounter order of the stream, as doing so would sacrifice the benefit of parallelism. For any given element, the action may be performed at whatever time and in whatever thread the library chooses. If the action accesses shared state, it is responsible for providing the required synchronization.
java.util.stream.DoubleStream.forEachOrdered	(	DoubleConsumer	): Performs an action for each element of this stream, guaranteeing that each element is processed in encounter order for streams that have a defined encounter order. This is a terminal operation.
java.util.stream.DoubleStream.generate	(	DoubleSupplier	): Returns an infinite sequential unordered stream where each element is generated by the provided DoubleSupplier. This is suitable for generating constant streams, streams of random elements, etc.
java.util.stream.DoubleStream.iterate	(	double	DoubleUnaryOperator	): Returns an infinite sequential ordered DoubleStream produced by iterative application of a function f to an initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc. The first element (position 0) in the DoubleStream will be the provided seed. For n > 0, the element at position n, will be the result of applying the function f to the element at position n - 1.
java.util.stream.DoubleStream.limit	(	long	): Returns a stream consisting of the elements of this stream, truncated to be no longer than maxSize in length. This is a short-circuiting stateful intermediate operation.
java.util.stream.DoubleStream.map	(	DoubleUnaryOperator	): Returns a stream consisting of the results of applying the given function to the elements of this stream. This is an intermediate operation.
java.util.stream.DoubleStream.mapToInt	(	DoubleToIntFunction	): Returns an IntStream consisting of the results of applying the given function to the elements of this stream. This is an intermediate operation.
java.util.stream.DoubleStream.mapToLong	(	DoubleToLongFunction	): Returns a LongStream consisting of the results of applying the given function to the elements of this stream. This is an intermediate operation.
java.util.stream.DoubleStream.mapToObj	(	DoubleFunction	): Returns an object-valued Stream consisting of the results of applying the given function to the elements of this stream. This is an  intermediate operation.
java.util.stream.DoubleStream.max	(	): Returns an OptionalDouble describing the maximum element of this stream, or an empty OptionalDouble if this stream is empty. The maximum element will be Double.NaN if any stream element was NaN. Unlike the numerical comparison operators, this method considers negative zero to be strictly smaller than positive zero. This is a special case of a reduction and is equivalent to: return reduce(Double::max); This is a terminal operation.
java.util.stream.DoubleStream.min	(	): Returns an OptionalDouble describing the minimum element of this stream, or an empty OptionalDouble if this stream is empty. The minimum element will be Double.NaN if any stream element was NaN. Unlike the numerical comparison operators, this method considers negative zero to be strictly smaller than positive zero. This is a special case of a reduction and is equivalent to: return reduce(Double::min); This is a terminal operation.
java.util.stream.DoubleStream.noneMatch	(	DoublePredicate	): Returns whether no elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then true is returned and the predicate is not evaluated. This is a short-circuiting terminal operation.
java.util.stream.DoubleStream.of	(	double	): Returns a sequential ordered stream whose elements are the specified values.
java.util.stream.DoubleStream.peek	(	DoubleConsumer	): Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream. This is an intermediate operation. For parallel stream pipelines, the action may be called at whatever time and in whatever thread the element is made available by the upstream operation. If the action modifies shared state, it is responsible for providing the required synchronization.
java.util.stream.DoubleStream.reduce	(	DoubleBinaryOperator	): Performs a reduction on the elements of this stream, using an associative accumulation function, and returns an OptionalDouble describing the reduced value, if any. This is equivalent to: boolean foundAny = false; double result = null; for (double element : this stream) if (!foundAny) { foundAny = true; result = element; } else result = accumulator.applyAsDouble(result, element); } return foundAny ? OptionalDouble.of(result) : OptionalDouble.empty(); } but is not constrained to execute sequentially. The accumulator function must be an associative function. This is a terminal operation.
java.util.stream.DoubleStream.reduce	(	double	DoubleBinaryOperator	): Performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value. This is equivalent to: double result = identity; for (double element : this stream) result = accumulator.applyAsDouble(result, element) return result; but is not constrained to execute sequentially. The identity value must be an identity for the accumulator function. This means that for all x, accumulator.apply(identity, x) is equal to x. The accumulator function must be an associative function. This is a terminal operation.
java.util.stream.DoubleStream.skip	(	long	): Returns a stream consisting of the remaining elements of this stream after discarding the first n elements of the stream. If this stream contains fewer than n elements then an empty stream will be returned. This is a stateful intermediate operation.
java.util.stream.DoubleStream.sorted	(	): Returns a stream consisting of the elements of this stream in sorted order. The elements are compared for equality according to compare(). This is a stateful intermediate operation.
java.util.stream.DoubleStream.sum	(	): Returns the sum of elements in this stream. Summation is a special case of a reduction. If floating-point summation were exact, this method would be equivalent to: return reduce(0, Double::sum); However, since floating-point summation is not exact, the above code is not necessarily equivalent to the summation computation done by this method. If any stream element is a NaN or the sum is at any point a NaN then the sum will be NaN. The value of a floating-point sum is a function both of the input values as well as the order of addition operations. The order of addition operations of this method is intentionally not defined to allow for implementation flexibility to improve the speed and accuracy of the computed result. In particular, this method may be implemented using compensated summation or other technique to reduce the error bound in the numerical sum compared to a simple summation of double values. This is a terminal operation.
java.util.stream.DoubleStream.summaryStatistics	(	): Returns a DoubleSummaryStatistics describing various summary data about the elements of this stream. This is a special case of a reduction. This is a terminal operation.
java.util.stream.DoubleStream.toArray	(	): Returns an array containing the elements of this stream. This is a terminal operation.
java.util.stream.FindOps: Factory for instances of a short-circuiting TerminalOp that searches for an element in a stream pipeline, and terminates when it finds one. Supported variants include find-first (find the first element in the encounter order) and find-any (find any element, may not be the first in encounter order.)
java.util.stream.FindOps.FindOp: A short-circuiting TerminalOp that searches for an element in a stream pipeline, and terminates when it finds one. Implements both find-first (find the first element in the encounter order) and find-any (find any element, may not be the first in encounter order.)
java.util.stream.FindOps.FindOp.FindOp	(	boolean	StreamShape	O	Predicate	Supplier	): Constructs a FindOp.
java.util.stream.FindOps.FindSink: Implementation of @{code TerminalSink} that implements the find functionality, requesting cancellation when something has been found
java.util.stream.FindOps.FindSink.OfDouble: Specialization of FindSink for double streams 
java.util.stream.FindOps.FindSink.OfInt: Specialization of FindSink for int streams 
java.util.stream.FindOps.FindSink.OfLong: Specialization of FindSink for long streams 
java.util.stream.FindOps.FindSink.OfRef: Specialization of FindSink for reference streams 
java.util.stream.FindOps.FindTask: ForkJoinTask implementing parallel short-circuiting search
java.util.stream.FindOps.makeDouble	(	boolean	): Constructs a FindOp for streams of doubles.
java.util.stream.FindOps.makeInt	(	boolean	): Constructs a TerminalOp for streams of ints.
java.util.stream.FindOps.makeLong	(	boolean	): Constructs a TerminalOp for streams of longs.
java.util.stream.FindOps.makeRef	(	boolean	): Constructs a TerminalOp for streams of objects.
java.util.stream.ForEachOps: Factory for creating instances of TerminalOp that perform an action for every element of a stream. Supported variants include unordered traversal (elements are provided to the Consumer as soon as they are available), and ordered traversal (elements are provided to the Consumer in encounter order.) Elements are provided to the Consumer on whatever thread and whatever order they become available. For ordered traversals, it is guaranteed that processing an element happens-before processing subsequent elements in the encounter order. Exceptions occurring as a result of sending an element to the Consumer will be relayed to the caller and traversal will be prematurely terminated.
java.util.stream.ForEachOps.ForEachOp: A TerminalOp that evaluates a stream pipeline and sends the output to itself as a TerminalSink. Elements will be sent in whatever thread they become available. If the traversal is unordered, they will be sent independent of the stream's encounter order. This terminal operation is stateless. For parallel evaluation, each leaf instance of a ForEachTask will send elements to the same TerminalSink reference that is an instance of this class.
java.util.stream.ForEachOps.ForEachOp.OfDouble: Implementation class for DoubleStream 
java.util.stream.ForEachOps.ForEachOp.OfInt: Implementation class for IntStream 
java.util.stream.ForEachOps.ForEachOp.OfLong: Implementation class for LongStream 
java.util.stream.ForEachOps.ForEachOp.OfRef: Implementation class for reference streams 
java.util.stream.ForEachOps.ForEachOrderedTask: A ForkJoinTask for performing a parallel for-each operation which visits the elements in encounter order
java.util.stream.ForEachOps.ForEachTask: A ForkJoinTask for performing a parallel for-each operation 
java.util.stream.ForEachOps.makeDouble	(	DoubleConsumer	boolean	): Constructs a TerminalOp that perform an action for every element of a DoubleStream.
java.util.stream.ForEachOps.makeInt	(	IntConsumer	boolean	): Constructs a TerminalOp that perform an action for every element of an IntStream.
java.util.stream.ForEachOps.makeLong	(	LongConsumer	boolean	): Constructs a TerminalOp that perform an action for every element of a LongStream.
java.util.stream.ForEachOps.makeRef	(	Consumer	boolean	): Constructs a TerminalOp that perform an action for every element of a stream.
java.util.stream.IntPipeline: Abstract base class for an intermediate pipeline stage or pipeline source stage implementing whose elements are of type int.
java.util.stream.IntPipeline.Head: Source stage of an IntStream.
java.util.stream.IntPipeline.Head.Head	(	Spliterator	int	boolean	): Constructor for the source stage of an IntStream.
java.util.stream.IntPipeline.Head.Head	(	Supplier	int	boolean	): Constructor for the source stage of an IntStream.
java.util.stream.IntPipeline.IntPipeline	(	AbstractPipeline	int	): Constructor for appending an intermediate operation onto an existing pipeline.
java.util.stream.IntPipeline.IntPipeline	(	Spliterator	int	boolean	): Constructor for the head of a stream pipeline.
java.util.stream.IntPipeline.IntPipeline	(	Supplier	int	boolean	): Constructor for the head of a stream pipeline.
java.util.stream.IntPipeline.StatefulOp: Base class for a stateful intermediate stage of an IntStream.
java.util.stream.IntPipeline.StatefulOp.StatefulOp	(	AbstractPipeline	StreamShape	int	): Construct a new IntStream by appending a stateful intermediate operation to an existing stream.
java.util.stream.IntPipeline.StatelessOp: Base class for a stateless intermediate stage of an IntStream
java.util.stream.IntPipeline.StatelessOp.StatelessOp	(	AbstractPipeline	StreamShape	int	): Construct a new IntStream by appending a stateless intermediate operation to an existing stream.
java.util.stream.IntPipeline.adapt	(	Sink	): Adapt a Sink to an IntConsumer, ideally simply by casting.
java.util.stream.IntPipeline.adapt	(	Spliterator	): Adapt a Spliterator to a Spliterator.OfInt.
java.util.stream.IntStream: A sequence of primitive int-valued elements supporting sequential and parallel aggregate operations. This is the int primitive specialization of Stream. The following example illustrates an aggregate operation using Stream and IntStream, computing the sum of the weights of the red widgets: int sum = widgets.stream() .filter(w -> w.getColor() == RED) .mapToInt(w -> w.getWeight()) .sum(); See the class documentation for Stream and the package documentation for java.util.stream for additional specification of streams, stream operations, stream pipelines, and parallelism.
java.util.stream.IntStream.Builder: A mutable builder for an IntStream. A stream builder has a lifecycle, which starts in a building phase, during which elements can be added, and then transitions to a built phase, after which elements may not be added. The built phase begins when the build() method is called, which creates an ordered stream whose elements are the elements that were added to the stream builder, in the order they were added.
java.util.stream.IntStream.Builder.accept	(	int	): Adds an element to the stream being built.
java.util.stream.IntStream.Builder.add	(	int	): Adds an element to the stream being built.
java.util.stream.IntStream.Builder.build	(	): Builds the stream, transitioning this builder to the built state. An IllegalStateException is thrown if there are further attempts to operate on the builder after it has entered the built state.
java.util.stream.IntStream.allMatch	(	IntPredicate	): Returns whether all elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then true is returned and the predicate is not evaluated. This is a short-circuiting terminal operation.
java.util.stream.IntStream.anyMatch	(	IntPredicate	): Returns whether any elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then false is returned and the predicate is not evaluated. This is a short-circuiting terminal operation.
java.util.stream.IntStream.asDoubleStream	(	): Returns a DoubleStream consisting of the elements of this stream, converted to double. This is an intermediate operation.
java.util.stream.IntStream.asLongStream	(	): Returns a LongStream consisting of the elements of this stream, converted to long. This is an intermediate operation.
java.util.stream.IntStream.average	(	): Returns an OptionalDouble describing the arithmetic mean of elements of this stream, or an empty optional if this stream is empty. This is a special case of a reduction. This is a terminal operation.
java.util.stream.IntStream.boxed	(	): Returns a Stream consisting of the elements of this stream, each boxed to an Integer. This is an intermediate operation.
java.util.stream.IntStream.builder	(	): Returns a builder for an IntStream.
java.util.stream.IntStream.collect	(	Supplier	ObjIntConsumer	BiConsumer	): Performs a mutable reduction operation on the elements of this stream. A mutable reduction is one in which the reduced value is a mutable result container, such as an ArrayList, and elements are incorporated by updating the state of the result rather than by replacing the result. This produces a result equivalent to: R result = supplier.get(); for (int element : this stream) accumulator.accept(result, element); return result; Like reduce(), collect operations can be parallelized without requiring additional synchronization. This is a terminal operation.
java.util.stream.IntStream.concat	(	IntStream	IntStream	): Creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream. The resulting stream is ordered if both of the input streams are ordered, and parallel if either of the input streams is parallel. When the resulting stream is closed, the close handlers for both input streams are invoked.
java.util.stream.IntStream.count	(	): Returns the count of elements in this stream. This is a special case of a reduction and is equivalent to: return mapToLong(e -> 1L).sum(); This is a terminal operation.
java.util.stream.IntStream.distinct	(	): Returns a stream consisting of the distinct elements of this stream. This is a stateful intermediate operation.
java.util.stream.IntStream.empty	(	): Returns an empty sequential IntStream.
java.util.stream.IntStream.filter	(	IntPredicate	): Returns a stream consisting of the elements of this stream that match the given predicate. This is an intermediate operation.
java.util.stream.IntStream.findAny	(	): Returns an OptionalInt describing some element of the stream, or an empty OptionalInt if the stream is empty. This is a short-circuiting terminal operation. The behavior of this operation is explicitly nondeterministic; it is free to select any element in the stream. This is to allow for maximal performance in parallel operations; the cost is that multiple invocations on the same source may not return the same result. (If a stable result is desired, use findFirst() instead.)
java.util.stream.IntStream.findFirst	(	): Returns an OptionalInt describing the first element of this stream, or an empty OptionalInt if the stream is empty. If the stream has no encounter order, then any element may be returned. This is a short-circuiting terminal operation.
java.util.stream.IntStream.flatMap	(	IntFunction	): Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element. Each mapped stream is close() closed after its contents have been placed into this stream. (If a mapped stream is null an empty stream is used, instead.) This is an intermediate operation.
java.util.stream.IntStream.forEach	(	IntConsumer	): Performs an action for each element of this stream. This is a terminal operation. For parallel stream pipelines, this operation does not guarantee to respect the encounter order of the stream, as doing so would sacrifice the benefit of parallelism. For any given element, the action may be performed at whatever time and in whatever thread the library chooses. If the action accesses shared state, it is responsible for providing the required synchronization.
java.util.stream.IntStream.forEachOrdered	(	IntConsumer	): Performs an action for each element of this stream, guaranteeing that each element is processed in encounter order for streams that have a defined encounter order. This is a terminal operation.
java.util.stream.IntStream.generate	(	IntSupplier	): Returns an infinite sequential unordered stream where each element is generated by the provided IntSupplier. This is suitable for generating constant streams, streams of random elements, etc.
java.util.stream.IntStream.iterate	(	int	IntUnaryOperator	): Returns an infinite sequential ordered IntStream produced by iterative application of a function f to an initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc. The first element (position 0) in the IntStream will be the provided seed. For n > 0, the element at position n, will be the result of applying the function f to the element at position n - 1.
java.util.stream.IntStream.limit	(	long	): Returns a stream consisting of the elements of this stream, truncated to be no longer than maxSize in length. This is a short-circuiting stateful intermediate operation.
java.util.stream.IntStream.map	(	IntUnaryOperator	): Returns a stream consisting of the results of applying the given function to the elements of this stream. This is an intermediate operation.
java.util.stream.IntStream.mapToDouble	(	IntToDoubleFunction	): Returns a DoubleStream consisting of the results of applying the given function to the elements of this stream. This is an intermediate operation.
java.util.stream.IntStream.mapToLong	(	IntToLongFunction	): Returns a LongStream consisting of the results of applying the given function to the elements of this stream. This is an intermediate operation.
java.util.stream.IntStream.mapToObj	(	IntFunction	): Returns an object-valued Stream consisting of the results of applying the given function to the elements of this stream. This is an  intermediate operation.
java.util.stream.IntStream.max	(	): Returns an OptionalInt describing the maximum element of this stream, or an empty optional if this stream is empty. This is a special case of a reduction and is equivalent to: return reduce(Integer::max); This is a terminal operation.
java.util.stream.IntStream.min	(	): Returns an OptionalInt describing the minimum element of this stream, or an empty optional if this stream is empty. This is a special case of a reduction and is equivalent to: return reduce(Integer::min); This is a terminal operation.
java.util.stream.IntStream.noneMatch	(	IntPredicate	): Returns whether no elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then true is returned and the predicate is not evaluated. This is a short-circuiting terminal operation.
java.util.stream.IntStream.of	(	int	): Returns a sequential ordered stream whose elements are the specified values.
java.util.stream.IntStream.peek	(	IntConsumer	): Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream. This is an intermediate operation. For parallel stream pipelines, the action may be called at whatever time and in whatever thread the element is made available by the upstream operation. If the action modifies shared state, it is responsible for providing the required synchronization.
java.util.stream.IntStream.range	(	int	int	): Returns a sequential ordered IntStream from startInclusive (inclusive) to endExclusive (exclusive) by an incremental step of 1.
java.util.stream.IntStream.rangeClosed	(	int	int	): Returns a sequential ordered IntStream from startInclusive (inclusive) to endInclusive (inclusive) by an incremental step of 1.
java.util.stream.IntStream.reduce	(	IntBinaryOperator	): Performs a reduction on the elements of this stream, using an associative accumulation function, and returns an OptionalInt describing the reduced value, if any. This is equivalent to: boolean foundAny = false; int result = null; for (int element : this stream) if (!foundAny) { foundAny = true; result = element; } else result = accumulator.applyAsInt(result, element); } return foundAny ? OptionalInt.of(result) : OptionalInt.empty(); } but is not constrained to execute sequentially. The accumulator function must be an associative function. This is a terminal operation.
java.util.stream.IntStream.reduce	(	int	IntBinaryOperator	): Performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value. This is equivalent to: int result = identity; for (int element : this stream) result = accumulator.applyAsInt(result, element) return result; but is not constrained to execute sequentially. The identity value must be an identity for the accumulator function. This means that for all x, accumulator.apply(identity, x) is equal to x. The accumulator function must be an associative function. This is a terminal operation.
java.util.stream.IntStream.skip	(	long	): Returns a stream consisting of the remaining elements of this stream after discarding the first n elements of the stream. If this stream contains fewer than n elements then an empty stream will be returned. This is a stateful intermediate operation.
java.util.stream.IntStream.sorted	(	): Returns a stream consisting of the elements of this stream in sorted order. This is a stateful intermediate operation.
java.util.stream.IntStream.sum	(	): Returns the sum of elements in this stream. This is a special case of a reduction and is equivalent to: return reduce(0, Integer::sum); This is a terminal operation.
java.util.stream.IntStream.summaryStatistics	(	): Returns an IntSummaryStatistics describing various summary data about the elements of this stream. This is a special case of a reduction. This is a terminal operation.
java.util.stream.IntStream.toArray	(	): Returns an array containing the elements of this stream. This is a terminal operation.
java.util.stream.LongPipeline: Abstract base class for an intermediate pipeline stage or pipeline source stage implementing whose elements are of type long.
java.util.stream.LongPipeline.Head: Source stage of a LongPipeline.
java.util.stream.LongPipeline.Head.Head	(	Spliterator	int	boolean	): Constructor for the source stage of a LongStream.
java.util.stream.LongPipeline.Head.Head	(	Supplier	int	boolean	): Constructor for the source stage of a LongStream.
java.util.stream.LongPipeline.LongPipeline	(	AbstractPipeline	int	): Constructor for appending an intermediate operation onto an existing pipeline.
java.util.stream.LongPipeline.LongPipeline	(	Spliterator	int	boolean	): Constructor for the head of a stream pipeline.
java.util.stream.LongPipeline.LongPipeline	(	Supplier	int	boolean	): Constructor for the head of a stream pipeline.
java.util.stream.LongPipeline.StatefulOp: Base class for a stateful intermediate stage of a LongStream.
java.util.stream.LongPipeline.StatefulOp.StatefulOp	(	AbstractPipeline	StreamShape	int	): Construct a new LongStream by appending a stateful intermediate operation to an existing stream.
java.util.stream.LongPipeline.StatelessOp: Base class for a stateless intermediate stage of a LongStream.
java.util.stream.LongPipeline.StatelessOp.StatelessOp	(	AbstractPipeline	StreamShape	int	): Construct a new LongStream by appending a stateless intermediate operation to an existing stream.
java.util.stream.LongPipeline.adapt	(	Sink	): Adapt a Sink to an LongConsumer, ideally simply by casting.
java.util.stream.LongPipeline.adapt	(	Spliterator	): Adapt a Spliterator to a Spliterator.OfLong.
java.util.stream.LongStream: A sequence of primitive long-valued elements supporting sequential and parallel aggregate operations. This is the long primitive specialization of Stream. The following example illustrates an aggregate operation using Stream and LongStream, computing the sum of the weights of the red widgets: long sum = widgets.stream() .filter(w -> w.getColor() == RED) .mapToLong(w -> w.getWeight()) .sum(); See the class documentation for Stream and the package documentation for java.util.stream for additional specification of streams, stream operations, stream pipelines, and parallelism.
java.util.stream.LongStream.Builder: A mutable builder for a LongStream. A stream builder has a lifecycle, which starts in a building phase, during which elements can be added, and then transitions to a built phase, after which elements may not be added. The built phase begins begins when the build() method is called, which creates an ordered stream whose elements are the elements that were added to the stream builder, in the order they were added.
java.util.stream.LongStream.Builder.accept	(	long	): Adds an element to the stream being built.
java.util.stream.LongStream.Builder.add	(	long	): Adds an element to the stream being built.
java.util.stream.LongStream.Builder.build	(	): Builds the stream, transitioning this builder to the built state. An IllegalStateException is thrown if there are further attempts to operate on the builder after it has entered the built state.
java.util.stream.LongStream.allMatch	(	LongPredicate	): Returns whether all elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then true is returned and the predicate is not evaluated. This is a short-circuiting terminal operation.
java.util.stream.LongStream.anyMatch	(	LongPredicate	): Returns whether any elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then false is returned and the predicate is not evaluated. This is a short-circuiting terminal operation.
java.util.stream.LongStream.asDoubleStream	(	): Returns a DoubleStream consisting of the elements of this stream, converted to double. This is an intermediate operation.
java.util.stream.LongStream.average	(	): Returns an OptionalDouble describing the arithmetic mean of elements of this stream, or an empty optional if this stream is empty. This is a special case of a reduction. This is a terminal operation.
java.util.stream.LongStream.boxed	(	): Returns a Stream consisting of the elements of this stream, each boxed to a Long. This is an intermediate operation.
java.util.stream.LongStream.builder	(	): Returns a builder for a LongStream.
java.util.stream.LongStream.collect	(	Supplier	ObjLongConsumer	BiConsumer	): Performs a mutable reduction operation on the elements of this stream. A mutable reduction is one in which the reduced value is a mutable result container, such as an ArrayList, and elements are incorporated by updating the state of the result rather than by replacing the result. This produces a result equivalent to: R result = supplier.get(); for (long element : this stream) accumulator.accept(result, element); return result; Like reduce(), collect operations can be parallelized without requiring additional synchronization. This is a terminal operation.
java.util.stream.LongStream.concat	(	LongStream	LongStream	): Creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream. The resulting stream is ordered if both of the input streams are ordered, and parallel if either of the input streams is parallel. When the resulting stream is closed, the close handlers for both input streams are invoked.
java.util.stream.LongStream.count	(	): Returns the count of elements in this stream. This is a special case of a reduction and is equivalent to: return map(e -> 1L).sum(); This is a terminal operation.
java.util.stream.LongStream.distinct	(	): Returns a stream consisting of the distinct elements of this stream. This is a stateful intermediate operation.
java.util.stream.LongStream.empty	(	): Returns an empty sequential LongStream.
java.util.stream.LongStream.filter	(	LongPredicate	): Returns a stream consisting of the elements of this stream that match the given predicate. This is an intermediate operation.
java.util.stream.LongStream.findAny	(	): Returns an OptionalLong describing some element of the stream, or an empty OptionalLong if the stream is empty. This is a short-circuiting terminal operation. The behavior of this operation is explicitly nondeterministic; it is free to select any element in the stream. This is to allow for maximal performance in parallel operations; the cost is that multiple invocations on the same source may not return the same result. (If a stable result is desired, use findFirst() instead.)
java.util.stream.LongStream.findFirst	(	): Returns an OptionalLong describing the first element of this stream, or an empty OptionalLong if the stream is empty. If the stream has no encounter order, then any element may be returned. This is a short-circuiting terminal operation.
java.util.stream.LongStream.flatMap	(	LongFunction	): Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element. Each mapped stream is close() closed after its contents have been placed into this stream. (If a mapped stream is null an empty stream is used, instead.) This is an intermediate operation.
java.util.stream.LongStream.forEach	(	LongConsumer	): Performs an action for each element of this stream. This is a terminal operation. For parallel stream pipelines, this operation does not guarantee to respect the encounter order of the stream, as doing so would sacrifice the benefit of parallelism. For any given element, the action may be performed at whatever time and in whatever thread the library chooses. If the action accesses shared state, it is responsible for providing the required synchronization.
java.util.stream.LongStream.forEachOrdered	(	LongConsumer	): Performs an action for each element of this stream, guaranteeing that each element is processed in encounter order for streams that have a defined encounter order. This is a terminal operation.
java.util.stream.LongStream.generate	(	LongSupplier	): Returns an infinite sequential unordered stream where each element is generated by the provided LongSupplier. This is suitable for generating constant streams, streams of random elements, etc.
java.util.stream.LongStream.iterate	(	long	LongUnaryOperator	): Returns an infinite sequential ordered LongStream produced by iterative application of a function f to an initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc. The first element (position 0) in the LongStream will be the provided seed. For n > 0, the element at position n, will be the result of applying the function f to the element at position n - 1.
java.util.stream.LongStream.limit	(	long	): Returns a stream consisting of the elements of this stream, truncated to be no longer than maxSize in length. This is a short-circuiting stateful intermediate operation.
java.util.stream.LongStream.map	(	LongUnaryOperator	): Returns a stream consisting of the results of applying the given function to the elements of this stream. This is an intermediate operation.
java.util.stream.LongStream.mapToDouble	(	LongToDoubleFunction	): Returns a DoubleStream consisting of the results of applying the given function to the elements of this stream. This is an intermediate operation.
java.util.stream.LongStream.mapToInt	(	LongToIntFunction	): Returns an IntStream consisting of the results of applying the given function to the elements of this stream. This is an intermediate operation.
java.util.stream.LongStream.mapToObj	(	LongFunction	): Returns an object-valued Stream consisting of the results of applying the given function to the elements of this stream. This is an  intermediate operation.
java.util.stream.LongStream.max	(	): Returns an OptionalLong describing the maximum element of this stream, or an empty optional if this stream is empty. This is a special case of a reduction and is equivalent to: return reduce(Long::max); This is a terminal operation.
java.util.stream.LongStream.min	(	): Returns an OptionalLong describing the minimum element of this stream, or an empty optional if this stream is empty. This is a special case of a reduction and is equivalent to: return reduce(Long::min); This is a terminal operation.
java.util.stream.LongStream.noneMatch	(	LongPredicate	): Returns whether no elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then true is returned and the predicate is not evaluated. This is a short-circuiting terminal operation.
java.util.stream.LongStream.of	(	long	): Returns a sequential ordered stream whose elements are the specified values.
java.util.stream.LongStream.peek	(	LongConsumer	): Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream. This is an intermediate operation. For parallel stream pipelines, the action may be called at whatever time and in whatever thread the element is made available by the upstream operation. If the action modifies shared state, it is responsible for providing the required synchronization.
java.util.stream.LongStream.range	(	long	long	): Returns a sequential ordered LongStream from startInclusive (inclusive) to endExclusive (exclusive) by an incremental step of 1.
java.util.stream.LongStream.rangeClosed	(	long	long	): Returns a sequential ordered LongStream from startInclusive (inclusive) to endInclusive (inclusive) by an incremental step of 1.
java.util.stream.LongStream.reduce	(	LongBinaryOperator	): Performs a reduction on the elements of this stream, using an associative accumulation function, and returns an OptionalLong describing the reduced value, if any. This is equivalent to: boolean foundAny = false; long result = null; for (long element : this stream) if (!foundAny) { foundAny = true; result = element; } else result = accumulator.applyAsLong(result, element); } return foundAny ? OptionalLong.of(result) : OptionalLong.empty(); } but is not constrained to execute sequentially. The accumulator function must be an associative function. This is a terminal operation.
java.util.stream.LongStream.reduce	(	long	LongBinaryOperator	): Performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value. This is equivalent to: long result = identity; for (long element : this stream) result = accumulator.applyAsLong(result, element) return result; but is not constrained to execute sequentially. The identity value must be an identity for the accumulator function. This means that for all x, accumulator.apply(identity, x) is equal to x. The accumulator function must be an associative function. This is a terminal operation.
java.util.stream.LongStream.skip	(	long	): Returns a stream consisting of the remaining elements of this stream after discarding the first n elements of the stream. If this stream contains fewer than n elements then an empty stream will be returned. This is a stateful intermediate operation.
java.util.stream.LongStream.sorted	(	): Returns a stream consisting of the elements of this stream in sorted order. This is a stateful intermediate operation.
java.util.stream.LongStream.sum	(	): Returns the sum of elements in this stream. This is a special case of a reduction and is equivalent to: return reduce(0, Long::sum); This is a terminal operation.
java.util.stream.LongStream.summaryStatistics	(	): Returns a LongSummaryStatistics describing various summary data about the elements of this stream. This is a special case of a reduction. This is a terminal operation.
java.util.stream.LongStream.toArray	(	): Returns an array containing the elements of this stream. This is a terminal operation.
java.util.stream.MatchOps: Factory for instances of a short-circuiting TerminalOp that implement quantified predicate matching on the elements of a stream. Supported variants include match-all, match-any, and match-none.
java.util.stream.MatchOps.BooleanTerminalSink: Boolean specific terminal sink to avoid the boxing costs when returning results. Subclasses implement the shape-specific functionality.
java.util.stream.MatchOps.MatchOp: A short-circuiting TerminalOp that evaluates a predicate on the elements of a stream and determines whether all, any or none of those elements match the predicate.
java.util.stream.MatchOps.MatchOp.MatchOp	(	StreamShape	MatchKind	Supplier	): Constructs a MatchOp.
java.util.stream.MatchOps.MatchTask: ForkJoinTask implementation to implement a parallel short-circuiting quantified match
java.util.stream.MatchOps.MatchTask.MatchTask	(	MatchOp	PipelineHelper	Spliterator	): Constructor for root node
java.util.stream.MatchOps.MatchTask.MatchTask	(	MatchTask	Spliterator	): Constructor for non-root node
java.util.stream.MatchOps.makeDouble	(	DoublePredicate	MatchKind	): Constructs a quantified predicate matcher for a DoubleStream.
java.util.stream.MatchOps.makeInt	(	IntPredicate	MatchKind	): Constructs a quantified predicate matcher for an IntStream.
java.util.stream.MatchOps.makeLong	(	LongPredicate	MatchKind	): Constructs a quantified predicate matcher for a LongStream.
java.util.stream.MatchOps.makeRef	(	Predicate	MatchKind	): Constructs a quantified predicate matcher for a Stream.
java.util.stream.Node: An immutable container for describing an ordered sequence of elements of some type T. A Node contains a fixed number of elements, which can be accessed via the count, spliterator, forEach, asArray, or copyInto methods. A Node may have zero or more child Nodes; if it has no children (accessed via getChildCount and getChild(), it is considered flat  or a leaf; if it has children, it is considered an internal node. The size of an internal node is the sum of sizes of its children.
java.util.stream.Node.Builder: A mutable builder for a Node that implements Sink, which builds a flat node containing the elements that have been pushed to it.
java.util.stream.Node.Builder.OfDouble: Specialized @{code Node.Builder} for double elements
java.util.stream.Node.Builder.OfInt: Specialized @{code Node.Builder} for int elements
java.util.stream.Node.Builder.OfLong: Specialized @{code Node.Builder} for long elements
java.util.stream.Node.Builder.build	(	): Builds the node. Should be called after all elements have been pushed and signalled with an invocation of end().
java.util.stream.Node.OfDouble: Specialized Node for double elements
java.util.stream.Node.OfDouble.copyInto	(	Double[]	int	): 
java.util.stream.Node.OfDouble.forEach	(	Consumer	): Traverses the elements of this node, and invoke the provided Consumer with each element. Elements are provided in encounter order if the source for the Node has a defined encounter order.
java.util.stream.Node.OfDouble.getShape	(	): Gets the StreamShape associated with this Node.
java.util.stream.Node.OfInt: Specialized Node for int elements
java.util.stream.Node.OfInt.copyInto	(	Integer[]	int	): 
java.util.stream.Node.OfInt.forEach	(	Consumer	): Traverses the elements of this node, and invoke the provided Consumer with each element. Elements are provided in encounter order if the source for the Node has a defined encounter order.
java.util.stream.Node.OfInt.getShape	(	): Gets the StreamShape associated with this Node.
java.util.stream.Node.OfLong: Specialized Node for long elements
java.util.stream.Node.OfLong.copyInto	(	Long[]	int	): 
java.util.stream.Node.OfLong.forEach	(	Consumer	): Traverses the elements of this node, and invoke the provided Consumer with each element. Elements are provided in encounter order if the source for the Node has a defined encounter order.
java.util.stream.Node.OfLong.getShape	(	): Gets the StreamShape associated with this Node.
java.util.stream.Node.OfPrimitive.asArray	(	IntFunction	): Provides an array view of the contents of this node. Depending on the underlying implementation, this may return a reference to an internal array rather than a copy. Since the returned array may be shared, the returned array should not be modified. The generator function may be consulted to create the array if a new array needs to be created.
java.util.stream.Node.OfPrimitive.asPrimitiveArray	(	): Views this node as a primitive array. Depending on the underlying implementation this may return a reference to an internal array rather than a copy. It is the callers responsibility to decide if either this node or the array is utilized as the primary reference for the data.
java.util.stream.Node.OfPrimitive.copyInto	(	T_ARR	int	): Copies the content of this Node into a primitive array, starting at a given offset into the array. It is the caller's responsibility to ensure there is sufficient room in the array.
java.util.stream.Node.OfPrimitive.forEach	(	T_CONS	): Traverses the elements of this node, and invoke the provided action with each element.
java.util.stream.Node.OfPrimitive.newArray	(	int	): Creates a new primitive array.
java.util.stream.Node.OfPrimitive.spliterator	(	): Returns a Spliterator describing the elements contained in this Node.
java.util.stream.Node.asArray	(	IntFunction	): Provides an array view of the contents of this node. Depending on the underlying implementation, this may return a reference to an internal array rather than a copy. Since the returned array may be shared, the returned array should not be modified. The generator function may be consulted to create the array if a new array needs to be created.
java.util.stream.Node.copyInto	(	T[]	int	): Copies the content of this Node into an array, starting at a given offset into the array. It is the caller's responsibility to ensure there is sufficient room in the array, otherwise unspecified behaviour will occur if the array length is less than the number of elements contained in this node.
java.util.stream.Node.count	(	): Returns the number of elements contained in this node.
java.util.stream.Node.forEach	(	Consumer	): Traverses the elements of this node, and invoke the provided Consumer with each element. Elements are provided in encounter order if the source for the Node has a defined encounter order.
java.util.stream.Node.getChild	(	int	): Retrieves the child Node at a given index.
java.util.stream.Node.getChildCount	(	): Returns the number of child nodes of this node.
java.util.stream.Node.getShape	(	): Gets the StreamShape associated with this Node.
java.util.stream.Node.spliterator	(	): Returns a Spliterator describing the elements contained in this Node.
java.util.stream.Node.truncate	(	long	long	IntFunction	): Return a node describing a subsequence of the elements of this node, starting at the given inclusive start offset and ending at the given exclusive end offset.
java.util.stream.Nodes: Factory methods for constructing implementations of Node and Node.Builder and their primitive specializations. Fork/Join tasks for collecting output from a PipelineHelper to a Node and flattening Nodes.
java.util.stream.Nodes.AbstractConcNode: Node class for an internal node with two or more children
java.util.stream.Nodes.ArrayNode: Node class for a reference array 
java.util.stream.Nodes.CollectionNode: Node class for a Collection 
java.util.stream.Nodes.FixedNodeBuilder: Fixed-sized builder class for reference nodes
java.util.stream.Nodes.InternalNodeSpliterator: Abstract class for spliterator for all internal node classes 
java.util.stream.Nodes.InternalNodeSpliterator.findNextLeafNode	(	Deque	): Depth first search, in left-to-right order, of the node tree, using an explicit stack, to find the next non-empty leaf node.
java.util.stream.Nodes.InternalNodeSpliterator.initStack	(	): Initiate a stack containing, in left-to-right order, the child nodes covered by this spliterator
java.util.stream.Nodes.SpinedNodeBuilder: Variable-sized builder class for reference nodes
java.util.stream.Nodes.builder	(	): Produces a variable size @{link Node.Builder}.
java.util.stream.Nodes.builder	(	long	IntFunction	): Produces a Node.Builder.
java.util.stream.Nodes.collect	(	PipelineHelper	Spliterator	boolean	IntFunction	): Collect, in parallel, elements output from a pipeline and describe those elements with a Node.
java.util.stream.Nodes.collectDouble	(	PipelineHelper	Spliterator	boolean	): Collect, in parallel, elements output from n double-valued pipeline and describe those elements with a Node.OfDouble.
java.util.stream.Nodes.collectInt	(	PipelineHelper	Spliterator	boolean	): Collect, in parallel, elements output from an int-valued pipeline and describe those elements with a Node.OfInt.
java.util.stream.Nodes.collectLong	(	PipelineHelper	Spliterator	boolean	): Collect, in parallel, elements output from a long-valued pipeline and describe those elements with a Node.OfLong.
java.util.stream.Nodes.conc	(	StreamShape	Node	Node	): Produces a concatenated Node that has two or more children. The count of the concatenated node is equal to the sum of the count of each child. Traversal of the concatenated node traverses the content of each child in encounter order of the list of children. Splitting a spliterator obtained from the concatenated node preserves the encounter order of the list of children. The result may be a concatenated node, the input sole node if the size of the list is 1, or an empty node.
java.util.stream.Nodes.doubleBuilder	(	): Produces a variable size @{link Node.Builder.OfDouble}.
java.util.stream.Nodes.doubleBuilder	(	long	): Produces a Node.Builder.OfDouble.
java.util.stream.Nodes.emptyNode	(	StreamShape	): Produces an empty node whose count is zero, has no children and no content.
java.util.stream.Nodes.flatten	(	Node	IntFunction	): Flatten, in parallel, a Node. A flattened node is one that has no children. If the node is already flat, it is simply returned.
java.util.stream.Nodes.flattenDouble	(	Node.OfDouble	): Flatten, in parallel, a Node.OfDouble. A flattened node is one that has no children. If the node is already flat, it is simply returned.
java.util.stream.Nodes.flattenInt	(	Node.OfInt	): Flatten, in parallel, a Node.OfInt. A flattened node is one that has no children. If the node is already flat, it is simply returned.
java.util.stream.Nodes.flattenLong	(	Node.OfLong	): Flatten, in parallel, a Node.OfLong. A flattened node is one that has no children. If the node is already flat, it is simply returned.
java.util.stream.Nodes.intBuilder	(	): Produces a variable size @{link Node.Builder.OfInt}.
java.util.stream.Nodes.intBuilder	(	long	): Produces a Node.Builder.OfInt.
java.util.stream.Nodes.longBuilder	(	): Produces a variable size @{link Node.Builder.OfLong}.
java.util.stream.Nodes.longBuilder	(	long	): Produces a Node.Builder.OfLong.
java.util.stream.Nodes.node	(	Collection	): Produces a Node describing a Collection.  The node will hold a reference to the collection and will not make a copy.
java.util.stream.Nodes.node	(	T[]	): Produces a Node describing an array. The node will hold a reference to the array and will not make a copy.
java.util.stream.Nodes.node	(	double[]	): Produces a Node.OfDouble describing a double[] array. The node will hold a reference to the array and will not make a copy.
java.util.stream.Nodes.node	(	int[]	): Produces a Node.OfInt describing an int[] array. The node will hold a reference to the array and will not make a copy.
java.util.stream.Nodes.node	(	long[]	): Produces a Node.OfLong describing a long[] array.  The node will hold a reference to the array and will not make a copy.
java.util.stream.PipelineHelper: Helper class for executing  stream pipelines, capturing all of the information about a stream pipeline (output shape, intermediate operations, stream flags, parallelism, etc) in one place.  A PipelineHelper describes the initial segment of a stream pipeline, including its source, intermediate operations, and may additionally incorporate information about the terminal (or stateful) operation which follows the last intermediate operation described by this PipelineHelper. The PipelineHelper is passed to the evaluateParallel(), evaluateSequential(), and opEvaluateParallel(), methods, which can use the PipelineHelper to access information about the pipeline such as head shape, stream flags, and size, and use the helper methods such as wrapAndCopyInto(), copyInto(), and wrapSink() to execute pipeline operations.
java.util.stream.PipelineHelper.copyInto	(	Sink	Spliterator	): Pushes elements obtained from the Spliterator into the provided Sink. If the stream pipeline is known to have short-circuiting stages in it (see SHORT_CIRCUIT), the cancellationRequested() is checked after each element, stopping if cancellation is requested.
java.util.stream.PipelineHelper.copyIntoWithCancel	(	Sink	Spliterator	): Pushes elements obtained from the Spliterator into the provided Sink, checking cancellationRequested() after each element, and stopping if cancellation is requested.
java.util.stream.PipelineHelper.evaluate	(	Spliterator	boolean	IntFunction	): Collects all output elements resulting from applying the pipeline stages to the source Spliterator into a Node.
java.util.stream.PipelineHelper.exactOutputSizeIfKnown	(	Spliterator	): Returns the exact output size of the portion of the output resulting from applying the pipeline stages described by this PipelineHelper to the the portion of the input described by the provided Spliterator, if known. If not known or known infinite, will return -1.
java.util.stream.PipelineHelper.getSourceShape	(	): Gets the stream shape for the source of the pipeline segment.
java.util.stream.PipelineHelper.getStreamAndOpFlags	(	): Gets the combined stream and operation flags for the output of the described pipeline. This will incorporate stream flags from the stream source, all the intermediate operations and the terminal operation.
java.util.stream.PipelineHelper.makeNodeBuilder	(	long	IntFunction	): Constructs a @{link Node.Builder} compatible with the output shape of this PipelineHelper.
java.util.stream.PipelineHelper.wrapAndCopyInto	(	S	Spliterator	): Applies the pipeline stages described by this PipelineHelper to the provided Spliterator and send the results to the provided Sink.
java.util.stream.PipelineHelper.wrapSink	(	Sink	): Takes a Sink that accepts elements of the output type of the PipelineHelper, and wrap it with a Sink that accepts elements of the input type and implements all the intermediate operations described by this PipelineHelper, delivering the result into the provided Sink.
java.util.stream.PipelineHelper.wrapSpliterator	(	Spliterator	): 
java.util.stream.ReduceOps: Factory for creating instances of TerminalOp that implement reductions.
java.util.stream.ReduceOps.AccumulatingSink: A type of TerminalSink that implements an associative reducing operation on elements of type T and producing a result of type R.
java.util.stream.ReduceOps.Box: State box for a single state element, used as a base class for AccumulatingSink instances
java.util.stream.ReduceOps.ReduceOp: A TerminalOp that evaluates a stream pipeline and sends the output into an AccumulatingSink, which performs a reduce operation. The AccumulatingSink must represent an associative reducing operation.
java.util.stream.ReduceOps.ReduceOp.ReduceOp	(	StreamShape	): Create a ReduceOp of the specified stream shape which uses the specified Supplier to create accumulating sinks.
java.util.stream.ReduceOps.ReduceTask: A ForkJoinTask for performing a parallel reduce operation.
java.util.stream.ReduceOps.makeDouble	(	DoubleBinaryOperator	): Constructs a TerminalOp that implements a functional reduce on double values, producing an optional double result.
java.util.stream.ReduceOps.makeDouble	(	Supplier	ObjDoubleConsumer	BinaryOperator	): Constructs a TerminalOp that implements a mutable reduce on double values.
java.util.stream.ReduceOps.makeDouble	(	double	DoubleBinaryOperator	): Constructs a TerminalOp that implements a functional reduce on double values.
java.util.stream.ReduceOps.makeInt	(	IntBinaryOperator	): Constructs a TerminalOp that implements a functional reduce on int values, producing an optional integer result.
java.util.stream.ReduceOps.makeInt	(	Supplier	ObjIntConsumer	BinaryOperator	): Constructs a TerminalOp that implements a mutable reduce on int values.
java.util.stream.ReduceOps.makeInt	(	int	IntBinaryOperator	): Constructs a TerminalOp that implements a functional reduce on int values.
java.util.stream.ReduceOps.makeLong	(	LongBinaryOperator	): Constructs a TerminalOp that implements a functional reduce on long values, producing an optional long result.
java.util.stream.ReduceOps.makeLong	(	Supplier	ObjLongConsumer	BinaryOperator	): Constructs a TerminalOp that implements a mutable reduce on long values.
java.util.stream.ReduceOps.makeLong	(	long	LongBinaryOperator	): Constructs a TerminalOp that implements a functional reduce on long values.
java.util.stream.ReduceOps.makeRef	(	BinaryOperator	): Constructs a TerminalOp that implements a functional reduce on reference values producing an optional reference result.
java.util.stream.ReduceOps.makeRef	(	Collector	): Constructs a TerminalOp that implements a mutable reduce on reference values.
java.util.stream.ReduceOps.makeRef	(	Supplier	BiConsumer	BiConsumer	): Constructs a TerminalOp that implements a mutable reduce on reference values.
java.util.stream.ReduceOps.makeRef	(	U	BiFunction	BinaryOperator	): Constructs a TerminalOp that implements a functional reduce on reference values.
java.util.stream.ReferencePipeline: Abstract base class for an intermediate pipeline stage or pipeline source stage implementing whose elements are of type U.
java.util.stream.ReferencePipeline.Head: Source stage of a ReferencePipeline.
java.util.stream.ReferencePipeline.Head.Head	(	Spliterator	int	boolean	): Constructor for the source stage of a Stream.
java.util.stream.ReferencePipeline.Head.Head	(	Supplier	int	boolean	): Constructor for the source stage of a Stream.
java.util.stream.ReferencePipeline.ReferencePipeline	(	AbstractPipeline	int	): Constructor for appending an intermediate operation onto an existing pipeline.
java.util.stream.ReferencePipeline.ReferencePipeline	(	Spliterator	int	boolean	): Constructor for the head of a stream pipeline.
java.util.stream.ReferencePipeline.ReferencePipeline	(	Supplier	int	boolean	): Constructor for the head of a stream pipeline.
java.util.stream.ReferencePipeline.StatefulOp: Base class for a stateful intermediate stage of a Stream.
java.util.stream.ReferencePipeline.StatefulOp.StatefulOp	(	AbstractPipeline	StreamShape	int	): Construct a new Stream by appending a stateful intermediate operation to an existing stream.
java.util.stream.ReferencePipeline.StatelessOp: Base class for a stateless intermediate stage of a Stream.
java.util.stream.ReferencePipeline.StatelessOp.StatelessOp	(	AbstractPipeline	StreamShape	int	): Construct a new Stream by appending a stateless intermediate operation to an existing stream.
java.util.stream.Sink: An extension of Consumer used to conduct values through the stages of a stream pipeline, with additional methods to manage size information, control flow, etc. Before calling the accept() method on a Sink for the first time, you must first call the begin() method to inform it that data is coming (optionally informing the sink how much data is coming), and after all data has been sent, you must call the end() method. After calling end(), you should not call accept() without again calling begin(). Sink also offers a mechanism by which the sink can cooperatively signal that it does not wish to receive any more data (the cancellationRequested() method), which a source can poll before sending more data to the Sink. A sink may be in one of two states: an initial state and an active state. It starts out in the initial state; the begin() method transitions it to the active state, and the end() method transitions it back into the initial state, where it can be re-used. Data-accepting methods (such as accept() are only valid in the active state.
java.util.stream.Sink.ChainedDouble: Abstract Sink implementation designed for creating chains of sinks. The begin, end, and cancellationRequested methods are wired to chain to the downstream Sink. This implementation takes a downstream Sink of unknown input shape and produces a Sink.OfDouble. The implementation of the accept() method must call the correct accept() method on the downstream Sink.
java.util.stream.Sink.ChainedInt: Abstract Sink implementation designed for creating chains of sinks. The begin, end, and cancellationRequested methods are wired to chain to the downstream Sink. This implementation takes a downstream Sink of unknown input shape and produces a Sink.OfInt. The implementation of the accept() method must call the correct accept() method on the downstream Sink.
java.util.stream.Sink.ChainedLong: Abstract Sink implementation designed for creating chains of sinks. The begin, end, and cancellationRequested methods are wired to chain to the downstream Sink. This implementation takes a downstream Sink of unknown input shape and produces a Sink.OfLong. The implementation of the accept() method must call the correct accept() method on the downstream Sink.
java.util.stream.Sink.ChainedReference: Abstract Sink implementation for creating chains of sinks. The begin, end, and cancellationRequested methods are wired to chain to the downstream Sink. This implementation takes a downstream Sink of unknown input shape and produces a Sink. The implementation of the accept() method must call the correct accept() method on the downstream Sink.
java.util.stream.Sink.OfDouble: Sink that implements Sink, re-abstracts accept(double), and wires accept(Double) to bridge to accept(double).
java.util.stream.Sink.OfInt: Sink that implements Sink, re-abstracts accept(int), and wires accept(Integer) to bridge to accept(int).
java.util.stream.Sink.OfLong: Sink that implements Sink, re-abstracts accept(long), and wires accept(Long) to bridge to accept(long).
java.util.stream.Sink.accept	(	double	): Accepts a double value.
java.util.stream.Sink.accept	(	int	): Accepts an int value.
java.util.stream.Sink.accept	(	long	): Accepts a long value.
java.util.stream.Sink.begin	(	long	): Resets the sink state to receive a fresh data set. This must be called before sending any data to the sink. After calling end(), you may call this method to reset the sink for another calculation.
java.util.stream.Sink.cancellationRequested	(	): Indicates that this Sink does not wish to receive any more data.
java.util.stream.Sink.end	(	): Indicates that all elements have been pushed. If the Sink is stateful, it should send any stored state downstream at this time, and should clear any accumulated state (and associated resources). Prior to this call, the sink must be in the active state, and after this call it is returned to the initial state.
java.util.stream.SliceOps: Factory for instances of a short-circuiting stateful intermediate operations that produce subsequences of their input stream.
java.util.stream.SliceOps.SliceTask: ForkJoinTask implementing slice computation.
java.util.stream.SliceOps.SliceTask.completedSize	(	long	): Compute the number of completed elements in this node.  Computation terminates if all nodes have been processed or the number of completed elements is greater than or equal to the target size.
java.util.stream.SliceOps.SliceTask.isLeftCompleted	(	long	): Determine if the number of completed elements in this node and nodes to the left of this node is greater than or equal to the target size.
java.util.stream.SliceOps.calcSize	(	long	long	long	): Calculates the sliced size given the current size, number of elements skip, and the number of elements to limit.
java.util.stream.SliceOps.calcSliceFence	(	long	long	): Calculates the slice fence, which is one past the index of the slice range
java.util.stream.SliceOps.makeDouble	(	AbstractPipeline	long	long	): Appends a "slice" operation to the provided DoubleStream. The slice operation may be may be skip-only, limit-only, or skip-and-limit.
java.util.stream.SliceOps.makeInt	(	AbstractPipeline	long	long	): Appends a "slice" operation to the provided IntStream. The slice operation may be may be skip-only, limit-only, or skip-and-limit.
java.util.stream.SliceOps.makeLong	(	AbstractPipeline	long	long	): Appends a "slice" operation to the provided LongStream. The slice operation may be may be skip-only, limit-only, or skip-and-limit.
java.util.stream.SliceOps.makeRef	(	AbstractPipeline	long	long	): Appends a "slice" operation to the provided stream. The slice operation may be may be skip-only, limit-only, or skip-and-limit.
java.util.stream.SliceOps.sliceSpliterator	(	StreamShape	Spliterator	long	long	): Creates a slice spliterator given a stream shape governing the spliterator type. Requires that the underlying Spliterator be SUBSIZED.
java.util.stream.SortedOps: Factory methods for transforming streams into sorted streams.
java.util.stream.SortedOps.AbstractDoubleSortingSink: Abstract Sink for implementing sort on long streams.
java.util.stream.SortedOps.AbstractIntSortingSink: Abstract Sink for implementing sort on int streams.
java.util.stream.SortedOps.AbstractLongSortingSink: Abstract Sink for implementing sort on long streams.
java.util.stream.SortedOps.AbstractRefSortingSink: Abstract Sink for implementing sort on reference streams.  Note: documentation below applies to reference and all primitive sinks.  Sorting sinks first accept all elements, buffering then into an array or a re-sizable data structure, if the size of the pipeline is known or unknown respectively. At the end of the sink protocol those elements are sorted and then pushed downstream. This class records if cancellationRequested is called. If so it can be inferred that the source pushing source elements into the pipeline knows that the pipeline is short-circuiting. In such cases sub-classes pushing elements downstream will preserve the short-circuiting protocol by calling downstream.cancellationRequested() and checking the result is false before an element is pushed.  Note that the above behaviour is an optimization for sorting with sequential streams. It is not an error that more elements, than strictly required to produce a result, may flow through the pipeline. This can occur, in general (not restricted to just sorting), for short-circuiting parallel pipelines.
java.util.stream.SortedOps.AbstractRefSortingSink.cancellationRequested	(	): Records is cancellation is requested so short-circuiting behaviour can be preserved when the sorted elements are pushed downstream.
java.util.stream.SortedOps.DoubleSortingSink: Sink for implementing sort on double streams.
java.util.stream.SortedOps.IntSortingSink: Sink for implementing sort on int streams.
java.util.stream.SortedOps.LongSortingSink: Sink for implementing sort on long streams.
java.util.stream.SortedOps.OfDouble: Specialized subtype for sorting double streams.
java.util.stream.SortedOps.OfInt: Specialized subtype for sorting int streams.
java.util.stream.SortedOps.OfLong: Specialized subtype for sorting long streams.
java.util.stream.SortedOps.OfRef: Specialized subtype for sorting reference streams
java.util.stream.SortedOps.OfRef.OfRef	(	AbstractPipeline	): Sort using natural order of  which must be Comparable.
java.util.stream.SortedOps.OfRef.OfRef	(	AbstractPipeline	Comparator	): Sort using the provided comparator.
java.util.stream.SortedOps.RefSortingSink: Sink for implementing sort on reference streams.
java.util.stream.SortedOps.SizedDoubleSortingSink: Sink for implementing sort on SIZED double streams.
java.util.stream.SortedOps.SizedIntSortingSink: Sink for implementing sort on SIZED int streams.
java.util.stream.SortedOps.SizedLongSortingSink: Sink for implementing sort on SIZED long streams.
java.util.stream.SortedOps.SizedRefSortingSink: Sink for implementing sort on SIZED reference streams.
java.util.stream.SortedOps.makeDouble	(	AbstractPipeline	): Appends a "sorted" operation to the provided stream.
java.util.stream.SortedOps.makeInt	(	AbstractPipeline	): Appends a "sorted" operation to the provided stream.
java.util.stream.SortedOps.makeLong	(	AbstractPipeline	): Appends a "sorted" operation to the provided stream.
java.util.stream.SortedOps.makeRef	(	AbstractPipeline	): Appends a "sorted" operation to the provided stream.
java.util.stream.SortedOps.makeRef	(	AbstractPipeline	Comparator	): Appends a "sorted" operation to the provided stream.
java.util.stream.SpinedBuffer: An ordered collection of elements. Elements can be added, but not removed. Goes through a building phase, during which elements can be added, and a traversal phase, during which elements can be traversed in order but no further modifications are possible.  One or more arrays are used to store elements. The use of a multiple arrays has better performance characteristics than a single array used by ArrayList, as when the capacity of the list needs to be increased no copying of elements is required. This is usually beneficial in the case where the results will be traversed a small number of times.
java.util.stream.SpinedBuffer.OfDouble: An ordered collection of double values.
java.util.stream.SpinedBuffer.OfInt: An ordered collection of int values.
java.util.stream.SpinedBuffer.OfLong: An ordered collection of long values.
java.util.stream.SpinedBuffer.OfPrimitive: An ordered collection of primitive values. Elements can be added, but not removed. Goes through a building phase, during which elements can be added, and a traversal phase, during which elements can be traversed in order but no further modifications are possible.  One or more arrays are used to store elements. The use of a multiple arrays has better performance characteristics than a single array used by ArrayList, as when the capacity of the list needs to be increased no copying of elements is required. This is usually beneficial in the case where the results will be traversed a small number of times.
java.util.stream.SpinedBuffer.OfPrimitive.OfPrimitive	(	): Constructs an empty list with an initial capacity of sixteen.
java.util.stream.SpinedBuffer.OfPrimitive.OfPrimitive	(	int	): Constructs an empty list with the specified initial capacity.
java.util.stream.SpinedBuffer.OfPrimitive.arrayForEach	(	T_ARR	int	int	T_CONS	): Iterate an array with the provided consumer 
java.util.stream.SpinedBuffer.OfPrimitive.arrayLength	(	T_ARR	): Get the length of an array 
java.util.stream.SpinedBuffer.OfPrimitive.newArray	(	int	): Create a new array of the proper type and size 
java.util.stream.SpinedBuffer.OfPrimitive.newArrayArray	(	int	): Create a new array-of-array of the proper type and size 
java.util.stream.SpinedBuffer.SpinedBuffer	(	): Constructs an empty list with an initial capacity of sixteen.
java.util.stream.SpinedBuffer.SpinedBuffer	(	int	): Constructs an empty list with the specified initial capacity.
java.util.stream.SpinedBuffer.asArray	(	IntFunction	): Create a new array using the specified array factory, and copy the elements into it.
java.util.stream.SpinedBuffer.capacity	(	): Returns the current capacity of the buffer
java.util.stream.SpinedBuffer.copyInto	(	E[]	int	): Copy the elements, starting at the specified offset, into the specified array.
java.util.stream.SpinedBuffer.ensureCapacity	(	long	): Ensure that the buffer has at least capacity to hold the target size
java.util.stream.SpinedBuffer.get	(	long	): Retrieve the element at the specified index.
java.util.stream.SpinedBuffer.increaseCapacity	(	): Force the buffer to increase its capacity.
java.util.stream.SpinedBuffer.spliterator	(	): Return a Spliterator describing the contents of the buffer.
java.util.stream.Stream: A sequence of elements supporting sequential and parallel aggregate operations. The following example illustrates an aggregate operation using Stream and IntStream: int sum = widgets.stream() .filter(w -> w.getColor() == RED) .mapToInt(w -> w.getWeight()) .sum(); In this example, widgets is a Collection. We create a stream of Widget objects via stream Collection.stream(), filter it to produce a stream containing only the red widgets, and then transform it into a stream of int values representing the weight of each red widget. Then this stream is summed to produce a total weight. In addition to Stream, which is a stream of object references, there are primitive specializations for IntStream, LongStream, and DoubleStream, all of which are referred to as "streams" and conform to the characteristics and restrictions described here. To perform a computation, stream operations are composed into a stream pipeline. A stream pipeline consists of a source (which might be an array, a collection, a generator function, an I/O channel, etc), zero or more intermediate operations (which transform a stream into another stream, such as filter()), and a terminal operation (which produces a result or side-effect, such as count() or forEach()). Streams are lazy; computation on the source data is only performed when the terminal operation is initiated, and source elements are consumed only as needed. Collections and streams, while bearing some superficial similarities, have different goals. Collections are primarily concerned with the efficient management of, and access to, their elements. By contrast, streams do not provide a means to directly access or manipulate their elements, and are instead concerned with declaratively describing their source and the computational operations which will be performed in aggregate on that source. However, if the provided stream operations do not offer the desired functionality, the iterator() and spliterator() operations can be used to perform a controlled traversal. A stream pipeline, like the "widgets" example above, can be viewed as a query on the stream source. Unless the source was explicitly designed for concurrent modification (such as a ConcurrentHashMap), unpredictable or erroneous behavior may result from modifying the stream source while it is being queried. Most stream operations accept parameters that describe user-specified behavior, such as the lambda expression w -> w.getWeight() passed to mapToInt in the example above. To preserve correct behavior, these behavioral parameters:  must be non-interfering (they do not modify the stream source); and in most cases must be stateless (their result should not depend on any state that might change during execution of the stream pipeline).  Such parameters are always instances of a functional interface such as java.util.function.Function, and are often lambda expressions or method references. Unless otherwise specified these parameters must be non-null. A stream should be operated on (invoking an intermediate or terminal stream operation) only once. This rules out, for example, "forked" streams, where the same source feeds two or more pipelines, or multiple traversals of the same stream. A stream implementation may throw IllegalStateException if it detects that the stream is being reused. However, since some stream operations may return their receiver rather than a new stream object, it may not be possible to detect reuse in all cases. Streams have a close() method and implement AutoCloseable, but nearly all stream instances do not actually need to be closed after use. Generally, only streams whose source is an IO channel (such as those returned by lines()) will require closing. Most streams are backed by collections, arrays, or generating functions, which require no special resource management. (If a stream does require closing, it can be declared as a resource in a try-with-resources statement.) Stream pipelines may execute either sequentially or in parallel. This execution mode is a property of the stream. Streams are created with an initial choice of sequential or parallel execution. (For example, stream() Collection.stream() creates a sequential stream, and parallelStream() Collection.parallelStream() creates a parallel one.) This choice of execution mode may be modified by the sequential() or parallel() methods, and may be queried with the isParallel() method.
java.util.stream.Stream.Builder: A mutable builder for a Stream. This allows the creation of a Stream by generating elements individually and adding them to the Builder (without the copying overhead that comes from using an ArrayList as a temporary buffer.) A stream builder has a lifecycle, which starts in a building phase, during which elements can be added, and then transitions to a built phase, after which elements may not be added. The built phase begins when the build() method is called, which creates an ordered Stream whose elements are the elements that were added to the stream builder, in the order they were added.
java.util.stream.Stream.Builder.accept	(	T	): Adds an element to the stream being built.
java.util.stream.Stream.Builder.add	(	T	): Adds an element to the stream being built.
java.util.stream.Stream.Builder.build	(	): Builds the stream, transitioning this builder to the built state. An IllegalStateException is thrown if there are further attempts to operate on the builder after it has entered the built state.
java.util.stream.Stream.allMatch	(	Predicate	): Returns whether all elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then true is returned and the predicate is not evaluated. This is a short-circuiting terminal operation.
java.util.stream.Stream.anyMatch	(	Predicate	): Returns whether any elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then false is returned and the predicate is not evaluated. This is a short-circuiting terminal operation.
java.util.stream.Stream.builder	(	): Returns a builder for a Stream.
java.util.stream.Stream.collect	(	Collector	): Performs a mutable reduction operation on the elements of this stream using a Collector. A Collector encapsulates the functions used as arguments to collect(), allowing for reuse of collection strategies and composition of collect operations such as multiple-level grouping or partitioning. If the stream is parallel, and the Collector is CONCURRENT concurrent, and either the stream is unordered or the collector is UNORDERED unordered, then a concurrent reduction will be performed (see Collector for details on concurrent reduction.) This is a terminal operation. When executed in parallel, multiple intermediate results may be instantiated, populated, and merged so as to maintain isolation of mutable data structures. Therefore, even when executed in parallel with non-thread-safe data structures (such as ArrayList), no additional synchronization is needed for a parallel reduction.
java.util.stream.Stream.collect	(	Supplier	BiConsumer	BiConsumer	): Performs a mutable reduction operation on the elements of this stream. A mutable reduction is one in which the reduced value is a mutable result container, such as an ArrayList, and elements are incorporated by updating the state of the result rather than by replacing the result. This produces a result equivalent to: R result = supplier.get(); for (T element : this stream) accumulator.accept(result, element); return result; Like reduce(), collect operations can be parallelized without requiring additional synchronization. This is a terminal operation.
java.util.stream.Stream.concat	(	Stream	Stream	): Creates a lazily concatenated stream whose elements are all the elements of the first stream followed by all the elements of the second stream. The resulting stream is ordered if both of the input streams are ordered, and parallel if either of the input streams is parallel. When the resulting stream is closed, the close handlers for both input streams are invoked.
java.util.stream.Stream.count	(	): Returns the count of elements in this stream. This is a special case of a reduction and is equivalent to: return mapToLong(e -> 1L).sum(); This is a terminal operation.
java.util.stream.Stream.distinct	(	): Returns a stream consisting of the distinct elements (according to equals()) of this stream. For ordered streams, the selection of distinct elements is stable (for duplicated elements, the element appearing first in the encounter order is preserved.) For unordered streams, no stability guarantees are made. This is a stateful intermediate operation.
java.util.stream.Stream.empty	(	): Returns an empty sequential Stream.
java.util.stream.Stream.filter	(	Predicate	): Returns a stream consisting of the elements of this stream that match the given predicate. This is an intermediate operation.
java.util.stream.Stream.findAny	(	): Returns an Optional describing some element of the stream, or an empty Optional if the stream is empty. This is a short-circuiting terminal operation. The behavior of this operation is explicitly nondeterministic; it is free to select any element in the stream. This is to allow for maximal performance in parallel operations; the cost is that multiple invocations on the same source may not return the same result. (If a stable result is desired, use findFirst() instead.)
java.util.stream.Stream.findFirst	(	): Returns an Optional describing the first element of this stream, or an empty Optional if the stream is empty. If the stream has no encounter order, then any element may be returned. This is a short-circuiting terminal operation.
java.util.stream.Stream.flatMap	(	Function	): Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element. Each mapped stream is close() closed after its contents have been placed into this stream. (If a mapped stream is null an empty stream is used, instead.) This is an intermediate operation.
java.util.stream.Stream.flatMapToDouble	(	Function	): Returns an DoubleStream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element. Each mapped stream is close() closed after its contents have placed been into this stream. (If a mapped stream is null an empty stream is used, instead.) This is an intermediate operation.
java.util.stream.Stream.flatMapToInt	(	Function	): Returns an IntStream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element. Each mapped stream is close() closed after its contents have been placed into this stream. (If a mapped stream is null an empty stream is used, instead.) This is an intermediate operation.
java.util.stream.Stream.flatMapToLong	(	Function	): Returns an LongStream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element. Each mapped stream is close() closed after its contents have been placed into this stream. (If a mapped stream is null an empty stream is used, instead.) This is an intermediate operation.
java.util.stream.Stream.forEach	(	Consumer	): Performs an action for each element of this stream. This is a terminal operation. The behavior of this operation is explicitly nondeterministic. For parallel stream pipelines, this operation does not guarantee to respect the encounter order of the stream, as doing so would sacrifice the benefit of parallelism. For any given element, the action may be performed at whatever time and in whatever thread the library chooses. If the action accesses shared state, it is responsible for providing the required synchronization.
java.util.stream.Stream.forEachOrdered	(	Consumer	): Performs an action for each element of this stream, in the encounter order of the stream if the stream has a defined encounter order. This is a terminal operation. This operation processes the elements one at a time, in encounter order if one exists. Performing the action for one element happens-before performing the action for subsequent elements, but for any given element, the action may be performed in whatever thread the library chooses.
java.util.stream.Stream.generate	(	Supplier	): Returns an infinite sequential unordered stream where each element is generated by the provided Supplier. This is suitable for generating constant streams, streams of random elements, etc.
java.util.stream.Stream.iterate	(	T	UnaryOperator	): Returns an infinite sequential ordered Stream produced by iterative application of a function f to an initial element seed, producing a Stream consisting of seed, f(seed), f(f(seed)), etc. The first element (position 0) in the Stream will be the provided seed. For n > 0, the element at position n, will be the result of applying the function f to the element at position n - 1.
java.util.stream.Stream.limit	(	long	): Returns a stream consisting of the elements of this stream, truncated to be no longer than maxSize in length. This is a short-circuiting stateful intermediate operation.
java.util.stream.Stream.map	(	Function	): Returns a stream consisting of the results of applying the given function to the elements of this stream. This is an intermediate operation.
java.util.stream.Stream.mapToDouble	(	ToDoubleFunction	): Returns a DoubleStream consisting of the results of applying the given function to the elements of this stream. This is an intermediate operation.
java.util.stream.Stream.mapToInt	(	ToIntFunction	): Returns an IntStream consisting of the results of applying the given function to the elements of this stream. This is an  intermediate operation.
java.util.stream.Stream.mapToLong	(	ToLongFunction	): Returns a LongStream consisting of the results of applying the given function to the elements of this stream. This is an intermediate operation.
java.util.stream.Stream.max	(	Comparator	): Returns the maximum element of this stream according to the provided Comparator. This is a special case of a reduction. This is a terminal operation.
java.util.stream.Stream.min	(	Comparator	): Returns the minimum element of this stream according to the provided Comparator. This is a special case of a reduction. This is a terminal operation.
java.util.stream.Stream.noneMatch	(	Predicate	): Returns whether no elements of this stream match the provided predicate. May not evaluate the predicate on all elements if not necessary for determining the result. If the stream is empty then true is returned and the predicate is not evaluated. This is a short-circuiting terminal operation.
java.util.stream.Stream.of	(	T	): Returns a sequential ordered stream whose elements are the specified values.
java.util.stream.Stream.peek	(	Consumer	): Returns a stream consisting of the elements of this stream, additionally performing the provided action on each element as elements are consumed from the resulting stream. This is an intermediate operation. For parallel stream pipelines, the action may be called at whatever time and in whatever thread the element is made available by the upstream operation. If the action modifies shared state, it is responsible for providing the required synchronization.
java.util.stream.Stream.reduce	(	BinaryOperator	): Performs a reduction on the elements of this stream, using an associative accumulation function, and returns an Optional describing the reduced value, if any. This is equivalent to: boolean foundAny = false; T result = null; for (T element : this stream) if (!foundAny) { foundAny = true; result = element; } else result = accumulator.apply(result, element); } return foundAny ? Optional.of(result) : Optional.empty(); } but is not constrained to execute sequentially. The accumulator function must be an associative function. This is a terminal operation.
java.util.stream.Stream.reduce	(	T	BinaryOperator	): Performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value. This is equivalent to: T result = identity; for (T element : this stream) result = accumulator.apply(result, element) return result; but is not constrained to execute sequentially. The identity value must be an identity for the accumulator function. This means that for all t, accumulator.apply(identity, t) is equal to t. The accumulator function must be an associative function. This is a terminal operation.
java.util.stream.Stream.reduce	(	U	BiFunction	BinaryOperator	): Performs a reduction on the elements of this stream, using the provided identity, accumulation and combining functions. This is equivalent to: U result = identity; for (T element : this stream) result = accumulator.apply(result, element) return result; but is not constrained to execute sequentially. The identity value must be an identity for the combiner function. This means that for all u, combiner(identity, u) is equal to u. Additionally, the combiner function must be compatible with the accumulator function; for all u and t, the following must hold: combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t) This is a terminal operation.
java.util.stream.Stream.skip	(	long	): Returns a stream consisting of the remaining elements of this stream after discarding the first n elements of the stream. If this stream contains fewer than n elements then an empty stream will be returned. This is a stateful intermediate operation.
java.util.stream.Stream.sorted	(	): Returns a stream consisting of the elements of this stream, sorted according to natural order. If the elements of this stream are not Comparable, a java.lang.ClassCastException may be thrown when the terminal operation is executed. For ordered streams, the sort is stable. For unordered streams, no stability guarantees are made. This is a stateful intermediate operation.
java.util.stream.Stream.sorted	(	Comparator	): Returns a stream consisting of the elements of this stream, sorted according to the provided Comparator. For ordered streams, the sort is stable. For unordered streams, no stability guarantees are made. This is a stateful intermediate operation.
java.util.stream.Stream.toArray	(	): Returns an array containing the elements of this stream. This is a terminal operation.
java.util.stream.Stream.toArray	(	IntFunction	): Returns an array containing the elements of this stream, using the provided generator function to allocate the returned array, as well as any additional arrays that might be required for a partitioned execution or for resizing. This is a terminal operation.
java.util.stream.StreamSpliterators: Spliterator implementations for wrapping and delegating spliterators, used in the implementation of the spliterator() method.
java.util.stream.StreamSpliterators.AbstractWrappingSpliterator: Abstract wrapping spliterator that binds to the spliterator of a pipeline helper on first operation. This spliterator is not late-binding and will bind to the source spliterator when first operated on. A wrapping spliterator produced from a sequential stream cannot be split if there are stateful operations present.
java.util.stream.StreamSpliterators.AbstractWrappingSpliterator.AbstractWrappingSpliterator	(	PipelineHelper	Spliterator	boolean	): Construct an AbstractWrappingSpliterator from a Spliterator.
java.util.stream.StreamSpliterators.AbstractWrappingSpliterator.AbstractWrappingSpliterator	(	PipelineHelper	Supplier	boolean	): Construct an AbstractWrappingSpliterator from a Supplier.
java.util.stream.StreamSpliterators.AbstractWrappingSpliterator.doAdvance	(	): Get an element from the source, pushing it into the sink chain, setting up the buffer if needed
java.util.stream.StreamSpliterators.AbstractWrappingSpliterator.fillBuffer	(	): If the buffer is empty, push elements into the sink chain until the source is empty or cancellation is requested.
java.util.stream.StreamSpliterators.AbstractWrappingSpliterator.init	(	): Called before advancing to set up spliterator, if needed.
java.util.stream.StreamSpliterators.AbstractWrappingSpliterator.initPartialTraversalState	(	): Initializes buffer, sink chain, and pusher for a shape-specific implementation.
java.util.stream.StreamSpliterators.AbstractWrappingSpliterator.wrap	(	Spliterator	): Invokes the shape-specific constructor with the provided arguments and returns the result.
java.util.stream.StreamSpliterators.DelegatingSpliterator: Spliterator implementation that delegates to an underlying spliterator, acquiring the spliterator from a Supplier on the first call to any spliterator method.
java.util.stream.StreamSpliterators.DistinctSpliterator: A wrapping spliterator that only reports distinct elements of the underlying spliterator. Does not preserve size and encounter order.
java.util.stream.StreamSpliterators.InfiniteSupplyingSpliterator: A Spliterator that infinitely supplies elements in no particular order. Splitting divides the estimated size in two and stops when the estimate size is 0. The forEachRemaining method if invoked will never terminate. The tryAdvance method always returns true.
java.util.stream.StreamSpliterators.SliceSpliterator: A slice Spliterator from a source Spliterator that reports SUBSIZED.
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator: A slice Spliterator that does not preserve order, if any, of a source Spliterator. Note: The source spliterator may report ORDERED since that spliterator be the result of a previous pipeline stage that was collected to a Node. It is the order of the pipeline stage that governs whether the this slice spliterator is to be used or not.
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator.OfPrimitive: Concrete sub-types must also be an instance of type T_CONS.
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator.acquirePermits	(	long	): Acquire permission to skip or process elements. The caller must first acquire the elements, then consult this method for guidance as to what to do with the data. We use an AtomicLong to atomically maintain a counter, which is initialized as skip+limit if we are limiting, or skip only if we are not limiting. The user should consult the method checkPermits() before acquiring data elements.
java.util.stream.StreamSpliterators.UnorderedSliceSpliterator.permitStatus	(	): Call to check if permits might be available before acquiring data 
java.util.stream.StreamSupport: Low-level utility methods for creating and manipulating streams. This class is mostly for library writers presenting stream views of data structures; most static stream methods intended for end users are in the various Stream classes.
java.util.stream.StreamSupport.doubleStream	(	Spliterator.OfDouble	boolean	): Creates a new sequential or parallel DoubleStream from a Spliterator.OfDouble. The spliterator is only traversed, split, or queried for estimated size after the terminal operation of the stream pipeline commences. It is strongly recommended the spliterator report a characteristic of IMMUTABLE or CONCURRENT, or be late-binding. Otherwise, doubleStream() should be used to reduce the scope of potential interference with the source. See Non-Interference for more details.
java.util.stream.StreamSupport.doubleStream	(	Supplier	int	boolean	): Creates a new sequential or parallel DoubleStream from a Supplier of Spliterator.OfDouble. The get() method will be invoked on the supplier no more than once, and only after the terminal operation of the stream pipeline commences. For spliterators that report a characteristic of IMMUTABLE or CONCURRENT, or that are late-binding, it is likely more efficient to use doubleStream() instead. The use of a Supplier in this form provides a level of indirection that reduces the scope of potential interference with the source. Since the supplier is only invoked after the terminal operation commences, any modifications to the source up to the start of the terminal operation are reflected in the stream result. See Non-Interference for more details.
java.util.stream.StreamSupport.intStream	(	Spliterator.OfInt	boolean	): Creates a new sequential or parallel IntStream from a Spliterator.OfInt. The spliterator is only traversed, split, or queried for estimated size after the terminal operation of the stream pipeline commences. It is strongly recommended the spliterator report a characteristic of IMMUTABLE or CONCURRENT, or be late-binding. Otherwise, intStream() should be used to reduce the scope of potential interference with the source. See Non-Interference for more details.
java.util.stream.StreamSupport.intStream	(	Supplier	int	boolean	): Creates a new sequential or parallel IntStream from a Supplier of Spliterator.OfInt. The get() method will be invoked on the supplier no more than once, and only after the terminal operation of the stream pipeline commences. For spliterators that report a characteristic of IMMUTABLE or CONCURRENT, or that are late-binding, it is likely more efficient to use intStream() instead. The use of a Supplier in this form provides a level of indirection that reduces the scope of potential interference with the source. Since the supplier is only invoked after the terminal operation commences, any modifications to the source up to the start of the terminal operation are reflected in the stream result. See Non-Interference for more details.
java.util.stream.StreamSupport.longStream	(	Spliterator.OfLong	boolean	): Creates a new sequential or parallel LongStream from a Spliterator.OfLong. The spliterator is only traversed, split, or queried for estimated size after the terminal operation of the stream pipeline commences. It is strongly recommended the spliterator report a characteristic of IMMUTABLE or CONCURRENT, or be late-binding. Otherwise, longStream() should be used to reduce the scope of potential interference with the source. See Non-Interference for more details.
java.util.stream.StreamSupport.longStream	(	Supplier	int	boolean	): Creates a new sequential or parallel LongStream from a Supplier of Spliterator.OfLong. The get() method will be invoked on the supplier no more than once, and only after the terminal operation of the stream pipeline commences. For spliterators that report a characteristic of IMMUTABLE or CONCURRENT, or that are late-binding, it is likely more efficient to use longStream() instead. The use of a Supplier in this form provides a level of indirection that reduces the scope of potential interference with the source. Since the supplier is only invoked after the terminal operation commences, any modifications to the source up to the start of the terminal operation are reflected in the stream result. See Non-Interference for more details.
java.util.stream.StreamSupport.stream	(	Spliterator	boolean	): Creates a new sequential or parallel Stream from a Spliterator. The spliterator is only traversed, split, or queried for estimated size after the terminal operation of the stream pipeline commences. It is strongly recommended the spliterator report a characteristic of IMMUTABLE or CONCURRENT, or be late-binding. Otherwise, stream() should be used to reduce the scope of potential interference with the source. See Non-Interference for more details.
java.util.stream.StreamSupport.stream	(	Supplier	int	boolean	): Creates a new sequential or parallel Stream from a Supplier of Spliterator. The get() method will be invoked on the supplier no more than once, and only after the terminal operation of the stream pipeline commences. For spliterators that report a characteristic of IMMUTABLE or CONCURRENT, or that are late-binding, it is likely more efficient to use stream() instead. The use of a Supplier in this form provides a level of indirection that reduces the scope of potential interference with the source. Since the supplier is only invoked after the terminal operation commences, any modifications to the source up to the start of the terminal operation are reflected in the stream result. See Non-Interference for more details.
java.util.stream.Streams: Utility methods for operating on and creating streams. Unless otherwise stated, streams are created as sequential streams. A sequential stream can be transformed into a parallel stream by calling the parallel() method on the created stream.
java.util.stream.Streams.DoubleStreamBuilderImpl.DoubleStreamBuilderImpl	(	): Constructor for building a stream of 0 or more elements.
java.util.stream.Streams.DoubleStreamBuilderImpl.DoubleStreamBuilderImpl	(	double	): Constructor for a singleton stream.
java.util.stream.Streams.IntStreamBuilderImpl.IntStreamBuilderImpl	(	): Constructor for building a stream of 0 or more elements.
java.util.stream.Streams.IntStreamBuilderImpl.IntStreamBuilderImpl	(	int	): Constructor for a singleton stream.
java.util.stream.Streams.LongStreamBuilderImpl.LongStreamBuilderImpl	(	): Constructor for building a stream of 0 or more elements.
java.util.stream.Streams.LongStreamBuilderImpl.LongStreamBuilderImpl	(	long	): Constructor for a singleton stream.
java.util.stream.Streams.RangeIntSpliterator: An int range spliterator.
java.util.stream.Streams.RangeLongSpliterator: A long range spliterator. This implementation cannot be used for ranges whose size is greater than Long.MAX_VALUE
java.util.stream.Streams.StreamBuilderImpl.StreamBuilderImpl	(	): Constructor for building a stream of 0 or more elements.
java.util.stream.Streams.StreamBuilderImpl.StreamBuilderImpl	(	T	): Constructor for a singleton stream.
java.util.stream.Streams.composeWithExceptions	(	Runnable	Runnable	): Given two Runnables, return a Runnable that executes both in sequence, even if the first throws an exception, and if both throw exceptions, add any exceptions thrown by the second as suppressed exceptions of the first.
java.util.stream.Streams.composedClose	(	BaseStream	BaseStream	): Given two streams, return a Runnable that executes both of their close methods in sequence, even if the first throws an exception, and if both throw exceptions, add any exceptions thrown by the second as suppressed exceptions of the first.
java.util.stream.TerminalOp: An operation in a stream pipeline that takes a stream as input and produces a result or side-effect. A TerminalOp has an input type and stream shape, and a result type. A TerminalOp also has a set of operation flags that describes how the operation processes elements of the stream (such as short-circuiting or respecting encounter order; see StreamOpFlag). A TerminalOp must provide a sequential and parallel implementation of the operation relative to a given stream source and set of intermediate operations.
java.util.stream.TerminalOp.evaluateParallel	(	PipelineHelper	Spliterator	): Performs a parallel evaluation of the operation using the specified PipelineHelper, which describes the upstream intermediate operations.
java.util.stream.TerminalOp.evaluateSequential	(	PipelineHelper	Spliterator	): Performs a sequential evaluation of the operation using the specified PipelineHelper, which describes the upstream intermediate operations.
java.util.stream.TerminalOp.getOpFlags	(	): Gets the stream flags of the operation. Terminal operations may set a limited subset of the stream flags defined in StreamOpFlag, and these flags are combined with the previously combined stream and intermediate operation flags for the pipeline.
java.util.stream.TerminalOp.inputShape	(	): Gets the shape of the input type of this operation.
java.util.stream.TerminalSink: A Sink which accumulates state as elements are accepted, and allows a result to be retrieved after the computation is finished.
java.util.stream.Tripwire: Utility class for detecting inadvertent uses of boxing in java.util.stream classes. The detection is turned on or off based on whether the system property org.openjdk.java.util.stream.tripwire is considered true according to getBoolean(). This should normally be turned off for production use.
java.util.stream.Tripwire.trip	(	Class	String	): Produces a log warning, using PlatformLogger.getLogger(className), using the supplied message. The class name of trippingClass will be used as the first parameter to the message.
java.util.zip.Adler32: A class that can be used to compute the Adler-32 checksum of a data stream. An Adler-32 checksum is almost as reliable as a CRC-32 but can be computed much faster.  Passing a null argument to a method in this class will cause a NullPointerException to be thrown.
java.util.zip.Adler32.Adler32	(	): Creates a new Adler32 object.
java.util.zip.Adler32.getValue	(	): Returns the checksum value.
java.util.zip.Adler32.reset	(	): Resets the checksum to initial value.
java.util.zip.Adler32.update	(	ByteBuffer	): Updates the checksum with the bytes from the specified buffer. The checksum is updated using buffer.remaining() remaining() bytes starting at buffer.position() position() Upon return, the buffer's position will be updated to its limit; its limit will not have been changed.
java.util.zip.Adler32.update	(	byte[]	): Updates the checksum with the specified array of bytes.
java.util.zip.Adler32.update	(	byte[]	int	int	): Updates the checksum with the specified array of bytes.
java.util.zip.Adler32.update	(	int	): Updates the checksum with the specified byte (the low eight bits of the argument b).
java.util.zip.CRC32: A class that can be used to compute the CRC-32 of a data stream.  Passing a null argument to a method in this class will cause a NullPointerException to be thrown.
java.util.zip.CRC32.CRC32	(	): Creates a new CRC32 object.
java.util.zip.CRC32.getValue	(	): Returns CRC-32 value.
java.util.zip.CRC32.reset	(	): Resets CRC-32 to initial value.
java.util.zip.CRC32.update	(	ByteBuffer	): Updates the checksum with the bytes from the specified buffer. The checksum is updated using buffer.remaining() remaining() bytes starting at buffer.position() position() Upon return, the buffer's position will be updated to its limit; its limit will not have been changed.
java.util.zip.CRC32.update	(	byte[]	): Updates the CRC-32 checksum with the specified array of bytes.
java.util.zip.CRC32.update	(	byte[]	int	int	): Updates the CRC-32 checksum with the specified array of bytes.
java.util.zip.CRC32.update	(	int	): Updates the CRC-32 checksum with the specified byte (the low eight bits of the argument b).
java.util.zip.CheckedInputStream: An input stream that also maintains a checksum of the data being read. The checksum can then be used to verify the integrity of the input data.
java.util.zip.CheckedInputStream.CheckedInputStream	(	InputStream	Checksum	): Creates an input stream using the specified Checksum.
java.util.zip.CheckedInputStream.getChecksum	(	): Returns the Checksum for this input stream.
java.util.zip.CheckedInputStream.read	(	): Reads a byte. Will block if no input is available.
java.util.zip.CheckedInputStream.read	(	byte[]	int	int	): Reads into an array of bytes. If len is not zero, the method blocks until some input is available; otherwise, no bytes are read and 0 is returned.
java.util.zip.CheckedInputStream.skip	(	long	): Skips specified number of bytes of input.
java.util.zip.CheckedOutputStream: An output stream that also maintains a checksum of the data being written. The checksum can then be used to verify the integrity of the output data.
java.util.zip.CheckedOutputStream.CheckedOutputStream	(	OutputStream	Checksum	): Creates an output stream with the specified Checksum.
java.util.zip.CheckedOutputStream.getChecksum	(	): Returns the Checksum for this output stream.
java.util.zip.CheckedOutputStream.write	(	byte[]	int	int	): Writes an array of bytes. Will block until the bytes are actually written.
java.util.zip.CheckedOutputStream.write	(	int	): Writes a byte. Will block until the byte is actually written.
java.util.zip.Checksum: An interface representing a data checksum.
java.util.zip.Checksum.getValue	(	): Returns the current checksum value.
java.util.zip.Checksum.reset	(	): Resets the checksum to its initial value.
java.util.zip.Checksum.update	(	byte[]	int	int	): Updates the current checksum with the specified array of bytes.
java.util.zip.Checksum.update	(	int	): Updates the current checksum with the specified byte.
java.util.zip.DataFormatException: Signals that a data format error has occurred.
java.util.zip.DataFormatException.DataFormatException	(	): Constructs a DataFormatException with no detail message.
java.util.zip.DataFormatException.DataFormatException	(	String	): Constructs a DataFormatException with the specified detail message. A detail message is a String that describes this particular exception.
java.util.zip.Deflater: This class provides support for general purpose compression using the popular ZLIB compression library. The ZLIB compression library was initially developed as part of the PNG graphics standard and is not protected by patents. It is fully described in the specifications at the java.util.zip package description. The following code fragment demonstrates a trivial compression and decompression of a string using Deflater and Inflater.  try { // Encode a String into bytes String inputString = "blahblahblah"; byte[] input = inputString.getBytes("UTF-8"); // Compress the bytes byte[] output = new byte[100]; Deflater compresser = new Deflater(); compresser.setInput(input); compresser.finish(); int compressedDataLength = compresser.deflate(output); compresser.end(); // Decompress the bytes Inflater decompresser = new Inflater(); decompresser.setInput(output, 0, compressedDataLength); byte[] result = new byte[100]; int resultLength = decompresser.inflate(result); decompresser.end(); // Decode the bytes into a String String outputString = new String(result, 0, resultLength, "UTF-8"); } catch(java.io.UnsupportedEncodingException ex) { // handle } catch (java.util.zip.DataFormatException ex) { // handle } 
java.util.zip.Deflater.Deflater	(	): Creates a new compressor with the default compression level. Compressed data will be generated in ZLIB format.
java.util.zip.Deflater.Deflater	(	int	): Creates a new compressor using the specified compression level. Compressed data will be generated in ZLIB format.
java.util.zip.Deflater.Deflater	(	int	boolean	): Creates a new compressor using the specified compression level. If 'nowrap' is true then the ZLIB header and checksum fields will not be used in order to support the compression format used in both GZIP and PKZIP.
java.util.zip.Deflater.deflate	(	byte[]	): Compresses the input data and fills specified buffer with compressed data. Returns actual number of bytes of compressed data. A return value of 0 indicates that needsInput() should be called in order to determine if more input data is required. This method uses NO_FLUSH as its compression flush mode. An invocation of this method of the form deflater.deflate(b) yields the same result as the invocation of deflater.deflate(b, 0, b.length, Deflater.NO_FLUSH).
java.util.zip.Deflater.deflate	(	byte[]	int	int	): Compresses the input data and fills specified buffer with compressed data. Returns actual number of bytes of compressed data. A return value of 0 indicates that needsInput() should be called in order to determine if more input data is required. This method uses NO_FLUSH as its compression flush mode. An invocation of this method of the form deflater.deflate(b, off, len) yields the same result as the invocation of deflater.deflate(b, off, len, Deflater.NO_FLUSH).
java.util.zip.Deflater.deflate	(	byte[]	int	int	int	): Compresses the input data and fills the specified buffer with compressed data. Returns actual number of bytes of data compressed. Compression flush mode is one of the following three modes:  NO_FLUSH: allows the deflater to decide how much data to accumulate, before producing output, in order to achieve the best compression (should be used in normal use scenario). A return value of 0 in this flush mode indicates that needsInput() should be called in order to determine if more input data is required. SYNC_FLUSH: all pending output in the deflater is flushed, to the specified output buffer, so that an inflater that works on compressed data can get all input data available so far (In particular the needsInput() returns true after this invocation if enough output space is provided). Flushing with SYNC_FLUSH may degrade compression for some compression algorithms and so it should be used only when necessary. FULL_FLUSH: all pending output is flushed out as with SYNC_FLUSH. The compression state is reset so that the inflater that works on the compressed output data can restart from this point if previous compressed data has been damaged or if random access is desired. Using FULL_FLUSH too often can seriously degrade compression.  In the case of FULL_FLUSH or SYNC_FLUSH, if the return value is len, the space available in output buffer b, this method should be invoked again with the same flush parameter and more output space.
java.util.zip.Deflater.end	(	): Closes the compressor and discards any unprocessed input. This method should be called when the compressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Deflater object is undefined.
java.util.zip.Deflater.finalize	(	): Closes the compressor when garbage is collected.
java.util.zip.Deflater.finish	(	): When called, indicates that compression should end with the current contents of the input buffer.
java.util.zip.Deflater.finished	(	): Returns true if the end of the compressed data output stream has been reached.
java.util.zip.Deflater.getAdler	(	): Returns the ADLER-32 value of the uncompressed data.
java.util.zip.Deflater.getBytesRead	(	): Returns the total number of uncompressed bytes input so far.
java.util.zip.Deflater.getBytesWritten	(	): Returns the total number of compressed bytes output so far.
java.util.zip.Deflater.getTotalIn	(	): Returns the total number of uncompressed bytes input so far. Since the number of bytes may be greater than Integer.MAX_VALUE, the getBytesRead() method is now the preferred means of obtaining this information.
java.util.zip.Deflater.getTotalOut	(	): Returns the total number of compressed bytes output so far. Since the number of bytes may be greater than Integer.MAX_VALUE, the getBytesWritten() method is now the preferred means of obtaining this information.
java.util.zip.Deflater.needsInput	(	): Returns true if the input data buffer is empty and setInput() should be called in order to provide more input.
java.util.zip.Deflater.reset	(	): Resets deflater so that a new set of input data can be processed. Keeps current compression level and strategy settings.
java.util.zip.Deflater.setDictionary	(	byte[]	): Sets preset dictionary for compression. A preset dictionary is used when the history buffer can be predetermined. When the data is later uncompressed with Inflater.inflate(), Inflater.getAdler() can be called in order to get the Adler-32 value of the dictionary required for decompression.
java.util.zip.Deflater.setDictionary	(	byte[]	int	int	): Sets preset dictionary for compression. A preset dictionary is used when the history buffer can be predetermined. When the data is later uncompressed with Inflater.inflate(), Inflater.getAdler() can be called in order to get the Adler-32 value of the dictionary required for decompression.
java.util.zip.Deflater.setInput	(	byte[]	): Sets input data for compression. This should be called whenever needsInput() returns true indicating that more input data is required.
java.util.zip.Deflater.setInput	(	byte[]	int	int	): Sets input data for compression. This should be called whenever needsInput() returns true indicating that more input data is required.
java.util.zip.Deflater.setLevel	(	int	): Sets the compression level to the specified value.  If the compression level is changed, the next invocation of deflate will compress the input available so far with the old level (and may be flushed); the new level will take effect only after that invocation.
java.util.zip.Deflater.setStrategy	(	int	): Sets the compression strategy to the specified value.  If the compression strategy is changed, the next invocation of deflate will compress the input available so far with the old strategy (and may be flushed); the new strategy will take effect only after that invocation.
java.util.zip.DeflaterInputStream: Implements an input stream filter for compressing data in the "deflate" compression format.
java.util.zip.DeflaterInputStream.DeflaterInputStream	(	InputStream	): Creates a new input stream with a default compressor and buffer size.
java.util.zip.DeflaterInputStream.DeflaterInputStream	(	InputStream	Deflater	): Creates a new input stream with the specified compressor and a default buffer size.
java.util.zip.DeflaterInputStream.DeflaterInputStream	(	InputStream	Deflater	int	): Creates a new input stream with the specified compressor and buffer size.
java.util.zip.DeflaterInputStream.available	(	): Returns 0 after EOF has been reached, otherwise always return 1.  Programs should not count on this method to return the actual number of bytes that could be read without blocking
java.util.zip.DeflaterInputStream.close	(	): Closes this input stream and its underlying input stream, discarding any pending uncompressed data.
java.util.zip.DeflaterInputStream.ensureOpen	(	): Check to make sure that this stream has not been closed.
java.util.zip.DeflaterInputStream.mark	(	int	): This operation is not supported.
java.util.zip.DeflaterInputStream.markSupported	(	): Always returns false because this input stream does not support the mark mark() and reset reset() methods.
java.util.zip.DeflaterInputStream.read	(	): Reads a single byte of compressed data from the input stream. This method will block until some input can be read and compressed.
java.util.zip.DeflaterInputStream.read	(	byte[]	int	int	): Reads compressed data into a byte array. This method will block until some input can be read and compressed.
java.util.zip.DeflaterInputStream.reset	(	): This operation is not supported.
java.util.zip.DeflaterInputStream.skip	(	long	): Skips over and discards data from the input stream. This method may block until the specified number of bytes are read and skipped. Note: While n is given as a long, the maximum number of bytes which can be skipped is Integer.MAX_VALUE.
java.util.zip.DeflaterOutputStream: This class implements an output stream filter for compressing data in the "deflate" compression format. It is also used as the basis for other types of compression filters, such as GZIPOutputStream.
java.util.zip.DeflaterOutputStream.DeflaterOutputStream	(	OutputStream	): Creates a new output stream with a default compressor and buffer size. The new output stream instance is created as if by invoking the 2-argument constructor DeflaterOutputStream(out, false).
java.util.zip.DeflaterOutputStream.DeflaterOutputStream	(	OutputStream	Deflater	): Creates a new output stream with the specified compressor and a default buffer size. The new output stream instance is created as if by invoking the 3-argument constructor DeflaterOutputStream(out, def, false).
java.util.zip.DeflaterOutputStream.DeflaterOutputStream	(	OutputStream	Deflater	boolean	): Creates a new output stream with the specified compressor, flush mode and a default buffer size.
java.util.zip.DeflaterOutputStream.DeflaterOutputStream	(	OutputStream	Deflater	int	): Creates a new output stream with the specified compressor and buffer size. The new output stream instance is created as if by invoking the 4-argument constructor DeflaterOutputStream(out, def, size, false).
java.util.zip.DeflaterOutputStream.DeflaterOutputStream	(	OutputStream	Deflater	int	boolean	): Creates a new output stream with the specified compressor, buffer size and flush mode.
java.util.zip.DeflaterOutputStream.DeflaterOutputStream	(	OutputStream	boolean	): Creates a new output stream with a default compressor, a default buffer size and the specified flush mode.
java.util.zip.DeflaterOutputStream.close	(	): Writes remaining compressed data to the output stream and closes the underlying stream.
java.util.zip.DeflaterOutputStream.deflate	(	): Writes next block of compressed data to the output stream.
java.util.zip.DeflaterOutputStream.finish	(	): Finishes writing compressed data to the output stream without closing the underlying stream. Use this method when applying multiple filters in succession to the same output stream.
java.util.zip.DeflaterOutputStream.flush	(	): Flushes the compressed output stream. If DeflaterOutputStream() syncFlush is true when this compressed output stream is constructed, this method first flushes the underlying compressor with the flush mode SYNC_FLUSH to force all pending data to be flushed out to the output stream and then flushes the output stream. Otherwise this method only flushes the output stream without flushing the compressor.
java.util.zip.DeflaterOutputStream.write	(	byte[]	int	int	): Writes an array of bytes to the compressed output stream. This method will block until all the bytes are written.
java.util.zip.DeflaterOutputStream.write	(	int	): Writes a byte to the compressed output stream. This method will block until the byte can be written.
java.util.zip.GZIPInputStream: This class implements a stream filter for reading compressed data in the GZIP file format.
java.util.zip.GZIPInputStream.GZIPInputStream	(	InputStream	): Creates a new input stream with a default buffer size.
java.util.zip.GZIPInputStream.GZIPInputStream	(	InputStream	int	): Creates a new input stream with the specified buffer size.
java.util.zip.GZIPInputStream.close	(	): Closes this input stream and releases any system resources associated with the stream.
java.util.zip.GZIPInputStream.ensureOpen	(	): Check to make sure that this stream has not been closed
java.util.zip.GZIPInputStream.read	(	byte[]	int	int	): Reads uncompressed data into an array of bytes. If len is not zero, the method will block until some input can be decompressed; otherwise, no bytes are read and 0 is returned.
java.util.zip.GZIPOutputStream: This class implements a stream filter for writing compressed data in the GZIP file format.
java.util.zip.GZIPOutputStream.GZIPOutputStream	(	OutputStream	): Creates a new output stream with a default buffer size. The new output stream instance is created as if by invoking the 2-argument constructor GZIPOutputStream(out, false).
java.util.zip.GZIPOutputStream.GZIPOutputStream	(	OutputStream	boolean	): Creates a new output stream with a default buffer size and the specified flush mode.
java.util.zip.GZIPOutputStream.GZIPOutputStream	(	OutputStream	int	): Creates a new output stream with the specified buffer size. The new output stream instance is created as if by invoking the 3-argument constructor GZIPOutputStream(out, size, false).
java.util.zip.GZIPOutputStream.GZIPOutputStream	(	OutputStream	int	boolean	): Creates a new output stream with the specified buffer size and flush mode.
java.util.zip.GZIPOutputStream.finish	(	): Finishes writing compressed data to the output stream without closing the underlying stream. Use this method when applying multiple filters in succession to the same output stream.
java.util.zip.GZIPOutputStream.write	(	byte[]	int	int	): Writes array of bytes to the compressed output stream. This method will block until all the bytes are written.
java.util.zip.Inflater: This class provides support for general purpose decompression using the popular ZLIB compression library. The ZLIB compression library was initially developed as part of the PNG graphics standard and is not protected by patents. It is fully described in the specifications at the java.util.zip package description. The following code fragment demonstrates a trivial compression and decompression of a string using Deflater and Inflater.  try { // Encode a String into bytes String inputString = "blahblahblah\u20AC\u20AC"; byte[] input = inputString.getBytes("UTF-8"); // Compress the bytes byte[] output = new byte[100]; Deflater compresser = new Deflater(); compresser.setInput(input); compresser.finish(); int compressedDataLength = compresser.deflate(output); // Decompress the bytes Inflater decompresser = new Inflater(); decompresser.setInput(output, 0, compressedDataLength); byte[] result = new byte[100]; int resultLength = decompresser.inflate(result); decompresser.end(); // Decode the bytes into a String String outputString = new String(result, 0, resultLength, "UTF-8"); } catch(java.io.UnsupportedEncodingException ex) { // handle } catch (java.util.zip.DataFormatException ex) { // handle } 
java.util.zip.Inflater.Inflater	(	): Creates a new decompressor.
java.util.zip.Inflater.Inflater	(	boolean	): Creates a new decompressor. If the parameter 'nowrap' is true then the ZLIB header and checksum fields will not be used. This provides compatibility with the compression format used by both GZIP and PKZIP.  Note: When using the 'nowrap' option it is also necessary to provide an extra "dummy" byte as input. This is required by the ZLIB native library in order to support certain optimizations.
java.util.zip.Inflater.end	(	): Closes the decompressor and discards any unprocessed input. This method should be called when the decompressor is no longer being used, but will also be called automatically by the finalize() method. Once this method is called, the behavior of the Inflater object is undefined.
java.util.zip.Inflater.finalize	(	): Closes the decompressor when garbage is collected.
java.util.zip.Inflater.finished	(	): Returns true if the end of the compressed data stream has been reached.
java.util.zip.Inflater.getAdler	(	): Returns the ADLER-32 value of the uncompressed data.
java.util.zip.Inflater.getBytesRead	(	): Returns the total number of compressed bytes input so far.
java.util.zip.Inflater.getBytesWritten	(	): Returns the total number of uncompressed bytes output so far.
java.util.zip.Inflater.getRemaining	(	): Returns the total number of bytes remaining in the input buffer. This can be used to find out what bytes still remain in the input buffer after decompression has finished.
java.util.zip.Inflater.getTotalIn	(	): Returns the total number of compressed bytes input so far. Since the number of bytes may be greater than Integer.MAX_VALUE, the getBytesRead() method is now the preferred means of obtaining this information.
java.util.zip.Inflater.getTotalOut	(	): Returns the total number of uncompressed bytes output so far. Since the number of bytes may be greater than Integer.MAX_VALUE, the getBytesWritten() method is now the preferred means of obtaining this information.
java.util.zip.Inflater.inflate	(	byte[]	): Uncompresses bytes into specified buffer. Returns actual number of bytes uncompressed. A return value of 0 indicates that needsInput() or needsDictionary() should be called in order to determine if more input data or a preset dictionary is required. In the latter case, getAdler() can be used to get the Adler-32 value of the dictionary required.
java.util.zip.Inflater.inflate	(	byte[]	int	int	): Uncompresses bytes into specified buffer. Returns actual number of bytes uncompressed. A return value of 0 indicates that needsInput() or needsDictionary() should be called in order to determine if more input data or a preset dictionary is required. In the latter case, getAdler() can be used to get the Adler-32 value of the dictionary required.
java.util.zip.Inflater.needsDictionary	(	): Returns true if a preset dictionary is needed for decompression.
java.util.zip.Inflater.needsInput	(	): Returns true if no data remains in the input buffer. This can be used to determine if #setInput should be called in order to provide more input.
java.util.zip.Inflater.reset	(	): Resets inflater so that a new set of input data can be processed.
java.util.zip.Inflater.setDictionary	(	byte[]	): Sets the preset dictionary to the given array of bytes. Should be called when inflate() returns 0 and needsDictionary() returns true indicating that a preset dictionary is required. The method getAdler() can be used to get the Adler-32 value of the dictionary needed.
java.util.zip.Inflater.setDictionary	(	byte[]	int	int	): Sets the preset dictionary to the given array of bytes. Should be called when inflate() returns 0 and needsDictionary() returns true indicating that a preset dictionary is required. The method getAdler() can be used to get the Adler-32 value of the dictionary needed.
java.util.zip.Inflater.setInput	(	byte[]	): Sets input data for decompression. Should be called whenever needsInput() returns true indicating that more input data is required.
java.util.zip.Inflater.setInput	(	byte[]	int	int	): Sets input data for decompression. Should be called whenever needsInput() returns true indicating that more input data is required.
java.util.zip.InflaterInputStream: This class implements a stream filter for uncompressing data in the "deflate" compression format. It is also used as the basis for other decompression filters, such as GZIPInputStream.
java.util.zip.InflaterInputStream.InflaterInputStream	(	InputStream	): Creates a new input stream with a default decompressor and buffer size.
java.util.zip.InflaterInputStream.InflaterInputStream	(	InputStream	Inflater	): Creates a new input stream with the specified decompressor and a default buffer size.
java.util.zip.InflaterInputStream.InflaterInputStream	(	InputStream	Inflater	int	): Creates a new input stream with the specified decompressor and buffer size.
java.util.zip.InflaterInputStream.available	(	): Returns 0 after EOF has been reached, otherwise always return 1.  Programs should not count on this method to return the actual number of bytes that could be read without blocking.
java.util.zip.InflaterInputStream.close	(	): Closes this input stream and releases any system resources associated with the stream.
java.util.zip.InflaterInputStream.ensureOpen	(	): Check to make sure that this stream has not been closed
java.util.zip.InflaterInputStream.fill	(	): Fills input buffer with more data to decompress.
java.util.zip.InflaterInputStream.mark	(	int	): Marks the current position in this input stream.  The mark method of InflaterInputStream does nothing.
java.util.zip.InflaterInputStream.markSupported	(	): Tests if this input stream supports the mark and reset methods. The markSupported method of InflaterInputStream returns false.
java.util.zip.InflaterInputStream.read	(	): Reads a byte of uncompressed data. This method will block until enough input is available for decompression.
java.util.zip.InflaterInputStream.read	(	byte[]	int	int	): Reads uncompressed data into an array of bytes. If len is not zero, the method will block until some input can be decompressed; otherwise, no bytes are read and 0 is returned.
java.util.zip.InflaterInputStream.reset	(	): Repositions this stream to the position at the time the mark method was last called on this input stream.  The method reset for class InflaterInputStream does nothing except throw an IOException.
java.util.zip.InflaterInputStream.skip	(	long	): Skips specified number of bytes of uncompressed data.
java.util.zip.InflaterOutputStream: Implements an output stream filter for uncompressing data stored in the "deflate" compression format.
java.util.zip.InflaterOutputStream.InflaterOutputStream	(	OutputStream	): Creates a new output stream with a default decompressor and buffer size.
java.util.zip.InflaterOutputStream.InflaterOutputStream	(	OutputStream	Inflater	): Creates a new output stream with the specified decompressor and a default buffer size.
java.util.zip.InflaterOutputStream.InflaterOutputStream	(	OutputStream	Inflater	int	): Creates a new output stream with the specified decompressor and buffer size.
java.util.zip.InflaterOutputStream.close	(	): Writes any remaining uncompressed data to the output stream and closes the underlying output stream.
java.util.zip.InflaterOutputStream.ensureOpen	(	): Checks to make sure that this stream has not been closed.
java.util.zip.InflaterOutputStream.finish	(	): Finishes writing uncompressed data to the output stream without closing the underlying stream. Use this method when applying multiple filters in succession to the same output stream.
java.util.zip.InflaterOutputStream.flush	(	): Flushes this output stream, forcing any pending buffered output bytes to be written.
java.util.zip.InflaterOutputStream.write	(	byte[]	int	int	): Writes an array of bytes to the uncompressed output stream.
java.util.zip.InflaterOutputStream.write	(	int	): Writes a byte to the uncompressed output stream.
java.util.zip.ZStreamRef: A reference to the native zlib's z_stream structure.
java.util.zip.ZipCoder: Utility class for zipfile name and comment decoding and encoding
java.util.zip.ZipEntry: This class is used to represent a ZIP file entry.
java.util.zip.ZipEntry.ZipEntry	(	): Creates a new un-initialized zip entry
java.util.zip.ZipEntry.ZipEntry	(	String	): Creates a new zip entry with the specified name.
java.util.zip.ZipEntry.ZipEntry	(	ZipEntry	): Creates a new zip entry with fields taken from the specified zip entry.
java.util.zip.ZipEntry.clone	(	): Returns a copy of this entry.
java.util.zip.ZipEntry.getComment	(	): Returns the comment string for the entry.
java.util.zip.ZipEntry.getCompressedSize	(	): Returns the size of the compressed entry data.  In the case of a stored entry, the compressed size will be the same as the uncompressed size of the entry.
java.util.zip.ZipEntry.getCrc	(	): Returns the CRC-32 checksum of the uncompressed entry data.
java.util.zip.ZipEntry.getCreationTime	(	): Returns the creation time of the entry.  The creation time is from the extended timestamp fields of entry's optional extra data when read from a ZIP file or ZIP file formatted stream.
java.util.zip.ZipEntry.getExtra	(	): Returns the extra field data for the entry.
java.util.zip.ZipEntry.getLastAccessTime	(	): Returns the last access time of the entry.  The last access time is from the extended timestamp fields of entry's optional extra data when read from a ZIP file or ZIP file formatted stream.
java.util.zip.ZipEntry.getLastModifiedTime	(	): Returns the last modification time of the entry.  If the entry is read from a ZIP file or ZIP file formatted input stream, this is the last modification time from the zip file entry's optional extra data if the extended timestamp fields are present. Otherwise the last modification time is read from the entry's date and time fields, the getDefault() default TimeZone is used to convert the standard MS-DOS formatted date and time to the epoch time.
java.util.zip.ZipEntry.getMethod	(	): Returns the compression method of the entry.
java.util.zip.ZipEntry.getName	(	): Returns the name of the entry.
java.util.zip.ZipEntry.getSize	(	): Returns the uncompressed size of the entry data.
java.util.zip.ZipEntry.getTime	(	): Returns the last modification time of the entry.  If the entry is read from a ZIP file or ZIP file formatted input stream, this is the last modification time from the date and time fields of the zip file entry. The getDefault() default TimeZone is used to convert the standard MS-DOS formatted date and time to the epoch time.
java.util.zip.ZipEntry.hashCode	(	): Returns the hash code value for this entry.
java.util.zip.ZipEntry.isDirectory	(	): Returns true if this is a directory entry. A directory entry is defined to be one whose name ends with a '/'.
java.util.zip.ZipEntry.setComment	(	String	): Sets the optional comment string for the entry. ZIP entry comments have maximum length of 0xffff. If the length of the specified comment string is greater than 0xFFFF bytes after encoding, only the first 0xFFFF bytes are output to the ZIP file entry.
java.util.zip.ZipEntry.setCompressedSize	(	long	): Sets the size of the compressed entry data.
java.util.zip.ZipEntry.setCrc	(	long	): Sets the CRC-32 checksum of the uncompressed entry data.
java.util.zip.ZipEntry.setCreationTime	(	FileTime	): Sets the creation time of the entry.  If set, the creation time will be stored into the extended timestamp fields of entry's optional extra data, when output to a ZIP file or ZIP file formatted stream.
java.util.zip.ZipEntry.setExtra	(	byte[]	): Sets the optional extra field data for the entry.  Invoking this method may change this entry's last modification time, last access time and creation time, if the extra field data includes the extensible timestamp fields, such as NTFS tag 0x0001 or Info-ZIP Extended Timestamp, as specified in Info-ZIP Application Note 970311.
java.util.zip.ZipEntry.setExtra0	(	byte[]	boolean	): Sets the optional extra field data for the entry.
java.util.zip.ZipEntry.setLastAccessTime	(	FileTime	): Sets the last access time of the entry.  If set, the last access time will be stored into the extended timestamp fields of entry's optional extra data, when output to a ZIP file or ZIP file formatted stream.
java.util.zip.ZipEntry.setLastModifiedTime	(	FileTime	): Sets the last modification time of the entry.  When output to a ZIP file or ZIP file formatted output stream the last modification time set by this method will be stored into zip file entry's date and time fields in standard MS-DOS date and time format), and the extended timestamp fields in optional extra data in UTC time.
java.util.zip.ZipEntry.setMethod	(	int	): Sets the compression method for the entry.
java.util.zip.ZipEntry.setSize	(	long	): Sets the uncompressed size of the entry data.
java.util.zip.ZipEntry.setTime	(	long	): Sets the last modification time of the entry.  If the entry is output to a ZIP file or ZIP file formatted output stream the last modification time set by this method will be stored into the date and time fields of the zip file entry and encoded in standard MS-DOS date and time format. The getDefault() default TimeZone is used to convert the epoch time to the MS-DOS data and time.
java.util.zip.ZipEntry.toString	(	): Returns a string representation of the ZIP entry.
java.util.zip.ZipError: Signals that an unrecoverable error has occurred.
java.util.zip.ZipError.ZipError	(	String	): Constructs a ZipError with the given detail message.
java.util.zip.ZipException: Signals that a Zip exception of some sort has occurred.
java.util.zip.ZipException.ZipException	(	): Constructs a ZipException with null as its error detail message.
java.util.zip.ZipException.ZipException	(	String	): Constructs a ZipException with the specified detail message.
java.util.zip.ZipFile: This class is used to read entries from a zip file.  Unless otherwise noted, passing a null argument to a constructor or method in this class will cause a NullPointerException to be thrown.
java.util.zip.ZipFile.ZipFile	(	File	): Opens a ZIP file for reading given the specified File object. The UTF-8 java.nio.charset.Charset charset is used to decode the entry names and comments.
java.util.zip.ZipFile.ZipFile	(	File	Charset	): Opens a ZIP file for reading given the specified File object.
java.util.zip.ZipFile.ZipFile	(	File	int	): Opens a new ZipFile to read from the specified File object in the specified mode. The mode argument must be either OPEN_READ or OPEN_READ | OPEN_DELETE. First, if there is a security manager, its checkRead method is called with the name argument as its argument to ensure the read is allowed. The UTF-8 java.nio.charset.Charset charset is used to decode the entry names and comments
java.util.zip.ZipFile.ZipFile	(	File	int	Charset	): Opens a new ZipFile to read from the specified File object in the specified mode. The mode argument must be either OPEN_READ or OPEN_READ | OPEN_DELETE. First, if there is a security manager, its checkRead method is called with the name argument as its argument to ensure the read is allowed.
java.util.zip.ZipFile.ZipFile	(	String	): Opens a zip file for reading. First, if there is a security manager, its checkRead method is called with the name argument as its argument to ensure the read is allowed. The UTF-8 java.nio.charset.Charset charset is used to decode the entry names and comments.
java.util.zip.ZipFile.ZipFile	(	String	Charset	): Opens a zip file for reading. First, if there is a security manager, its checkRead method is called with the name argument as its argument to ensure the read is allowed.
java.util.zip.ZipFile.close	(	): Closes the ZIP file.  Closing this ZIP file will close all of the input streams previously returned by invocations of the getInputStream method.
java.util.zip.ZipFile.entries	(	): Returns an enumeration of the ZIP file entries.
java.util.zip.ZipFile.finalize	(	): Ensures that the system resources held by this ZipFile object are released when there are no more references to it.  Since the time when GC would invoke this method is undetermined, it is strongly recommended that applications invoke the close method as soon they have finished accessing this ZipFile. This will prevent holding up system resources for an undetermined length of time.
java.util.zip.ZipFile.getComment	(	): Returns the zip file comment, or null if none.
java.util.zip.ZipFile.getEntry	(	String	): Returns the zip file entry for the specified name, or null if not found.
java.util.zip.ZipFile.getInputStream	(	ZipEntry	): Returns an input stream for reading the contents of the specified zip file entry.  Closing this ZIP file will, in turn, close all input streams that have been returned by invocations of this method.
java.util.zip.ZipFile.getName	(	): Returns the path name of the ZIP file.
java.util.zip.ZipFile.size	(	): Returns the number of entries in the ZIP file.
java.util.zip.ZipFile.startsWithLocHeader	(	): Returns true if, and only if, the zip file begins with LOCSIG.
java.util.zip.ZipFile.stream	(	): Return an ordered Stream over the ZIP file entries. Entries appear in the Stream in the order they appear in the central directory of the ZIP file.
java.util.zip.ZipInputStream: This class implements an input stream filter for reading files in the ZIP file format. Includes support for both compressed and uncompressed entries.
java.util.zip.ZipInputStream.ZipInputStream	(	InputStream	): Creates a new ZIP input stream. The UTF-8 java.nio.charset.Charset charset is used to decode the entry names.
java.util.zip.ZipInputStream.ZipInputStream	(	InputStream	Charset	): Creates a new ZIP input stream.
java.util.zip.ZipInputStream.available	(	): Returns 0 after EOF has reached for the current entry data, otherwise always return 1.  Programs should not count on this method to return the actual number of bytes that could be read without blocking.
java.util.zip.ZipInputStream.close	(	): Closes this input stream and releases any system resources associated with the stream.
java.util.zip.ZipInputStream.closeEntry	(	): Closes the current ZIP entry and positions the stream for reading the next entry.
java.util.zip.ZipInputStream.createZipEntry	(	String	): Creates a new ZipEntry object for the specified entry name.
java.util.zip.ZipInputStream.ensureOpen	(	): Check to make sure that this stream has not been closed
java.util.zip.ZipInputStream.getNextEntry	(	): Reads the next ZIP file entry and positions the stream at the beginning of the entry data.
java.util.zip.ZipInputStream.read	(	byte[]	int	int	): Reads from the current ZIP entry into an array of bytes. If len is not zero, the method blocks until some input is available; otherwise, no bytes are read and 0 is returned.
java.util.zip.ZipInputStream.skip	(	long	): Skips specified number of bytes in the current ZIP entry.
java.util.zip.ZipOutputStream: This class implements an output stream filter for writing files in the ZIP file format. Includes support for both compressed and uncompressed entries.
java.util.zip.ZipOutputStream.ZipOutputStream	(	OutputStream	): Creates a new ZIP output stream. The UTF-8 java.nio.charset.Charset charset is used to encode the entry names and comments.
java.util.zip.ZipOutputStream.ZipOutputStream	(	OutputStream	Charset	): Creates a new ZIP output stream.
java.util.zip.ZipOutputStream.close	(	): Closes the ZIP output stream as well as the stream being filtered.
java.util.zip.ZipOutputStream.closeEntry	(	): Closes the current ZIP entry and positions the stream for writing the next entry.
java.util.zip.ZipOutputStream.ensureOpen	(	): Checks to make sure that this stream has not been closed.
java.util.zip.ZipOutputStream.finish	(	): Finishes writing the contents of the ZIP output stream without closing the underlying stream. Use this method when applying multiple filters in succession to the same output stream.
java.util.zip.ZipOutputStream.putNextEntry	(	ZipEntry	): Begins writing a new ZIP file entry and positions the stream to the start of the entry data. Closes the current entry if still active. The default compression method will be used if no compression method was specified for the entry, and the current time will be used if the entry has no set modification time.
java.util.zip.ZipOutputStream.setComment	(	String	): Sets the ZIP file comment.
java.util.zip.ZipOutputStream.setLevel	(	int	): Sets the compression level for subsequent entries which are DEFLATED. The default setting is DEFAULT_COMPRESSION.
java.util.zip.ZipOutputStream.setMethod	(	int	): Sets the default compression method for subsequent entries. This default will be used whenever the compression method is not specified for an individual ZIP file entry, and is initially set to DEFLATED.
java.util.zip.ZipOutputStream.write	(	byte[]	int	int	): Writes an array of bytes to the current ZIP entry data. This method will block until all the bytes are written.
java.util.zip.ZipUtils.dosToJavaTime	(	long	): Converts DOS time to Java time (number of milliseconds since epoch).
java.util.zip.ZipUtils.extendedDosToJavaTime	(	long	): Converts extended DOS time to Java time, where up to 1999 milliseconds might be encoded into the upper half of the returned long.
java.util.zip.ZipUtils.fileTimeToUnixTime	(	FileTime	): Converts FileTime to "standard Unix time".
java.util.zip.ZipUtils.fileTimeToWinTime	(	FileTime	): Converts FileTime to Windows time.
java.util.zip.ZipUtils.get16	(	byte	int	): Fetches unsigned 16-bit value from byte array at specified offset. The bytes are assumed to be in Intel (little-endian) byte order.
java.util.zip.ZipUtils.get32	(	byte	int	): Fetches unsigned 32-bit value from byte array at specified offset. The bytes are assumed to be in Intel (little-endian) byte order.
java.util.zip.ZipUtils.get64	(	byte	int	): Fetches signed 64-bit value from byte array at specified offset. The bytes are assumed to be in Intel (little-endian) byte order.
java.util.zip.ZipUtils.javaToDosTime	(	long	): Converts Java time to DOS time.
java.util.zip.ZipUtils.javaToExtendedDosTime	(	long	): Converts Java time to DOS time, encoding any milliseconds lost in the conversion into the upper half of the returned long.
java.util.zip.ZipUtils.unixTimeToFileTime	(	long	): Converts "standard Unix time"(in seconds, UTC/GMT) to FileTime
java.util.zip.ZipUtils.winTimeToFileTime	(	long	): Converts Windows time (in microseconds, UTC/GMT) time to FileTime.
